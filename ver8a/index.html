<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RDF Grapher ver8 - –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è RDF –¥–∞–Ω–Ω—ã—Ö —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π TriG + SPARQL Smart Design + Ontology </title>

    <!--
        RDF Grapher ver8a - –°–µ—Ä–≤–∏—Å –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ RDF –¥–∞–Ω–Ω—ã—Ö –∏ –∏—Ö –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ –≤–∏–¥–µ –≥—Ä–∞—Ñ–∞
        –ù–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ ver8: SPARQL Smart Design + Ontology
        –≠—Ç–æ—Ç —Å–µ—Ä–≤–∏—Å —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ–º https://www.ldf.fi/service/rdf-grapher –≤ —á–∞—Å—Ç–∏ BPM
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –∫–ª–∏–µ–Ω—Ç—Å–∫–∏–µ JavaScript –±–∏–±–ª–∏–æ—Ç–µ–∫–∏:
        - N3.js –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ RDF (–∑–∞–º–µ–Ω–∞ Redland Raptor)
        - Viz.js –¥–ª—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ –≥—Ä–∞—Ñ–æ–≤ (–∑–∞–º–µ–Ω–∞ Graphviz)

        –°–µ—Ä–≤–∏—Å —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ –∫–ª–∏–µ–Ω—Ç–∞ –∏ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–∑–º–µ—â–µ–Ω –Ω–∞ GitHub Pages
    -->

    <!-- –°—Ç–∏–ª–∏ –¥–ª—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ -->
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –ø–∞–Ω–µ–ª–µ–π —Å–≤–æ–π—Å—Ç–≤ —É–∑–ª–æ–≤ -->
    <div id="properties-panels-container"></div>

    <div class="description">
        <p>
            <strong>–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–∏–º–µ—Ä RDF –¥–∞–Ω–Ω—ã—Ö:</strong>
            <span class="example-link" onclick="loadExampleTrigVADv4()">Trig VADv4</span>
        </p>
        <div id="example-status" class="example-status" style="display: none;"></div>
    </div>

    <div class="container">
        <div class="rdf-input-header">
            <label for="rdf-input">RDF –¥–∞–Ω–Ω—ã–µ –∏–ª–∏ URI:</label>
            <button class="show-in-window-btn" onclick="showRdfInSeparateWindow()">–ü–æ–∫–∞–∑–∞—Ç—å –≤ –æ–∫–Ω–µ</button>
            <button class="clear-btn" onclick="clearRdfInput()">–û—á–∏—Å—Ç–∏—Ç—å</button>
            <button class="save-as-btn" onclick="saveAsFile()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫</button>
            <button class="load-btn" onclick="document.getElementById('file-input').click()">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
            <button class="test-btn" onclick="testRdfValidation()">–¢–µ—Å—Ç</button>
            <button class="virtual-rdf-btn" onclick="showVirtualRDFData()">virtualRDFdata</button>
            <input type="file" id="file-input" style="display: none;" accept=".ttl,.rdf,.nt,.nq,.trig" onchange="loadFile(event)">
        </div>
        <textarea id="rdf-input" placeholder="–í–≤–µ–¥–∏—Ç–µ RDF –¥–∞–Ω–Ω—ã–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ TriG..."></textarea>

        <div class="format-selectors">
            <div class="form-group">
                <label for="input-format">–í—Ö–æ–¥–Ω–æ–π —Ñ–æ—Ä–º–∞—Ç:</label>
                <select id="input-format">
                    <option value="trig" selected>TriG</option>
                </select>
            </div>

            <div class="form-group">
                <label for="output-format">–í—ã—Ö–æ–¥–Ω–æ–π —Ñ–æ—Ä–º–∞—Ç:</label>
                <select id="output-format">
                    <option value="svg" selected>SVG</option>
                    <option value="png">PNG</option>
                </select>
            </div>

            <div class="form-group">
                <label for="layout-engine">–î–≤–∏–∂–æ–∫ –∫–æ–º–ø–æ–Ω–æ–≤–∫–∏:</label>
                <select id="layout-engine">
                    <option value="dot" selected>dot (–∏–µ—Ä–∞—Ä—Ö–∏—á–µ—Å–∫–∞—è)</option>
                    <option value="neato">neato (spring model)</option>
                    <option value="fdp">fdp (force-directed)</option>
                    <option value="circo">circo (–∫—Ä—É–≥–æ–≤–∞—è)</option>
                    <option value="twopi">twopi (—Ä–∞–¥–∏–∞–ª—å–Ω–∞—è)</option>
                </select>
            </div>

            <div class="form-group">
                <label for="visualization-mode">–†–µ–∂–∏–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏:</label>
                <select id="visualization-mode" onchange="updateModeDescription()">
                    <option value="vad-trig" selected>–†–µ–∂–∏–º VAD TriG</option>
                </select>
                <div class="mode-description" id="mode-description">
                    VAD –¥–∏–∞–≥—Ä–∞–º–º–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –∏–µ—Ä–∞—Ä—Ö–∏–∏ TriG –≥—Ä–∞—Ñ–æ–≤
                </div>
            </div>

            <div class="form-group">
                <label for="sparql-mode">–†–µ–∂–∏–º SPARQL:</label>
                <select id="sparql-mode" onchange="toggleSparqlPanel()">
                    <option value="smart-design" selected>SPARQL Smart Design</option>
                </select>
                <div class="mode-description" id="sparql-mode-description">
                    Smart Design –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è SPARQL –∑–∞–ø—Ä–æ—Å–æ–≤
                </div>
            </div>

            <div class="form-group" id="max-label-length-group">
                <label for="max-label-length">–ú–∞–∫—Å. –¥–ª–∏–Ω–∞ –∏–º–µ–Ω–∏:</label>
                <input type="number" id="max-label-length" value="25" min="5" max="200" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                <div class="mode-description" id="max-label-length-description">
                    –ü–µ—Ä–µ–Ω–æ—Å –ø–æ —Å–ª–æ–≤–∞–º –ø—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏
                </div>
            </div>

            <div class="form-group" id="max-vad-row-length-group" style="display: none;">
                <label for="max-vad-row-length">–ú–∞–∫—Å. –¥–ª–∏–Ω–∞ VAD:</label>
                <input type="number" id="max-vad-row-length" value="8" min="2" max="20" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                <div class="mode-description" id="max-vad-row-length-description">
                    –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ VAD-—ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ —Å—Ç—Ä–æ–∫–µ –¥–æ –ø–µ—Ä–µ–Ω–æ—Å–∞
                </div>
            </div>
        </div>

        <button id="visualize-btn" onclick="visualize()">–ü–æ–∫–∞–∑–∞—Ç—å</button>
    </div>

    <!-- Smart Design Container - –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ "SPARQL Smart Design" –≤ —Ä–µ–∂–∏–º–µ VAD TriG -->
    <div class="smart-design-container" id="smart-design-container">
        <!-- –ü–∞–Ω–µ–ª—å Smart Design -->
        <div class="smart-design-panel">
            <h3>Smart Design</h3>
            <!-- –í–µ—Ä—Ö–Ω–∏–π —Ä—è–¥: TriG -->
            <div class="smart-design-trig-row">
                <div class="smart-design-field smart-design-field-trig">
                    <label for="smart-design-trig">TriG:</label>
                    <select id="smart-design-trig">
                        <option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ TriG --</option>
                    </select>
                </div>
            </div>
            <!-- –ù–∏–∂–Ω–∏–π —Ä—è–¥: Subject Type, Subject, Predicate, Object -->
            <div class="smart-design-fields">
                <div class="smart-design-field">
                    <label for="smart-design-subject-type">Subject Type:</label>
                    <div class="smart-design-field-wrapper">
                        <select id="smart-design-subject-type">
                            <option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø Subject --</option>
                        </select>
                        <button class="copy-to-clipboard-btn" onclick="copyFieldValue('smart-design-subject-type')" title="–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ">üìã</button>
                    </div>
                </div>
                <div class="smart-design-field">
                    <label for="smart-design-subject">Subject:</label>
                    <div class="smart-design-field-wrapper">
                        <select id="smart-design-subject">
                            <option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Subject --</option>
                        </select>
                        <button class="copy-to-clipboard-btn" onclick="copyFieldValue('smart-design-subject')" title="–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ">üìã</button>
                    </div>
                </div>
                <div class="smart-design-field">
                    <label for="smart-design-predicate">Predicate:</label>
                    <div class="smart-design-field-wrapper">
                        <select id="smart-design-predicate">
                            <option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Predicate --</option>
                        </select>
                        <button class="copy-to-clipboard-btn" onclick="copyFieldValue('smart-design-predicate')" title="–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ">üìã</button>
                    </div>
                </div>
                <div class="smart-design-field">
                    <label for="smart-design-object">Object:</label>
                    <div class="smart-design-field-wrapper">
                        <select id="smart-design-object">
                            <option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Object --</option>
                        </select>
                        <button class="copy-to-clipboard-btn" onclick="copyFieldValue('smart-design-object')" title="–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ">üìã</button>
                    </div>
                </div>
            </div>
            <div class="smart-design-buttons">
                <button class="new-trig-btn" onclick="openNewTrigModal()">New TriG (VADProcessDia)</button>
                <button class="del-trig-btn" onclick="openDelTrigModal()">Del TriG</button>
                <button onclick="smartDesignCreate()">–°–æ–∑–¥–∞—Ç—å SPARQL</button>
                <button onclick="smartDesignCreateWithPrefix()" style="background-color: #1565C0;">–°–æ–∑–¥–∞—Ç—å SPARQL (prefix)</button>
                <button class="delete-btn" onclick="smartDesignDelete()">–£–¥–∞–ª–∏—Ç—å —Ç—Ä–∏–ø–ª–µ—Ç</button>
                <button class="clear-btn" onclick="smartDesignClear()">–û—á–∏—Å—Ç–∏—Ç—å</button>
            </div>
            <div id="smart-design-message" class="smart-design-message" style="display: none;"></div>
        </div>
        <!-- –ü–∞–Ω–µ–ª—å Result in SPARQL -->
        <div class="result-sparql-panel">
            <h3>Result in SPARQL</h3>
            <textarea class="result-sparql-textarea" id="result-sparql-query" placeholder="–ó–¥–µ—Å—å –±—É–¥–µ—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π SPARQL –∑–∞–ø—Ä–æ—Å..."></textarea>
            <div class="smart-design-buttons" style="margin-top: 10px;">
                <button class="apply-btn" onclick="smartDesignApply()">–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫–∞–∫ Simple Triple</button>
                <button class="apply-btn" onclick="smartDesignApplyShorthand()" style="background-color: #8E24AA;">–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫–∞–∫ Shorthand Triple</button>
            </div>
            <div id="result-sparql-message" class="smart-design-message" style="display: none;"></div>
        </div>
    </div>

    <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ TriG -->
    <div id="new-trig-modal" class="new-trig-modal">
        <div class="new-trig-modal-content">
            <div class="new-trig-modal-header">
                <h3>–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ TriG –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ (VADProcessDia)</h3>
                <button class="new-trig-modal-close" onclick="closeNewTrigModal()">&times;</button>
            </div>
            <div class="new-trig-modal-body">
                <div class="new-trig-field">
                    <label for="new-trig-process-concept">–ö–æ–Ω—Ü–µ–ø—Ç –ø—Ä–æ—Ü–µ—Å—Å–∞:</label>
                    <select id="new-trig-process-concept" onchange="updateNewTrigFields()">
                        <option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ü–µ–ø—Ç –ø—Ä–æ—Ü–µ—Å—Å–∞ --</option>
                    </select>
                    <small class="field-hint">ID –∏ label TriG —Ñ–æ—Ä–º–∏—Ä—É—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ü–µ–ø—Ç–∞</small>
                </div>
                <div class="new-trig-field">
                    <label for="new-trig-id">ID –Ω–æ–≤–æ–≥–æ TriG (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏):</label>
                    <input type="text" id="new-trig-id" placeholder="t_{processId}" readonly style="background-color: #f5f5f5;">
                </div>
                <div class="new-trig-field">
                    <label for="new-trig-label">rdfs:label (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏):</label>
                    <input type="text" id="new-trig-label" placeholder="–°—Ö–µ–º–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞ {processLabel}" readonly style="background-color: #f5f5f5;">
                </div>
                <div class="new-trig-field">
                    <label for="new-trig-parent">vad:hasParentTrig (—Ä–æ–¥–∏—Ç–µ–ª—å):</label>
                    <select id="new-trig-parent">
                        <option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–¥–∏—Ç–µ–ª—è --</option>
                    </select>
                </div>
            </div>
            <div class="new-trig-modal-buttons">
                <button class="new-trig-cancel-btn" onclick="closeNewTrigModal()">–û—Ç–º–µ–Ω–∞</button>
                <button class="new-trig-create-btn" onclick="createNewTrig()">–°–æ–∑–¥–∞—Ç—å –∑–∞–ø—Ä–æ—Å New TriG</button>
            </div>
        </div>
    </div>

    <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è TriG -->
    <div id="del-trig-modal" class="new-trig-modal">
        <div class="new-trig-modal-content">
            <div class="new-trig-modal-header" style="background-color: #f44336;">
                <h3>–£–¥–∞–ª–µ–Ω–∏–µ TriG –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞</h3>
                <button class="new-trig-modal-close" onclick="closeDelTrigModal()">&times;</button>
            </div>
            <div class="new-trig-modal-body">
                <div class="new-trig-field">
                    <label for="del-trig-select">–í—ã–±–µ—Ä–∏—Ç–µ TriG –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:</label>
                    <select id="del-trig-select" onchange="updateDelTrigInfo()">
                        <option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ TriG --</option>
                    </select>
                </div>
                <div class="new-trig-field">
                    <label>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ TriG:</label>
                    <div id="del-trig-info" style="padding: 10px; background-color: #f5f5f5; border-radius: 4px; font-size: 13px; min-height: 60px;">
                        –í—ã–±–µ—Ä–∏—Ç–µ TriG –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
                    </div>
                </div>
                <div id="del-trig-warning" style="display: none; padding: 10px; background-color: #ffebee; border: 1px solid #f44336; border-radius: 4px; margin-top: 10px; color: #c62828;">
                </div>
            </div>
            <div class="new-trig-modal-buttons">
                <button class="new-trig-cancel-btn" onclick="closeDelTrigModal()">–û—Ç–º–µ–Ω–∞</button>
                <button class="new-trig-create-btn" id="del-trig-confirm-btn" onclick="deleteTriG()" style="background-color: #f44336;" disabled>–°–æ–∑–¥–∞—Ç—å –∑–∞–ø—Ä–æ—Å Del TriG</button>
            </div>
        </div>
    </div>

    <div class="result-container" id="result-container">
        <h2>–†–µ–∑—É–ª—å—Ç–∞—Ç:</h2>

        <!-- VAD TriG —Ä–µ–∂–∏–º: –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å –¥–∏–∞–≥—Ä–∞–º–º–æ–π —Å–ª–µ–≤–∞ –∏ –ø–∞–Ω–µ–ª—è–º–∏ —Å–ø—Ä–∞–≤–∞ -->
        <div class="vad-trig-container" id="vad-trig-container" style="display: none;">
            <!-- –û–±–µ—Ä—Ç–∫–∞ –¥–ª—è –¥–∏–∞–≥—Ä–∞–º–º—ã -->
            <div class="vad-trig-diagram-wrapper">
                <div class="diagram-panel">
                    <div class="diagram-panel-header">–î–∏–∞–≥—Ä–∞–º–º–∞</div>
                    <div class="diagram-panel-content">
                        <div class="zoom-container vad-trig-zoom-container" id="vad-trig-zoom-container">
                            <div class="zoom-content" id="vad-trig-zoom-content">
                                <div id="vad-trig-output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="zoom-controls vad-trig-zoom-controls" id="vad-trig-zoom-controls" style="display: none;">
                        <button onclick="zoomOut()">-</button>
                        <span id="vad-trig-zoom-level">100%</span>
                        <button onclick="zoomIn()">+</button>
                        <button onclick="zoomReset()">–°–±—Ä–æ—Å</button>
                        <button onclick="zoomFit()">–í–ø–∏—Å–∞—Ç—å</button>
                    </div>
                </div>
            </div>

            <!-- –ü–∞–Ω–µ–ª–∏ —Å–ª–µ–≤–∞ -->
            <div class="vad-trig-left-panels">
                <!-- –ü–∞–Ω–µ–ª—å –¥–µ—Ä–µ–≤–∞ TriG -->
                <div class="trig-tree-panel">
                    <div class="trig-tree-header">–î–µ—Ä–µ–≤–æ TriG</div>
                    <div class="trig-tree-content" id="trig-tree-content">
                        <div class="trig-properties-empty">–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ TriG</div>
                    </div>
                </div>

                <!-- –ü–∞–Ω–µ–ª—å —Å–≤–æ–π—Å—Ç–≤ –æ–±—ä–µ–∫—Ç–∞ -->
                <div class="trig-properties-panel">
                    <div class="trig-properties-header">–û–∫–Ω–æ —Å–≤–æ–π—Å—Ç–≤ –æ–±—ä–µ–∫—Ç–∞</div>
                    <div class="trig-properties-content" id="trig-properties-content">
                        <div class="trig-properties-empty">–í—ã–±–µ—Ä–∏—Ç–µ TriG –≤ –¥–µ—Ä–µ–≤–µ</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="zoom-controls" id="zoom-controls" style="display: none;">
            <button onclick="zoomOut()">-</button>
            <span id="zoom-level">100%</span>
            <button onclick="zoomIn()">+</button>
            <button onclick="zoomReset()">–°–±—Ä–æ—Å</button>
            <button onclick="zoomFit()">–í–ø–∏—Å–∞—Ç—å</button>
        </div>
        <div class="zoom-container" id="zoom-container">
            <div class="zoom-content" id="zoom-content">
                <div id="output"></div>
            </div>
        </div>
        <div class="export-buttons" id="export-buttons" style="display: none;">
            <button onclick="downloadSVG()">–°–∫–∞—á–∞—Ç—å SVG</button>
            <button onclick="downloadPNG()">–°–∫–∞—á–∞—Ç—å PNG</button>
            <button onclick="openInNewWindowGitHub()">–ü–æ–∫–∞–∑–∞—Ç—å –≤ –æ–∫–Ω–µ github</button>
            <button onclick="openInNewWindowLdfFi()">–ü–æ–∫–∞–∑–∞—Ç—å –≤ –æ–∫–Ω–µ ldf.fi</button>
            <button onclick="openInNewWindowGraphvizOnline()">–ü–æ–∫–∞–∑–∞—Ç—å –≤ –æ–∫–Ω–µ GraphvizOnline</button>
        </div>
        <div class="legend-panel" id="legend-panel" style="display: none;">
            <h3>–õ–µ–≥–µ–Ω–¥–∞ —Å—Ç–∏–ª–µ–π:</h3>
            <div class="legend-content" id="legend-content"></div>
        </div>
        <div class="prefixes-panel" id="prefixes-panel" style="display: none;">
            <h3>Prefixes:</h3>
            <div class="prefixes-content" id="prefixes-content"></div>
        </div>
        <div class="sparql-panel" id="sparql-panel">
            <h3>SPARQL –∑–∞–ø—Ä–æ—Å:</h3>
            <textarea class="sparql-query-textarea" id="sparql-query" placeholder="–í–≤–µ–¥–∏—Ç–µ SPARQL –∑–∞–ø—Ä–æ—Å...">SELECT ?s ?p ?o
WHERE {
    ?s ?p ?o .
}</textarea>
            <div class="sparql-buttons">
                <button onclick="executeSparqlQuery()">–í—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å</button>
                <button onclick="resetSparqlQuery()">–°–±—Ä–æ—Å–∏—Ç—å</button>
            </div>
            <div class="sparql-results" id="sparql-results" style="display: none;">
                <h4>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞–ø—Ä–æ—Å–∞:</h4>
                <div id="sparql-results-content"></div>
            </div>
        </div>
    </div>

    <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ N3.js –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ RDF -->
    <script src="https://unpkg.com/n3@1.17.2/browser/n3.min.js"></script>

    <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ Viz.js –¥–ª—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ –≥—Ä–∞—Ñ–æ–≤ -->
    <script src="https://unpkg.com/@viz-js/viz@3.4.0/lib/viz-standalone.js"></script>

    <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ Comunica –¥–ª—è SPARQL –∑–∞–ø—Ä–æ—Å–æ–≤ -->
    <script src="https://rdf.js.org/comunica-browser/versions/v4/engines/query-sparql-rdfjs/comunica-browser.js"></script>

    <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ SPARQL –∑–∞–ø—Ä–æ—Å–æ–≤ –¥–ª—è Smart Design (—Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏) -->
    <script src="sparql-queries-choice.js"></script>

    <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ SPARQL –∑–∞–ø—Ä–æ—Å–æ–≤ –¥–ª—è –ª–æ–≥–∏–∫–∏ –∫–æ–¥–∞ -->
    <script src="sparql-queries-code.js"></script>

    <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª –≤–∞–ª–∏–¥–∞—Ü–∏–∏ VAD —Å—Ö–µ–º—ã -->
    <script src="vad-validation-rules.js"></script>

    <script>
        /**
         * RDF Grapher ver4p - –û—Å–Ω–æ–≤–Ω–æ–π JavaScript –º–æ–¥—É–ª—å
         */

        // ============================================================================
        // –†–ï–ñ–ò–ú –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–ò
        // ============================================================================

        const Mode = 'notation';

        // ============================================================================
        // EMBEDDED EXAMPLE DATA
        // ============================================================================

        const EXAMPLE_DATA = {
            // TriG VADv4 –ø—Ä–∏–º–µ—Ä
            'trig-vad-v4': `# –ü—Ä–∏–º–µ—Ä TriG VADv4 (Value Added Chain Diagram —Å –∏–µ—Ä–∞—Ä—Ö–∏–µ–π TriG)
# –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –∏–µ—Ä–∞—Ä—Ö–∏–∏ TriG –≥—Ä–∞—Ñ–æ–≤ —á–µ—Ä–µ–∑ hasParentTrig
# –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤ vad:rtree (–î–µ—Ä–µ–≤–æ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π)
#
# vad:processSubtype –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ virtualRDFdata:
# - vad:DetailedChild: –ø—Ä–æ—Ü–µ—Å—Å —Å vad:hasTrig, –≥–¥–µ –¥–æ—á–µ—Ä–Ω–∏–π TriG —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–µ–∫—É—â–∏–π
# - vad:notDetailedChild: –ø—Ä–æ—Ü–µ—Å—Å —Å vad:hasParentProcess, —Å–æ–≤–ø–∞–¥–∞—é—â–∏–º —Å —Ä–æ–¥–∏—Ç–µ–ª–µ–º —Ç–µ–∫—É—â–µ–π —Å—Ö–µ–º—ã
# - vad:NotDefinedType: –ø—Ä–æ—Ü–µ—Å—Å —Å vad:hasParentProcess = vad:NotDefined
#
# –í–ê–ñ–ù–´–ï –ü–†–ê–í–ò–õ–ê:
# 1. vad:hasTrig –∏ vad:hasParentProcess - –≤–∑–∞–∏–º–æ–∏—Å–∫–ª—é—á–∞—é—â–∏–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã
# 2. vad:processSubtype –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ virtualRDFdata
# 3. vad:isSubprocessTrig —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø–µ—Ä–≤—ã–º –¥–ª—è —è–≤–Ω–æ–π —Å–≤—è–∑–∏ –∏–Ω–¥–∏–≤–∏–¥–∞ —Å TriG
# 4. ID –≥—Ä—É–ø–ø—ã –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è –∫–∞–∫: ExecutorGroup_ + ID –ø—Ä–æ—Ü–µ—Å—Å–∞

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix vad: <http://example.org/vad#> .

# ============================================================================
# –î–µ—Ä–µ–≤–æ –ü—Ä–æ—Ü–µ—Å—Å–æ–≤ (ptree) - –æ–±—â–∏–π –≥—Ä–∞—Ñ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ –≤—Å–µ—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
# ============================================================================

vad:ptree {
    vad:ptree rdf:type vad:ProcessTree ;
        rdfs:label "–î–µ—Ä–µ–≤–æ –ü—Ä–æ—Ü–µ—Å—Å–æ–≤ (TriG)" ;
        vad:hasParentTrig vad:root .

    vad:p1 rdf:type vad:TypeProcess ;
        rdfs:label "p1 –ü—Ä–æ—Ü–µ—Å—Å 1" ;
        dcterms:description "p1 –ü—Ä–æ—Ü–µ—Å—Å 1" ;
        vad:hasTrig vad:t_p1 .

    vad:p1.1 rdf:type vad:TypeProcess ;
        rdfs:label "p1.1 –ü—Ä–æ—Ü–µ—Å—Å 1.1" ;
        dcterms:description "–ü–µ—Ä–≤—ã–π –ø—Ä–æ—Ü–µ—Å—Å –≤ —Ü–µ–ø–æ—á–∫–µ –¥–æ–±–∞–≤–ª–µ–Ω–Ω–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç–∏" ;
        vad:hasTrig vad:t_p1.1 .

    vad:p1.2 rdf:type vad:TypeProcess ;
        rdfs:label "–ü—Ä–æ—Ü–µ—Å—Å 1.2" ;
        dcterms:description "–í—Ç–æ—Ä–æ–π –ø—Ä–æ—Ü–µ—Å—Å, –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø–æ—Å–ª–µ –ü—Ä–æ—Ü–µ—Å—Å–∞ 1" ;
        vad:hasParentProcess vad:p1 .

    # p1.1.1
    vad:p1.1.1 rdf:type vad:TypeProcess ;
        rdfs:label "p1.1.1 –ü—Ä–æ—Ü–µ—Å—Å 1.1.1" ;
        dcterms:description "–ü–µ—Ä–≤—ã–π –ø—Ä–æ—Ü–µ—Å—Å –≤ —Ü–µ–ø–æ—á–∫–µ –¥–æ–±–∞–≤–ª–µ–Ω–Ω–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç–∏" ;
        vad:hasParentProcess vad:p1.1 .

    vad:p1.1.2 rdf:type vad:TypeProcess ;
        rdfs:label "p1.1.2 –ü—Ä–æ—Ü–µ—Å—Å 1.1.2" ;
        dcterms:description "–í—Ç–æ—Ä–æ–π –ø—Ä–æ—Ü–µ—Å—Å –≤ —Ü–µ–ø–æ—á–∫–µ –¥–æ–±–∞–≤–ª–µ–Ω–Ω–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç–∏" ;
        vad:hasParentProcess vad:p2 .

    vad:p2 rdf:type vad:TypeProcess ;
        rdfs:label "p2 –ü—Ä–æ—Ü–µ—Å—Å 2" ;
        dcterms:description "p2 –ü—Ä–æ—Ü–µ—Å—Å 2" ;
        vad:hasTrig vad:t_p2 .

    vad:p2.1 rdf:type vad:TypeProcess ;
        rdfs:label "p2.1 –ü—Ä–æ—Ü–µ—Å—Å 2.1" ;
        dcterms:description "–ü–µ—Ä–≤—ã–π –ø—Ä–æ—Ü–µ—Å—Å –≤ —Ü–µ–ø–æ—á–∫–µ –¥–æ–±–∞–≤–ª–µ–Ω–Ω–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç–∏" ;
        vad:hasParentProcess vad:p2 .

    vad:p2.2 rdf:type vad:TypeProcess ;
        rdfs:label "p2.2 –ü—Ä–æ—Ü–µ—Å—Å 2.2" ;
        dcterms:description "–í—Ç–æ—Ä–æ–π –ø—Ä–æ—Ü–µ—Å—Å" ;
        vad:hasParentProcess vad:NotDefined .
}

# ============================================================================
# –î–µ—Ä–µ–≤–æ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π (rtree) - –æ–±—â–∏–π –≥—Ä–∞—Ñ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ –≤—Å–µ—Ö –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π
# –°–æ–¥–µ—Ä–∂–∏—Ç rdf:type, rdfs:label –¥–ª—è –≤—Å–µ—Ö vad:Executor
# ============================================================================

vad:rtree {
    vad:rtree rdf:type vad:ExecutorTree ;
        rdfs:label "–î–µ—Ä–µ–≤–æ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π (TriG)" ;
        vad:hasParentTrig vad:root .

    # –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–∏
    vad:Executor1 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 1" .

    vad:Executor2 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 2" .

    vad:Executor3 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 3" .

    vad:Executor4 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 4" .

    vad:Executor5 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 5" .

    vad:Executor6 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 6" .

    vad:Executor7 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 7" .

    vad:Executor8 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 8" .

    # –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–∏
    vad:Executor21 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 21" .

    vad:Executor22 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 22" .

    vad:Executor23 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 23" .

    vad:Executor24 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 24" .

    vad:Executor25 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 25" .

    vad:Executor26 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 26" .

    vad:Executor27 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 27" .

    vad:Executor28 rdf:type vad:TypeExecutor ;
        rdfs:label "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å 28" .
}

# ============================================================================
# –ö–æ—Ä–Ω–µ–≤–æ–π TriG –≥—Ä–∞—Ñ: t_p1 (hasParentTrig = root)
# ============================================================================

vad:t_p1 {
    vad:t_p1 rdf:type vad:VADProcessDia ;
        rdfs:label "–°—Ö–µ–º–∞ t_p1 –ø—Ä–æ—Ü–µ—Å—Å–∞ p1" ;
        vad:hasParentTrig vad:root ;
        vad:definesProcess vad:p1 .

    # –ü—Ä–æ—Ü–µ—Å—Å p1.1 - DetailedChild (–∏–º–µ–µ—Ç –¥–æ—á–µ—Ä–Ω—é—é —Å—Ö–µ–º—É vad:t_p1.1 —Å hasParentTrig –Ω–∞ —Ç–µ–∫—É—â—É—é)
    # rdf:type –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ vad:ptree
    # isSubprocessTrig —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø–µ—Ä–≤—ã–º –¥–ª—è —è–≤–Ω–æ–π —Å–≤—è–∑–∏ —Å TriG
    vad:p1.1 vad:isSubprocessTrig vad:t_p1 ;
        vad:hasExecutor vad:ExecutorGroup_p1.1 ;
        vad:hasNext vad:p1.2 .

    # –ü—Ä–æ—Ü–µ—Å—Å p1.2 - notDetailedChild
    vad:p1.2 vad:isSubprocessTrig vad:t_p1 ;
        vad:hasExecutor vad:ExecutorGroup_p1.2 .

    # –ì—Ä—É–ø–ø—ã –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π (ID —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è –∫–∞–∫ ExecutorGroup_ + ID –ø—Ä–æ—Ü–µ—Å—Å–∞)
    vad:ExecutorGroup_p1.1 rdf:type vad:ExecutorGroup ;
        rdfs:label "–ì—Ä—É–ø–ø–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –ø—Ä–æ—Ü–µ—Å—Å–∞ p1.1" ;
        vad:includes vad:Executor1 .

    vad:ExecutorGroup_p1.2 rdf:type vad:ExecutorGroup ;
        rdfs:label "–ì—Ä—É–ø–ø–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –ø—Ä–æ—Ü–µ—Å—Å–∞ p1.2" ;
        vad:includes vad:Executor1, vad:Executor2 .

    # –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–∏ (vad:Executor1..8) –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤ vad:rtree
}

# ============================================================================
# –î–æ—á–µ—Ä–Ω–∏–π TriG –≥—Ä–∞—Ñ: t_p1.1 (hasParentTrig = t_p1)
# –≠—Ç–æ –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞ p1.1 –∏–∑ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–≥–æ –≥—Ä–∞—Ñ–∞ t_p1
# ============================================================================

vad:t_p1.1 {
    vad:t_p1.1 rdf:type vad:VADProcessDia ;
        rdfs:label "–°—Ö–µ–º–∞ t_p1.1 –ø—Ä–æ—Ü–µ—Å—Å–∞ p1.1" ;
        vad:hasParentTrig vad:t_p1 ;
        vad:definesProcess vad:p1.1 .

    # –ü—Ä–æ—Ü–µ—Å—Å p1.1.1 - notDetailedChild
    # rdf:type –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ vad:ptree
    # isSubprocessTrig —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø–µ—Ä–≤—ã–º –¥–ª—è —è–≤–Ω–æ–π —Å–≤—è–∑–∏ —Å TriG
    vad:p1.1.1 vad:isSubprocessTrig vad:t_p1.1 ;
        vad:hasExecutor vad:ExecutorGroup_p1.1.1 ;
        vad:hasNext vad:p1.1.2 .

    # –ü—Ä–æ—Ü–µ—Å—Å p1.1.2 - notDetailedExternal (hasParentProcess = p2, –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å p1.1)
    vad:p1.1.2 vad:isSubprocessTrig vad:t_p1.1 ;
        vad:hasExecutor vad:ExecutorGroup_p1.1.2 .

    # –ì—Ä—É–ø–ø—ã –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π (ID —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è –∫–∞–∫ ExecutorGroup_ + ID –ø—Ä–æ—Ü–µ—Å—Å–∞)
    vad:ExecutorGroup_p1.1.1 rdf:type vad:ExecutorGroup ;
        rdfs:label "–ì—Ä—É–ø–ø–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –ø—Ä–æ—Ü–µ—Å—Å–∞ p1.1.1" ;
        vad:includes vad:Executor21 .

    vad:ExecutorGroup_p1.1.2 rdf:type vad:ExecutorGroup ;
        rdfs:label "–ì—Ä—É–ø–ø–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –ø—Ä–æ—Ü–µ—Å—Å–∞ p1.1.2" ;
        vad:includes vad:Executor21, vad:Executor22 .
}

# ============================================================================
# –ö–æ—Ä–Ω–µ–≤–æ–π TriG –≥—Ä–∞—Ñ: t_p2 (hasParentTrig = root)
# ============================================================================

vad:t_p2 {
    vad:t_p2 rdf:type vad:VADProcessDia ;
        rdfs:label "–°—Ö–µ–º–∞ t_p2 –ø—Ä–æ—Ü–µ—Å—Å–∞ p2" ;
        vad:hasParentTrig vad:root ;
        vad:definesProcess vad:p2 .

    # –ü—Ä–æ—Ü–µ—Å—Å p2.1 - notDetailedChild
    # rdf:type –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ vad:ptree
    # isSubprocessTrig —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø–µ—Ä–≤—ã–º –¥–ª—è —è–≤–Ω–æ–π —Å–≤—è–∑–∏ —Å TriG
    vad:p2.1 vad:isSubprocessTrig vad:t_p2 ;
        vad:hasExecutor vad:ExecutorGroup_p2.1 ;
        vad:hasNext vad:p2.2 .

    # –ü—Ä–æ—Ü–µ—Å—Å p2.2 - NotDefinedType (hasParentProcess = NotDefined)
    vad:p2.2 vad:isSubprocessTrig vad:t_p2 ;
        vad:hasExecutor vad:ExecutorGroup_p2.2 .

    # –ì—Ä—É–ø–ø—ã –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π (ID —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è –∫–∞–∫ ExecutorGroup_ + ID –ø—Ä–æ—Ü–µ—Å—Å–∞)
    vad:ExecutorGroup_p2.1 rdf:type vad:ExecutorGroup ;
        rdfs:label "–ì—Ä—É–ø–ø–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –ø—Ä–æ—Ü–µ—Å—Å–∞ p2.1" ;
        vad:includes vad:Executor1 .

    vad:ExecutorGroup_p2.2 rdf:type vad:ExecutorGroup ;
        rdfs:label "–ì—Ä—É–ø–ø–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –ø—Ä–æ—Ü–µ—Å—Å–∞ p2.2" ;
        vad:includes vad:Executor1, vad:Executor2 .
}\`
        };

        // ============================================================================
        // –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –§–ò–õ–¨–¢–†–û–í
        // ============================================================================

        const Filter = {
            hiddenPredicates: [
                'rdf:type',
                'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
                'rdfs:subClassOf',
                'http://www.w3.org/2000/01/rdf-schema#subClassOf'
            ]
        };

        const FilterBase = {
            hiddenPredicates: []
        };

        const FilterAggregation = {
            hiddenPredicates: [
                'rdf:type',
                'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
                'rdfs:subClassOf',
                'http://www.w3.org/2000/01/rdf-schema#subClassOf'
            ]
        };

        // –§–∏–ª—å—Ç—Ä—ã –¥–ª—è —Ä–µ–∂–∏–º–∞ VAD - —Å–∫—Ä—ã–≤–∞–µ–º hasParentTrig –∏ rdf:type
        const FilterVAD = {
            hiddenPredicates: [
                'rdf:type',
                'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
                'vad:hasParentTrig',
                'http://example.org/vad#hasParentTrig'
            ]
        };

        function getFilterConfig(mode) {
            if (mode === 'base') {
                return FilterBase;
            } else if (mode === 'aggregation') {
                return FilterAggregation;
            } else if (mode === 'vad' || mode === 'vad-trig') {
                return FilterVAD;
            }
            return Filter;
        }

        // ============================================================================
        // –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ê–ì–†–ï–ì–ê–¶–ò–ò
        // ============================================================================

        const MaxAggregationParams = 5;
        const DEFAULT_MAX_LABEL_LENGTH = 25;
        let currentMaxLabelLength = DEFAULT_MAX_LABEL_LENGTH;

        // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ VAD —ç–ª–µ–º–µ–Ω—Ç–æ–≤ (CDS) –≤ –æ–¥–Ω–æ–π –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–π —Å—Ç—Ä–æ–∫–µ
        const DEFAULT_MAX_VAD_ROW_LENGTH = 8;
        let currentMaxVadRowLength = DEFAULT_MAX_VAD_ROW_LENGTH;

        // ============================================================================
        // –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø VAD (Value Added Chain Diagram)
        // ============================================================================

        /**
         * VAD_ALLOWED_TYPES - –†–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã –æ–±—ä–µ–∫—Ç–æ–≤ –¥–ª—è —Ä–µ–∂–∏–º–∞ VAD
         */
        const VAD_ALLOWED_TYPES = [
            'vad:TypeProcess',
            'http://example.org/vad#TypeProcess',
            'vad:ExecutorGroup',
            'http://example.org/vad#ExecutorGroup',
            'vad:TypeExecutor',
            'http://example.org/vad#TypeExecutor',
            'vad:VADProcessDia',
            'http://example.org/vad#VADProcessDia',
            'vad:ProcessTree',
            'http://example.org/vad#ProcessTree',
            'vad:ExecutorTree',
            'http://example.org/vad#ExecutorTree',
            // Process subtypes - parent classes
            'vad:Detailed',
            'http://example.org/vad#Detailed',
            'vad:notDetailed',
            'http://example.org/vad#notDetailed',
            // Detailed subtypes (process has vad:hasTrig)
            'vad:DetailedChild',
            'http://example.org/vad#DetailedChild',
            'vad:DetailedExternal',
            'http://example.org/vad#DetailedExternal',
            // notDetailed subtypes (process has vad:hasParentProcess)
            'vad:notDetailedChild',
            'http://example.org/vad#notDetailedChild',
            'vad:notDetailedExternal',
            'http://example.org/vad#notDetailedExternal',
            'vad:NotDefinedType',
            'http://example.org/vad#NotDefinedType',
            // Special values
            'vad:NotDefined',
            'http://example.org/vad#NotDefined'
        ];

        /**
         * VAD_ALLOWED_PREDICATES - –†–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –¥–ª—è —Ä–µ–∂–∏–º–∞ VAD
         */
        const VAD_ALLOWED_PREDICATES = [
            'rdf:type',
            'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
            'rdfs:label',
            'http://www.w3.org/2000/01/rdf-schema#label',
            'dcterms:description',
            'http://purl.org/dc/terms/description',
            'vad:hasNext',
            'http://example.org/vad#hasNext',
            'vad:hasExecutor',
            'http://example.org/vad#hasExecutor',
            'vad:hasParentTrig',
            'http://example.org/vad#hasParentTrig',
            'vad:includes',
            'http://example.org/vad#includes',
            'vad:processSubtype',
            'http://example.org/vad#processSubtype',
            'vad:hasTrig',
            'http://example.org/vad#hasTrig',
            'vad:definesProcess',
            'http://example.org/vad#definesProcess',
            'vad:isSubprocessTrig',
            'http://example.org/vad#isSubprocessTrig',
            'vad:hasParentProcess',
            'http://example.org/vad#hasParentProcess'
        ];

        /**
         * PTREE_PREDICATES - –ü—Ä–µ–¥–∏–∫–∞—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –¥–ª—è —Å—É—â–Ω–æ—Å—Ç–µ–π —Ç–∏–ø–∞ vad:TypeProcess
         * –¥–æ–ª–∂–Ω—ã —Ö—Ä–∞–Ω–∏—Ç—å—Å—è –≤ –≥—Ä–∞—Ñ–µ vad:ptree (–î–µ—Ä–µ–≤–æ –ü—Ä–æ—Ü–µ—Å—Å–æ–≤)
         * –û—Å—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –æ—Å—Ç–∞—é—Ç—Å—è –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–º TriG (—Å—Ö–µ–º–µ –ø—Ä–æ—Ü–µ—Å—Å–∞)
         */
        const PTREE_PREDICATES = [
            'rdf:type',
            'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
            'rdfs:label',
            'http://www.w3.org/2000/01/rdf-schema#label',
            'dcterms:description',
            'http://purl.org/dc/terms/description',
            'vad:hasTrig',
            'http://example.org/vad#hasTrig',
            'vad:hasParentProcess',
            'http://example.org/vad#hasParentProcess'
        ];

        /**
         * RTREE_PREDICATES - –ü—Ä–µ–¥–∏–∫–∞—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –¥–ª—è —Å—É—â–Ω–æ—Å—Ç–µ–π —Ç–∏–ø–∞ vad:TypeExecutor
         * –¥–æ–ª–∂–Ω—ã —Ö—Ä–∞–Ω–∏—Ç—å—Å—è –≤ –≥—Ä–∞—Ñ–µ vad:rtree (–î–µ—Ä–µ–≤–æ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π)
         * –û—Å—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –æ—Å—Ç–∞—é—Ç—Å—è –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–º TriG (—Å—Ö–µ–º–µ –ø—Ä–æ—Ü–µ—Å—Å–∞)
         */
        const RTREE_PREDICATES = [
            'rdf:type',
            'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
            'rdfs:label',
            'http://www.w3.org/2000/01/rdf-schema#label'
        ];

        /**
         * TRIG_TYPES - –¢–∏–ø—ã TriG –≥—Ä–∞—Ñ–æ–≤ –≤ VAD –æ–Ω—Ç–æ–ª–æ–≥–∏–∏
         * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–∏–ø–æ–≤ –≥—Ä–∞—Ñ–æ–≤
         */
        const TRIG_TYPES = {
            PROCESS_TREE: ['vad:ProcessTree', 'http://example.org/vad#ProcessTree'],
            EXECUTOR_TREE: ['vad:ExecutorTree', 'http://example.org/vad#ExecutorTree'],
            VAD_PROCESS_DIA: ['vad:VADProcessDia', 'http://example.org/vad#VADProcessDia']
        };

        /**
         * PROCESS_SUBTYPES - –ü–æ–¥—Ç–∏–ø—ã –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –≤ VAD –æ–Ω—Ç–æ–ª–æ–≥–∏–∏
         *
         * Detailed (–∏–º–µ–µ—Ç vad:hasTrig):
         * - DetailedChild: –¥–æ—á–µ—Ä–Ω—è—è —Å—Ö–µ–º–∞ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–µ–∫—É—â—É—é (hasParentTrig)
         * - DetailedExternal: –¥–æ—á–µ—Ä–Ω—è—è —Å—Ö–µ–º–∞ –ù–ï —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–µ–∫—É—â—É—é
         *
         * notDetailed (–ù–ï –∏–º–µ–µ—Ç vad:hasTrig):
         * - notDetailedChild: hasParentProcess —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å —Ç–µ–∫—É—â–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º
         * - notDetailedExternal: hasParentProcess –ù–ï —Å–æ–≤–ø–∞–¥–∞–µ—Ç
         * - NotDefinedType: hasParentProcess = NotDefined
         *
         * Basic –∏ Detailed - —É—Å—Ç–∞—Ä–µ–≤—à–∏–µ, –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
         */
        const PROCESS_SUBTYPES = {
            // –£—Å—Ç–∞—Ä–µ–≤—à–∏–µ (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
            BASIC: ['vad:Basic', 'http://example.org/vad#Basic'],
            DETAILED: ['vad:Detailed', 'http://example.org/vad#Detailed'],
            // –î–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ (–∏–º–µ—é—Ç vad:hasTrig)
            DETAILED_CHILD: ['vad:DetailedChild', 'http://example.org/vad#DetailedChild'],
            DETAILED_EXTERNAL: ['vad:DetailedExternal', 'http://example.org/vad#DetailedExternal'],
            // –ù–µ–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ (–ù–ï –∏–º–µ—é—Ç vad:hasTrig)
            NOT_DETAILED: ['vad:notDetailed', 'http://example.org/vad#notDetailed'],
            NOT_DETAILED_CHILD: ['vad:notDetailedChild', 'http://example.org/vad#notDetailedChild'],
            NOT_DETAILED_EXTERNAL: ['vad:notDetailedExternal', 'http://example.org/vad#notDetailedExternal'],
            NOT_DEFINED_TYPE: ['vad:NotDefinedType', 'http://example.org/vad#NotDefinedType']
        };

        /**
         * TYPE_PREDICATE_MAP - –°–≤–æ–¥–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ ¬´–û–±—ä–µ–∫—Ç-–ü—Ä–µ–¥–∏–∫–∞—Ç¬ª (–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ 1 –∫ –æ–Ω—Ç–æ–ª–æ–≥–∏–∏)
         * –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –¥–æ–ø—É—Å—Ç–∏–º—ã–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞ –æ–±—ä–µ–∫—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ TriG
         *
         * –°–≤—è–∑—å —Å –æ–Ω—Ç–æ–ª–æ–≥–∏–µ–π: –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ 1 –≤ vad-basic-ontology.ttl
         */
        const TYPE_PREDICATE_MAP = {
            // Process –≤ ptree (–∫–æ–Ω—Ü–µ–ø—Ç) - –æ–±—â–∏–µ —Å–≤–æ–π—Å—Ç–≤–∞
            'vad:TypeProcess': {
                ptree: [
                    'rdf:type',
                    'rdfs:label',
                    'dcterms:description',
                    'vad:hasTrig',
                    'vad:hasParentProcess'
                ],
                // Process –≤ VADProcessDia (–∏–Ω–¥–∏–≤–∏–¥) - –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞
                vadProcessDia: [
                    'vad:isSubprocessTrig',
                    'vad:hasExecutor',
                    'vad:processSubtype',
                    'vad:hasNext'
                ]
            },
            // Executor –≤ rtree - –æ–±—â–∏–µ —Å–≤–æ–π—Å—Ç–≤–∞
            'vad:TypeExecutor': {
                rtree: [
                    'rdf:type',
                    'rdfs:label'
                ]
            },
            // ExecutorGroup –≤ VADProcessDia
            'vad:ExecutorGroup': {
                vadProcessDia: [
                    'rdf:type',
                    'rdfs:label',
                    'vad:includes'
                ]
            },
            // VADProcessDia - —Å–≤–æ–π—Å—Ç–≤–∞ —Å—Ö–µ–º—ã –ø—Ä–æ—Ü–µ—Å—Å–∞
            'vad:VADProcessDia': {
                vadProcessDia: [
                    'rdf:type',
                    'rdfs:label',
                    'vad:hasParentTrig',
                    'vad:definesProcess'
                ]
            },
            // ProcessTree (vad:ptree)
            'vad:ProcessTree': {
                ptree: [
                    'rdf:type',
                    'rdfs:label',
                    'vad:hasParentTrig'
                ]
            },
            // ExecutorTree (vad:rtree)
            'vad:ExecutorTree': {
                rtree: [
                    'rdf:type',
                    'rdfs:label',
                    'vad:hasParentTrig'
                ]
            }
        };

        /**
         * –†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã Smart Design:
         * - 'filtered' - —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏ —Ñ–∏–ª—å—Ç—Ä—É—é—Ç—Å—è –ø–æ —Å–≤—è–∑–∞–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏—è–º (Subject Type -> Predicate)
         * - 'full' - —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏ –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç –ø–æ–ª–Ω—ã–π –Ω–∞–±–æ—Ä –∑–Ω–∞—á–µ–Ω–∏–π
         */
        let smartDesignMode = 'filtered';

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø—Ä–µ–¥–∏–∫–∞—Ç –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–º –¥–ª—è ptree
         * @param {string} predicateUri - URI –∏–ª–∏ prefixed name –ø—Ä–µ–¥–∏–∫–∞—Ç–∞
         * @returns {boolean}
         */
        function isPtreePredicate(predicateUri) {
            return PTREE_PREDICATES.some(allowed =>
                predicateUri === allowed || predicateUri.endsWith('#' + allowed.split(':')[1])
            );
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø—Ä–µ–¥–∏–∫–∞—Ç –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–º –¥–ª—è rtree
         * @param {string} predicateUri - URI –∏–ª–∏ prefixed name –ø—Ä–µ–¥–∏–∫–∞—Ç–∞
         * @returns {boolean}
         */
        function isRtreePredicate(predicateUri) {
            return RTREE_PREDICATES.some(allowed =>
                predicateUri === allowed || predicateUri.endsWith('#' + allowed.split(':')[1])
            );
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—É–±—ä–µ–∫—Ç —Ç–∏–ø–æ–º vad:TypeProcess
         * @param {string} subjectUri - URI —Å—É–±—ä–µ–∫—Ç–∞
         * @returns {boolean}
         */
        function isSubjectVadProcess(subjectUri) {
            const types = nodeTypesCache[subjectUri] || [];
            return types.some(t =>
                t === 'vad:TypeProcess' || t === 'http://example.org/vad#TypeProcess'
            );
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—É–±—ä–µ–∫—Ç —Ç–∏–ø–æ–º vad:TypeExecutor
         * @param {string} subjectUri - URI —Å—É–±—ä–µ–∫—Ç–∞
         * @returns {boolean}
         */
        function isSubjectVadExecutor(subjectUri) {
            const types = nodeTypesCache[subjectUri] || [];
            return types.some(t =>
                t === 'vad:TypeExecutor' || t === 'http://example.org/vad#TypeExecutor'
            );
        }

        /**
         * –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–∏–ø TriG –≥—Ä–∞—Ñ–∞
         * @param {string} trigUri - URI TriG –≥—Ä–∞—Ñ–∞
         * @param {Array} quads - –ú–∞—Å—Å–∏–≤ –∫–≤–∞–¥–æ–≤
         * @returns {string|null} - –¢–∏–ø –≥—Ä–∞—Ñ–∞ –∏–ª–∏ null
         */
        function getTrigType(trigUri, quads) {
            const typeQuad = quads.find(quad =>
                quad.subject.value === trigUri &&
                (quad.predicate.value.endsWith('#type') ||
                 quad.predicate.value === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
            );

            if (typeQuad) {
                const typeValue = typeQuad.object.value;
                if (TRIG_TYPES.PROCESS_TREE.some(t => typeValue === t || typeValue.endsWith('#ProcessTree'))) {
                    return 'vad:ProcessTree';
                }
                if (TRIG_TYPES.EXECUTOR_TREE.some(t => typeValue === t || typeValue.endsWith('#ExecutorTree'))) {
                    return 'vad:ExecutorTree';
                }
                if (TRIG_TYPES.VAD_PROCESS_DIA.some(t => typeValue === t || typeValue.endsWith('#VADProcessDia'))) {
                    return 'vad:VADProcessDia';
                }
            }

            // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –ø–æ —ç–≤—Ä–∏—Å—Ç–∏–∫–µ (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
            if (trigUri.endsWith('#ptree') || trigUri.includes('ptree')) {
                return 'vad:ProcessTree';
            }
            if (trigUri.endsWith('#rtree') || trigUri.includes('rtree')) {
                return 'vad:ExecutorTree';
            }
            return 'vad:VADProcessDia';
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–∏–ø —Ç–∏–ø–æ–º ProcessTree
         * @param {string} typeUri - URI —Ç–∏–ø–∞
         * @returns {boolean}
         */
        function isProcessTreeType(typeUri) {
            return TRIG_TYPES.PROCESS_TREE.some(t =>
                typeUri === t || typeUri.endsWith('#ProcessTree')
            );
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–∏–ø —Ç–∏–ø–æ–º ExecutorTree
         * @param {string} typeUri - URI —Ç–∏–ø–∞
         * @returns {boolean}
         */
        function isExecutorTreeType(typeUri) {
            return TRIG_TYPES.EXECUTOR_TREE.some(t =>
                typeUri === t || typeUri.endsWith('#ExecutorTree')
            );
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–∏–ø —Ç–∏–ø–æ–º VADProcessDia
         * @param {string} typeUri - URI —Ç–∏–ø–∞
         * @returns {boolean}
         */
        function isVADProcessDiaType(typeUri) {
            return TRIG_TYPES.VAD_PROCESS_DIA.some(t =>
                typeUri === t || typeUri.endsWith('#VADProcessDia')
            );
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–¥—Ç–∏–ø –ø—Ä–æ—Ü–µ—Å—Å–∞ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º (Detailed, DetailedChild, DetailedExternal)
         * @param {string} subtypeUri - URI –ø–æ–¥—Ç–∏–ø–∞
         * @returns {boolean}
         */
        function isDetailedSubtype(subtypeUri) {
            return PROCESS_SUBTYPES.DETAILED.some(t => subtypeUri === t || subtypeUri.endsWith('#Detailed')) ||
                   PROCESS_SUBTYPES.DETAILED_CHILD.some(t => subtypeUri === t || subtypeUri.endsWith('#DetailedChild')) ||
                   PROCESS_SUBTYPES.DETAILED_EXTERNAL.some(t => subtypeUri === t || subtypeUri.endsWith('#DetailedExternal'));
        }

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∏–ª—å VADNodeStyle –¥–ª—è –ø—Ä–æ—Ü–µ—Å—Å–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –µ–≥–æ processSubtype
         * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ —Å —Ä–∞–∑–Ω—ã–º–∏ —Ü–≤–µ—Ç–∞–º–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–æ–¥—Ç–∏–ø–∞
         * @param {Array<string>} nodeSubtypes - –º–∞—Å—Å–∏–≤ –ø–æ–¥—Ç–∏–ø–æ–≤ –ø—Ä–æ—Ü–µ—Å—Å–∞
         * @returns {string} - DOT-—Å—Ç—Ä–æ–∫–∞ —Å—Ç–∏–ª—è –¥–ª—è —É–∑–ª–∞
         */
        function getProcessStyleForSubtype(nodeSubtypes) {
            // –ü–æ—Ä—è–¥–æ–∫ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏:
            // 1. –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –ø–æ–¥—Ç–∏–ø—ã (DetailedChild, DetailedExternal, notDetailedChild, notDetailedExternal, NotDefinedType)
            // 2. –û–±—â–∏–µ –ø–æ–¥—Ç–∏–ø—ã (Detailed, notDetailed)
            // 3. –£—Å—Ç–∞—Ä–µ–≤—à–∏–µ –ø–æ–¥—Ç–∏–ø—ã (Basic)
            // 4. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é - notDetailedChild (–∑–µ–ª–µ–Ω—ã–π)

            for (const subtype of nodeSubtypes) {
                // DetailedChild - –≥–æ–ª—É–±–æ–π
                if (PROCESS_SUBTYPES.DETAILED_CHILD.some(t => subtype === t || subtype.endsWith('#DetailedChild'))) {
                    return VADNodeStyles['ProcessStyleDetailedChild'].dot;
                }
                // DetailedExternal - –æ—Ä–∞–Ω–∂–µ–≤—ã–π
                if (PROCESS_SUBTYPES.DETAILED_EXTERNAL.some(t => subtype === t || subtype.endsWith('#DetailedExternal'))) {
                    return VADNodeStyles['ProcessStyleDetailedExternal'].dot;
                }
                // notDetailedChild - –∑–µ–ª–µ–Ω—ã–π
                if (PROCESS_SUBTYPES.NOT_DETAILED_CHILD.some(t => subtype === t || subtype.endsWith('#notDetailedChild'))) {
                    return VADNodeStyles['ProcessStyleNotDetailedChild'].dot;
                }
                // notDetailedExternal - —Å–µ—Ä—ã–π
                if (PROCESS_SUBTYPES.NOT_DETAILED_EXTERNAL.some(t => subtype === t || subtype.endsWith('#notDetailedExternal'))) {
                    return VADNodeStyles['ProcessStyleNotDetailedExternal'].dot;
                }
                // NotDefinedType - –∫—Ä–∞—Å–Ω–æ–≤–∞—Ç—ã–π
                if (PROCESS_SUBTYPES.NOT_DEFINED_TYPE.some(t => subtype === t || subtype.endsWith('#NotDefinedType'))) {
                    return VADNodeStyles['ProcessStyleNotDefinedType'].dot;
                }
                // –û–±—â–∏–π Detailed - –≥–æ–ª—É–±–æ–π (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
                if (PROCESS_SUBTYPES.DETAILED.some(t => subtype === t || subtype.endsWith('#Detailed'))) {
                    return VADNodeStyles['ProcessStyleDetailed'].dot;
                }
                // notDetailed –æ–±—â–∏–π - –∑–µ–ª–µ–Ω—ã–π
                if (PROCESS_SUBTYPES.NOT_DETAILED.some(t => subtype === t || subtype.endsWith('#notDetailed'))) {
                    return VADNodeStyles['ProcessStyleNotDetailedChild'].dot;
                }
                // Basic (—É—Å—Ç–∞—Ä–µ–≤—à–∏–π) - –∑–µ–ª–µ–Ω—ã–π
                if (PROCESS_SUBTYPES.BASIC.some(t => subtype === t || subtype.endsWith('#Basic'))) {
                    return VADNodeStyles['ProcessStyleBasic'].dot;
                }
            }

            // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é - notDetailedChild (–∑–µ–ª–µ–Ω—ã–π)
            return VADNodeStyles['ProcessStyleNotDetailedChild'].dot;
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ç—Ä–∏–ø–ª–µ—Ç–∞ –≤–æ –≤—Å–µ—Ö –≥—Ä–∞—Ñ–∞—Ö (–¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤)
         * –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫—É –∫–∞–∫ –ø–æ–ª–Ω—ã—Ö URI, —Ç–∞–∫ –∏ prefixed names
         * @param {string} subjectValue - URI –∏–ª–∏ prefixed name —Å—É–±—ä–µ–∫—Ç–∞
         * @param {string} predicateValue - URI –∏–ª–∏ prefixed name –ø—Ä–µ–¥–∏–∫–∞—Ç–∞
         * @param {string} objectValue - URI, prefixed name –∏–ª–∏ –ª–∏—Ç–µ—Ä–∞–ª –æ–±—ä–µ–∫—Ç–∞
         * @returns {Object|null} - {graphUri, graphLabel} –µ—Å–ª–∏ –Ω–∞–π–¥–µ–Ω –¥—É–±–ª–∏–∫–∞—Ç, –∏–Ω–∞—á–µ null
         */
        function findDuplicateTriple(subjectValue, predicateValue, objectValue) {
            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º prefixed names –≤ –ø–æ–ª–Ω—ã–µ URI –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
            let subjectUri = subjectValue;
            let predicateUri = predicateValue;
            let objectUri = objectValue;

            for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                if (subjectValue.startsWith(prefix + ':')) {
                    subjectUri = namespace + subjectValue.substring(prefix.length + 1);
                }
                if (predicateValue.startsWith(prefix + ':')) {
                    predicateUri = namespace + predicateValue.substring(prefix.length + 1);
                }
                if (objectValue.startsWith(prefix + ':')) {
                    objectUri = namespace + objectValue.substring(prefix.length + 1);
                }
            }

            // –¢–∞–∫–∂–µ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –ø–æ–ª–Ω—ã–µ URI –≤ prefixed names –¥–ª—è –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
            const subjectPrefixed = getPrefixedName(subjectUri, currentPrefixes);
            const predicatePrefixed = getPrefixedName(predicateUri, currentPrefixes);
            const objectPrefixed = getPrefixedName(objectUri, currentPrefixes);

            for (const quad of currentQuads) {
                const qSubjectUri = quad.subject.value;
                const qPredicateUri = quad.predicate.value;
                const qObjectValue = quad.object.value;
                const qSubjectPrefixed = getPrefixedName(qSubjectUri, currentPrefixes);
                const qPredicatePrefixed = getPrefixedName(qPredicateUri, currentPrefixes);
                const qObjectPrefixed = quad.object.termType === 'Literal'
                    ? quad.object.value
                    : getPrefixedName(qObjectValue, currentPrefixes);

                // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º –∫–∞–∫ –ø–æ–ª–Ω—ã–µ URI, —Ç–∞–∫ –∏ prefixed names
                const subjectMatch = (subjectUri === qSubjectUri) || (subjectPrefixed === qSubjectPrefixed);
                const predicateMatch = (predicateUri === qPredicateUri) || (predicatePrefixed === qPredicatePrefixed);
                const objectMatch = (objectUri === qObjectValue) || (objectPrefixed === qObjectPrefixed) ||
                    (objectValue === qObjectValue) || (objectValue === qObjectPrefixed);

                if (subjectMatch && predicateMatch && objectMatch) {
                    const graphUri = quad.graph ? quad.graph.value : null;
                    const graphLabel = graphUri ? getPrefixedName(graphUri, currentPrefixes) : 'default graph';
                    return { graphUri, graphLabel };
                }
            }

            return null;
        }

        /**
         * –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ü–µ–ª–µ–≤–æ–π –≥—Ä–∞—Ñ –¥–ª—è —Ç—Ä–∏–ø–ª–µ—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–∞–≤–∏–ª ptree
         * –ï—Å–ª–∏ —Å—É–±—ä–µ–∫—Ç —è–≤–ª—è–µ—Ç—Å—è vad:TypeProcess –∏ –ø—Ä–µ–¥–∏–∫–∞—Ç –≤ PTREE_PREDICATES,
         * —Ç—Ä–∏–ø–ª–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω –≤ vad:ptree
         * @param {string} subjectValue - URI –∏–ª–∏ prefixed name —Å—É–±—ä–µ–∫—Ç–∞
         * @param {string} predicateValue - URI –∏–ª–∏ prefixed name –ø—Ä–µ–¥–∏–∫–∞—Ç–∞
         * @param {string} originalTrigValue - –ò—Å—Ö–æ–¥–Ω—ã–π –≤—ã–±—Ä–∞–Ω–Ω—ã–π –≥—Ä–∞—Ñ
         * @param {string} objectValue - URI –∏–ª–∏ prefixed name –æ–±—ä–µ–∫—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ rdf:type)
         * @returns {string} - URI –≥—Ä–∞—Ñ–∞ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç—Ä–∏–ø–ª–µ—Ç–∞
         */
        function determineTargetGraph(subjectValue, predicateValue, originalTrigValue, objectValue = null) {
            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º prefixed names –≤ –ø–æ–ª–Ω—ã–µ URI
            let subjectUri = subjectValue;
            let predicateUri = predicateValue;
            let objectUri = objectValue;

            for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                if (subjectValue.startsWith(prefix + ':')) {
                    subjectUri = namespace + subjectValue.substring(prefix.length + 1);
                }
                if (predicateValue.startsWith(prefix + ':')) {
                    predicateUri = namespace + predicateValue.substring(prefix.length + 1);
                }
                if (objectValue && objectValue.startsWith(prefix + ':')) {
                    objectUri = namespace + objectValue.substring(prefix.length + 1);
                }
            }

            // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —Å–ª—É—á–∞–π: –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ rdf:type vad:TypeProcess - –≤—Å–µ–≥–¥–∞ –≤ ptree
            const isRdfType = (predicateUri === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' ||
                              predicateValue === 'rdf:type');
            const isProcessType = (objectUri === 'http://example.org/vad#TypeProcess' ||
                                  objectValue === 'vad:TypeProcess');
            if (isRdfType && isProcessType) {
                return 'vad:ptree';
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—É–±—ä–µ–∫—Ç —Ç–∏–ø–æ–º vad:TypeProcess
            if (isSubjectVadProcess(subjectUri)) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø—Ä–µ–¥–∏–∫–∞—Ç –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–º –¥–ª—è ptree
                if (isPtreePredicate(predicateUri) || isPtreePredicate(predicateValue)) {
                    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º vad:ptree
                    return 'vad:ptree';
                }
            }

            return originalTrigValue;
        }

        /**
         * –í–∞–ª–∏–¥–∏—Ä—É–µ—Ç RDF —Ç—Ä–∏–ø–ª–µ—Ç—ã –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Å—Ö–µ–º–µ VAD –æ–Ω—Ç–æ–ª–æ–≥–∏–∏
         *
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –≤—Å–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –∏ —Ç–∏–ø—ã –æ–±—ä–µ–∫—Ç–æ–≤ –≤ RDF –¥–∞–Ω–Ω—ã—Ö —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç
         * —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏—è–º, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º –≤ VAD –æ–Ω—Ç–æ–ª–æ–≥–∏–∏ (VAD_ALLOWED_PREDICATES,
         * VAD_ALLOWED_TYPES). –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö –ø–µ—Ä–µ–¥
         * –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–µ–π –∏ –ø—Ä–∏ —Ä—É—á–Ω–æ–º —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É "–¢–µ—Å—Ç".
         *
         * @param {Array} quads - –ú–∞—Å—Å–∏–≤ RDF –∫–≤–∞–¥–æ–≤ (N3.js quad objects)
         * @param {Object} prefixes - –û–±—ä–µ–∫—Ç —Å –ø—Ä–µ—Ñ–∏–∫—Å–∞–º–∏ {prefix: namespace}
         * @returns {Object} –†–µ–∑—É–ª—å—Ç–∞—Ç –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Å –ø–æ–ª—è–º–∏:
         *   - valid {boolean} - true –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ –≤–∞–ª–∏–¥–Ω—ã, false –µ—Å–ª–∏ –µ—Å—Ç—å –æ—à–∏–±–∫–∏
         *   - errors {Array<Object>} - –ú–∞—Å—Å–∏–≤ –æ—à–∏–±–æ–∫, –∫–∞–∂–¥–∞—è —Å –ø–æ–ª—è–º–∏:
         *       - triple {string} - –¢—Ä–∏–ø–ª–µ—Ç —Å –æ—à–∏–±–∫–æ–π
         *       - position {string} - –ü–æ–∑–∏—Ü–∏—è –æ—à–∏–±–∫–∏ (predicate, object, etc.)
         *       - value {string} - –ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
         *       - message {string} - –û–ø–∏—Å–∞–Ω–∏–µ –æ—à–∏–±–∫–∏
         *
         * @example
         * const quads = [...]; // Parsed RDF quads
         * const prefixes = { vad: 'http://example.org/vad#', rdf: '...' };
         * const result = validateVAD(quads, prefixes);
         * if (!result.valid) {
         *   console.error('Validation errors:', result.errors);
         * }
         *
         * @see VAD_ALLOWED_PREDICATES - –°–ø–∏—Å–æ–∫ —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–≤
         * @see VAD_ALLOWED_TYPES - –°–ø–∏—Å–æ–∫ —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤ –æ–±—ä–µ–∫—Ç–æ–≤
         * @see formatVADErrors - –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
         */
        function validateVAD(quads, prefixes) {
            const errors = [];

            quads.forEach((quad, index) => {
                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, prefixes);

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø—Ä–µ–¥–∏–∫–∞—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω
                const predicateAllowed = VAD_ALLOWED_PREDICATES.some(allowed =>
                    predicateUri === allowed || predicateLabel === allowed
                );

                if (!predicateAllowed) {
                    const subjectLabel = getPrefixedName(quad.subject.value, prefixes);
                    const objectLabel = quad.object.termType === 'Literal'
                        ? `"${quad.object.value}"`
                        : getPrefixedName(quad.object.value, prefixes);

                    errors.push({
                        triple: `${subjectLabel} ${predicateLabel} ${objectLabel}`,
                        position: 'predicate',
                        value: predicateLabel,
                        message: `–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π –ø—Ä–µ–¥–∏–∫–∞—Ç: ${predicateLabel}`
                    });
                }

                // –ï—Å–ª–∏ –ø—Ä–µ–¥–∏–∫–∞—Ç - rdf:type, –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–∏–ø —Ä–∞–∑—Ä–µ—à–µ–Ω
                const typePredicates = [
                    'rdf:type',
                    'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
                ];

                if (typePredicates.includes(predicateUri) || typePredicates.includes(predicateLabel)) {
                    const typeUri = quad.object.value;
                    const typeLabel = getPrefixedName(typeUri, prefixes);

                    const typeAllowed = VAD_ALLOWED_TYPES.some(allowed =>
                        typeUri === allowed || typeLabel === allowed
                    );

                    if (!typeAllowed) {
                        const subjectLabel = getPrefixedName(quad.subject.value, prefixes);

                        errors.push({
                            triple: `${subjectLabel} ${predicateLabel} ${typeLabel}`,
                            position: 'object (type)',
                            value: typeLabel,
                            message: `–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ç–∏–ø –æ–±—ä–µ–∫—Ç–∞: ${typeLabel}`
                        });
                    }
                }
            });

            return {
                valid: errors.length === 0,
                errors: errors
            };
        }

        /**
         * –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –æ—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ VAD –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
         * @param {Array} errors - –ú–∞—Å—Å–∏–≤ –æ—à–∏–±–æ–∫
         * @returns {string} - –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
         */
        function formatVADErrors(errors) {
            let message = '–û–®–ò–ë–ö–ê –í–ê–õ–ò–î–ê–¶–ò–ò VAD\n';
            message += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';

            errors.forEach((error, index) => {
                message += `–û—à–∏–±–∫–∞ ${index + 1}:\n`;
                message += `  –¢—Ä–∏–ø–ª–µ—Ç: ${error.triple}\n`;
                message += `  –ü–æ–∑–∏—Ü–∏—è: ${error.position}\n`;
                message += `  –ó–Ω–∞—á–µ–Ω–∏–µ: ${error.value}\n`;
                message += `  ${error.message}\n\n`;
            });

            message += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
            message += `–í—Å–µ–≥–æ –æ—à–∏–±–æ–∫: ${errors.length}\n`;
            message += '\n–†–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã: vad:TypeProcess, vad:ExecutorGroup, vad:TypeExecutor\n';
            message += '–†–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã: rdf:type, rdfs:label, dcterms:description,\n';
            message += '  vad:hasNext, vad:hasExecutor, vad:hasParentTrig, vad:includes,\n';
            message += '  vad:processSubtype, vad:hasTrig';

            return message;
        }

        // ============================================================================
        // –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –°–¢–ò–õ–ï–ô
        // ============================================================================

        const StyleName = {
            nodeStyles: {
                'PersonStyle': {
                    types: ['foaf:Person', 'schema:Person', 'http://xmlns.com/foaf/0.1/Person'],
                    dot: 'shape="octagon" height="0.75" width="0.75" fixedsize="true" color="#9C27B0" fillcolor="#F3E5F5" fontname="Arial" fontsize="10" style="filled"',
                    label: '–õ—é–¥–∏ (foaf:Person)',
                    description: '–û–±—ä–µ–∫—Ç—ã —Ç–∏–ø–∞ foaf:Person –∏–ª–∏ schema:Person'
                },
                'OrganizationStyle': {
                    types: ['foaf:Organization', 'schema:Organization', 'http://xmlns.com/foaf/0.1/Organization'],
                    dot: 'shape="box" height="0.6" width="1.2" color="Blue" fillcolor="#E6F3FF" fontname="Arial" fontsize="10" style="filled,bold"',
                    label: '–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ (foaf:Organization)',
                    description: '–û–±—ä–µ–∫—Ç—ã —Ç–∏–ø–∞ foaf:Organization'
                },
                'DocumentStyle': {
                    types: ['foaf:Document', 'schema:Document', 'http://xmlns.com/foaf/0.1/Document'],
                    dot: 'shape="note" height="0.6" width="1.0" color="Green" fillcolor="#E8F5E9" fontname="Arial" fontsize="10" style="filled"',
                    label: '–î–æ–∫—É–º–µ–Ω—Ç—ã (foaf:Document)',
                    description: '–û–±—ä–µ–∫—Ç—ã —Ç–∏–ø–∞ foaf:Document'
                },
                'LiteralStyle': {
                    types: ['_Literal'],
                    dot: 'shape="box" color="#666666" fillcolor="#FFFFCC" fontname="Arial" fontsize="9" style="filled,rounded"',
                    label: '–õ–∏—Ç–µ—Ä–∞–ª—ã (Literal)',
                    description: '–°—Ç—Ä–æ–∫–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è, —á–∏—Å–ª–∞, –¥–∞—Ç—ã'
                },
                'BlankNodeStyle': {
                    types: ['_BlankNode'],
                    dot: 'shape="ellipse" color="#999999" fillcolor="#E0E0E0" fontname="Arial" fontsize="9" style="filled,dashed"',
                    label: '–ü—É—Å—Ç—ã–µ —É–∑–ª—ã (BlankNode)',
                    description: '–ê–Ω–æ–Ω–∏–º–Ω—ã–µ —É–∑–ª—ã –±–µ–∑ URI'
                },
                'default': {
                    types: [],
                    dot: 'shape="ellipse" color="#1976D2" fillcolor="#CCE5FF" fontname="Arial" fontsize="10" style="filled"',
                    label: '–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é (URI)',
                    description: '–í—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ URI-—Ä–µ—Å—É—Ä—Å—ã'
                }
            },
            edgeStyles: {
                'TypeStyle': {
                    predicates: ['rdf:type', 'a', 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'],
                    dot: 'color="#9C27B0" penwidth="2" style="dashed" arrowhead="empty"',
                    label: '–¢–∏–ø –æ–±—ä–µ–∫—Ç–∞ (rdf:type)',
                    description: '–°–≤—è–∑—å –æ–±—ä–µ–∫—Ç–∞ —Å –µ–≥–æ RDF-—Ç–∏–ø–æ–º'
                },
                'KnowsStyle': {
                    predicates: ['foaf:knows', 'http://xmlns.com/foaf/0.1/knows'],
                    dot: 'color="#4CAF50" penwidth="2" style="solid" arrowhead="vee"',
                    label: '–ó–Ω–∞–µ—Ç (foaf:knows)',
                    description: '–°–æ—Ü–∏–∞–ª—å–Ω–∞—è —Å–≤—è–∑—å –º–µ–∂–¥—É –ª—é–¥—å–º–∏'
                },
                'MemberStyle': {
                    predicates: ['foaf:member', 'schema:member', 'http://xmlns.com/foaf/0.1/member'],
                    dot: 'color="#795548" penwidth="2" style="solid" arrowhead="diamond"',
                    label: '–ß–ª–µ–Ω (foaf:member)',
                    description: '–ß–ª–µ–Ω—Å—Ç–≤–æ –≤ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏'
                },
                'AttributeStyle': {
                    predicates: [
                        'foaf:name', 'http://xmlns.com/foaf/0.1/name',
                        'foaf:age', 'http://xmlns.com/foaf/0.1/age',
                        'rdfs:label', 'http://www.w3.org/2000/01/rdf-schema#label',
                        'rdfs:comment', 'http://www.w3.org/2000/01/rdf-schema#comment'
                    ],
                    dot: 'color="#2196F3" penwidth="1" style="dotted" arrowhead="normal"',
                    label: '–ê—Ç—Ä–∏–±—É—Ç—ã (name, label...)',
                    description: '–°–≤–æ–π—Å—Ç–≤–∞ –æ–±—ä–µ–∫—Ç–∞: –∏–º—è, –≤–æ–∑—Ä–∞—Å—Ç –∏ –¥—Ä.'
                },
                'default': {
                    predicates: [],
                    dot: 'color="#666666" penwidth="1" style="solid" arrowhead="normal"',
                    label: '–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é',
                    description: '–í—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã'
                }
            }
        };

        // ============================================================================
        // –°–¢–ò–õ–ò VAD (Value Added Chain Diagram)
        // ============================================================================

        const VADNodeStyles = {
            // =================================================================
            // –î–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ü–µ—Å—Å—ã (Detailed) - –∏–º–µ—é—Ç vad:hasTrig
            // =================================================================
            'ProcessStyleDetailedChild': {
                types: ['vad:TypeProcess', 'http://example.org/vad#TypeProcess'],
                subtypes: ['vad:DetailedChild', 'http://example.org/vad#DetailedChild'],
                // cds shape —Å –≥–æ–ª—É–±–æ–π –∑–∞–ª–∏–≤–∫–æ–π –¥–ª—è –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–¥–ø—Ä–æ—Ü–µ—Å—Å–∞
                dot: 'shape="cds" height="0.8" width="1.5" color="#1565C0" fillcolor="#90CAF9" fontname="Arial" fontsize="11" style="filled"',
                label: '–î–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–¥–ø—Ä–æ—Ü–µ—Å—Å (vad:DetailedChild)',
                description: '–î–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å, —è–≤–ª—è—é—â–∏–π—Å—è –ø–æ–¥–ø—Ä–æ—Ü–µ—Å—Å–æ–º —Ç–µ–∫—É—â–µ–π —Å—Ö–µ–º—ã'
            },
            'ProcessStyleDetailedExternal': {
                types: ['vad:TypeProcess', 'http://example.org/vad#TypeProcess'],
                subtypes: ['vad:DetailedExternal', 'http://example.org/vad#DetailedExternal'],
                // cds shape —Å –æ—Ä–∞–Ω–∂–µ–≤–æ–π –∑–∞–ª–∏–≤–∫–æ–π –¥–ª—è –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≤–Ω–µ—à–Ω–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
                dot: 'shape="cds" height="0.8" width="1.5" color="#E65100" fillcolor="#FFB74D" fontname="Arial" fontsize="11" style="filled"',
                label: '–î–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤–Ω–µ—à–Ω–∏–π (vad:DetailedExternal)',
                description: '–î–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å, –ù–ï —è–≤–ª—è—é—â–∏–π—Å—è –ø–æ–¥–ø—Ä–æ—Ü–µ—Å—Å–æ–º —Ç–µ–∫—É—â–µ–π —Å—Ö–µ–º—ã'
            },
            // =================================================================
            // –ù–µ–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ü–µ—Å—Å—ã (notDetailed) - –ù–ï –∏–º–µ—é—Ç vad:hasTrig
            // =================================================================
            'ProcessStyleNotDetailedChild': {
                types: ['vad:TypeProcess', 'http://example.org/vad#TypeProcess'],
                subtypes: ['vad:notDetailedChild', 'http://example.org/vad#notDetailedChild'],
                // cds shape —Å –∑–µ–ª—ë–Ω–æ–π –∑–∞–ª–∏–≤–∫–æ–π –¥–ª—è –Ω–µ–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–¥–ø—Ä–æ—Ü–µ—Å—Å–∞
                dot: 'shape="cds" height="0.8" width="1.5" color="#2E7D32" fillcolor="#A5D6A7" fontname="Arial" fontsize="11" style="filled"',
                label: '–ù–µ–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–¥–ø—Ä–æ—Ü–µ—Å—Å (vad:notDetailedChild)',
                description: '–ù–µ–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å-–ø–æ–¥–ø—Ä–æ—Ü–µ—Å—Å'
            },
            'ProcessStyleNotDetailedExternal': {
                types: ['vad:TypeProcess', 'http://example.org/vad#TypeProcess'],
                subtypes: ['vad:notDetailedExternal', 'http://example.org/vad#notDetailedExternal'],
                // cds shape —Å–æ —Å–≤–µ—Ç–ª–æ-—Å–µ—Ä–æ–π –∑–∞–ª–∏–≤–∫–æ–π –¥–ª—è –Ω–µ–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≤–Ω–µ—à–Ω–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
                dot: 'shape="cds" height="0.8" width="1.5" color="#616161" fillcolor="#E0E0E0" fontname="Arial" fontsize="11" style="filled"',
                label: '–ù–µ–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤–Ω–µ—à–Ω–∏–π (vad:notDetailedExternal)',
                description: '–ù–µ–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤–Ω–µ—à–Ω–∏–π –ø—Ä–æ—Ü–µ—Å—Å'
            },
            'ProcessStyleNotDefinedType': {
                types: ['vad:TypeProcess', 'http://example.org/vad#TypeProcess'],
                subtypes: ['vad:NotDefinedType', 'http://example.org/vad#NotDefinedType'],
                // cds shape —Å –∫—Ä–∞—Å–Ω–æ–≤–∞—Ç–æ–π –∑–∞–ª–∏–≤–∫–æ–π –¥–ª—è –ø—Ä–æ—Ü–µ—Å—Å–∞ —Å –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º —Ç–∏–ø–æ–º
                dot: 'shape="cds" height="0.8" width="1.5" color="#C62828" fillcolor="#FFCDD2" fontname="Arial" fontsize="11" style="filled"',
                label: '–¢–∏–ø –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω (vad:NotDefinedType)',
                description: '–ü—Ä–æ—Ü–µ—Å—Å —Å –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º'
            },
            // =================================================================
            // –£—Å—Ç–∞—Ä–µ–≤—à–∏–µ —Å—Ç–∏–ª–∏ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
            // =================================================================
            'ProcessStyleBasic': {
                types: ['vad:TypeProcess', 'http://example.org/vad#TypeProcess'],
                subtypes: ['vad:Basic', 'http://example.org/vad#Basic'],
                // cds shape (chevron) —Å –∑–µ–ª—ë–Ω–æ–π –∑–∞–ª–∏–≤–∫–æ–π –¥–ª—è –±–∞–∑–æ–≤–æ–≥–æ —Ç–∏–ø–∞ (—É—Å—Ç–∞—Ä–µ–≤—à–∏–π)
                dot: 'shape="cds" height="0.8" width="1.5" color="#2E7D32" fillcolor="#A5D6A7" fontname="Arial" fontsize="11" style="filled"',
                label: '–ü—Ä–æ—Ü–µ—Å—Å –ë–∞–∑–æ–≤—ã–π (vad:Basic) [—É—Å—Ç–∞—Ä–µ–≤—à–∏–π]',
                description: '–£—Å—Ç–∞—Ä–µ–≤—à–∏–π –±–∞–∑–æ–≤—ã–π –±–∏–∑–Ω–µ—Å-–ø—Ä–æ—Ü–µ—Å—Å –≤ VAD –¥–∏–∞–≥—Ä–∞–º–º–µ'
            },
            'ProcessStyleDetailed': {
                types: ['vad:TypeProcess', 'http://example.org/vad#TypeProcess'],
                subtypes: ['vad:Detailed', 'http://example.org/vad#Detailed'],
                // cds shape (chevron) —Å –≥–æ–ª—É–±–æ–π –∑–∞–ª–∏–≤–∫–æ–π –¥–ª—è –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ (—É—Å—Ç–∞—Ä–µ–≤—à–∏–π)
                dot: 'shape="cds" height="0.8" width="1.5" color="#1565C0" fillcolor="#90CAF9" fontname="Arial" fontsize="11" style="filled"',
                label: '–ü—Ä–æ—Ü–µ—Å—Å –î–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π (vad:Detailed) [—É—Å—Ç–∞—Ä–µ–≤—à–∏–π]',
                description: '–£—Å—Ç–∞—Ä–µ–≤—à–∏–π –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –±–∏–∑–Ω–µ—Å-–ø—Ä–æ—Ü–µ—Å—Å –≤ VAD –¥–∏–∞–≥—Ä–∞–º–º–µ'
            },
            // =================================================================
            // –î—Ä—É–≥–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã
            // =================================================================
            'ExecutorGroupStyle': {
                types: ['vad:ExecutorGroup', 'http://example.org/vad#ExecutorGroup'],
                dot: 'shape="ellipse" color="#B8860B" fillcolor="#FFFFCC" fontname="Arial" fontsize="9" style="filled"',
                label: '–ì—Ä—É–ø–ø–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π (vad:ExecutorGroup)',
                description: '–ì—Ä—É–ø–ø–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –ø—Ä–æ—Ü–µ—Å—Å–∞ (—ç–ª–ª–∏–ø—Å —Å –∂–µ–ª—Ç–æ–≤–∞—Ç–æ–π –∑–∞–ª–∏–≤–∫–æ–π)'
            },
            'ExecutorStyle': {
                types: ['vad:TypeExecutor', 'http://example.org/vad#TypeExecutor'],
                dot: 'shape="ellipse" height="0.4" width="0.8" color="#6A1B9A" fillcolor="#E1BEE7" fontname="Arial" fontsize="9" style="filled"',
                label: '–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å (vad:TypeExecutor)',
                description: '–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å –ø—Ä–æ—Ü–µ—Å—Å–∞'
            },
            'default': {
                types: [],
                dot: 'shape="ellipse" color="#1976D2" fillcolor="#CCE5FF" fontname="Arial" fontsize="10" style="filled"',
                label: '–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é',
                description: '–î—Ä—É–≥–∏–µ –æ–±—ä–µ–∫—Ç—ã'
            }
        };

        const VADEdgeStyles = {
            'HasNextStyle': {
                predicates: ['vad:hasNext', 'http://example.org/vad#hasNext'],
                // –ó–µ–ª—ë–Ω–∞—è —Å—Ç—Ä–µ–ª–∫–∞ –¥–ª—è —Å–≤—è–∑–µ–π –º–µ–∂–¥—É –ø—Ä–æ—Ü–µ—Å—Å–∞–º–∏
                dot: 'color="#2E7D32" penwidth="2" style="solid" arrowhead="vee"',
                label: '–°–ª–µ–¥—É—é—â–∏–π (vad:hasNext)',
                description: '–°–≤—è–∑—å —Å —Å–ª–µ–¥—É—é—â–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º'
            },
            'HasExecutorStyle': {
                predicates: ['vad:hasExecutor', 'http://example.org/vad#hasExecutor'],
                dot: 'color="#1565C0" penwidth="1" style="dashed" arrowhead="none"',
                label: '–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å (vad:hasExecutor)',
                description: '–°–≤—è–∑—å –ø—Ä–æ—Ü–µ—Å—Å–∞ —Å –≥—Ä—É–ø–ø–æ–π –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π (–Ω–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è)'
            },
            'IncludesStyle': {
                predicates: ['vad:includes', 'http://example.org/vad#includes'],
                dot: 'color="#6A1B9A" penwidth="1" style="dotted" arrowhead="normal"',
                label: '–í–∫–ª—é—á–∞–µ—Ç (vad:includes)',
                description: '–°–≤—è–∑—å –≥—Ä—É–ø–ø—ã —Å –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è–º–∏'
            },
            'HasParentStyle': {
                predicates: ['vad:hasParentTrig', 'http://example.org/vad#hasParentTrig'],
                dot: 'color="#999999" penwidth="1" style="dashed" arrowhead="empty"',
                label: '–†–æ–¥–∏—Ç–µ–ª—å (vad:hasParentTrig)',
                description: '–°–≤—è–∑—å —Å —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º'
            },
            'TypeStyle': {
                predicates: ['rdf:type', 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'],
                dot: 'color="#9C27B0" penwidth="1" style="dashed" arrowhead="empty"',
                label: '–¢–∏–ø (rdf:type)',
                description: '–¢–∏–ø –æ–±—ä–µ–∫—Ç–∞'
            },
            'default': {
                predicates: [],
                dot: 'color="#666666" penwidth="1" style="solid" arrowhead="normal"',
                label: '–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é',
                description: '–î—Ä—É–≥–∏–µ —Å–≤—è–∑–∏'
            }
        };

        const AggregationNodeStyles = {
            'PersonStyle': {
                types: ['foaf:Person', 'schema:Person', 'http://xmlns.com/foaf/0.1/Person'],
                dot: 'shape="ellipse" color="#9C27B0" penwidth="2" fillcolor="#F3E5F5" fontname="Arial" fontsize="10" style="filled"',
                label: '–õ—é–¥–∏ (foaf:Person)',
                description: '–û–±—ä–µ–∫—Ç—ã —Ç–∏–ø–∞ foaf:Person'
            },
            'OrganizationStyle': {
                types: ['foaf:Organization', 'schema:Organization', 'http://xmlns.com/foaf/0.1/Organization'],
                dot: 'shape="ellipse" color="Blue" penwidth="3" fillcolor="#E3F2FD" fontname="Arial" fontsize="10" style="filled"',
                label: '–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ (foaf:Organization)',
                description: '–û–±—ä–µ–∫—Ç—ã —Ç–∏–ø–∞ foaf:Organization'
            },
            'DocumentStyle': {
                types: ['foaf:Document', 'schema:Document', 'http://xmlns.com/foaf/0.1/Document'],
                dot: 'shape="ellipse" color="Green" penwidth="2" fillcolor="#E8F5E9" fontname="Arial" fontsize="10" style="filled"',
                label: '–î–æ–∫—É–º–µ–Ω—Ç—ã (foaf:Document)',
                description: '–û–±—ä–µ–∫—Ç—ã —Ç–∏–ø–∞ foaf:Document'
            },
            'BlankNodeStyle': {
                types: ['_BlankNode'],
                dot: 'shape="ellipse" color="#999999" penwidth="1" fillcolor="#E0E0E0" fontname="Arial" fontsize="9" style="filled,dashed"',
                label: '–ü—É—Å—Ç—ã–µ —É–∑–ª—ã (BlankNode)',
                description: '–ê–Ω–æ–Ω–∏–º–Ω—ã–µ —É–∑–ª—ã –±–µ–∑ URI'
            },
            'default': {
                types: [],
                dot: 'shape="ellipse" color="#1976D2" penwidth="1" fillcolor="#CCE5FF" fontname="Arial" fontsize="10" style="filled"',
                label: '–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é (URI)',
                description: '–í—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ URI-—Ä–µ—Å—É—Ä—Å—ã'
            }
        };

        // ============================================================================
        // –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï
        // ============================================================================

        let currentSvgElement = null;
        let currentScale = 1.0;
        let currentPrefixes = {};
        let nodeTypesCache = {};
        let nodeSubtypesCache = {};
        let currentQuads = [];
        let nodeLabelToUri = {};
        let selectedNodeElement = null;
        let propertiesPanelCounter = 0;
        let openPropertiesPanels = [];
        let currentMode = Mode;
        let draggedPanel = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let currentStore = null;
        let comunicaEngine = null;
        let currentDotCode = '';

        // virtualRDFdata - —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –≤—ã—á–∏—Å–ª—è–µ–º—ã—Ö RDF –¥–∞–Ω–Ω—ã—Ö (vad:processSubtype –∏ –¥—Ä.)
        // –°—Ç—Ä—É–∫—Ç—É—Ä–∞: { 'vad:vt_trigName': { quads: [...], trigData: {...} } }
        let virtualRDFdata = {};

        const defaultSparqlQuery = `SELECT ?s ?p ?o
WHERE {
    ?s ?p ?o .
}`;

        /**
         * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç SPARQL PREFIX –¥–µ–∫–ª–∞—Ä–∞—Ü–∏–∏ –∏–∑ –æ–±—ä–µ–∫—Ç–∞ –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤
         * @param {Object} prefixes - –û–±—ä–µ–∫—Ç —Å –ø—Ä–µ—Ñ–∏–∫—Å–∞–º–∏ {prefix: uri}
         * @returns {string} - –°—Ç—Ä–æ–∫–∞ —Å PREFIX –¥–µ–∫–ª–∞—Ä–∞—Ü–∏—è–º–∏
         */
        function generateSparqlPrefixes(prefixes) {
            if (!prefixes || Object.keys(prefixes).length === 0) {
                return '';
            }

            let prefixLines = [];
            for (const [prefix, uri] of Object.entries(prefixes)) {
                prefixLines.push(`PREFIX ${prefix}: <${uri}>`);
            }
            return prefixLines.join('\n') + '\n\n';
        }

        /**
         * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç SPARQL –∑–∞–ø—Ä–æ—Å —Å GRAPH clause –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ TriG
         * @param {string} trigUri - URI TriG –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
         * @returns {string} - SPARQL –∑–∞–ø—Ä–æ—Å —Å GRAPH clause –∏ PREFIX –¥–µ–∫–ª–∞—Ä–∞—Ü–∏—è–º–∏
         */
        function getSparqlQueryForTriG(trigUri) {
            if (!trigUri) return defaultSparqlQuery;

            const prefixedUri = getPrefixedName(trigUri, currentPrefixes);
            // –ï—Å–ª–∏ URI –∏–º–µ–µ—Ç –ø—Ä–µ—Ñ–∏–∫—Å, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ, –∏–Ω–∞—á–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª–Ω—ã–π URI –≤ —É–≥–ª–æ–≤—ã—Ö —Å–∫–æ–±–∫–∞—Ö
            const graphRef = prefixedUri.includes(':') && !prefixedUri.startsWith('http')
                ? prefixedUri
                : `<${trigUri}>`;

            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º PREFIX –¥–µ–∫–ª–∞—Ä–∞—Ü–∏–∏ –¥–ª—è SPARQL –∑–∞–ø—Ä–æ—Å–∞
            const prefixDeclarations = generateSparqlPrefixes(currentPrefixes);

            return `${prefixDeclarations}SELECT ?s ?p ?o
WHERE {
    GRAPH ${graphRef} {
        ?s ?p ?o .
    }
}`;
        }

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç SPARQL –∑–∞–ø—Ä–æ—Å –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º –ø–æ–ª–µ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ TriG
         */
        function updateSparqlQueryForTriG() {
            if (currentMode !== 'vad-trig' || !selectedTrigUri) return;

            const queryInput = document.getElementById('sparql-query');
            if (!queryInput) return;

            queryInput.value = getSparqlQueryForTriG(selectedTrigUri);
        }

        let activeFilters = [...getFilterConfig(Mode).hiddenPredicates];
        let allPredicates = [];

        // ============================================================================
        // –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï –î–õ–Ø VAD TriG –†–ï–ñ–ò–ú–ê
        // ============================================================================

        let trigHierarchy = {};  // –ò–µ—Ä–∞—Ä—Ö–∏—è TriG –≥—Ä–∞—Ñ–æ–≤: { uri -> { label, hasParentTrig, children, quads } }
        let selectedTrigUri = null;  // –¢–µ–∫—É—â–∏–π –≤—ã–±—Ä–∞–Ω–Ω—ã–π TriG –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
        let allTrigGraphs = [];  // –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö TriG –≥—Ä–∞—Ñ–æ–≤
        let isNewTrigQuery = false;  // –§–ª–∞–≥: —Ç–µ–∫—É—â–∏–π SPARQL –∑–∞–ø—Ä–æ—Å —Å–æ–∑–¥–∞–Ω —Ñ—É–Ω–∫—Ü–∏–µ–π "New TriG"
        const PTREE_GRAPH_URI = 'http://example.org/vad#ptree';  // URI –≥—Ä–∞—Ñ–∞ –î–µ—Ä–µ–≤–æ –ü—Ä–æ—Ü–µ—Å—Å–æ–≤
        const RTREE_GRAPH_URI = 'http://example.org/vad#rtree';  // URI –≥—Ä–∞—Ñ–∞ –î–µ—Ä–µ–≤–æ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ü–µ—Å—Å–∞ –∏–∑ vad:ptree (rdfs:label, dcterms:description, vad:hasTrig)
         * @param {string} processUri - URI –ø—Ä–æ—Ü–µ—Å—Å–∞
         * @param {Object} prefixes - –°–ª–æ–≤–∞—Ä—å –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤
         * @returns {Object} - { label: string|null, description: string|null, hasTrig: string|null }
         */
        function getProcessMetadataFromPtree(processUri, prefixes) {
            const result = { label: null, description: null, hasTrig: null };

            // –ï—Å–ª–∏ –Ω–µ—Ç trigHierarchy –∏–ª–∏ –Ω–µ—Ç vad:ptree, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            if (!trigHierarchy || !trigHierarchy[PTREE_GRAPH_URI]) {
                return result;
            }

            const ptreeQuads = trigHierarchy[PTREE_GRAPH_URI].quads;

            ptreeQuads.forEach(quad => {
                if (quad.subject.value !== processUri) return;

                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, prefixes);

                if (predicateLabel === 'rdfs:label' || predicateUri === 'http://www.w3.org/2000/01/rdf-schema#label') {
                    result.label = quad.object.value;
                }
                if (predicateLabel === 'dcterms:description' || predicateUri === 'http://purl.org/dc/terms/description') {
                    result.description = quad.object.value;
                }
                if (predicateLabel === 'vad:hasTrig' || predicateUri === 'http://example.org/vad#hasTrig') {
                    result.hasTrig = quad.object.value;
                }
            });

            return result;
        }

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç –∏–º—è –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è (rdfs:label) –∏–∑ vad:rtree
         * @param {string} executorUri - URI –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è
         * @param {Object} prefixes - –°–ª–æ–≤–∞—Ä—å –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤
         * @returns {string|null} - rdfs:label –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è –∏–ª–∏ null
         */
        function getExecutorNameFromRtree(executorUri, prefixes) {
            // –ï—Å–ª–∏ –Ω–µ—Ç trigHierarchy –∏–ª–∏ –Ω–µ—Ç vad:rtree, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º null
            if (!trigHierarchy || !trigHierarchy[RTREE_GRAPH_URI]) {
                return null;
            }

            const rtreeQuads = trigHierarchy[RTREE_GRAPH_URI].quads;

            for (const quad of rtreeQuads) {
                if (quad.subject.value !== executorUri) continue;

                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, prefixes);

                if (predicateLabel === 'rdfs:label' || predicateUri === 'http://www.w3.org/2000/01/rdf-schema#label') {
                    return quad.object.value;
                }
            }

            return null;
        }

        // ============================================================================
        // –§–£–ù–ö–¶–ò–ò –î–õ–Ø VAD TriG –†–ï–ñ–ò–ú–ê
        // ============================================================================

        /**
         * –ü–∞—Ä—Å–∏—Ç –∏–µ—Ä–∞—Ä—Ö–∏—é TriG –≥—Ä–∞—Ñ–æ–≤ –∏–∑ –∫–≤–∞–¥–æ–≤
         * @param {Array} quads - –í—Å–µ –∫–≤–∞–¥—ã –∏–∑ RDF –¥–∞–Ω–Ω—ã—Ö
         * @param {Object} prefixes - –°–ª–æ–≤–∞—Ä—å –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤
         * @returns {Object} - { valid: boolean, errors: [], hierarchy: {}, rootTrigUri: string }
         */
        function parseTriGHierarchy(quads, prefixes) {
            const errors = [];
            const hierarchy = {};
            const graphUris = new Set();

            // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ –≥—Ä–∞—Ñ—ã
            quads.forEach(quad => {
                if (quad.graph && quad.graph.value && quad.graph.value !== '') {
                    graphUris.add(quad.graph.value);
                }
            });

            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≥—Ä–∞—Ñ–∞
            graphUris.forEach(graphUri => {
                hierarchy[graphUri] = {
                    uri: graphUri,
                    label: null,
                    hasParent: null,
                    children: [],
                    quads: [],
                    processes: []
                };
            });

            // –°–æ–±–∏—Ä–∞–µ–º –∫–≤–∞–¥—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≥—Ä–∞—Ñ–∞
            quads.forEach(quad => {
                const graphUri = quad.graph?.value || '';
                if (graphUri && hierarchy[graphUri]) {
                    hierarchy[graphUri].quads.push(quad);
                }
            });

            // –ò—â–µ–º rdfs:label –∏ vad:hasParentTrig –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≥—Ä–∞—Ñ–∞ (–æ–ø—Ä–µ–¥–µ–ª—è—é—Ç—Å—è –≤–Ω–µ –≥—Ä–∞—Ñ–∞)
            quads.forEach(quad => {
                const subjectUri = quad.subject.value;
                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, prefixes);

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—É–±—ä–µ–∫—Ç –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–º –≥—Ä–∞—Ñ–æ–º
                if (hierarchy[subjectUri]) {
                    // rdfs:label –¥–ª—è –≥—Ä–∞—Ñ–∞
                    if (predicateLabel === 'rdfs:label' || predicateUri === 'http://www.w3.org/2000/01/rdf-schema#label') {
                        hierarchy[subjectUri].label = quad.object.value;
                    }

                    // vad:hasParentTrig –¥–ª—è –≥—Ä–∞—Ñ–∞
                    if (predicateLabel === 'vad:hasParentTrig' || predicateUri === 'http://example.org/vad#hasParentTrig') {
                        hierarchy[subjectUri].hasParent = quad.object.value;
                    }
                }
            });

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –≥—Ä–∞—Ñ—ã –∏–º–µ—é—Ç hasParentTrig
            Object.values(hierarchy).forEach(graphInfo => {
                if (!graphInfo.hasParent) {
                    const graphLabel = getPrefixedName(graphInfo.uri, prefixes);
                    errors.push({
                        graph: graphLabel,
                        message: `TriG "${graphLabel}" –Ω–µ –∏–º–µ–µ—Ç —Å–≤–æ–π—Å—Ç–≤–∞ hasParentTrig. –í —Ä–µ–∂–∏–º–µ VAD TriG –∫–∞–∂–¥—ã–π TriG –≥—Ä–∞—Ñ –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å —Å–≤–æ–π—Å—Ç–≤–æ hasParentTrig.`
                    });
                }
            });

            if (errors.length > 0) {
                return { valid: false, errors, hierarchy: null, rootTrigUris: [] };
            }

            // –°—Ç—Ä–æ–∏–º –¥–µ—Ä–µ–≤–æ: –Ω–∞—Ö–æ–¥–∏–º –∫–æ—Ä–Ω–µ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã (hasParentTrig = vad:root)
            const rootUri = 'http://example.org/vad#root';
            const rootTrigUris = [];

            Object.values(hierarchy).forEach(graphInfo => {
                const parentUri = graphInfo.hasParent;
                const parentLabel = getPrefixedName(parentUri, prefixes);

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ä–æ–¥–∏—Ç–µ–ª—å "root"
                if (parentUri === rootUri || parentLabel === 'vad:root') {
                    // vad:ptree –∏ vad:rtree - —ç—Ç–æ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –≥—Ä–∞—Ñ—ã –¥–ª—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π,
                    // –æ–Ω–∏ –Ω–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∫–ª—é—á–µ–Ω—ã –≤ rootTrigUris –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–µ—Ä–µ–≤–∞
                    if (graphInfo.uri !== PTREE_GRAPH_URI && graphInfo.uri !== RTREE_GRAPH_URI) {
                        rootTrigUris.push(graphInfo.uri);
                    }
                } else if (hierarchy[parentUri]) {
                    // –î–æ–±–∞–≤–ª—è–µ–º –∫–∞–∫ –¥–æ—á–µ—Ä–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –∫ —Ä–æ–¥–∏—Ç–µ–ª—é
                    hierarchy[parentUri].children.push(graphInfo.uri);
                }
            });

            // –°–æ–±–∏—Ä–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ—Ü–µ—Å—Å–∞—Ö –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≥—Ä–∞—Ñ–∞
            // –®–∞–≥ 1: –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ URI –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –∏–∑ –≤—Å–µ—Ö –≥—Ä–∞—Ñ–æ–≤ (–≤–∫–ª—é—á–∞—è vad:ptree)
            const allProcessUris = new Set();
            Object.values(hierarchy).forEach(graphInfo => {
                graphInfo.quads.forEach(quad => {
                    const predicateUri = quad.predicate.value;
                    const predicateLabel = getPrefixedName(predicateUri, prefixes);

                    // –ï—Å–ª–∏ —ç—Ç–æ rdf:type –∏ —Ç–∏–ø = vad:TypeProcess
                    if (predicateLabel === 'rdf:type' || predicateUri === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type') {
                        const typeUri = quad.object.value;
                        const typeLabel = getPrefixedName(typeUri, prefixes);
                        if (typeLabel === 'vad:TypeProcess' || typeUri === 'http://example.org/vad#TypeProcess') {
                            allProcessUris.add(quad.subject.value);
                        }
                    }
                });
            });

            // –®–∞–≥ 2: –î–ª—è –∫–∞–∂–¥–æ–≥–æ –≥—Ä–∞—Ñ–∞ (–∫—Ä–æ–º–µ ptree) –æ–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–∏–µ –ø—Ä–æ—Ü–µ—Å—Å—ã –≤ –Ω—ë–º –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç
            // –ü—Ä–æ—Ü–µ—Å—Å —Å—á–∏—Ç–∞–µ—Ç—Å—è –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—â–∏–º –≤ –≥—Ä–∞—Ñ–µ, –µ—Å–ª–∏ —É –Ω–µ–≥–æ –µ—Å—Ç—å —Å–≤–æ–π—Å—Ç–≤–∞ (vad:hasExecutor, vad:hasNext –∏ —Ç.–¥.) –≤ —ç—Ç–æ–º –≥—Ä–∞—Ñ–µ
            const processPredicates = [
                'http://example.org/vad#hasExecutor',
                'vad:hasExecutor',
                'http://example.org/vad#hasNext',
                'vad:hasNext',
                'http://example.org/vad#processSubtype',
                'vad:processSubtype'
            ];

            Object.values(hierarchy).forEach(graphInfo => {
                // –î–ª—è vad:ptree –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ (—ç—Ç–æ –≥—Ä–∞—Ñ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö)
                if (graphInfo.uri === PTREE_GRAPH_URI) {
                    return;
                }

                // –ò—â–µ–º –ø—Ä–æ—Ü–µ—Å—Å—ã, –∫–æ—Ç–æ—Ä—ã–µ –∏–º–µ—é—Ç —Å–≤–æ–π—Å—Ç–≤–∞ –≤ —ç—Ç–æ–º –≥—Ä–∞—Ñ–µ
                const processesInGraph = new Set();
                graphInfo.quads.forEach(quad => {
                    const subjectUri = quad.subject.value;
                    const predicateUri = quad.predicate.value;
                    const predicateLabel = getPrefixedName(predicateUri, prefixes);

                    // –ï—Å–ª–∏ —Å—É–±—ä–µ–∫—Ç —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–æ—Ü–µ—Å—Å–æ–º (–∏–∑ allProcessUris) –∏ –ø—Ä–µ–¥–∏–∫–∞—Ç - —ç—Ç–æ —Å–≤–æ–π—Å—Ç–≤–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
                    if (allProcessUris.has(subjectUri)) {
                        if (processPredicates.includes(predicateUri) || processPredicates.includes(predicateLabel)) {
                            processesInGraph.add(subjectUri);
                        }
                    }
                });

                graphInfo.processes = Array.from(processesInGraph);
            });

            return { valid: true, errors: [], hierarchy, rootTrigUris };
        }

        /**
         * –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –æ—à–∏–±–∫–∏ VAD TriG –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
         * @param {Array} errors - –ú–∞—Å—Å–∏–≤ –æ—à–∏–±–æ–∫
         * @returns {string} - –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
         */
        function formatVADTriGErrors(errors) {
            let message = '–û–®–ò–ë–ö–ê –í–ê–õ–ò–î–ê–¶–ò–ò VAD TriG\n';
            message += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';

            errors.forEach((error, index) => {
                message += `–û—à–∏–±–∫–∞ ${index + 1}:\n`;
                message += `  TriG –≥—Ä–∞—Ñ: ${error.graph}\n`;
                message += `  ${error.message}\n\n`;
            });

            message += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
            message += `–í—Å–µ–≥–æ –æ—à–∏–±–æ–∫: ${errors.length}\n`;
            message += '\n–í —Ä–µ–∂–∏–º–µ VAD TriG –∫–∞–∂–¥—ã–π TriG –≥—Ä–∞—Ñ –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å —Å–≤–æ–π—Å—Ç–≤–æ vad:hasParentTrig.\n';
            message += '–ö–æ—Ä–Ω–µ–≤–æ–π –≥—Ä–∞—Ñ –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å hasParentTrig = vad:root.\n';
            message += '–î–æ—á–µ—Ä–Ω–∏–µ –≥—Ä–∞—Ñ—ã —É–∫–∞–∑—ã–≤–∞—é—Ç –Ω–∞ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π –≥—Ä–∞—Ñ —á–µ—Ä–µ–∑ hasParentTrig.';

            return message;
        }

        /**
         * –°—Ç—Ä–æ–∏—Ç HTML –¥–ª—è –¥–µ—Ä–µ–≤–∞ TriG
         * @param {string} trigUri - URI —Ç–µ–∫—É—â–µ–≥–æ TriG
         * @param {Object} hierarchy - –ò–µ—Ä–∞—Ä—Ö–∏—è TriG
         * @param {Object} prefixes - –°–ª–æ–≤–∞—Ä—å –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤
         * @param {number} level - –£—Ä–æ–≤–µ–Ω—å –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏ (–¥–ª—è –æ—Ç—Å—Ç—É–ø–æ–≤)
         * @returns {string} - HTML –¥–µ—Ä–µ–≤–∞
         */
        function buildTriGTreeHtml(trigUri, hierarchy, prefixes, level = 0) {
            const graphInfo = hierarchy[trigUri];
            if (!graphInfo) return '';

            const prefixedUri = getPrefixedName(trigUri, prefixes);
            const localName = getLocalName(trigUri);
            const displayLabel = graphInfo.label || localName;
            const isSelected = trigUri === selectedTrigUri;
            const hasChildren = graphInfo.children.length > 0;
            const hasProcesses = graphInfo.processes.length > 0;
            const hasExpandableContent = hasChildren || hasProcesses;

            let html = '';

            // –≠–ª–µ–º–µ–Ω—Ç –¥–µ—Ä–µ–≤–∞
            html += `<div class="trig-tree-item ${isSelected ? 'selected active' : ''}"
                         data-trig-uri="${escapeHtml(trigUri)}"
                         onclick="selectTriG('${escapeHtml(trigUri)}')">`;

            // –ó–Ω–∞—á–æ–∫ —Ä–∞—Å–∫—Ä—ã—Ç–∏—è/–∑–∞–∫—Ä—ã—Ç–∏—è
            if (hasExpandableContent) {
                html += `<span class="trig-tree-toggle">‚ñº</span>`;
            } else {
                html += `<span class="trig-tree-toggle"></span>`;
            }

            // –ú–µ—Ç–∫–∞ —Å id
            html += `<span class="trig-tree-label">${escapeHtml(displayLabel)}</span>`;
            html += `<span class="trig-tree-id">(${escapeHtml(localName)})</span>`;
            html += `</div>`;

            // –°–æ–¥–µ—Ä–∂–∏–º–æ–µ –¥–µ—Ä–µ–≤–∞ (–¥–æ—á–µ—Ä–Ω–∏–µ TriG –∏ —Å–æ—Å—Ç–∞–≤ –æ–±—ä–µ–∫—Ç–æ–≤)
            if (hasExpandableContent) {
                html += `<div class="trig-tree-children">`;

                // –°–Ω–∞—á–∞–ª–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–æ—á–µ—Ä–Ω–∏–µ TriG
                graphInfo.children.forEach(childUri => {
                    html += buildTriGTreeHtml(childUri, hierarchy, prefixes, level + 1);
                });

                // –ó–∞—Ç–µ–º –ø–æ–∫–∞–∑—ã–≤–∞–µ–º "–°–æ—Å—Ç–∞–≤ –æ–±—ä–µ–∫—Ç–æ–≤" —Å –ø—Ä–æ—Ü–µ—Å—Å–∞–º–∏
                if (hasProcesses) {
                    html += buildObjectCompositionHtml(trigUri, graphInfo.processes, prefixes);
                }

                html += `</div>`;
            }

            return html;
        }

        /**
         * –°—Ç—Ä–æ–∏—Ç HTML –¥–ª—è —Ä–∞–∑–¥–µ–ª–∞ "–°–æ—Å—Ç–∞–≤ –æ–±—ä–µ–∫—Ç–æ–≤" —Å –ø—Ä–æ—Ü–µ—Å—Å–∞–º–∏
         * @param {string} trigUri - URI TriG, –∫–æ—Ç–æ—Ä–æ–º—É –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç –ø—Ä–æ—Ü–µ—Å—Å—ã
         * @param {Array} processes - –ú–∞—Å—Å–∏–≤ URI –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
         * @param {Object} prefixes - –°–ª–æ–≤–∞—Ä—å –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤
         * @returns {string} - HTML —Ä–∞–∑–¥–µ–ª–∞
         */
        function buildObjectCompositionHtml(trigUri, processes, prefixes) {
            const objectCompositionId = `obj-comp-${escapeHtml(trigUri).replace(/[^a-zA-Z0-9]/g, '_')}`;

            let html = '';

            // –ó–∞–≥–æ–ª–æ–≤–æ–∫ "–°–æ—Å—Ç–∞–≤ –æ–±—ä–µ–∫—Ç–æ–≤"
            html += `<div class="trig-tree-item object-composition-header"
                         onclick="toggleObjectComposition('${objectCompositionId}')">`;
            html += `<span class="trig-tree-toggle object-composition-toggle" id="${objectCompositionId}-toggle">‚ñ∂</span>`;
            html += `<span class="trig-tree-label object-composition-label">–°–æ—Å—Ç–∞–≤ –æ–±—ä–µ–∫—Ç–æ–≤</span>`;
            html += `<span class="trig-tree-id">(${processes.length})</span>`;
            html += `</div>`;

            // –°–ø–∏—Å–æ–∫ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ (—Å–∫—Ä—ã—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
            html += `<div class="trig-tree-children object-composition-list" id="${objectCompositionId}" style="display: none;">`;

            processes.forEach(processUri => {
                const processLabel = getPrefixedName(processUri, prefixes);
                const processLocalName = getLocalName(processUri);

                // –ò—â–µ–º rdfs:label –ø—Ä–æ—Ü–µ—Å—Å–∞ - —Å–Ω–∞—á–∞–ª–∞ –≤ —Ç–µ–∫—É—â–µ–º TriG, –∑–∞—Ç–µ–º –≤ vad:ptree
                let processDisplayName = processLocalName;
                if (trigHierarchy && trigHierarchy[trigUri]) {
                    const graphQuads = trigHierarchy[trigUri].quads;
                    const labelQuad = graphQuads.find(q =>
                        q.subject.value === processUri &&
                        (q.predicate.value === 'http://www.w3.org/2000/01/rdf-schema#label' ||
                         getPrefixedName(q.predicate.value, prefixes) === 'rdfs:label')
                    );
                    if (labelQuad) {
                        processDisplayName = labelQuad.object.value;
                    } else {
                        // Fallback: –∏—â–µ–º –≤ vad:ptree
                        const ptreeMetadata = getProcessMetadataFromPtree(processUri, prefixes);
                        if (ptreeMetadata.label) {
                            processDisplayName = ptreeMetadata.label;
                        }
                    }
                }

                html += `<div class="trig-tree-item process-item"
                             data-process-uri="${escapeHtml(processUri)}"
                             data-trig-uri="${escapeHtml(trigUri)}"
                             onclick="event.stopPropagation(); selectProcess('${escapeHtml(processUri)}', '${escapeHtml(trigUri)}')">`;
                html += `<span class="trig-tree-toggle"></span>`;
                html += `<span class="process-icon">‚öô</span>`;
                html += `<span class="trig-tree-label">${escapeHtml(processDisplayName)}</span>`;
                html += `</div>`;
            });

            html += `</div>`;

            return html;
        }

        /**
         * –ü–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç –≤–∏–¥–∏–º–æ—Å—Ç—å —Å–ø–∏—Å–∫–∞ –æ–±—ä–µ–∫—Ç–æ–≤ (–°–æ—Å—Ç–∞–≤ –æ–±—ä–µ–∫—Ç–æ–≤)
         * @param {string} listId - ID —Å–ø–∏—Å–∫–∞ –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è
         */
        function toggleObjectComposition(listId) {
            const list = document.getElementById(listId);
            const toggle = document.getElementById(listId + '-toggle');

            if (list && toggle) {
                if (list.style.display === 'none') {
                    list.style.display = 'block';
                    toggle.textContent = '‚ñº';
                } else {
                    list.style.display = 'none';
                    toggle.textContent = '‚ñ∂';
                }
            }
        }

        /**
         * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞ –≤ –¥–µ—Ä–µ–≤–µ
         * @param {string} processUri - URI –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
         * @param {string} trigUri - URI TriG, —Å–æ–¥–µ—Ä–∂–∞—â–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å
         */
        function selectProcess(processUri, trigUri) {
            // –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å –∏–∑ –¥—Ä—É–≥–æ–≥–æ TriG, —Å–Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ —ç—Ç–æ—Ç TriG
            if (selectedTrigUri !== trigUri) {
                selectTriG(trigUri);
            }

            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å –Ω–∞ –¥–∏–∞–≥—Ä–∞–º–º–µ
            highlightProcessOnDiagram(processUri);
        }

        /**
         * –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å –Ω–∞ –¥–∏–∞–≥—Ä–∞–º–º–µ
         * @param {string} processUri - URI –ø—Ä–æ—Ü–µ—Å—Å–∞ –¥–ª—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏
         */
        function highlightProcessOnDiagram(processUri) {
            // –°–Ω–∏–º–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ
            const previouslySelected = document.querySelectorAll('#vad-trig-output .node.process-highlighted');
            previouslySelected.forEach(node => {
                node.classList.remove('process-highlighted');
            });

            // –ù–∞—Ö–æ–¥–∏–º —É–∑–µ–ª –ø—Ä–æ—Ü–µ—Å—Å–∞ –ø–æ –µ–≥–æ ID (–∏—Å–ø–æ–ª—å–∑—É–µ–º nodeLabelToUri –¥–ª—è –ø–æ–∏—Å–∫–∞)
            const prefixedUri = getPrefixedName(processUri, currentPrefixes);
            const nodeId = generateVadNodeId(processUri, currentPrefixes);

            // –ò—â–µ–º —É–∑–µ–ª SVG –ø–æ ID –∏–ª–∏ –ø–æ —Ç–µ–∫—Å—Ç—É
            const output = document.getElementById('vad-trig-output');
            if (!output) return;

            const nodes = output.querySelectorAll('.node');
            nodes.forEach(node => {
                const titleElement = node.querySelector('title');
                if (titleElement) {
                    const nodeTitle = titleElement.textContent.trim();
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–≤–ø–∞–¥–∞–µ—Ç –ª–∏ ID —É–∑–ª–∞ –∏–ª–∏ –µ–≥–æ –º–µ—Ç–∫–∞ —Å URI –ø—Ä–æ—Ü–µ—Å—Å–∞
                    if (nodeTitle === nodeId || nodeLabelToUri[nodeTitle] === processUri) {
                        node.classList.add('process-highlighted');
                        // –ü—Ä–æ–∫—Ä—É—á–∏–≤–∞–µ–º –∫ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É
                        node.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            });

            // –¢–∞–∫–∂–µ –≤—ã–¥–µ–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç –≤ –¥–µ—Ä–µ–≤–µ
            const processItems = document.querySelectorAll('.process-item');
            processItems.forEach(item => {
                if (item.getAttribute('data-process-uri') === processUri) {
                    item.classList.add('process-selected');
                } else {
                    item.classList.remove('process-selected');
                }
            });
        }

        /**
         * –û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –¥–µ—Ä–µ–≤–æ TriG
         * @param {Object} hierarchy - –ò–µ—Ä–∞—Ä—Ö–∏—è TriG
         * @param {string} rootUri - URI –∫–æ—Ä–Ω–µ–≤–æ–≥–æ TriG
         * @param {Object} prefixes - –°–ª–æ–≤–∞—Ä—å –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤
         */
        function displayTriGTree(hierarchy, rootUris, prefixes) {
            const treeContent = document.getElementById('trig-tree-content');
            if (!treeContent) return;

            if (!rootUris || rootUris.length === 0) {
                treeContent.innerHTML = '<div class="trig-properties-empty">–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö TriG –≥—Ä–∞—Ñ–æ–≤</div>';
                return;
            }

            let html = '';
            rootUris.forEach(rootUri => {
                if (hierarchy[rootUri]) {
                    html += buildTriGTreeHtml(rootUri, hierarchy, prefixes, 0);
                }
            });
            treeContent.innerHTML = html;
        }

        /**
         * –û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç —Å–≤–æ–π—Å—Ç–≤–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ TriG
         * @param {string} trigUri - URI TriG
         * @param {Object} hierarchy - –ò–µ—Ä–∞—Ä—Ö–∏—è TriG
         * @param {Object} prefixes - –°–ª–æ–≤–∞—Ä—å –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤
         */
        function displayTriGProperties(trigUri, hierarchy, prefixes) {
            const propertiesContent = document.getElementById('trig-properties-content');
            if (!propertiesContent) return;

            const graphInfo = hierarchy[trigUri];
            if (!graphInfo) {
                propertiesContent.innerHTML = '<div class="trig-properties-empty">–í—ã–±–µ—Ä–∏—Ç–µ TriG –≤ –¥–µ—Ä–µ–≤–µ</div>';
                return;
            }

            let html = '';

            // –û—Å–Ω–æ–≤–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞ TriG
            const prefixedUri = getPrefixedName(trigUri, prefixes);

            // URI with copy button
            html += `<div class="trig-property-item">`;
            html += `<div class="trig-property-predicate">URI</div>`;
            html += `<div class="trig-property-value-container">`;
            html += `<div class="trig-property-value uri">${escapeHtml(prefixedUri)}</div>`;
            html += `<button class="copy-id-btn" onclick="copyObjectId('${escapeHtml(trigUri)}', this)">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>`;
            html += `</div>`;
            html += `</div>`;

            // Label
            if (graphInfo.label) {
                html += `<div class="trig-property-item">`;
                html += `<div class="trig-property-predicate">rdfs:label</div>`;
                html += `<div class="trig-property-value literal">"${escapeHtml(graphInfo.label)}"</div>`;
                html += `</div>`;
            }

            // hasParent
            if (graphInfo.hasParent) {
                const parentLabel = getPrefixedName(graphInfo.hasParent, prefixes);
                html += `<div class="trig-property-item">`;
                html += `<div class="trig-property-predicate">vad:hasParentTrig</div>`;
                html += `<div class="trig-property-value uri">${escapeHtml(parentLabel)}</div>`;
                html += `</div>`;
            }

            // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
            html += `<div class="trig-property-item">`;
            html += `<div class="trig-property-predicate">–ü—Ä–æ—Ü–µ—Å—Å—ã (vad:TypeProcess)</div>`;
            html += `<div class="trig-property-value">${graphInfo.processes.length} —à—Ç.</div>`;
            html += `</div>`;

            // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ—á–µ—Ä–Ω–∏—Ö TriG
            if (graphInfo.children.length > 0) {
                html += `<div class="trig-property-item">`;
                html += `<div class="trig-property-predicate">–î–æ—á–µ—Ä–Ω–∏–µ TriG</div>`;
                html += `<div class="trig-property-value">${graphInfo.children.length} —à—Ç.</div>`;
                html += `</div>`;
            }

            // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–∏–ø–ª–µ—Ç–æ–≤
            html += `<div class="trig-property-item">`;
            html += `<div class="trig-property-predicate">–¢—Ä–∏–ø–ª–µ—Ç—ã</div>`;
            html += `<div class="trig-property-value">${graphInfo.quads.length} —à—Ç.</div>`;
            html += `</div>`;

            propertiesContent.innerHTML = html;
        }

        /**
         * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ TriG –≤ –¥–µ—Ä–µ–≤–µ
         * @param {string} trigUri - URI –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ TriG
         */
        function selectTriG(trigUri) {
            selectedTrigUri = trigUri;

            // –û–±–Ω–æ–≤–ª—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –≤ –¥–µ—Ä–µ–≤–µ
            const treeItems = document.querySelectorAll('.trig-tree-item');
            treeItems.forEach(item => {
                if (item.getAttribute('data-trig-uri') === trigUri) {
                    item.classList.add('selected', 'active');
                } else {
                    item.classList.remove('selected', 'active');
                }
            });

            // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ TriG
            displayTriGProperties(trigUri, trigHierarchy, currentPrefixes);

            // –ü–µ—Ä–µ–≤–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ–º –≥—Ä–∞—Ñ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ TriG
            revisualizeTrigVAD(trigUri);

            // –û–±–Ω–æ–≤–ª—è–µ–º SPARQL –∑–∞–ø—Ä–æ—Å –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ TriG
            updateSparqlQueryForTriG();
        }

        /**
         * –ü–µ—Ä–µ–≤–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ—Ç VAD –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ TriG
         * @param {string} trigUri - URI TriG –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
         */
        async function revisualizeTrigVAD(trigUri) {
            const graphInfo = trigHierarchy[trigUri];
            if (!graphInfo) return;

            const layoutEngine = document.getElementById('layout-engine').value;

            try {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–≤–∞–¥—ã —Ç–æ–ª—å–∫–æ –∏–∑ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞
                const filteredQuads = graphInfo.quads.filter(quad => {
                    const predicateUri = quad.predicate.value;
                    const predicateLabel = getPrefixedName(predicateUri, currentPrefixes);
                    return !isPredicateHidden(predicateUri, predicateLabel);
                });

                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º DOT-–∫–æ–¥ –≤ —Ä–µ–∂–∏–º–µ VAD
                const originalMode = currentMode;
                currentMode = 'vad';  // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª–æ–≥–∏–∫—É VAD –¥–ª—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞

                // –í—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–º–µ–Ω—è–µ–º currentQuads –Ω–∞ –∫–≤–∞–¥—ã –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞
                const originalQuads = currentQuads;
                currentQuads = graphInfo.quads;

                const dotCode = rdfToDot(filteredQuads, currentPrefixes);
                currentDotCode = dotCode;
                console.log('VAD TriG - –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π DOT-–∫–æ–¥:', dotCode);

                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º
                currentQuads = originalQuads;
                currentMode = originalMode;

                const viz = await Viz.instance();
                const svgString = viz.renderString(dotCode, { format: 'svg', engine: layoutEngine });

                // –í —Ä–µ–∂–∏–º–µ VAD TriG –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä vad-trig-output
                const output = document.getElementById('vad-trig-output');
                output.innerHTML = svgString;
                currentSvgElement = output.querySelector('svg');
                document.getElementById('vad-trig-zoom-controls').style.display = 'flex';
                addNodeClickHandlers();

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ VAD TriG:', error);
            }
        }

        /**
         * –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∏–ª–∏ —Å–∫—Ä—ã–≤–∞–µ—Ç –ø–∞–Ω–µ–ª–∏ VAD TriG —Ä–µ–∂–∏–º–∞
         * @param {boolean} show - –ü–æ–∫–∞–∑–∞—Ç—å –∏–ª–∏ —Å–∫—Ä—ã—Ç—å
         */
        function toggleVADTriGPanels(show) {
            const vadTrigContainer = document.getElementById('vad-trig-container');
            const regularZoomContainer = document.getElementById('zoom-container');
            const regularZoomControls = document.getElementById('zoom-controls');
            const regularOutput = document.getElementById('output');

            if (vadTrigContainer) {
                vadTrigContainer.style.display = show ? 'flex' : 'none';
            }

            // Hide regular zoom container and clear output when showing VAD TriG panels
            if (regularZoomContainer) {
                regularZoomContainer.style.display = show ? 'none' : 'block';
            }
            if (regularZoomControls && show) {
                regularZoomControls.style.display = 'none';
            }
            if (regularOutput && show) {
                regularOutput.innerHTML = '';
            }
        }

        // ============================================================================
        // –§–£–ù–ö–¶–ò–ò –†–ê–ë–û–¢–´ –°–û –°–¢–ò–õ–Ø–ú–ò
        // ============================================================================

        const BaseStyles = {
            literal: 'shape="box" style="filled" fillcolor="#ffffcc"',
            blankNode: 'shape="ellipse" style="filled" fillcolor="#e0e0e0"',
            uri: 'shape="ellipse" style="filled" fillcolor="#cce5ff"',
            edge: ''
        };

        function getNodeStyle(nodeUri, isLiteral, isBlankNode) {
            if (currentMode === 'base') {
                if (isLiteral) return BaseStyles.literal;
                if (isBlankNode) return BaseStyles.blankNode;
                return BaseStyles.uri;
            }

            if (currentMode === 'aggregation') {
                if (isBlankNode) return AggregationNodeStyles['BlankNodeStyle'].dot;
                const nodeTypes = nodeTypesCache[nodeUri] || [];
                for (const [styleName, styleConfig] of Object.entries(AggregationNodeStyles)) {
                    if (styleName === 'default') continue;
                    for (const type of styleConfig.types) {
                        if (type.startsWith('_')) continue;
                        if (nodeTypes.includes(type)) return styleConfig.dot;
                    }
                }
                return AggregationNodeStyles['default'].dot;
            }

            if (currentMode === 'vad' || currentMode === 'vad-trig') {
                if (isBlankNode) return VADNodeStyles['default'].dot;
                const nodeTypes = nodeTypesCache[nodeUri] || [];
                const nodeSubtypes = nodeSubtypesCache[nodeUri] || [];

                // First, check styles that have subtypes defined (ProcessStyleBasic, ProcessStyleDetailed)
                for (const [styleName, styleConfig] of Object.entries(VADNodeStyles)) {
                    if (styleName === 'default') continue;
                    if (!styleConfig.subtypes) continue; // Skip styles without subtypes

                    // Check if node has matching type
                    const hasMatchingType = styleConfig.types.some(type => nodeTypes.includes(type));
                    if (!hasMatchingType) continue;

                    // Check if node has matching subtype
                    const hasMatchingSubtype = styleConfig.subtypes.some(subtype => nodeSubtypes.includes(subtype));
                    if (hasMatchingSubtype) return styleConfig.dot;
                }

                // Then, check styles without subtypes (ExecutorGroupStyle, ExecutorStyle, etc.)
                for (const [styleName, styleConfig] of Object.entries(VADNodeStyles)) {
                    if (styleName === 'default') continue;
                    if (styleConfig.subtypes) continue; // Skip styles with subtypes (already checked)

                    for (const type of styleConfig.types) {
                        if (nodeTypes.includes(type)) return styleConfig.dot;
                    }
                }

                // For Process nodes without explicit subtype, default to ProcessStyleBasic
                const isProcess = nodeTypes.some(t =>
                    t === 'vad:TypeProcess' || t === 'http://example.org/vad#TypeProcess'
                );
                if (isProcess) {
                    return VADNodeStyles['ProcessStyleBasic'].dot;
                }

                return VADNodeStyles['default'].dot;
            }

            // –†–µ–∂–∏–º –Ω–æ—Ç–∞—Ü–∏–∏
            if (isLiteral) return StyleName.nodeStyles['LiteralStyle'].dot;
            if (isBlankNode) return StyleName.nodeStyles['BlankNodeStyle'].dot;

            const nodeTypes = nodeTypesCache[nodeUri] || [];
            for (const [styleName, styleConfig] of Object.entries(StyleName.nodeStyles)) {
                if (styleName === 'default') continue;
                for (const type of styleConfig.types) {
                    if (type.startsWith('_')) continue;
                    if (nodeTypes.includes(type)) return styleConfig.dot;
                }
            }
            return StyleName.nodeStyles['default'].dot;
        }

        function getEdgeStyle(predicateUri, predicateLabel) {
            if (currentMode === 'base') return BaseStyles.edge;

            if (currentMode === 'vad') {
                for (const [styleName, styleConfig] of Object.entries(VADEdgeStyles)) {
                    if (styleName === 'default') continue;
                    for (const predicate of styleConfig.predicates) {
                        if (predicateUri === predicate || predicateLabel === predicate) {
                            return styleConfig.dot;
                        }
                    }
                }
                return VADEdgeStyles['default'].dot;
            }

            // –†–µ–∂–∏–º –Ω–æ—Ç–∞—Ü–∏–∏ –∏–ª–∏ –∞–≥—Ä–µ–≥–∞—Ü–∏–∏
            for (const [styleName, styleConfig] of Object.entries(StyleName.edgeStyles)) {
                if (styleName === 'default') continue;
                for (const predicate of styleConfig.predicates) {
                    if (predicateUri === predicate || predicateLabel === predicate) {
                        return styleConfig.dot;
                    }
                }
            }
            return StyleName.edgeStyles['default'].dot;
        }

        function buildNodeTypesCache(quads, prefixes) {
            nodeTypesCache = {};
            nodeSubtypesCache = {};
            const typePredicates = [
                'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
                'rdf:type',
                'a'
            ];
            const subtypePredicates = [
                'http://example.org/vad#processSubtype',
                'vad:processSubtype'
            ];

            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–≤–∞–¥–æ–≤ –∏ –Ω–∞–ø–æ–ª–Ω–µ–Ω–∏—è –∫–µ—à–µ–π
            function processQuads(quadsToProcess) {
                quadsToProcess.forEach(quad => {
                    const predicateValue = quad.predicate.value;
                    const predicateLabel = getPrefixedName(predicateValue, prefixes);

                    // Build types cache
                    if (typePredicates.includes(predicateValue) ||
                        typePredicates.includes(predicateLabel) ||
                        predicateLabel === 'a') {

                        const subjectUri = quad.subject.value;
                        const typeUri = quad.object.value;
                        const typeLabel = getPrefixedName(typeUri, prefixes);

                        if (!nodeTypesCache[subjectUri]) {
                            nodeTypesCache[subjectUri] = [];
                        }

                        if (!nodeTypesCache[subjectUri].includes(typeUri)) {
                            nodeTypesCache[subjectUri].push(typeUri);
                        }
                        if (!nodeTypesCache[subjectUri].includes(typeLabel)) {
                            nodeTypesCache[subjectUri].push(typeLabel);
                        }
                    }

                    // Build subtypes cache for vad:processSubtype
                    if (subtypePredicates.includes(predicateValue) ||
                        subtypePredicates.includes(predicateLabel)) {

                        const subjectUri = quad.subject.value;
                        const subtypeUri = quad.object.value;
                        const subtypeLabel = getPrefixedName(subtypeUri, prefixes);

                        if (!nodeSubtypesCache[subjectUri]) {
                            nodeSubtypesCache[subjectUri] = [];
                        }

                        if (!nodeSubtypesCache[subjectUri].includes(subtypeUri)) {
                            nodeSubtypesCache[subjectUri].push(subtypeUri);
                        }
                        if (!nodeSubtypesCache[subjectUri].includes(subtypeLabel)) {
                            nodeSubtypesCache[subjectUri].push(subtypeLabel);
                        }
                    }
                });
            }

            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–µ –∫–≤–∞–¥—ã
            processQuads(quads);

            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ: –≤ —Ä–µ–∂–∏–º–µ VAD TriG —Ç–∞–∫–∂–µ –≤–∫–ª—é—á–∞–µ–º —Ç–∏–ø—ã –∏–∑ vad:ptree
            // —á—Ç–æ–±—ã rdf:type vad:TypeProcess –±—ã–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã –¥–ª—è –≤—Å–µ—Ö TriG –≥—Ä–∞—Ñ–æ–≤
            if (trigHierarchy && trigHierarchy[PTREE_GRAPH_URI]) {
                const ptreeQuads = trigHierarchy[PTREE_GRAPH_URI].quads;
                processQuads(ptreeQuads);
            }
        }

        // ============================================================================
        // –§–£–ù–ö–¶–ò–ò –ú–ê–°–®–¢–ê–ë–ò–†–û–í–ê–ù–ò–Ø
        // ============================================================================

        function applyZoom() {
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞—Å—à—Ç–∞–± –∫ –æ–±–æ–∏–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞–º (–æ–±—ã—á–Ω—ã–π –∏ VAD TriG)
            const zoomContent = document.getElementById('zoom-content');
            const zoomLevel = document.getElementById('zoom-level');
            const vadTrigZoomContent = document.getElementById('vad-trig-zoom-content');
            const vadTrigZoomLevel = document.getElementById('vad-trig-zoom-level');

            if (zoomContent) zoomContent.style.transform = `scale(${currentScale})`;
            if (zoomLevel) zoomLevel.textContent = Math.round(currentScale * 100) + '%';
            if (vadTrigZoomContent) vadTrigZoomContent.style.transform = `scale(${currentScale})`;
            if (vadTrigZoomLevel) vadTrigZoomLevel.textContent = Math.round(currentScale * 100) + '%';
        }

        function zoomIn() {
            if (currentScale < 3.0) { currentScale += 0.1; applyZoom(); }
        }

        function zoomOut() {
            if (currentScale > 0.1) { currentScale -= 0.1; applyZoom(); }
        }

        function zoomReset() {
            currentScale = 1.0;
            applyZoom();
        }

        function zoomFit() {
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å–µ–π—á–∞—Å –∞–∫—Ç–∏–≤–µ–Ω
            const vadTrigContainer = document.getElementById('vad-trig-container');
            const isVadTrigMode = vadTrigContainer && vadTrigContainer.style.display !== 'none';

            let zoomContainer, output;
            if (isVadTrigMode) {
                zoomContainer = document.getElementById('vad-trig-zoom-container');
                output = document.getElementById('vad-trig-output');
            } else {
                zoomContainer = document.getElementById('zoom-container');
                output = document.getElementById('output');
            }

            const svg = output ? output.querySelector('svg') : null;
            if (!zoomContainer || !svg) return;

            const containerWidth = zoomContainer.clientWidth - 20;
            const containerHeight = zoomContainer.clientHeight - 20;

            let svgWidth = parseFloat(svg.getAttribute('width')) || svg.getBoundingClientRect().width;
            let svgHeight = parseFloat(svg.getAttribute('height')) || svg.getBoundingClientRect().height;

            const widthStr = svg.getAttribute('width') || '';
            const heightStr = svg.getAttribute('height') || '';
            if (widthStr.includes('pt')) svgWidth = parseFloat(widthStr) * 1.33;
            if (heightStr.includes('pt')) svgHeight = parseFloat(heightStr) * 1.33;

            const scaleX = containerWidth / svgWidth;
            const scaleY = containerHeight / svgHeight;
            currentScale = Math.min(scaleX, scaleY, 1.0);
            applyZoom();
        }

        // ============================================================================
        // –§–£–ù–ö–¶–ò–ò –ü–ê–ù–ï–õ–ò –°–í–û–ô–°–¢–í –£–ó–õ–ê
        // ============================================================================

        function closePropertiesPanel(panelId) {
            const panel = document.getElementById(panelId);
            if (panel) {
                panel.remove();
                openPropertiesPanels = openPropertiesPanels.filter(p => p.id !== panelId);
            }
            if (selectedNodeElement) {
                selectedNodeElement.classList.remove('selected');
                selectedNodeElement = null;
            }
        }

        function closeAllPropertiesPanels() {
            const container = document.getElementById('properties-panels-container');
            if (container) container.innerHTML = '';
            openPropertiesPanels = [];
            if (selectedNodeElement) {
                selectedNodeElement.classList.remove('selected');
                selectedNodeElement = null;
            }
        }

        function getNodeProperties(nodeUri) {
            const properties = [];
            currentQuads.forEach(quad => {
                if (quad.subject.value === nodeUri) {
                    const predicateLabel = getPrefixedName(quad.predicate.value, currentPrefixes);
                    const isLiteral = quad.object.termType === 'Literal';
                    const objectLabel = isLiteral
                        ? `"${quad.object.value}"`
                        : getPrefixedName(quad.object.value, currentPrefixes);

                    properties.push({
                        predicate: quad.predicate.value,
                        predicateLabel: predicateLabel,
                        object: quad.object.value,
                        objectLabel: objectLabel,
                        isLiteral: isLiteral
                    });
                }
            });
            return properties;
        }

        function showNodeProperties(nodeUri, nodeLabel) {
            const container = document.getElementById('properties-panels-container');
            if (!container) return;

            const existingPanel = openPropertiesPanels.find(p => p.uri === nodeUri);
            if (existingPanel) {
                const panel = document.getElementById(existingPanel.id);
                if (panel) bringPanelToFront(panel);
                return;
            }

            propertiesPanelCounter++;
            const panelId = 'properties-panel-' + propertiesPanelCounter;

            const offsetMultiplier = openPropertiesPanels.length % 5;
            const rightOffset = 20 + (offsetMultiplier * 30);
            const topOffset = 100 + (offsetMultiplier * 30);

            const properties = getNodeProperties(nodeUri);

            let propertiesHtml = '';
            if (properties.length === 0) {
                propertiesHtml = '<div class="properties-empty">–£ —ç—Ç–æ–≥–æ —É–∑–ª–∞ –Ω–µ—Ç —Å–≤–æ–π—Å—Ç–≤</div>';
            } else {
                properties.forEach(prop => {
                    propertiesHtml += '<div class="property-item">';
                    propertiesHtml += `<div class="property-predicate">${prop.predicateLabel}</div>`;
                    propertiesHtml += `<div class="property-value ${prop.isLiteral ? 'literal' : 'uri'}">${prop.objectLabel}</div>`;
                    propertiesHtml += '</div>';
                });
            }

            const nodeTypes = nodeTypesCache[nodeUri] || [];
            if (nodeTypes.length > 0) {
                const prefixedTypes = nodeTypes.filter(t => t.includes(':') && !t.startsWith('http'));
                if (prefixedTypes.length > 0) {
                    propertiesHtml += '<div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ddd;">';
                    propertiesHtml += '<div style="font-size: 12px; color: #666; margin-bottom: 5px;">–¢–∏–ø —É–∑–ª–∞:</div>';
                    prefixedTypes.forEach(type => {
                        propertiesHtml += `<span class="properties-type-badge">${type}</span> `;
                    });
                    propertiesHtml += '</div>';
                }
            }

            // –î–æ–±–∞–≤–ª—è–µ–º –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞ –∏–∑ virtualRDFdata (—Å —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–µ–º)
            const computedProperties = getComputedPropertiesForNode(nodeUri);
            if (computedProperties.length > 0) {
                propertiesHtml += '<div style="margin-top: 15px; padding-top: 10px; border-top: 2px dashed #9C27B0;">';
                propertiesHtml += '<div style="font-size: 12px; color: #9C27B0; margin-bottom: 8px; font-weight: bold;">–í—ã—á–∏—Å–ª—è–µ–º—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞ (virtualRDFdata):</div>';
                computedProperties.forEach(prop => {
                    propertiesHtml += '<div class="property-item" style="background-color: #F3E5F5; border-left: 3px solid #9C27B0;">';
                    propertiesHtml += `<div class="property-predicate" style="color: #7B1FA2;">${prop.predicateLabel}</div>`;
                    propertiesHtml += `<div class="property-value uri" style="color: #4A148C;">${prop.valueLabel}</div>`;
                    propertiesHtml += '</div>';
                });
                propertiesHtml += '</div>';
            }

            const escapedNodeLabel = nodeLabel.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const panelHtml = `
                <div class="properties-panel visible" id="${panelId}" style="right: ${rightOffset}px; top: ${topOffset}px;">
                    <div class="properties-header" onmousedown="startDragPanel(event, '${panelId}')">
                        <div class="properties-header-content">
                            <div class="properties-header-title">–°–≤–æ–π—Å—Ç–≤–∞ –æ–±—ä–µ–∫—Ç–∞</div>
                            <div class="properties-header-row">
                                <h3>${nodeLabel}</h3>
                                <button class="properties-copy-btn" onclick="event.stopPropagation(); copyObjectId('${escapedNodeLabel}', this)">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
                            </div>
                        </div>
                        <button class="properties-close-btn" onclick="closePropertiesPanel('${panelId}')">&times;</button>
                    </div>
                    <div class="properties-content">
                        ${propertiesHtml}
                    </div>
                </div>
            `;

            container.insertAdjacentHTML('beforeend', panelHtml);
            openPropertiesPanels.push({ id: panelId, uri: nodeUri, label: nodeLabel });

            const newPanel = document.getElementById(panelId);
            if (newPanel) bringPanelToFront(newPanel);
        }

        function bringPanelToFront(panel) {
            let maxZIndex = 1000;
            openPropertiesPanels.forEach(p => {
                const el = document.getElementById(p.id);
                if (el) {
                    const z = parseInt(el.style.zIndex) || 1000;
                    if (z > maxZIndex) maxZIndex = z;
                }
            });
            panel.style.zIndex = maxZIndex + 1;
        }

        function startDragPanel(event, panelId) {
            if (event.target.classList.contains('properties-close-btn')) return;
            const panel = document.getElementById(panelId);
            if (!panel) return;

            draggedPanel = panel;
            const rect = panel.getBoundingClientRect();
            dragOffsetX = event.clientX - rect.left;
            dragOffsetY = event.clientY - rect.top;

            bringPanelToFront(panel);
            document.addEventListener('mousemove', dragPanel);
            document.addEventListener('mouseup', stopDragPanel);
            event.preventDefault();
        }

        function dragPanel(event) {
            if (!draggedPanel) return;
            const newLeft = event.clientX - dragOffsetX;
            const newTop = event.clientY - dragOffsetY;
            draggedPanel.style.left = newLeft + 'px';
            draggedPanel.style.top = newTop + 'px';
            draggedPanel.style.right = 'auto';
        }

        function stopDragPanel() {
            draggedPanel = null;
            document.removeEventListener('mousemove', dragPanel);
            document.removeEventListener('mouseup', stopDragPanel);
        }

        // ============================================================================
        // –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ö–õ–ò–ö–û–í –ü–û –£–ó–õ–ê–ú
        // ============================================================================

        function addNodeClickHandlers() {
            // Add click handlers to both regular output and VAD TriG output
            const regularSvg = document.querySelector('#output svg');
            const vadTrigSvg = document.querySelector('#vad-trig-output svg');

            const svgElements = [regularSvg, vadTrigSvg].filter(svg => svg !== null);

            svgElements.forEach(svg => {
                const nodes = svg.querySelectorAll('.node');
                nodes.forEach(node => {
                    node.addEventListener('click', handleNodeClick);
                    node.addEventListener('dblclick', handleNodeDoubleClick);
                });
            });
        }

        function handleNodeClick(event) {
            const nodeElement = event.currentTarget;
            const titleElement = nodeElement.querySelector('title');
            if (!titleElement) return;

            const dotId = titleElement.textContent;

            let nodeUri = null;
            let nodeLabel = null;

            for (const [label, info] of Object.entries(nodeLabelToUri)) {
                if (info.dotId === dotId) {
                    nodeUri = info.uri;
                    nodeLabel = label;
                    break;
                }
            }

            if (!nodeUri) return;

            // –ù–ï —Å–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å —ç–ª–µ–º–µ–Ω—Ç–∞ TriG-–¥–µ—Ä–µ–≤–∞ –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–∞ —É–∑–µ–ª –¥–∏–∞–≥—Ä–∞–º–º—ã.
            // –í—ã–¥–µ–ª–µ–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç TriG –¥–µ—Ä–µ–≤–∞ –≤—Å–µ–≥–¥–∞ –¥–æ–ª–∂–µ–Ω –æ—Ç—Ä–∞–∂–∞—Ç—å, —á—å—è —Å—Ö–µ–º–∞ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –Ω–∞ –¥–∏–∞–≥—Ä–∞–º–º–µ.
            // –°–Ω–∏–º–∞–µ–º —Ç–æ–ª—å–∫–æ –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –≤ —Å–ø–∏—Å–∫–µ "–°–æ—Å—Ç–∞–≤ –æ–±—ä–µ–∫—Ç–æ–≤" –∏ –ø–æ–¥—Å–≤–µ—Ç–∫—É –Ω–∞ –¥–∏–∞–≥—Ä–∞–º–º–µ.
            const processItems = document.querySelectorAll('.process-item.process-selected');
            processItems.forEach(item => {
                item.classList.remove('process-selected');
            });
            const highlightedProcesses = document.querySelectorAll('.node.process-highlighted');
            highlightedProcesses.forEach(node => {
                node.classList.remove('process-highlighted');
            });

            if (selectedNodeElement) {
                selectedNodeElement.classList.remove('selected');
            }
            nodeElement.classList.add('selected');
            selectedNodeElement = nodeElement;

            showNodeProperties(nodeUri, nodeLabel);
        }

        /**
         * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–≤–æ–π–Ω–æ–≥–æ –∫–ª–∏–∫–∞ –ø–æ —É–∑–ª—É –¥–∏–∞–≥—Ä–∞–º–º—ã
         * –î–ª—è –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ —Å –ø–æ–¥—Ç–∏–ø–æ–º "–î–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π" (vad:Detailed) –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é —Å—Ö–µ–º—É TriG
         * @param {Event} event - –°–æ–±—ã—Ç–∏–µ –¥–≤–æ–π–Ω–æ–≥–æ –∫–ª–∏–∫–∞
         */
        function handleNodeDoubleClick(event) {
            event.preventDefault();
            event.stopPropagation();

            const nodeElement = event.currentTarget;
            const titleElement = nodeElement.querySelector('title');
            if (!titleElement) return;

            const dotId = titleElement.textContent;

            let nodeUri = null;
            let nodeLabel = null;

            for (const [label, info] of Object.entries(nodeLabelToUri)) {
                if (info.dotId === dotId) {
                    nodeUri = info.uri;
                    nodeLabel = label;
                    break;
                }
            }

            if (!nodeUri) return;

            // –ò—â–µ–º —Å–≤–æ–π—Å—Ç–≤–æ vad:hasTrig –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ —É–∑–ª–∞
            const hasTrigPredicate = 'http://example.org/vad#hasTrig';
            let targetTrigUri = null;

            // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤ vad:ptree (—Ç–∞–º —Ö—Ä–∞–Ω—è—Ç—Å—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤, –≤–∫–ª—é—á–∞—è hasTrig)
            if (trigHierarchy && trigHierarchy[PTREE_GRAPH_URI]) {
                const ptreeQuads = trigHierarchy[PTREE_GRAPH_URI].quads;
                for (const quad of ptreeQuads) {
                    if (quad.subject.value === nodeUri && quad.predicate.value === hasTrigPredicate) {
                        targetTrigUri = quad.object.value;
                        break;
                    }
                }
            }

            // –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ ptree, –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤ —Ç–µ–∫—É—â–µ–º –≥—Ä–∞—Ñ–µ –∏–ª–∏ –≤–æ –≤—Å–µ—Ö –≥—Ä–∞—Ñ–∞—Ö
            if (!targetTrigUri) {
                const quadsToCheck = selectedTrigUri && trigHierarchy[selectedTrigUri]
                    ? trigHierarchy[selectedTrigUri].quads
                    : currentQuads;

                for (const quad of quadsToCheck) {
                    if (quad.subject.value === nodeUri && quad.predicate.value === hasTrigPredicate) {
                        targetTrigUri = quad.object.value;
                        break;
                    }
                }
            }

            // –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω —Å–≤—è–∑–∞–Ω–Ω—ã–π TriG, –æ—Ç–∫—Ä—ã–≤–∞–µ–º –µ–≥–æ
            if (targetTrigUri && trigHierarchy[targetTrigUri]) {
                selectTriG(targetTrigUri);
            }
        }

        /**
         * –°–Ω–∏–º–∞–µ—Ç –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å–æ –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ TriG-–¥–µ—Ä–µ–≤–∞
         */
        function clearTriGTreeSelection() {
            // –°–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å TriG-—ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–µ—Ä–µ–≤–∞
            const treeItems = document.querySelectorAll('.trig-tree-item');
            treeItems.forEach(item => {
                item.classList.remove('selected', 'active');
            });

            // –°–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –≤ –¥–µ—Ä–µ–≤–µ
            const processItems = document.querySelectorAll('.process-item.process-selected');
            processItems.forEach(item => {
                item.classList.remove('process-selected');
            });

            // –°–Ω–∏–º–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É –ø—Ä–æ—Ü–µ—Å—Å–∞ –Ω–∞ –¥–∏–∞–≥—Ä–∞–º–º–µ
            const highlightedProcesses = document.querySelectorAll('.node.process-highlighted');
            highlightedProcesses.forEach(node => {
                node.classList.remove('process-highlighted');
            });
        }

        // ============================================================================
        // –§–£–ù–ö–¶–ò–ò –§–ò–õ–¨–¢–†–û–í
        // ============================================================================

        function isPredicateHidden(predicateUri, predicateLabel) {
            return activeFilters.includes(predicateUri) || activeFilters.includes(predicateLabel);
        }

        function displayFilters() {
            // filter-panel removed in minimization - function kept for compatibility
            return;

            allPredicates = [];
            const predicateSet = new Set();

            currentQuads.forEach(quad => {
                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, currentPrefixes);
                if (!predicateSet.has(predicateLabel)) {
                    predicateSet.add(predicateLabel);
                    allPredicates.push({ uri: predicateUri, label: predicateLabel });
                }
            });

            if (allPredicates.length === 0) {
                filterPanel.style.display = 'none';
                return;
            }

            allPredicates.sort((a, b) => a.label.localeCompare(b.label));

            let html = '';
            allPredicates.forEach(pred => {
                const isHidden = isPredicateHidden(pred.uri, pred.label);
                const checkboxId = 'filter-' + pred.label.replace(/[^a-zA-Z0-9]/g, '_');

                html += `<div class="filter-item">`;
                html += `<input type="checkbox" id="${checkboxId}" ${!isHidden ? 'checked' : ''} onchange="togglePredicateFilter('${pred.uri}', '${pred.label}', this.checked)">`;
                html += `<label for="${checkboxId}">${pred.label}</label>`;
                html += `</div>`;
            });

            filterContent.innerHTML = html;
            filterPanel.style.display = 'block';
        }

        function togglePredicateFilter(predicateUri, predicateLabel, isVisible) {
            if (isVisible) {
                activeFilters = activeFilters.filter(f => f !== predicateUri && f !== predicateLabel);
            } else {
                if (!activeFilters.includes(predicateUri)) {
                    activeFilters.push(predicateUri);
                }
                if (!activeFilters.includes(predicateLabel)) {
                    activeFilters.push(predicateLabel);
                }
            }
            revisualize();
        }

        function selectAllFilters() {
            activeFilters = [];
            displayFilters();
            revisualize();
        }

        function deselectAllFilters() {
            activeFilters = allPredicates.flatMap(p => [p.uri, p.label]);
            displayFilters();
            revisualize();
        }

        async function revisualize() {
            const layoutEngine = document.getElementById('layout-engine').value;

            try {
                const filteredQuads = currentQuads.filter(quad => {
                    const predicateUri = quad.predicate.value;
                    const predicateLabel = getPrefixedName(predicateUri, currentPrefixes);
                    return !isPredicateHidden(predicateUri, predicateLabel);
                });

                const dotCode = rdfToDot(filteredQuads, currentPrefixes);
                currentDotCode = dotCode;
                console.log('–ü–µ—Ä–µ—Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π DOT-–∫–æ–¥:', dotCode);

                const viz = await Viz.instance();
                const svgString = viz.renderString(dotCode, { format: 'svg', engine: layoutEngine });

                const output = document.getElementById('output');
                output.innerHTML = svgString;
                currentSvgElement = output.querySelector('svg');
                addNodeClickHandlers();

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏:', error);
            }
        }

        // ============================================================================
        // –§–£–ù–ö–¶–ò–ò –ó–ê–ì–†–£–ó–ö–ò –ü–†–ò–ú–ï–†–û–í
        // ============================================================================

        /**
         * –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–∏–º–µ—Ä–∞ –∏–∑ —Ñ–∞–π–ª–∞.
         * –ü—ã—Ç–∞–µ—Ç—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª —á–µ—Ä–µ–∑ fetch. –ü—Ä–∏ –æ—à–∏–±–∫–µ CORS (–ª–æ–∫–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª)
         * –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∫–∞–∫ fallback.
         * @param {string} filename - –ò–º—è —Ñ–∞–π–ª–∞ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏
         * @param {string} exampleName - –ß–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º–æ–µ –∏–º—è –ø—Ä–∏–º–µ—Ä–∞
         * @param {string} inputFormat - –§–æ—Ä–º–∞—Ç –≤–≤–æ–¥–∞ (turtle, n-triples, n-quads, trig)
         * @param {string} visualizationMode - –†–µ–∂–∏–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ (notation, vad, vad-trig)
         * @param {string} fallbackDataKey - –ö–ª—é—á –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–º –¥–∞–Ω–Ω—ã–º EXAMPLE_DATA
         */
        async function loadExampleFromFile(filename, exampleName, inputFormat, visualizationMode, fallbackDataKey) {
            const statusEl = document.getElementById('example-status');

            statusEl.textContent = `–ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–∏–º–µ—Ä–∞ ${exampleName}...`;
            statusEl.style.display = 'block';
            statusEl.style.backgroundColor = '#fff3cd';
            statusEl.style.borderColor = '#ffc107';
            statusEl.style.color = '#856404';

            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.text();

                document.getElementById('rdf-input').value = data;
                document.getElementById('input-format').value = inputFormat;
                document.getElementById('visualization-mode').value = visualizationMode;
                updateModeDescription();

                statusEl.textContent = `–ü—Ä–∏–º–µ—Ä ${exampleName} —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω –∏–∑ —Ñ–∞–π–ª–∞ ${filename}`;
                statusEl.style.backgroundColor = '#d4edda';
                statusEl.style.borderColor = '#c3e6cb';
                statusEl.style.color = '#155724';
            } catch (error) {
                console.warn(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª ${filename}:`, error.message);

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —ç—Ç–æ –æ—à–∏–±–∫–∞ CORS (–ª–æ–∫–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª) –∏–ª–∏ —Å–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞
                const isCorsError = error.message.includes('Failed to fetch') ||
                                    error.message.includes('NetworkError') ||
                                    error.message.includes('CORS');

                if (isCorsError) {
                    // –î–ª—è –ª–æ–∫–∞–ª—å–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                    statusEl.textContent = `–§–∞–π–ª ${filename} –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (CORS). –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.`;
                    statusEl.style.backgroundColor = '#fff3cd';
                    statusEl.style.borderColor = '#ffc107';
                    statusEl.style.color = '#856404';
                } else {
                    // –î–ª—è —Å–µ—Ä–≤–µ—Ä–Ω—ã—Ö –æ—à–∏–±–æ–∫ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—à–∏–±–∫—É, –Ω–æ –≤—Å—ë —Ä–∞–≤–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback
                    statusEl.textContent = `–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ ${filename}: ${error.message}. –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.`;
                    statusEl.style.backgroundColor = '#fff3cd';
                    statusEl.style.borderColor = '#ffc107';
                    statusEl.style.color = '#856404';
                }

                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∫–∞–∫ fallback
                try {
                    document.getElementById('rdf-input').value = EXAMPLE_DATA[fallbackDataKey];
                    document.getElementById('input-format').value = inputFormat;
                    document.getElementById('visualization-mode').value = visualizationMode;
                    updateModeDescription();
                } catch (fallbackError) {
                    console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö:`, fallbackError);
                    statusEl.textContent = `–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–∏–º–µ—Ä–∞ ${exampleName}: ${fallbackError.message}`;
                    statusEl.style.backgroundColor = '#f8d7da';
                    statusEl.style.borderColor = '#f5c6cb';
                    statusEl.style.color = '#721c24';
                }
            }
        }

        /**
         * –ó–∞–≥—Ä—É–∂–∞–µ—Ç –ø—Ä–∏–º–µ—Ä Turtle
         * –ê–ª–≥–æ—Ä–∏—Ç–º –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞:
         * 1. –û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –∑–∞–≥—Ä—É–∑–∫–∏
         * 2. –í—ã–ø–æ–ª–Ω—è–µ—Ç fetch –∑–∞–ø—Ä–æ—Å –∫ —Ñ–∞–π–ª—É 'Turtle.ttl' (–æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –æ—Ç —Ç–µ–∫—É—â–µ–≥–æ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è HTML —Ñ–∞–π–ª–∞)
         * 3. –ü—Ä–∏ —É—Å–ø–µ—Ö–µ: –∑–∞–ø–æ–ª–Ω—è–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø–æ–ª–µ RDF –¥–∞–Ω–Ω—ã–º–∏, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ñ–æ—Ä–º–∞—Ç –≤–≤–æ–¥–∞ –∏ —Ä–µ–∂–∏–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
         * 4. –ü—Ä–∏ –æ—à–∏–±–∫–µ CORS (–ª–æ–∫–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª): –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
         * 5. –ü—Ä–∏ –¥—Ä—É–≥–æ–π –æ—à–∏–±–∫–µ: –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—à–∏–±–∫–µ
         */
        /**
         * –ó–∞–≥—Ä—É–∂–∞–µ—Ç –ø—Ä–∏–º–µ—Ä TriG VADv4 (Value Added Chain Diagram —Å –∏–µ—Ä–∞—Ä—Ö–∏–µ–π TriG)
         * –î–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç:
         * - –ò–µ—Ä–∞—Ä—Ö–∏—é –ø—Ä–æ—Ü–µ—Å—Å–æ–≤: p1, p1.1, p1.2, p1.1.1, p1.1.2, p2, p2.1, p2.2
         * - –ö–æ—Ä–Ω–µ–≤—ã–µ TriG –≥—Ä–∞—Ñ—ã: t_p1, t_p2 (hasParentTrig = root)
         * - –î–æ—á–µ—Ä–Ω–∏–π TriG –≥—Ä–∞—Ñ: t_p1.1 (hasParentTrig = t_p1)
         * - –í—ã—á–∏—Å–ª—è–µ–º—ã–µ –ø–æ–¥—Ç–∏–ø—ã: DetailedChild, notDetailedChild, notDetailedExternal, NotDefinedType
         */
        function loadExampleTrigVADv4() {
            loadExampleFromFile('Trig_VADv4.ttl', 'Trig VADv4', 'trig', 'vad-trig', 'trig-vad-v4');
        }

        /**
         * –î–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏: –≤—ã–∑—ã–≤–∞–µ—Ç –∑–∞–≥—Ä—É–∑–∫—É –ø—Ä–∏–º–µ—Ä–∞ Trig VADv4
         */
        function loadExample() {
            loadExampleTrigVADv4();
        }

        /**
         * –û—á–∏—â–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø–æ–ª—è RDF –¥–∞–Ω–Ω—ã—Ö
         */
        function clearRdfInput() {
            document.getElementById('rdf-input').value = '';
        }

        /**
         * –°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ RDF –ø–æ–ª—è –∫–∞–∫ —Ñ–∞–π–ª
         */
        function saveAsFile() {
            const content = document.getElementById('rdf-input').value;
            if (!content.trim()) {
                alert('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è');
                return;
            }

            const format = document.getElementById('input-format').value;
            let extension = 'ttl';
            if (format === 'n-triples') extension = 'nt';
            else if (format === 'n-quads') extension = 'nq';
            else if (format === 'trig') extension = 'trig';

            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `rdf-data.${extension}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        /**
         * –ó–∞–≥—Ä—É–∂–∞–µ—Ç —Ñ–∞–π–ª, –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
         */
        function loadFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                document.getElementById('rdf-input').value = e.target.result;

                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ–æ—Ä–º–∞—Ç –ø–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—é
                const extension = file.name.split('.').pop().toLowerCase();
                let format = 'turtle';
                if (extension === 'nt') format = 'n-triples';
                else if (extension === 'nq') format = 'n-quads';
                else if (extension === 'trig') format = 'trig';

                document.getElementById('input-format').value = format;

                // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–≥—Ä—É–∑–∫–∏
                const statusEl = document.getElementById('example-status');
                statusEl.textContent = `–§–∞–π–ª ${file.name} —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω`;
                statusEl.style.display = 'block';
                statusEl.style.backgroundColor = '#d4edda';
                statusEl.style.borderColor = '#c3e6cb';
                statusEl.style.color = '#155724';

                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ input –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–æ–≥–æ –∂–µ —Ñ–∞–π–ª–∞
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        /**
         * –¢–µ—Å—Ç–∏—Ä—É–µ—Ç –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å RDF –¥–∞–Ω–Ω—ã—Ö –≤—Ä—É—á–Ω—É—é
         *
         * –í—ã–ø–æ–ª–Ω—è–µ—Ç –∫–æ–º–ø–ª–µ–∫—Å–Ω—É—é –ø—Ä–æ–≤–µ—Ä–∫—É RDF –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –ø–æ–ª—è:
         * 1. –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫—É—é –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å (–ø–∞—Ä—Å–∏–Ω–≥ —á–µ—Ä–µ–∑ N3.js)
         * 2. –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –ø—Ä–∞–≤–∏–ª–∞–º VAD –æ–Ω—Ç–æ–ª–æ–≥–∏–∏ (—á–µ—Ä–µ–∑ validateVAD)
         *
         * –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏ "–¢–µ—Å—Ç" –≤ –∑–∞–≥–æ–ª–æ–≤–∫–µ –ø–æ–ª—è RDF –¥–∞–Ω–Ω—ã—Ö.
         * –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è —á–µ—Ä–µ–∑ alert() —Å –ø–æ–¥—Ä–æ–±–Ω—ã–º –æ–ø–∏—Å–∞–Ω–∏–µ–º –æ—à–∏–±–æ–∫.
         *
         * @returns {void}
         *
         * @example
         * // –í—ã–∑–æ–≤ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏ "–¢–µ—Å—Ç"
         * <button onclick="testRdfValidation()">–¢–µ—Å—Ç</button>
         *
         * @see validateVAD - –§—É–Ω–∫—Ü–∏—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –ø—Ä–∞–≤–∏–ª VAD
         * @see formatVADErrors - –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
         */
        function testRdfValidation() {
            const rdfInput = document.getElementById('rdf-input');
            const inputFormat = document.getElementById('input-format').value;

            if (!rdfInput || !rdfInput.value.trim()) {
                alert('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏. –í–≤–µ–¥–∏—Ç–µ RDF –¥–∞–Ω–Ω—ã–µ –≤ –ø–æ–ª–µ –≤—ã—à–µ.');
                return;
            }

            const rdfData = rdfInput.value;

            // –°–æ–∑–¥–∞–µ–º –ø–∞—Ä—Å–µ—Ä N3
            const parser = new N3.Parser({ format: inputFormat });

            const quads = [];
            const prefixes = {};

            try {
                parser.parse(rdfData, (error, quad, prefixesParsed) => {
                    if (error) {
                        alert(`‚ùå –û–®–ò–ë–ö–ê –°–ò–ù–¢–ê–ö–°–ò–°–ê RDF\n\n${error.message}\n\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ RDF –¥–∞–Ω–Ω—ã—Ö.`);
                        return;
                    }

                    if (quad) {
                        quads.push(quad);
                    } else {
                        // Parsing complete
                        Object.assign(prefixes, prefixesParsed);

                        // –í—ã–ø–æ–ª–Ω—è–µ–º –≤–∞–ª–∏–¥–∞—Ü–∏—é VAD –æ–Ω—Ç–æ–ª–æ–≥–∏–∏
                        const validation = validateVAD(quads, prefixes);

                        // –í—ã–ø–æ–ª–Ω—è–µ–º –≤–∞–ª–∏–¥–∞—Ü–∏—é VAD —Å—Ö–µ–º—ã
                        const schemaValidation = validateVADSchema(quads, prefixes);

                        // –§–æ—Ä–º–∏—Ä—É–µ–º –∏—Ç–æ–≥–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                        let resultMessage = '';

                        if (validation.valid && schemaValidation.valid) {
                            resultMessage = '‚úÖ –í–ê–õ–ò–î–ê–¶–ò–Ø –£–°–ü–ï–®–ù–ê\n\n' +
                                  'RDF –¥–∞–Ω–Ω—ã–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –ø—Ä–∞–≤–∏–ª–∞–º VAD –æ–Ω—Ç–æ–ª–æ–≥–∏–∏ –∏ —Å—Ö–µ–º—ã.\n\n' +
                                  `–í—Å–µ–≥–æ —Ç—Ä–∏–ø–ª–µ—Ç–æ–≤: ${quads.length}\n` +
                                  `–ü—Ä–µ—Ñ–∏–∫—Å–æ–≤: ${Object.keys(prefixes).length}`;
                            alert(resultMessage);
                        } else {
                            // –ï—Å—Ç—å –æ—à–∏–±–∫–∏ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–µ—Ç–∞–ª–∏
                            if (!validation.valid) {
                                resultMessage += formatVADErrors(validation.errors);
                                resultMessage += '\n\n';
                            }
                            if (!schemaValidation.valid || schemaValidation.warnings.length > 0) {
                                resultMessage += formatVADSchemaValidation(schemaValidation);
                            }
                            alert(resultMessage);
                        }
                    }
                });
            } catch (error) {
                alert(`‚ùå –û–®–ò–ë–ö–ê –ü–†–ò –ü–†–û–í–ï–†–ö–ï\n\n${error.message}\n\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å RDF –¥–∞–Ω–Ω—ã—Ö.`);
            }
        }

        // ============================================================================
        // –§–£–ù–ö–¶–ò–ò –î–õ–Ø VIRTUALRDFDATA (–≤—ã—á–∏—Å–ª—è–µ–º—ã–µ RDF –¥–∞–Ω–Ω—ã–µ)
        // ============================================================================

        /**
         * –í—ã—á–∏—Å–ª—è–µ—Ç processSubtype –¥–ª—è –≤—Å–µ—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –≤–æ –≤—Å–µ—Ö TriG —Å—Ö–µ–º–∞—Ö
         * –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ virtualRDFdata
         *
         * –ê–ª–≥–æ—Ä–∏—Ç–º –≤—ã—á–∏—Å–ª–µ–Ω–∏—è vad:processSubtype:
         * - –ï—Å–ª–∏ –ø—Ä–æ—Ü–µ—Å—Å –∏–º–µ–µ—Ç vad:hasTrig (–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π):
         *   - DetailedChild: –¥–æ—á–µ—Ä–Ω–∏–π TriG —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–µ–∫—É—â–∏–π (hasParentTrig = currentTrig)
         *   - DetailedExternal: –¥–æ—á–µ—Ä–Ω–∏–π TriG –ù–ï —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–µ–∫—É—â–∏–π
         * - –ï—Å–ª–∏ –ø—Ä–æ—Ü–µ—Å—Å –∏–º–µ–µ—Ç vad:hasParentProcess (–Ω–µ–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π):
         *   - notDetailedChild: hasParentProcess —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –ø—Ä–æ—Ü–µ—Å—Å–æ–º-–≤–ª–∞–¥–µ–ª—å—Ü–µ–º —Ç–µ–∫—É—â–µ–π —Å—Ö–µ–º—ã
         *   - notDetailedExternal: hasParentProcess –ù–ï —Å–æ–≤–ø–∞–¥–∞–µ—Ç
         *   - NotDefinedType: hasParentProcess = vad:NotDefined
         *
         * @returns {Object} virtualRDFdata - —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
         */
        function computeVirtualRDFdata() {
            virtualRDFdata = {};

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ trigHierarchy
            if (!trigHierarchy || Object.keys(trigHierarchy).length === 0) {
                console.warn('computeVirtualRDFdata: trigHierarchy –ø—É—Å—Ç –∏–ª–∏ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
                return virtualRDFdata;
            }

            // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ ptree –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è hasTrig –∏ hasParentProcess
            const ptreeQuads = trigHierarchy[PTREE_GRAPH_URI]?.quads || [];

            // –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
            const processHasTrig = new Map();  // processUri -> trigUri
            const processHasParentProcess = new Map();  // processUri -> parentProcessUri
            const trigDefinesProcess = new Map();  // trigUri -> processUri
            const trigHasParentTrig = new Map();  // trigUri -> parentTrigUri

            // –ó–∞–ø–æ–ª–Ω—è–µ–º –∫–∞—Ä—Ç—É hasTrig –∏–∑ ptree
            ptreeQuads.forEach(quad => {
                const predicateLabel = getPrefixedName(quad.predicate.value, currentPrefixes);
                if (predicateLabel === 'vad:hasTrig' || quad.predicate.value === 'http://example.org/vad#hasTrig') {
                    processHasTrig.set(quad.subject.value, quad.object.value);
                }
                if (predicateLabel === 'vad:hasParentProcess' || quad.predicate.value === 'http://example.org/vad#hasParentProcess') {
                    processHasParentProcess.set(quad.subject.value, quad.object.value);
                }
            });

            // –ó–∞–ø–æ–ª–Ω—è–µ–º –∫–∞—Ä—Ç—ã definesProcess –∏ hasParentTrig –¥–ª—è –∫–∞–∂–¥–æ–≥–æ TriG
            Object.entries(trigHierarchy).forEach(([trigUri, graphInfo]) => {
                if (trigUri === PTREE_GRAPH_URI || trigUri === RTREE_GRAPH_URI) return;

                graphInfo.quads.forEach(quad => {
                    const predicateLabel = getPrefixedName(quad.predicate.value, currentPrefixes);
                    if (predicateLabel === 'vad:definesProcess' || quad.predicate.value === 'http://example.org/vad#definesProcess') {
                        trigDefinesProcess.set(trigUri, quad.object.value);
                    }
                    if (predicateLabel === 'vad:hasParentTrig' || quad.predicate.value === 'http://example.org/vad#hasParentTrig') {
                        trigHasParentTrig.set(trigUri, quad.object.value);
                    }
                });
            });

            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π TriG —Ç–∏–ø–∞ VADProcessDia
            Object.entries(trigHierarchy).forEach(([trigUri, graphInfo]) => {
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –≥—Ä–∞—Ñ—ã
                if (trigUri === PTREE_GRAPH_URI || trigUri === RTREE_GRAPH_URI) return;

                // –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å, –∫–æ—Ç–æ—Ä—ã–π –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —ç—Ç–∏–º TriG
                const definingProcess = trigDefinesProcess.get(trigUri);

                // –°–æ–∑–¥–∞–µ–º –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π TriG –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è processSubtype
                const virtualTrigId = trigUri.replace(/t_/, 'vt_');
                const virtualTrigLabel = getPrefixedName(virtualTrigId, currentPrefixes);

                virtualRDFdata[virtualTrigId] = {
                    trigUri: trigUri,
                    label: `–í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π TriG –¥–ª—è ${getPrefixedName(trigUri, currentPrefixes)}`,
                    processSubtypes: {}
                };

                // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –ø—Ä–æ—Ü–µ—Å—Å—ã –≤ —ç—Ç–æ–º TriG (–ø–æ vad:isSubprocessTrig)
                const processesInTrig = [];
                graphInfo.quads.forEach(quad => {
                    const predicateLabel = getPrefixedName(quad.predicate.value, currentPrefixes);
                    if (predicateLabel === 'vad:isSubprocessTrig' || quad.predicate.value === 'http://example.org/vad#isSubprocessTrig') {
                        processesInTrig.push(quad.subject.value);
                    }
                });

                // –í—ã—á–∏—Å–ª—è–µ–º processSubtype –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ –≤ —ç—Ç–æ–º TriG
                processesInTrig.forEach(processUri => {
                    let subtype = null;

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–º–µ–µ—Ç –ª–∏ –ø—Ä–æ—Ü–µ—Å—Å —Å–≤–æ–π TriG (–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π)
                    if (processHasTrig.has(processUri)) {
                        const childTrigUri = processHasTrig.get(processUri);
                        const childParentTrig = trigHasParentTrig.get(childTrigUri);

                        if (childParentTrig === trigUri) {
                            subtype = 'vad:DetailedChild';
                        } else {
                            subtype = 'vad:DetailedExternal';
                        }
                    }
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–º–µ–µ—Ç –ª–∏ –ø—Ä–æ—Ü–µ—Å—Å hasParentProcess (–Ω–µ–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π)
                    else if (processHasParentProcess.has(processUri)) {
                        const parentProcess = processHasParentProcess.get(processUri);
                        const parentProcessLabel = getPrefixedName(parentProcess, currentPrefixes);

                        if (parentProcessLabel === 'vad:NotDefined' || parentProcess === 'http://example.org/vad#NotDefined') {
                            subtype = 'vad:NotDefinedType';
                        } else if (parentProcess === definingProcess) {
                            subtype = 'vad:notDetailedChild';
                        } else {
                            subtype = 'vad:notDetailedExternal';
                        }
                    }
                    // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é - notDetailedChild (–µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ)
                    else {
                        subtype = 'vad:notDetailedChild';
                    }

                    virtualRDFdata[virtualTrigId].processSubtypes[processUri] = subtype;
                });
            });

            // –û–±–Ω–æ–≤–ª—è–µ–º nodeSubtypesCache –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
            updateNodeSubtypesCacheFromVirtualData();

            return virtualRDFdata;
        }

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç nodeSubtypesCache –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã—Ö virtualRDFdata
         * –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–µ –ø–æ–¥—Ç–∏–ø—ã
         */
        function updateNodeSubtypesCacheFromVirtualData() {
            Object.values(virtualRDFdata).forEach(vTrig => {
                Object.entries(vTrig.processSubtypes).forEach(([processUri, subtype]) => {
                    if (!nodeSubtypesCache[processUri]) {
                        nodeSubtypesCache[processUri] = [];
                    }

                    const fullSubtypeUri = subtype.replace('vad:', 'http://example.org/vad#');

                    if (!nodeSubtypesCache[processUri].includes(subtype)) {
                        nodeSubtypesCache[processUri].push(subtype);
                    }
                    if (!nodeSubtypesCache[processUri].includes(fullSubtypeUri)) {
                        nodeSubtypesCache[processUri].push(fullSubtypeUri);
                    }
                });
            });
        }

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞ (processSubtype) –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
         * @param {string} nodeUri - URI —É–∑–ª–∞
         * @returns {Array} - –º–∞—Å—Å–∏–≤ –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã—Ö —Å–≤–æ–π—Å—Ç–≤ [{predicate, value}]
         */
        function getComputedPropertiesForNode(nodeUri) {
            const computed = [];

            // –ò—â–µ–º processSubtype –≤ virtualRDFdata
            Object.values(virtualRDFdata).forEach(vTrig => {
                if (vTrig.processSubtypes[nodeUri]) {
                    computed.push({
                        predicate: 'vad:processSubtype',
                        predicateLabel: 'vad:processSubtype',
                        value: vTrig.processSubtypes[nodeUri],
                        valueLabel: vTrig.processSubtypes[nodeUri],
                        source: 'virtualRDFdata'
                    });
                }
            });

            return computed;
        }

        /**
         * –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç virtualRDFdata –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –æ–∫–Ω–µ
         * –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏ "virtualRDFdata"
         */
        function showVirtualRDFData() {
            // –í—ã—á–∏—Å–ª—è–µ–º virtualRDFdata, –µ—Å–ª–∏ –µ—â–µ –Ω–µ –≤—ã—á–∏—Å–ª–µ–Ω—ã
            if (!trigHierarchy || Object.keys(trigHierarchy).length === 0) {
                // –ù—É–∂–Ω–æ —Å–Ω–∞—á–∞–ª–∞ —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å RDF –¥–∞–Ω–Ω—ã–µ
                const rdfInput = document.getElementById('rdf-input');
                if (!rdfInput || !rdfInput.value.trim()) {
                    alert('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞. –í–≤–µ–¥–∏—Ç–µ RDF –¥–∞–Ω–Ω—ã–µ –∏ –Ω–∞–∂–º–∏—Ç–µ "–ü–æ–∫–∞–∑–∞—Ç—å" –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏.');
                    return;
                }

                // –ü–∞—Ä—Å–∏–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è trigHierarchy
                const parser = new N3.Parser({ format: 'trig' });
                const quads = [];
                let prefixes = {};

                try {
                    parser.parse(rdfInput.value, (error, quad, parsedPrefixes) => {
                        if (error) {
                            alert(`–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ RDF: ${error.message}`);
                            return;
                        }
                        if (quad) {
                            quads.push(quad);
                        } else {
                            if (parsedPrefixes) {
                                prefixes = parsedPrefixes;
                            }

                            currentPrefixes = prefixes;
                            currentQuads = quads;

                            const hierarchyResult = parseTriGHierarchy(quads, prefixes);
                            if (hierarchyResult.valid) {
                                trigHierarchy = hierarchyResult.hierarchy;
                                computeVirtualRDFdata();
                                displayVirtualRDFDataWindow();
                            } else {
                                alert('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –∏–µ—Ä–∞—Ä—Ö–∏–∏ TriG. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã.');
                            }
                        }
                    });
                } catch (error) {
                    alert(`–û—à–∏–±–∫–∞: ${error.message}`);
                }
            } else {
                computeVirtualRDFdata();
                displayVirtualRDFDataWindow();
            }
        }

        /**
         * –û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç virtualRDFdata –≤ –Ω–æ–≤–æ–º –æ–∫–Ω–µ –±—Ä–∞—É–∑–µ—Ä–∞
         */
        function displayVirtualRDFDataWindow() {
            // –§–æ—Ä–º–∏—Ä—É–µ–º TriG —Ñ–æ—Ä–º–∞—Ç –¥–ª—è virtualRDFdata
            let trigContent = '# virtualRDFdata - –≤—ã—á–∏—Å–ª—è–µ–º—ã–µ RDF –¥–∞–Ω–Ω—ã–µ\n';
            trigContent += '# –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ RDF –¥–∞–Ω–Ω—ã—Ö\n';
            trigContent += '#\n';
            trigContent += '# –°–æ–¥–µ—Ä–∂–∏—Ç –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–µ vad:processSubtype –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ –≤ –∫–∞–∂–¥–æ–π —Å—Ö–µ–º–µ\n';
            trigContent += '#\n';
            trigContent += '# –ü–æ–¥—Ç–∏–ø—ã –ø—Ä–æ—Ü–µ—Å—Å–æ–≤:\n';
            trigContent += '# - vad:DetailedChild (–≥–æ–ª—É–±–æ–π): –ø—Ä–æ—Ü–µ—Å—Å —Å vad:hasTrig, –¥–æ—á–µ—Ä–Ω–∏–π TriG —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–µ–∫—É—â–∏–π\n';
            trigContent += '# - vad:DetailedExternal (–æ—Ä–∞–Ω–∂–µ–≤—ã–π): –ø—Ä–æ—Ü–µ—Å—Å —Å vad:hasTrig, –¥–æ—á–µ—Ä–Ω–∏–π TriG –ù–ï —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–µ–∫—É—â–∏–π\n';
            trigContent += '# - vad:notDetailedChild (–∑–µ–ª—ë–Ω—ã–π): –ø—Ä–æ—Ü–µ—Å—Å —Å vad:hasParentProcess, —Å–æ–≤–ø–∞–¥–∞—é—â–∏–º —Å —Ä–æ–¥–∏—Ç–µ–ª–µ–º —Å—Ö–µ–º—ã\n';
            trigContent += '# - vad:notDetailedExternal (—Å–µ—Ä—ã–π): –ø—Ä–æ—Ü–µ—Å—Å —Å vad:hasParentProcess, –ù–ï —Å–æ–≤–ø–∞–¥–∞—é—â–∏–º —Å —Ä–æ–¥–∏—Ç–µ–ª–µ–º\n';
            trigContent += '# - vad:NotDefinedType (–∫—Ä–∞—Å–Ω–æ–≤–∞—Ç—ã–π): –ø—Ä–æ—Ü–µ—Å—Å —Å vad:hasParentProcess = vad:NotDefined\n\n';

            trigContent += '@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n';
            trigContent += '@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n';
            trigContent += '@prefix vad: <http://example.org/vad#> .\n\n';

            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ TriG
            Object.entries(virtualRDFdata).forEach(([vTrigId, vTrigData]) => {
                const vTrigLabel = getPrefixedName(vTrigId, currentPrefixes);
                const originalTrigLabel = getPrefixedName(vTrigData.trigUri, currentPrefixes);

                trigContent += `# ============================================================================\n`;
                trigContent += `# ${vTrigLabel} - –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞ –¥–ª—è ${originalTrigLabel}\n`;
                trigContent += `# ============================================================================\n\n`;

                trigContent += `${vTrigLabel} {\n`;

                // –î–æ–±–∞–≤–ª—è–µ–º processSubtype –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
                Object.entries(vTrigData.processSubtypes).forEach(([processUri, subtype]) => {
                    const processLabel = getPrefixedName(processUri, currentPrefixes);
                    trigContent += `    ${processLabel} vad:processSubtype ${subtype} .\n`;
                });

                trigContent += '}\n\n';
            });

            // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ –æ–∫–Ω–æ
            const newWindow = window.open('', '_blank', 'width=900,height=700,scrollbars=yes,resizable=yes');

            if (newWindow) {
                const htmlContent = '<!DOCTYPE html>' +
                    '<html><head><title>virtualRDFdata</title>' +
                    '<style>' +
                    'body { font-family: Consolas, Monaco, monospace; padding: 20px; background-color: #f5f5f5; margin: 0; }' +
                    '.container { background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }' +
                    'h1 { color: #333; font-size: 18px; margin-top: 0; border-bottom: 2px solid #9C27B0; padding-bottom: 10px; }' +
                    'pre { white-space: pre-wrap; word-wrap: break-word; font-size: 13px; line-height: 1.5; margin: 0; color: #333; }' +
                    '.copy-btn { background-color: #9C27B0; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 10px; margin-bottom: 15px; }' +
                    '.copy-btn:hover { background-color: #7B1FA2; }' +
                    '.save-btn { background-color: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-bottom: 15px; }' +
                    '.save-btn:hover { background-color: #45a049; }' +
                    '.comment { color: #6a9955; }' +
                    '.keyword { color: #0000ff; }' +
                    '.uri { color: #795E26; }' +
                    '</style></head>' +
                    '<body><div class="container">' +
                    '<h1>virtualRDFdata - –í—ã—á–∏—Å–ª—è–µ–º—ã–µ RDF –¥–∞–Ω–Ω—ã–µ</h1>' +
                    '<button class="copy-btn" id="copy-btn">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤ –±—É—Ñ–µ—Ä</button>' +
                    '<button class="save-btn" id="save-btn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫ —Ñ–∞–π–ª</button>' +
                    '<pre id="trig-content"></pre>' +
                    '</div></body></html>';

                newWindow.document.write(htmlContent);
                newWindow.document.close();

                // –ó–∞–ø–æ–ª–Ω—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
                const preElement = newWindow.document.getElementById('trig-content');
                if (preElement) {
                    preElement.textContent = trigContent;
                }

                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
                const copyBtn = newWindow.document.getElementById('copy-btn');
                if (copyBtn) {
                    copyBtn.onclick = function() {
                        newWindow.navigator.clipboard.writeText(trigContent).then(function() {
                            newWindow.alert('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞');
                        }).catch(function() {
                            const textarea = newWindow.document.createElement('textarea');
                            textarea.value = trigContent;
                            newWindow.document.body.appendChild(textarea);
                            textarea.select();
                            newWindow.document.execCommand('copy');
                            newWindow.document.body.removeChild(textarea);
                            newWindow.alert('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞');
                        });
                    };
                }

                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
                const saveBtn = newWindow.document.getElementById('save-btn');
                if (saveBtn) {
                    saveBtn.onclick = function() {
                        const blob = new Blob([trigContent], { type: 'text/turtle' });
                        const url = URL.createObjectURL(blob);
                        const a = newWindow.document.createElement('a');
                        a.href = url;
                        a.download = 'virtualRDFdata.ttl';
                        newWindow.document.body.appendChild(a);
                        a.click();
                        newWindow.document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    };
                }
            }
        }

        // ============================================================================
        // –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–ë–û–¢–´ –° URI
        // ============================================================================

        function getLocalName(uri) {
            if (typeof uri !== 'string') return String(uri);
            const hashIndex = uri.lastIndexOf('#');
            const slashIndex = uri.lastIndexOf('/');
            const splitIndex = Math.max(hashIndex, slashIndex);
            if (splitIndex !== -1 && splitIndex < uri.length - 1) {
                return uri.substring(splitIndex + 1);
            }
            return uri;
        }

        function getPrefixedName(uri, prefixes) {
            if (typeof uri !== 'string') return String(uri);
            for (const [prefix, namespace] of Object.entries(prefixes)) {
                if (uri.startsWith(namespace)) {
                    const localName = uri.substring(namespace.length);
                    return prefix + ':' + localName;
                }
            }
            return getLocalName(uri);
        }

        function escapeDotString(str) {
            return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        }

        function generateNodeId(value) {
            let hash = 0;
            for (let i = 0; i < value.length; i++) {
                const char = value.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return 'node' + Math.abs(hash);
        }

        /**
         * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç ID —É–∑–ª–∞ –¥–ª—è VAD —Ä–µ–∂–∏–º–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ RDF –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞.
         * –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç prefixed name (–Ω–∞–ø—Ä–∏–º–µ—Ä, vad:Process1) –≤ –≤–∞–ª–∏–¥–Ω—ã–π DOT ID (vad_Process1).
         * @param {string} uri - URI —É–∑–ª–∞
         * @param {Object} prefixes - –°–ª–æ–≤–∞—Ä—å –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤
         * @returns {string} - –í–∞–ª–∏–¥–Ω—ã–π DOT ID
         */
        function generateVadNodeId(uri, prefixes) {
            const prefixedName = getPrefixedName(uri, prefixes);
            // –ó–∞–º–µ–Ω—è–µ–º ':' –Ω–∞ '_' –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤–∞–ª–∏–¥–Ω–æ–≥–æ DOT ID
            // –¢–∞–∫–∂–µ –∑–∞–º–µ–Ω—è–µ–º –¥—Ä—É–≥–∏–µ –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã –Ω–∞ '_'
            return prefixedName.replace(/[:\-\.\s]/g, '_');
        }

        function isNameOrLabelPredicate(predicateLabel) {
            const lowerPredicate = predicateLabel.toLowerCase();
            return lowerPredicate.includes('name') || lowerPredicate.includes('label');
        }

        function escapeHtmlLabel(str) {
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        /**
         * –≠–∫—Ä–∞–Ω–∏—Ä—É–µ—Ç HTML —Å–∏–º–≤–æ–ª—ã –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
         * @param {string} text - –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç
         * @returns {string} - –≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * –ö–æ–ø–∏—Ä—É–µ—Ç ID –æ–±—ä–µ–∫—Ç–∞ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞
         * @param {string} id - ID –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
         * @param {HTMLElement} button - –ö–Ω–æ–ø–∫–∞, –∫–æ—Ç–æ—Ä–∞—è –±—ã–ª–∞ –Ω–∞–∂–∞—Ç–∞
         */
        function copyObjectId(id, button) {
            navigator.clipboard.writeText(id).then(() => {
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
                const originalText = button.textContent;
                button.textContent = '–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!';
                button.classList.add('copied');

                // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è:', err);
                // Fallback –¥–ª—è —Å—Ç–∞—Ä—ã—Ö –±—Ä–∞—É–∑–µ—Ä–æ–≤
                const textArea = document.createElement('textarea');
                textArea.value = id;
                textArea.style.position = 'fixed';
                textArea.style.left = '-9999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    button.textContent = '–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!';
                    button.classList.add('copied');
                    setTimeout(() => {
                        button.textContent = '–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å';
                        button.classList.remove('copied');
                    }, 2000);
                } catch (e) {
                    console.error('Fallback copy failed:', e);
                }
                document.body.removeChild(textArea);
            });
        }

        function wrapTextByWords(text, maxLength) {
            if (!text || text.length <= maxLength) return [text];
            const words = text.split(/\s+/);
            const lines = [];
            let currentLine = '';
            for (const word of words) {
                if (currentLine.length === 0) {
                    currentLine = word;
                } else if (currentLine.length + 1 + word.length <= maxLength) {
                    currentLine += ' ' + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine.length > 0) lines.push(currentLine);
            return lines;
        }

        function formatLabelWithWrap(label, maxLength, isBold = false) {
            const lines = wrapTextByWords(label, maxLength);
            const needsWrap = lines.length > 1;
            if (!needsWrap) {
                if (isBold) return `<B>${escapeHtmlLabel(label)}</B>`;
                return escapeHtmlLabel(label);
            }
            let result = '';
            for (let i = 0; i < lines.length; i++) {
                if (i > 0) result += '<BR/>';
                const escapedLine = escapeHtmlLabel(lines[i]);
                if (isBold) {
                    result += `<FONT POINT-SIZE="9"><B>${escapedLine}</B></FONT>`;
                } else {
                    result += `<FONT POINT-SIZE="9">${escapedLine}</FONT>`;
                }
            }
            return result;
        }

        // ============================================================================
        // –ì–ï–ù–ï–†–ê–¶–ò–Ø DOT-–ö–û–î–ê
        // ============================================================================

        /**
         * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç DOT-–∫–æ–¥ –¥–ª—è —Ä–µ–∂–∏–º–∞ VAD
         * –í —ç—Ç–æ–º —Ä–µ–∂–∏–º–µ:
         * - –ü—Ä–æ—Ü–µ—Å—Å—ã –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è –∫–∞–∫ cds (chevron) —Å –∑–µ–ª–µ–Ω–æ–π –∑–∞–ª–∏–≤–∫–æ–π
         * - –ü–æ–¥ –ø—Ä–æ—Ü–µ—Å—Å–∞–º–∏ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç—Å—è –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–∏
         * - –°–≤—è–∑–∏ hasNext –∏–¥—É—Ç —Å –≤–æ—Å—Ç–æ–∫–∞ –Ω–∞ –∑–∞–ø–∞–¥
         * - hasParentTrig –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è, –Ω–æ –µ—Å—Ç—å –≤ —Å–≤–æ–π—Å—Ç–≤–∞—Ö
         */
        function rdfToDotVAD(quads, prefixes = {}) {
            buildNodeTypesCache(currentQuads, prefixes);
            nodeLabelToUri = {};

            // –°–æ–±–∏—Ä–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ—Ü–µ—Å—Å–∞—Ö –∏ –∏—Ö –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è—Ö
            const processes = new Map();  // URI –ø—Ä–æ—Ü–µ—Å—Å–∞ -> –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
            const executorGroups = new Map();  // URI –≥—Ä—É–ø–ø—ã -> —Å–ø–∏—Å–æ–∫ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π
            const hasNextEdges = [];  // –°–≤—è–∑–∏ hasNext –º–µ–∂–¥—É –ø—Ä–æ—Ü–µ—Å—Å–∞–º–∏

            // ver5t: –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏–º–µ–Ω–æ–≤–∞–Ω–Ω–æ–º –≥—Ä–∞—Ñ–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∑–∞–≥–æ–ª–æ–≤–∫–∞ —Å—Ö–µ–º—ã
            let namedGraphUri = null;
            const graphLabels = new Map();  // URI –≥—Ä–∞—Ñ–∞ -> rdfs:label

            // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ –≥—Ä–∞—Ñ—ã –∏ –∏—Ö –º–µ—Ç–∫–∏
            quads.forEach(quad => {
                // –ü–æ–ª—É—á–∞–µ–º URI –∏–º–µ–Ω–æ–≤–∞–Ω–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
                if (quad.graph && quad.graph.value && quad.graph.value !== '') {
                    if (!namedGraphUri) {
                        namedGraphUri = quad.graph.value;  // –ë–µ—Ä—ë–º –ø–µ—Ä–≤—ã–π –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–π –≥—Ä–∞—Ñ
                    }
                }
            });

            // –ò—â–µ–º rdfs:label –¥–ª—è –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã—Ö –≥—Ä–∞—Ñ–æ–≤ (–æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –≤–Ω–µ –≥—Ä–∞—Ñ–∞)
            quads.forEach(quad => {
                const subjectUri = quad.subject.value;
                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, prefixes);

                if (predicateLabel === 'rdfs:label' || predicateUri === 'http://www.w3.org/2000/01/rdf-schema#label') {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ subject –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–º –≥—Ä–∞—Ñ–æ–º
                    if (subjectUri === namedGraphUri) {
                        graphLabels.set(subjectUri, quad.object.value);
                    }
                }
            });

            // –ü–µ—Ä–≤—ã–π –ø—Ä–æ—Ö–æ–¥: —Å–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã
            quads.forEach(quad => {
                const subjectUri = quad.subject.value;
                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, prefixes);
                const objectValue = quad.object.value;

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø—ã
                const subjectTypes = nodeTypesCache[subjectUri] || [];
                const isProcess = subjectTypes.some(t =>
                    t === 'vad:TypeProcess' || t === 'http://example.org/vad#TypeProcess'
                );

                if (isProcess) {
                    if (!processes.has(subjectUri)) {
                        processes.set(subjectUri, {
                            uri: subjectUri,
                            label: getPrefixedName(subjectUri, prefixes),
                            name: null,
                            executorGroup: null,
                            hasNext: [],
                            hasParent: null
                        });
                    }

                    const processInfo = processes.get(subjectUri);

                    // –°–æ–±–∏—Ä–∞–µ–º rdfs:label –¥–ª—è –∏–º–µ–Ω–∏
                    if (predicateLabel === 'rdfs:label' || predicateUri === 'http://www.w3.org/2000/01/rdf-schema#label') {
                        processInfo.name = objectValue;
                    }

                    // –°–æ–±–∏—Ä–∞–µ–º hasExecutor
                    if (predicateLabel === 'vad:hasExecutor' || predicateUri === 'http://example.org/vad#hasExecutor') {
                        processInfo.executorGroup = objectValue;
                    }

                    // –°–æ–±–∏—Ä–∞–µ–º hasNext
                    if (predicateLabel === 'vad:hasNext' || predicateUri === 'http://example.org/vad#hasNext') {
                        processInfo.hasNext.push(objectValue);
                        hasNextEdges.push({ from: subjectUri, to: objectValue });
                    }

                    // –°–æ–±–∏—Ä–∞–µ–º hasParent
                    if (predicateLabel === 'vad:hasParentTrig' || predicateUri === 'http://example.org/vad#hasParentTrig') {
                        processInfo.hasParent = objectValue;
                    }
                }

                // –°–æ–±–∏—Ä–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≥—Ä—É–ø–ø–∞—Ö –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π
                const isExecutorGroup = subjectTypes.some(t =>
                    t === 'vad:ExecutorGroup' || t === 'http://example.org/vad#ExecutorGroup'
                );

                if (isExecutorGroup) {
                    if (!executorGroups.has(subjectUri)) {
                        executorGroups.set(subjectUri, {
                            uri: subjectUri,
                            label: null,
                            executors: []
                        });
                    }

                    const groupInfo = executorGroups.get(subjectUri);

                    if (predicateLabel === 'rdfs:label' || predicateUri === 'http://www.w3.org/2000/01/rdf-schema#label') {
                        groupInfo.label = objectValue;
                    }

                    if (predicateLabel === 'vad:includes' || predicateUri === 'http://example.org/vad#includes') {
                        groupInfo.executors.push(objectValue);
                    }
                }
            });

            // –î–æ–ø–æ–ª–Ω—è–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –∏–∑ vad:ptree (–µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ —Ç–µ–∫—É—â–µ–º TriG)
            processes.forEach((processInfo, processUri) => {
                if (!processInfo.name) {
                    const ptreeMetadata = getProcessMetadataFromPtree(processUri, prefixes);
                    if (ptreeMetadata.label) {
                        processInfo.name = ptreeMetadata.label;
                    }
                }
            });

            // –°–æ–±–∏—Ä–∞–µ–º –∏–º–µ–Ω–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π
            // –°–Ω–∞—á–∞–ª–∞ –∏–∑ —Ç–µ–∫—É—â–∏—Ö quads (–µ—Å–ª–∏ rdfs:label –µ—Å—Ç—å –≤ —ç—Ç–æ–º –≥—Ä–∞—Ñ–µ)
            const executorNames = new Map();
            quads.forEach(quad => {
                const subjectUri = quad.subject.value;
                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, prefixes);
                const objectValue = quad.object.value;

                const subjectTypes = nodeTypesCache[subjectUri] || [];
                const isExecutor = subjectTypes.some(t =>
                    t === 'vad:TypeExecutor' || t === 'http://example.org/vad#TypeExecutor'
                );

                if (isExecutor && (predicateLabel === 'rdfs:label' || predicateUri === 'http://www.w3.org/2000/01/rdf-schema#label')) {
                    executorNames.set(subjectUri, objectValue);
                }
            });

            // –î–æ–ø–æ–ª–Ω—è–µ–º –∏–º–µ–Ω–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –∏–∑ vad:rtree (–µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ —Ç–µ–∫—É—â–µ–º TriG)
            executorGroups.forEach((groupInfo, groupUri) => {
                groupInfo.executors.forEach(executorUri => {
                    if (!executorNames.has(executorUri)) {
                        const nameFromRtree = getExecutorNameFromRtree(executorUri, prefixes);
                        if (nameFromRtree) {
                            executorNames.set(executorUri, nameFromRtree);
                        }
                    }
                });
            });

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è DOT-–∫–æ–¥–∞
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º rankdir=TB —á—Ç–æ–±—ã rank=same –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–ª —É–∑–ª—ã –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ
            // –ê –ø—Ä–æ—Ü–µ—Å—Å—ã –∏–¥—É—Ç –≤ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ –±–ª–∞–≥–æ–¥–∞—Ä—è rank=same
            let dot = 'digraph VADGraph {\n';
            dot += '    // VAD (Value Added Chain Diagram)\n';
            dot += '    rankdir=TB;\n';  // Top-to-bottom –ø–æ–∑–≤–æ–ª—è–µ—Ç –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ —á–µ—Ä–µ–∑ rank=same
            dot += '    node [fontname="Arial"];\n';
            dot += '    edge [fontname="Arial", fontsize=10];\n';
            dot += '    splines=spline;\n';  // spline –¥–ª—è –ª—É—á—à–µ–π –º–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ü–∏–∏ skip-—Ä–µ–±–µ—Ä
            dot += '    nodesep=0.8;\n';  // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —É–∑–ª–∞–º–∏
            dot += '    ranksep=0.3;\n';  // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —Ä–∞–Ω–≥–∞–º–∏ (CDS –∏ ExecutorGroup)

            // ver5t: –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å—Ö–µ–º—ã –∏–∑ –∏–º–µ–Ω–æ–≤–∞–Ω–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
            // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º graphLabels (–¥–ª—è –æ–±—ã—á–Ω–æ–≥–æ VAD —Ä–µ–∂–∏–º–∞)
            // –ó–∞—Ç–µ–º –ø—Ä–æ–≤–µ—Ä—è–µ–º trigHierarchy (–¥–ª—è VAD TriG —Ä–µ–∂–∏–º–∞)
            let schemaTitle = null;
            if (namedGraphUri && graphLabels.has(namedGraphUri)) {
                schemaTitle = graphLabels.get(namedGraphUri);
            } else if (namedGraphUri && trigHierarchy && trigHierarchy[namedGraphUri] && trigHierarchy[namedGraphUri].label) {
                schemaTitle = trigHierarchy[namedGraphUri].label;
            }
            if (schemaTitle) {
                dot += `    label="${escapeDotString(schemaTitle)}";\n`;
                dot += '    labelloc="t";\n';  // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –≤–≤–µ—Ä—Ö—É
                dot += '    fontname="Arial";\n';
                dot += '    fontsize=16;\n';
            }
            dot += '\n';

            // –§–∏–ª—å—Ç—Ä—É–µ–º –ø—Ä–æ—Ü–µ—Å—Å—ã - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —è–≤–ª—è—é—Ç—Å—è –º–∞—Ç–µ—Ä–∏–Ω—Å–∫–∏–º–∏
            // (Process0 —Å–∫—Ä—ã—Ç, –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–Ω –Ω–µ –∏–º–µ–µ—Ç hasNext –∏ —è–≤–ª—è–µ—Ç—Å—è —Ä–æ–¥–∏—Ç–µ–ª–µ–º)
            const visibleProcesses = new Map();
            processes.forEach((processInfo, uri) => {
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å, –µ—Å–ª–∏ –æ–Ω –∏–º–µ–µ—Ç hasNext –∏–ª–∏ –Ω–∞ –Ω–µ–≥–æ —Å—Å—ã–ª–∞–µ—Ç—Å—è hasNext
                const hasOutgoingNext = processInfo.hasNext.length > 0;
                const hasIncomingNext = [...processes.values()].some(p => p.hasNext.includes(uri));

                if (hasOutgoingNext || hasIncomingNext) {
                    visibleProcesses.set(uri, processInfo);
                }
            });

            // –°—Ç—Ä–æ–∏–º –ø–æ—Ä—è–¥–æ–∫ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è skip-—Ä–µ–±–µ—Ä (—Ä–µ–±–µ—Ä, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–æ–ø—É—Å–∫–∞—é—Ç –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —É–∑–ª—ã)
            // –¢–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –ø–æ hasNext –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∏—Ö –ø–æ—Ä—è–¥–∫–∞
            const processOrder = [];
            const visited = new Set();
            const processUris = [...visibleProcesses.keys()];

            // –ù–∞–π—Ç–∏ –Ω–∞—á–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å (–ø—Ä–æ—Ü–µ—Å—Å –±–µ–∑ –≤—Ö–æ–¥—è—â–∏—Ö hasNext)
            const incomingCount = new Map();
            processUris.forEach(uri => incomingCount.set(uri, 0));
            hasNextEdges.forEach(edge => {
                if (visibleProcesses.has(edge.to)) {
                    incomingCount.set(edge.to, (incomingCount.get(edge.to) || 0) + 1);
                }
            });

            // –¢–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ (BFS)
            const queue = [];
            processUris.forEach(uri => {
                if (incomingCount.get(uri) === 0) {
                    queue.push(uri);
                }
            });

            while (queue.length > 0) {
                const uri = queue.shift();
                if (!visited.has(uri)) {
                    visited.add(uri);
                    processOrder.push(uri);
                    const processInfo = visibleProcesses.get(uri);
                    if (processInfo) {
                        processInfo.hasNext.forEach(nextUri => {
                            if (visibleProcesses.has(nextUri)) {
                                const count = incomingCount.get(nextUri) - 1;
                                incomingCount.set(nextUri, count);
                                if (count === 0 && !visited.has(nextUri)) {
                                    queue.push(nextUri);
                                }
                            }
                        });
                    }
                }
            }

            // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –ø—Ä–æ—Ü–µ—Å—Å—ã (–Ω–∞ —Å–ª—É—á–∞–π —Ü–∏–∫–ª–æ–≤ –∏–ª–∏ –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö)
            processUris.forEach(uri => {
                if (!visited.has(uri)) {
                    processOrder.push(uri);
                }
            });

            // –°–æ–∑–¥–∞–µ–º –∏–Ω–¥–µ–∫—Å –ø–æ–∑–∏—Ü–∏–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è skip-—Ä–µ–±–µ—Ä
            const processPositionIndex = new Map();
            processOrder.forEach((uri, index) => {
                processPositionIndex.set(uri, index);
            });

            // –î–æ–±–∞–≤–ª—è–µ–º —É–∑–ª—ã –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ (CDS) –∏ ExecutorGroup –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —É–∑–ª—ã
            dot += '    // –ü—Ä–æ—Ü–µ—Å—Å—ã VAD (cds shape) –∏ ExecutorGroup (ellipse –∂–µ–ª—Ç—ã–π)\n';

            // –°–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ —É–∑–ª—ã CDS
            visibleProcesses.forEach((processInfo, uri) => {
                const nodeId = generateVadNodeId(uri, prefixes);
                const processName = processInfo.name || processInfo.label;

                // –§–æ—Ä–º–∏—Ä—É–µ–º HTML label —Å –∏–º–µ–Ω–µ–º –ø—Ä–æ—Ü–µ—Å—Å–∞ (–ë–ï–ó –∂–∏—Ä–Ω–æ–≥–æ —à—Ä–∏—Ñ—Ç–∞)
                const wrappedProcessName = wrapTextByWords(processName, currentMaxLabelLength);

                let htmlLabel = '<';
                for (let i = 0; i < wrappedProcessName.length; i++) {
                    if (i > 0) htmlLabel += '<BR/>';
                    htmlLabel += escapeHtmlLabel(wrappedProcessName[i]);
                }
                htmlLabel += '>';

                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∏–ª—å —É–∑–ª–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ vad:processSubtype
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º nodeSubtypesCache –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–∏–ø–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞
                // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –ø–æ–¥—Ç–∏–ø—ã:
                // - DetailedChild (–≥–æ–ª—É–±–æ–π) - –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–¥–ø—Ä–æ—Ü–µ—Å—Å —Ç–µ–∫—É—â–µ–π —Å—Ö–µ–º—ã
                // - DetailedExternal (–æ—Ä–∞–Ω–∂–µ–≤—ã–π) - –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤–Ω–µ—à–Ω–∏–π –ø—Ä–æ—Ü–µ—Å—Å
                // - notDetailedChild (–∑–µ–ª–µ–Ω—ã–π) - –Ω–µ–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–¥–ø—Ä–æ—Ü–µ—Å—Å
                // - notDetailedExternal (—Å–µ—Ä—ã–π) - –Ω–µ–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤–Ω–µ—à–Ω–∏–π –ø—Ä–æ—Ü–µ—Å—Å
                // - NotDefinedType (–∫—Ä–∞—Å–Ω–æ–≤–∞—Ç—ã–π) - —Ç–∏–ø –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω
                const nodeSubtypes = nodeSubtypesCache[uri] || [];

                // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∏–ª—å –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–¥—Ç–∏–ø–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é)
                const nodeStyle = getProcessStyleForSubtype(nodeSubtypes);
                dot += `    ${nodeId} [label=${htmlLabel} ${nodeStyle}];\n`;

                nodeLabelToUri[processInfo.label] = { uri: uri, dotId: nodeId };
            });

            dot += '\n';

            // –î–æ–±–∞–≤–ª—è–µ–º ExecutorGroup —É–∑–ª—ã (–∂–µ–ª—Ç—ã–µ —ç–ª–ª–∏–ø—Å—ã)
            // ExecutorGroup –æ–±—ä–µ–∫—Ç—ã —Ç–µ–ø–µ—Ä—å –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—ã –∏ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç —Å–≤–æ–π—Å—Ç–≤–∞
            dot += '    // ExecutorGroup —É–∑–ª—ã (—ç–ª–ª–∏–ø—Å—ã —Å –∂–µ–ª—Ç–æ–≤–∞—Ç–æ–π –∑–∞–ª–∏–≤–∫–æ–π)\n';
            visibleProcesses.forEach((processInfo, uri) => {
                const nodeId = generateVadNodeId(uri, prefixes);

                // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π
                let executorsList = '';
                let executorGroupUri = null;
                if (processInfo.executorGroup && executorGroups.has(processInfo.executorGroup)) {
                    executorGroupUri = processInfo.executorGroup;
                    const group = executorGroups.get(processInfo.executorGroup);
                    const executorNamesList = group.executors.map(exUri =>
                        executorNames.get(exUri) || getPrefixedName(exUri, prefixes)
                    );
                    executorsList = executorNamesList.join(', ');
                }

                if (executorsList && executorGroupUri) {
                    const executorNodeId = `${nodeId}_exec`;
                    const wrappedExecutors = wrapTextByWords(executorsList, currentMaxLabelLength);

                    let execLabel = '<<FONT POINT-SIZE="9">';
                    for (let i = 0; i < wrappedExecutors.length; i++) {
                        if (i > 0) execLabel += '<BR/>';
                        execLabel += escapeHtmlLabel(wrappedExecutors[i]);
                    }
                    execLabel += '</FONT>>';

                    // ExecutorGroup –∫–∞–∫ —ç–ª–ª–∏–ø—Å —Å –∂–µ–ª—Ç–æ–≤–∞—Ç–æ–π –∑–∞–ª–∏–≤–∫–æ–π
                    dot += `    ${executorNodeId} [label=${execLabel} shape="ellipse" color="#B8860B" fillcolor="#FFFFCC" fontname="Arial" style="filled"];\n`;

                    // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º ExecutorGroup –¥–ª—è –∫–ª–∏–∫–∞–±–µ–ª—å–Ω–æ—Å—Ç–∏ (–ø–æ–∫–∞–∑ —Å–≤–æ–π—Å—Ç–≤ –æ–±—ä–µ–∫—Ç–∞)
                    const executorGroupLabel = getPrefixedName(executorGroupUri, prefixes);
                    nodeLabelToUri[executorGroupLabel] = { uri: executorGroupUri, dotId: executorNodeId };
                }
            });

            dot += '\n';

            // –°–æ–±–∏—Ä–∞–µ–º ID —É–∑–ª–æ–≤ –¥–ª—è rank constraints, –∏—Å–ø–æ–ª—å–∑—É—è –ø–æ—Ä—è–¥–æ–∫ –∏–∑ topological sort
            const cdsNodeIds = [];
            const execNodeIds = [];
            const nodeIdToUri = new Map();  // –û–±—Ä–∞—Ç–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞

            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
            processOrder.forEach(uri => {
                if (visibleProcesses.has(uri)) {
                    const processInfo = visibleProcesses.get(uri);
                    const nodeId = generateVadNodeId(uri, prefixes);
                    cdsNodeIds.push(nodeId);
                    nodeIdToUri.set(nodeId, uri);

                    if (processInfo.executorGroup && executorGroups.has(processInfo.executorGroup)) {
                        const group = executorGroups.get(processInfo.executorGroup);
                        if (group.executors.length > 0) {
                            execNodeIds.push(`${nodeId}_exec`);
                        }
                    }
                }
            });

            // –†–∞–∑–±–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å—ã –Ω–∞ —Å—Ç—Ä–æ–∫–∏ –ø–æ currentMaxVadRowLength
            const rows = [];
            for (let i = 0; i < cdsNodeIds.length; i += currentMaxVadRowLength) {
                rows.push(cdsNodeIds.slice(i, i + currentMaxVadRowLength));
            }

            // –°–æ–±–∏—Ä–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ execNodeIds –¥–ª—è –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–∏
            // –í–∞–∂–Ω–æ: execNodeIds –¥–æ–ª–∂–Ω—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –ø–æ–∑–∏—Ü–∏—è–º cdsNodeIds
            const execRows = [];
            rows.forEach((rowCdsIds, rowIndex) => {
                const rowExecIds = [];
                rowCdsIds.forEach(cdsId => {
                    const execId = `${cdsId}_exec`;
                    if (execNodeIds.includes(execId)) {
                        rowExecIds.push(execId);
                    }
                });
                execRows.push(rowExecIds);
            });

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è rank constraints –¥–ª—è –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–∏
            dot += '    // Rank constraints –¥–ª—è CDS —Å—Ç—Ä–æ–∫ –∏ ExecutorGroup —Å—Ç—Ä–æ–∫\n';
            rows.forEach((rowCdsIds, rowIndex) => {
                // CDS —Å—Ç—Ä–æ–∫–∞
                dot += `    { rank=same; ${rowCdsIds.join('; ')}; }\n`;
            });

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è rank constraints –¥–ª—è ExecutorGroup —Å—Ç—Ä–æ–∫
            execRows.forEach((rowExecIds, rowIndex) => {
                if (rowExecIds.length > 0) {
                    dot += `    { rank=same; ${rowExecIds.join('; ')}; }\n`;
                }
            });

            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–≤–∏–¥–∏–º—ã–µ —Ä–µ–±—Ä–∞ –º–µ–∂–¥—É —Å—Ç—Ä–æ–∫–∞–º–∏ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è —Ä—è–¥–æ–≤
            // –≠—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã Graphviz —Ä–∞–∑–º–µ—Å—Ç–∏–ª —Å—Ç—Ä–æ–∫–∏ –æ–¥–Ω—É –ø–æ–¥ –¥—Ä—É–≥–æ–π
            // FIX issue #60: –°–≤—è–∑—ã–≤–∞–µ–º –ü–ï–†–í–´–ô CDS —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–æ–∫–∏ —Å –ü–ï–†–í–´–ú CDS —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–æ–∫–∏
            // –¥–ª—è –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è –≤—Å–µ—Ö —Å—Ç—Ä–æ–∫ –ø–æ –ª–µ–≤–æ–º—É –∫—Ä–∞—é (–∫–∞–∫ —Ç—Ä–µ–±—É–µ—Ç—Å—è –≤ issue #60)
            dot += '\n    // –ù–µ–≤–∏–¥–∏–º—ã–µ —Ä–µ–±—Ä–∞ –º–µ–∂–¥—É —Å—Ç—Ä–æ–∫–∞–º–∏ –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è —Ä—è–¥–æ–≤ –∏ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è –ø–æ –ª–µ–≤–æ–º—É –∫—Ä–∞—é\n';
            for (let rowIndex = 0; rowIndex < rows.length - 1; rowIndex++) {
                const currentRowCdsIds = rows[rowIndex];
                const nextRowCdsIds = rows[rowIndex + 1];

                if (currentRowCdsIds.length > 0 && nextRowCdsIds.length > 0) {
                    // –°–≤—è–∑—ã–≤–∞–µ–º –ü–ï–†–í–´–ô CDS —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–æ–∫–∏ —Å –ü–ï–†–í–´–ú CDS —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–æ–∫–∏
                    // –≠—Ç–æ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç –≤—Å–µ —Å—Ç—Ä–æ–∫–∏ –ø–æ –ª–µ–≤–æ–º—É –∫—Ä–∞—é (issue #60)
                    const firstCurrentCdsId = currentRowCdsIds[0];
                    const firstNextCdsId = nextRowCdsIds[0];
                    dot += `    ${firstCurrentCdsId} -> ${firstNextCdsId} [style=invis weight=100 minlen=2];\n`;
                }
            }
            dot += '\n';

            // –î–æ–±–∞–≤–ª—è–µ–º –≤–∏–¥–∏–º—ã–µ —Å–≤—è–∑–∏ vad:hasExecutor –º–µ–∂–¥—É CDS –∏ ExecutorGroup
            dot += '    // –°–≤—è–∑–∏ vad:hasExecutor - –≤–∏–¥–∏–º—ã–µ —Ä–µ–±—Ä–∞ –æ—Ç –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –∫ –≥—Ä—É–ø–ø–∞–º –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π\n';
            visibleProcesses.forEach((processInfo, uri) => {
                const nodeId = generateVadNodeId(uri, prefixes);

                let hasExecutorGroup = false;
                if (processInfo.executorGroup && executorGroups.has(processInfo.executorGroup)) {
                    const group = executorGroups.get(processInfo.executorGroup);
                    hasExecutorGroup = group.executors.length > 0;
                }

                if (hasExecutorGroup) {
                    const executorNodeId = `${nodeId}_exec`;
                    // –í–∏–¥–∏–º–∞—è —Å–≤—è–∑—å vad:hasExecutor (—Å–∏–Ω—è—è –ø—É–Ω–∫—Ç–∏—Ä–Ω–∞—è, –Ω–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è)
                    dot += `    ${nodeId} -> ${executorNodeId} [color="#1565C0" penwidth="1" style="dashed" arrowhead="none" weight=10];\n`;
                }
            });

            dot += '\n';

            // –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–±—Ä–∞ hasNext –º–µ–∂–¥—É –ø—Ä–æ—Ü–µ—Å—Å–∞–º–∏
            // –í—Å–µ —Ä–µ–±—Ä–∞ hasNext –∏—Å–ø–æ–ª—å–∑—É—é—Ç –ø–æ—Ä—Ç—ã East -> West (–≤—ã—Ö–æ–¥ —Å–ø—Ä–∞–≤–∞, –≤—Ö–æ–¥ —Å–ª–µ–≤–∞) —Å–æ–≥–ª–∞—Å–Ω–æ issue #58
            dot += '    // –°–≤—è–∑–∏ hasNext - –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ (East -> West)\n';

            // –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ —Ä–µ–±—Ä–∞ hasNext
            hasNextEdges.forEach(edge => {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞ –≤–∏–¥–∏–º—ã
                if (visibleProcesses.has(edge.from) && visibleProcesses.has(edge.to)) {
                    const fromId = generateVadNodeId(edge.from, prefixes);
                    const toId = generateVadNodeId(edge.to, prefixes);

                    // –í—Å–µ —Ä–µ–±—Ä–∞ hasNext –∏—Å–ø–æ–ª—å–∑—É—é—Ç –ø–æ—Ä—Ç—ã East -> West (–≤—ã—Ö–æ–¥ —Å–ø—Ä–∞–≤–∞, –≤—Ö–æ–¥ —Å–ª–µ–≤–∞)
                    // –≠—Ç–æ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –µ–¥–∏–Ω–æ–æ–±—Ä–∞–∑–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤—è–∑–µ–π —Å–æ–≥–ª–∞—Å–Ω–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º issue #58
                    dot += `    ${fromId}:e -> ${toId}:w [color="#2E7D32" penwidth="1" style="solid" arrowhead="vee"];\n`;
                }
            });

            dot += '}\n';

            return dot;
        }

        function rdfToDotAggregation(quads, prefixes = {}) {
            buildNodeTypesCache(currentQuads, prefixes);
            nodeLabelToUri = {};

            const nodes = new Map();
            const edges = [];
            const nodeLiterals = new Map();

            quads.forEach(quad => {
                const subject = quad.subject;
                const predicate = quad.predicate;
                const object = quad.object;

                const subjectValue = subject.value;
                const predicateValue = predicate.value;
                const objectValue = object.value;

                const subjectLabel = getPrefixedName(subjectValue, prefixes);
                const predicateLabel = getPrefixedName(predicateValue, prefixes);

                if (!nodes.has(subjectValue)) {
                    const nodeId = generateNodeId(subjectValue);
                    nodes.set(subjectValue, {
                        id: nodeId,
                        label: subjectLabel,
                        value: subjectValue,
                        isUri: subject.termType === 'NamedNode',
                        isBlank: subject.termType === 'BlankNode',
                        isLiteral: false
                    });
                    nodeLabelToUri[subjectLabel] = { uri: subjectValue, dotId: nodeId };
                    nodeLiterals.set(subjectValue, []);
                }

                if (object.termType === 'Literal') {
                    const literals = nodeLiterals.get(subjectValue);
                    literals.push({
                        predicate: predicateLabel,
                        value: objectValue,
                        isNameLabel: isNameOrLabelPredicate(predicateLabel)
                    });
                } else {
                    const objectLabel = getPrefixedName(objectValue, prefixes);
                    if (!nodes.has(objectValue)) {
                        const nodeId = generateNodeId(objectValue);
                        nodes.set(objectValue, {
                            id: nodeId,
                            label: objectLabel,
                            value: objectValue,
                            isUri: object.termType === 'NamedNode',
                            isLiteral: false,
                            isBlank: object.termType === 'BlankNode'
                        });
                        nodeLabelToUri[objectLabel] = { uri: objectValue, dotId: nodeId };
                        if (!nodeLiterals.has(objectValue)) {
                            nodeLiterals.set(objectValue, []);
                        }
                    }
                    edges.push({
                        from: nodes.get(subjectValue).id,
                        to: nodes.get(objectValue).id,
                        label: predicateLabel,
                        predicateUri: predicateValue
                    });
                }
            });

            let dot = 'digraph RDFGraph {\n';
            dot += '    rankdir=LR;\n';
            dot += '    node [fontname="Arial", shape="ellipse"];\n';
            dot += '    edge [fontname="Arial", fontsize=10];\n';
            dot += '\n';

            nodes.forEach((nodeInfo, value) => {
                const literals = nodeLiterals.get(value) || [];
                const nameLabelLiterals = literals.filter(l => l.isNameLabel);
                const otherLiterals = literals.filter(l => !l.isNameLabel);

                let htmlLabel = '<';
                htmlLabel += formatLabelWithWrap(nodeInfo.label, currentMaxLabelLength, true);

                let addedLines = 1;
                for (const lit of nameLabelLiterals) {
                    if (addedLines >= MaxAggregationParams) break;
                    htmlLabel += '<BR/>';
                    htmlLabel += formatLabelWithWrap(lit.value, currentMaxLabelLength, false);
                    addedLines++;
                }

                for (const lit of otherLiterals) {
                    if (addedLines >= MaxAggregationParams) break;
                    htmlLabel += '<BR/>';
                    const fullText = lit.predicate + ': ' + lit.value;
                    const wrappedLines = wrapTextByWords(fullText, currentMaxLabelLength);
                    for (let j = 0; j < wrappedLines.length; j++) {
                        if (j > 0) htmlLabel += '<BR/>';
                        htmlLabel += `<FONT POINT-SIZE="8">${escapeHtmlLabel(wrappedLines[j])}</FONT>`;
                    }
                    addedLines++;
                }

                htmlLabel += '>';

                const nodeStyle = getNodeStyle(nodeInfo.value, false, nodeInfo.isBlank);
                dot += `    ${nodeInfo.id} [label=${htmlLabel} ${nodeStyle}];\n`;
            });

            dot += '\n';

            edges.forEach(edge => {
                const edgeStyle = getEdgeStyle(edge.predicateUri, edge.label);
                dot += `    ${edge.from} -> ${edge.to} [label="${escapeDotString(edge.label)}" ${edgeStyle}];\n`;
            });

            dot += '}\n';
            return dot;
        }

        function rdfToDot(quads, prefixes = {}) {
            if (currentMode === 'aggregation') {
                return rdfToDotAggregation(quads, prefixes);
            }

            if (currentMode === 'vad') {
                return rdfToDotVAD(quads, prefixes);
            }

            buildNodeTypesCache(currentQuads, prefixes);
            nodeLabelToUri = {};

            const nodes = new Map();
            const edges = [];

            quads.forEach(quad => {
                const subject = quad.subject;
                const predicate = quad.predicate;
                const object = quad.object;

                const subjectValue = subject.value;
                const predicateValue = predicate.value;
                const objectValue = object.value;

                const subjectLabel = getPrefixedName(subjectValue, prefixes);
                const predicateLabel = getPrefixedName(predicateValue, prefixes);
                const objectLabel = object.termType === 'Literal'
                    ? `"${objectValue}"`
                    : getPrefixedName(objectValue, prefixes);

                if (!nodes.has(subjectValue)) {
                    const nodeId = generateNodeId(subjectValue);
                    nodes.set(subjectValue, {
                        id: nodeId,
                        label: subjectLabel,
                        value: subjectValue,
                        isUri: subject.termType === 'NamedNode',
                        isBlank: subject.termType === 'BlankNode',
                        isLiteral: false
                    });
                    nodeLabelToUri[subjectLabel] = { uri: subjectValue, dotId: nodeId };
                }

                if (!nodes.has(objectValue)) {
                    const nodeId = generateNodeId(objectValue);
                    nodes.set(objectValue, {
                        id: nodeId,
                        label: objectLabel,
                        value: objectValue,
                        isUri: object.termType === 'NamedNode',
                        isLiteral: object.termType === 'Literal',
                        isBlank: object.termType === 'BlankNode'
                    });
                    nodeLabelToUri[objectLabel] = { uri: objectValue, dotId: nodeId };
                }

                edges.push({
                    from: nodes.get(subjectValue).id,
                    to: nodes.get(objectValue).id,
                    label: predicateLabel,
                    predicateUri: predicateValue
                });
            });

            let dot = 'digraph RDFGraph {\n';
            dot += '    rankdir=LR;\n';
            dot += '    node [fontname="Arial"];\n';
            dot += '    edge [fontname="Arial", fontsize=10];\n';
            dot += '\n';

            nodes.forEach((nodeInfo, value) => {
                const nodeStyle = getNodeStyle(nodeInfo.value, nodeInfo.isLiteral, nodeInfo.isBlank);

                if (currentMode === 'notation' && nodeInfo.label.length > currentMaxLabelLength) {
                    const wrappedLabel = formatLabelWithWrap(nodeInfo.label, currentMaxLabelLength, false);
                    dot += `    ${nodeInfo.id} [label=<${wrappedLabel}> ${nodeStyle}];\n`;
                } else {
                    dot += `    ${nodeInfo.id} [label="${escapeDotString(nodeInfo.label)}" ${nodeStyle}];\n`;
                }
            });

            dot += '\n';

            edges.forEach(edge => {
                const edgeStyle = getEdgeStyle(edge.predicateUri, edge.label);
                dot += `    ${edge.from} -> ${edge.to} [label="${escapeDotString(edge.label)}" ${edgeStyle}];\n`;
            });

            dot += '}\n';
            return dot;
        }

        // ============================================================================
        // –§–£–ù–ö–¶–ò–ò –û–¢–û–ë–†–ê–ñ–ï–ù–ò–Ø
        // ============================================================================

        function showLoading() {
            const output = document.getElementById('output');
            const resultContainer = document.getElementById('result-container');

            resultContainer.style.display = 'block';
            output.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>–û–±—Ä–∞–±–æ—Ç–∫–∞ RDF –¥–∞–Ω–Ω—ã—Ö...</p>
                </div>
            `;

            document.getElementById('export-buttons').style.display = 'none';
            document.getElementById('zoom-controls').style.display = 'none';
            document.getElementById('prefixes-panel').style.display = 'none';
            document.getElementById('legend-panel').style.display = 'none';
            // filter-panel removed in minimization
        }

        /**
         * –£–ª—É—á—à–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –ø–∞—Ä—Å–∏–Ω–≥–∞, –¥–æ–±–∞–≤–ª—è—è —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø—Ä–æ–±–ª–µ–º–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
         * @param {string} errorMessage - –ò—Å—Ö–æ–¥–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
         * @param {string} rdfInput - –ò—Å—Ö–æ–¥–Ω—ã–µ RDF –¥–∞–Ω–Ω—ã–µ
         * @returns {string} - –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
         */
        function enhanceParseError(errorMessage, rdfInput) {
            // –ò—â–µ–º –Ω–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏ –æ–± –æ—à–∏–±–∫–µ (–ø–∞—Ç—Ç–µ—Ä–Ω "on line N" –∏–ª–∏ "line N")
            const lineMatch = errorMessage.match(/(?:on\s+)?line\s+(\d+)/i);
            if (lineMatch && rdfInput) {
                const lineNumber = parseInt(lineMatch[1], 10);
                const lines = rdfInput.split('\n');
                if (lineNumber > 0 && lineNumber <= lines.length) {
                    const problemLine = lines[lineNumber - 1];
                    return `${errorMessage}\n–°—Ç—Ä–æ–∫–∞ ${lineNumber}: ${problemLine}`;
                }
            }
            return errorMessage;
        }

        function showError(message) {
            const output = document.getElementById('output');
            const resultContainer = document.getElementById('result-container');
            const vadTrigOutput = document.getElementById('vad-trig-output');
            const vadTrigContainer = document.getElementById('vad-trig-container');

            resultContainer.style.display = 'block';
            // –ó–∞–º–µ–Ω—è–µ–º –ø–µ—Ä–µ–Ω–æ—Å—ã —Å—Ç—Ä–æ–∫ –Ω–∞ <br> –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ HTML
            const formattedMessage = message.replace(/\n/g, '<br>');
            const errorHtml = `<div class="error"><strong>–û—à–∏–±–∫–∞:</strong> ${formattedMessage}</div>`;

            // –ï—Å–ª–∏ –∞–∫—Ç–∏–≤–µ–Ω —Ä–µ–∂–∏–º VAD-TriG, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—à–∏–±–∫—É —Ç–∞–∫–∂–µ –≤ –µ–≥–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ
            const isVadTrigMode = vadTrigContainer && vadTrigContainer.style.display !== 'none';
            if (isVadTrigMode && vadTrigOutput) {
                vadTrigOutput.innerHTML = errorHtml;
            }

            // –í—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –≤ –æ—Å–Ω–æ–≤–Ω–æ–º output (–¥–ª—è –Ω–µ-VAD-TriG —Ä–µ–∂–∏–º–æ–≤ –∏–ª–∏ –ø—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏)
            output.innerHTML = errorHtml;

            // –°–∫—Ä—ã–≤–∞–µ–º VAD-TriG –ø–∞–Ω–µ–ª–∏ –ø—Ä–∏ –æ—à–∏–±–∫–µ, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π output
            toggleVADTriGPanels(false);

            document.getElementById('export-buttons').style.display = 'none';
            document.getElementById('zoom-controls').style.display = 'none';
            document.getElementById('prefixes-panel').style.display = 'none';
            document.getElementById('legend-panel').style.display = 'none';
            // filter-panel removed in minimization
        }

        function showValidationError(message) {
            const output = document.getElementById('output');
            const resultContainer = document.getElementById('result-container');
            const vadTrigOutput = document.getElementById('vad-trig-output');
            const vadTrigContainer = document.getElementById('vad-trig-container');

            resultContainer.style.display = 'block';
            const errorHtml = `<div class="validation-error">${message}</div>`;

            // –ï—Å–ª–∏ –∞–∫—Ç–∏–≤–µ–Ω —Ä–µ–∂–∏–º VAD-TriG, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—à–∏–±–∫—É —Ç–∞–∫–∂–µ –≤ –µ–≥–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ
            const isVadTrigMode = vadTrigContainer && vadTrigContainer.style.display !== 'none';
            if (isVadTrigMode && vadTrigOutput) {
                vadTrigOutput.innerHTML = errorHtml;
            }

            // –í—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –≤ –æ—Å–Ω–æ–≤–Ω–æ–º output (–¥–ª—è –Ω–µ-VAD-TriG —Ä–µ–∂–∏–º–æ–≤ –∏–ª–∏ –ø—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏)
            output.innerHTML = errorHtml;

            // –°–∫—Ä—ã–≤–∞–µ–º VAD-TriG –ø–∞–Ω–µ–ª–∏ –ø—Ä–∏ –æ—à–∏–±–∫–µ, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π output
            toggleVADTriGPanels(false);

            document.getElementById('export-buttons').style.display = 'none';
            document.getElementById('zoom-controls').style.display = 'none';
            document.getElementById('prefixes-panel').style.display = 'none';
            document.getElementById('legend-panel').style.display = 'none';
            // filter-panel removed in minimization
        }

        function displayPrefixes(prefixes) {
            const prefixesPanel = document.getElementById('prefixes-panel');
            const prefixesContent = document.getElementById('prefixes-content');

            const prefixEntries = Object.entries(prefixes);
            if (prefixEntries.length === 0) {
                prefixesPanel.style.display = 'none';
                return;
            }

            prefixEntries.sort((a, b) => a[0].localeCompare(b[0]));

            let html = '';
            for (const [prefix, namespace] of prefixEntries) {
                html += `<div class="prefix-line">`;
                html += `<span class="prefix-name">@prefix ${prefix}:</span> `;
                html += `<a href="${namespace}" class="prefix-url" target="_blank">&lt;${namespace}&gt;</a> .`;
                html += `</div>`;
            }

            prefixesContent.innerHTML = html;
            prefixesPanel.style.display = 'block';
        }

        function displayLegend() {
            const legendPanel = document.getElementById('legend-panel');
            const legendContent = document.getElementById('legend-content');

            let html = '';

            // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ VAD —Å—Ç–∏–ª–∏ (—Ä–µ–∂–∏–º VAD TriG)
            let nodeStylesSource, edgeStylesSource;
            nodeStylesSource = VADNodeStyles;
            edgeStylesSource = VADEdgeStyles;

            html += '<div class="legend-section">';
            html += '<h4>–°—Ç–∏–ª–∏ —É–∑–ª–æ–≤ (Node Styles)</h4>';

            for (const [styleName, styleConfig] of Object.entries(nodeStylesSource)) {
                const fillColorMatch = styleConfig.dot.match(/fillcolor="([^"]+)"/);
                const borderColorMatch = styleConfig.dot.match(/color="([^"]+)"/);
                const shapeMatch = styleConfig.dot.match(/shape="([^"]+)"/);

                const fillColor = fillColorMatch ? fillColorMatch[1] : '#ffffff';
                const borderColor = borderColorMatch ? borderColorMatch[1] : '#000000';
                const shape = shapeMatch ? shapeMatch[1] : 'ellipse';

                let shapeStyle = '';
                if (shape === 'box' || shape === 'note') {
                    shapeStyle = 'border-radius: 0;';
                } else if (shape === 'octagon') {
                    shapeStyle = 'border-radius: 0; clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);';
                } else if (shape === 'cds') {
                    shapeStyle = 'border-radius: 0; clip-path: polygon(0% 0%, 85% 0%, 100% 50%, 85% 100%, 0% 100%, 15% 50%);';
                } else {
                    shapeStyle = 'border-radius: 50%;';
                }

                html += `<div class="legend-item">`;
                html += `<div class="legend-shape" style="background-color: ${fillColor}; border-color: ${borderColor}; ${shapeStyle}"></div>`;
                html += `<span class="legend-label">${styleConfig.label}</span>`;
                html += `</div>`;
            }

            html += '</div>';

            html += '<div class="legend-section">';
            html += '<h4>–°—Ç–∏–ª–∏ —Ä–µ–±–µ—Ä (Edge Styles)</h4>';

            for (const [styleName, styleConfig] of Object.entries(edgeStylesSource)) {
                const colorMatch = styleConfig.dot.match(/color="([^"]+)"/);
                const penwidthMatch = styleConfig.dot.match(/penwidth="([^"]+)"/);
                const lineStyleMatch = styleConfig.dot.match(/style="([^"]+)"/);

                const color = colorMatch ? colorMatch[1] : '#666666';
                const penwidth = penwidthMatch ? parseInt(penwidthMatch[1]) : 1;
                const lineStyle = lineStyleMatch ? lineStyleMatch[1] : 'solid';

                let borderStyle = 'solid';
                if (lineStyle === 'dashed') borderStyle = 'dashed';
                if (lineStyle === 'dotted') borderStyle = 'dotted';

                html += `<div class="legend-item">`;
                html += `<span class="legend-line" style="background-color: ${color}; height: ${penwidth + 1}px; border-bottom: ${penwidth}px ${borderStyle} ${color}; background: none;"></span>`;
                html += `<span class="legend-label">${styleConfig.label}</span>`;
                html += `</div>`;
            }

            html += '</div>';

            legendContent.innerHTML = html;
            legendPanel.style.display = 'block';
        }

        // ============================================================================
        // –§–£–ù–ö–¶–ò–ò –î–õ–Ø SPARQL SMART DESIGN
        // ============================================================================

        /**
         * –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø–∞–Ω–µ–ª–∏ Smart Design
         * @param {string} message - –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
         * @param {string} type - –¢–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è: 'error', 'success', 'info'
         */
        function showSmartDesignMessage(message, type) {
            const messageDiv = document.getElementById('smart-design-message');
            if (messageDiv) {
                messageDiv.textContent = message;
                messageDiv.className = 'smart-design-message ' + type;
                messageDiv.style.display = 'block';
                // –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Å—Ç–∞–µ—Ç—Å—è –≤–∏–¥–∏–º—ã–º –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                // (–Ω–µ —Å–∫—Ä—ã–≤–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ —Ç–∞–π–º–µ—Ä—É)
            }
        }

        /**
         * –°–∫—Ä—ã–≤–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø–∞–Ω–µ–ª–∏ Smart Design
         */
        function hideSmartDesignMessage() {
            const messageDiv = document.getElementById('smart-design-message');
            if (messageDiv) {
                messageDiv.style.display = 'none';
            }
        }

        /**
         * –°–æ–±–∏—Ä–∞–µ—Ç –≤—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ TriG –≥—Ä–∞—Ñ—ã –∏–∑ —Ç–µ–∫—É—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
         * @returns {Array} - –ú–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤ {uri, label}
         */
        function getAllTriGs() {
            const trigs = [];
            const seen = new Set();

            // –°–æ–±–∏—Ä–∞–µ–º –∏–∑ trigHierarchy (–µ—Å–ª–∏ –µ—Å—Ç—å)
            for (const [uri, info] of Object.entries(trigHierarchy)) {
                if (!seen.has(uri)) {
                    seen.add(uri);
                    const label = info.label || getPrefixedName(uri, currentPrefixes);
                    trigs.push({ uri: uri, label: label });
                }
            }

            // –¢–∞–∫–∂–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º allTrigGraphs
            for (const trigUri of allTrigGraphs) {
                if (!seen.has(trigUri)) {
                    seen.add(trigUri);
                    const label = getPrefixedName(trigUri, currentPrefixes);
                    trigs.push({ uri: trigUri, label: label });
                }
            }

            return trigs.sort((a, b) => a.label.localeCompare(b.label));
        }

        /**
         * –°–æ–±–∏—Ä–∞–µ—Ç –≤—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Å—É–±—ä–µ–∫—Ç—ã (–æ–±—ä–µ–∫—Ç—ã) –∏–∑ —Ç–µ–∫—É—â–∏—Ö RDF –¥–∞–Ω–Ω—ã—Ö
         * @returns {Array} - –ú–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤ {uri, label}
         */
        function getAllSubjects() {
            const subjects = [];
            const seen = new Set();

            currentQuads.forEach(quad => {
                const uri = quad.subject.value;
                if (!seen.has(uri)) {
                    seen.add(uri);
                    const label = getPrefixedName(uri, currentPrefixes);
                    subjects.push({ uri: uri, label: label });
                }
            });

            return subjects.sort((a, b) => a.label.localeCompare(b.label));
        }

        /**
         * –°–æ–±–∏—Ä–∞–µ—Ç –≤—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –∏–∑ —Ç–µ–∫—É—â–∏—Ö RDF –¥–∞–Ω–Ω—ã—Ö
         * @returns {Array} - –ú–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤ {uri, label}
         */
        function getAllPredicates() {
            const predicates = [];
            const seen = new Set();

            currentQuads.forEach(quad => {
                const uri = quad.predicate.value;
                if (!seen.has(uri)) {
                    seen.add(uri);
                    const label = getPrefixedName(uri, currentPrefixes);
                    predicates.push({ uri: uri, label: label });
                }
            });

            return predicates.sort((a, b) => a.label.localeCompare(b.label));
        }

        /**
         * –°–æ–±–∏—Ä–∞–µ—Ç –≤—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã (–∏—Å–∫–ª—é—á–∞—è –ª–∏—Ç–µ—Ä–∞–ª—ã) –∏–∑ —Ç–µ–∫—É—â–∏—Ö RDF –¥–∞–Ω–Ω—ã—Ö
         * @returns {Array} - –ú–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤ {uri, label}
         */
        function getAllObjects() {
            const objects = [];
            const seen = new Set();

            currentQuads.forEach(quad => {
                // –ò—Å–∫–ª—é—á–∞–µ–º –ª–∏—Ç–µ—Ä–∞–ª—ã —Å–æ–≥–ª–∞—Å–Ω–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º
                if (quad.object.termType !== 'Literal') {
                    const uri = quad.object.value;
                    if (!seen.has(uri)) {
                        seen.add(uri);
                        const label = getPrefixedName(uri, currentPrefixes);
                        objects.push({ uri: uri, label: label });
                    }
                }
            });

            return objects.sort((a, b) => a.label.localeCompare(b.label));
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ TriG —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º –∏–º–µ–Ω–µ–º –≤ RDF –¥–∞–Ω–Ω—ã—Ö
         * @param {string} name - –ò–º—è TriG –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
         * @returns {boolean}
         */
        function trigExists(name) {
            const trigs = getAllTriGs();
            const normalizedName = name.toLowerCase();
            return trigs.some(t => {
                const label = t.label.toLowerCase();
                const localName = getLocalName(t.uri).toLowerCase();
                return label === normalizedName || localName === normalizedName || t.uri === name;
            });
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Å—É–±—ä–µ–∫—Ç —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º –∏–º–µ–Ω–µ–º –≤ RDF –¥–∞–Ω–Ω—ã—Ö
         * @param {string} name - –ò–º—è —Å—É–±—ä–µ–∫—Ç–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
         * @returns {boolean}
         */
        function subjectExists(name) {
            const subjects = getAllSubjects();
            const normalizedName = name.toLowerCase();
            return subjects.some(s => {
                const label = s.label.toLowerCase();
                const localName = getLocalName(s.uri).toLowerCase();
                return label === normalizedName || localName === normalizedName || s.uri === name;
            });
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—Ä–µ–¥–∏–∫–∞—Ç —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º –∏–º–µ–Ω–µ–º –≤ RDF –¥–∞–Ω–Ω—ã—Ö
         * @param {string} name - –ò–º—è –ø—Ä–µ–¥–∏–∫–∞—Ç–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
         * @returns {boolean}
         */
        function predicateExists(name) {
            const predicates = getAllPredicates();
            const normalizedName = name.toLowerCase();
            return predicates.some(p => {
                const label = p.label.toLowerCase();
                const localName = getLocalName(p.uri).toLowerCase();
                return label === normalizedName || localName === normalizedName || p.uri === name;
            });
        }

        /**
         * –ó–∞–ø–æ–ª–Ω—è–µ—Ç –≤—ã–ø–∞–¥–∞—é—â–∏–µ —Å–ø–∏—Å–∫–∏ –≤ –ø–∞–Ω–µ–ª–∏ Smart Design
         */
        function populateSmartDesignDropdowns() {
            const trigSelect = document.getElementById('smart-design-trig');
            const subjectSelect = document.getElementById('smart-design-subject');
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const predicateSelect = document.getElementById('smart-design-predicate');
            const objectSelect = document.getElementById('smart-design-object');

            if (!trigSelect || !subjectSelect || !predicateSelect || !objectSelect) return;

            // –û—á–∏—â–∞–µ–º –∏ –∑–∞–ø–æ–ª–Ω—è–µ–º TriG (–±–µ–∑ –æ–ø—Ü–∏–∏ "New" - –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤—ã—Ö TriG –µ—Å—Ç—å –æ—Ç–¥–µ–ª—å–Ω–∞—è –∫–Ω–æ–ø–∫–∞)
            trigSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ TriG --</option>';
            const trigs = getAllTriGs();
            trigs.forEach(t => {
                const option = document.createElement('option');
                option.value = t.uri;
                // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º id —Å label –≤ —Å–∫–æ–±–∫–∞—Ö (–ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏)
                const id = getPrefixedName(t.uri, currentPrefixes);
                const displayText = t.label && t.label !== id ? `${id} (${t.label})` : id;
                option.textContent = displayText;
                trigSelect.appendChild(option);
            });

            // –û—á–∏—â–∞–µ–º –∏ –∑–∞–ø–æ–ª–Ω—è–µ–º Subject
            subjectSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Subject --</option>';
            subjectSelect.innerHTML += '<option value="__NEW__">New (—Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π)</option>';
            const subjects = getAllSubjects();
            subjects.forEach(s => {
                const option = document.createElement('option');
                option.value = s.uri;
                option.textContent = s.label;
                subjectSelect.appendChild(option);
            });

            // –û—á–∏—â–∞–µ–º –∏ –∑–∞–ø–æ–ª–Ω—è–µ–º Subject Type
            if (subjectTypeSelect) {
                populateSubjectTypeDropdown();
            }

            // –û—á–∏—â–∞–µ–º –∏ –∑–∞–ø–æ–ª–Ω—è–µ–º Predicate (–±–µ–∑ –æ–ø—Ü–∏–∏ "New" - –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –±–µ—Ä—É—Ç—Å—è —Ç–æ–ª—å–∫–æ –∏–∑ –æ–Ω—Ç–æ–ª–æ–≥–∏–∏)
            predicateSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Predicate --</option>';
            const predicates = getAllPredicates();
            predicates.forEach(p => {
                const option = document.createElement('option');
                option.value = p.uri;
                option.textContent = p.label;
                predicateSelect.appendChild(option);
            });

            // –û—á–∏—â–∞–µ–º –∏ –∑–∞–ø–æ–ª–Ω—è–µ–º Object (–±–µ–∑ –ª–∏—Ç–µ—Ä–∞–ª–æ–≤)
            objectSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Object --</option>';
            objectSelect.innerHTML += '<option value="__NEW__">New (—Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ª–∏—Ç–µ—Ä–∞–ª)</option>';
            const objects = getAllObjects();
            objects.forEach(o => {
                const option = document.createElement('option');
                option.value = o.uri;
                option.textContent = o.label;
                objectSelect.appendChild(option);
            });

            // –î–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º Subject/Predicate/Object –ø–æ–ª—è –¥–æ –≤—ã–±–æ—Ä–∞ TriG
            updateSmartDesignFieldsState();
        }

        /**
         * –ó–∞–ø–æ–ª–Ω—è–µ—Ç –≤—ã–ø–∞–¥–∞—é—â–∏–π —Å–ø–∏—Å–æ–∫ Subject Type
         * –¢–∏–ø—ã –∑–∞–≤–∏—Å—è—Ç –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ TriG
         */
        function populateSubjectTypeDropdown() {
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const trigSelect = document.getElementById('smart-design-trig');

            if (!subjectTypeSelect) return;

            subjectTypeSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø Subject --</option>';

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–∏–ø—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ TriG
            const trigValue = trigSelect ? trigSelect.value : '';
            const isPtree = trigValue === 'vad:ptree' || trigValue === 'http://example.org/vad#ptree' || trigValue.endsWith('#ptree');
            const isRtree = trigValue === 'vad:rtree' || trigValue === 'http://example.org/vad#rtree' || trigValue.endsWith('#rtree');

            let availableTypes = [];

            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ Tech appendix, –µ—Å–ª–∏ –æ–Ω–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã
            if (techAppendixData && techAppendixData.predicateGroups) {
                if (isPtree) {
                    // –í ptree: ConceptProcessPredicate, ConceptTreePredicate
                    availableTypes = [
                        { value: 'vad:TypeProcess', label: 'vad:TypeProcess (–∫–æ–Ω—Ü–µ–ø—Ç –ø—Ä–æ—Ü–µ—Å—Å–∞)' },
                        { value: 'vad:ProcessTree', label: 'vad:ProcessTree (–¥–µ—Ä–µ–≤–æ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤)' }
                    ];
                } else if (isRtree) {
                    // –í rtree: ConceptExecutorPredicate, ExecutorTreePredicate
                    availableTypes = [
                        { value: 'vad:TypeExecutor', label: 'vad:TypeExecutor (–∫–æ–Ω—Ü–µ–ø—Ç –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è)' },
                        { value: 'vad:ExecutorTree', label: 'vad:ExecutorTree (–¥–µ—Ä–µ–≤–æ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π)' }
                    ];
                } else if (trigValue) {
                    // –í VADProcessDia: IndividProcessPredicate, ExecutorGroupPredicate, DiagramPredicate
                    availableTypes = [
                        { value: 'vad:TypeProcess', label: 'vad:TypeProcess (–∏–Ω–¥–∏–≤–∏–¥ –ø—Ä–æ—Ü–µ—Å—Å–∞)' },
                        { value: 'vad:ExecutorGroup', label: 'vad:ExecutorGroup (–≥—Ä—É–ø–ø–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π)' },
                        { value: 'vad:VADProcessDia', label: 'vad:VADProcessDia (–¥–∏–∞–≥—Ä–∞–º–º–∞)' }
                    ];
                }
            } else {
                // Fallback: –∏—Å—Ö–æ–¥–Ω–∞—è –ª–æ–≥–∏–∫–∞, –µ—Å–ª–∏ Tech appendix –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω
                if (isPtree) {
                    availableTypes = [
                        { value: 'vad:TypeProcess', label: 'vad:TypeProcess' },
                        { value: 'vad:ProcessTree', label: 'vad:ProcessTree' }
                    ];
                } else if (isRtree) {
                    availableTypes = [
                        { value: 'vad:TypeExecutor', label: 'vad:TypeExecutor' },
                        { value: 'vad:ExecutorTree', label: 'vad:ExecutorTree' }
                    ];
                } else if (trigValue) {
                    availableTypes = [
                        { value: 'vad:TypeProcess', label: 'vad:TypeProcess' },
                        { value: 'vad:ExecutorGroup', label: 'vad:ExecutorGroup' },
                        { value: 'vad:VADProcessDia', label: 'vad:VADProcessDia' }
                    ];
                }
            }

            availableTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type.value;
                option.textContent = type.label;
                subjectTypeSelect.appendChild(option);
            });
        }

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç –¥–æ–ø—É—Å—Ç–∏–º—ã–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ Subject Type –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ TriG
         * @param {string} subjectType - –¢–∏–ø —Å—É–±—ä–µ–∫—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'vad:Process')
         * @param {string} trigContext - –ö–æ–Ω—Ç–µ–∫—Å—Ç TriG ('ptree', 'rtree', 'vadProcessDia')
         * @returns {Array} - –ú–∞—Å—Å–∏–≤ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–≤
         */
        function getPredicatesForSubjectType(subjectType, trigContext) {
            const typeConfig = TYPE_PREDICATE_MAP[subjectType];
            if (!typeConfig) return [];

            let predicates = [];

            if (trigContext === 'ptree' && typeConfig.ptree) {
                predicates = typeConfig.ptree;
            } else if (trigContext === 'rtree' && typeConfig.rtree) {
                predicates = typeConfig.rtree;
            } else if (trigContext === 'vadProcessDia' && typeConfig.vadProcessDia) {
                predicates = typeConfig.vadProcessDia;
            }

            return predicates;
        }

        /**
         * –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç TriG –ø–æ –µ–≥–æ URI
         * @param {string} trigUri - URI TriG –≥—Ä–∞—Ñ–∞
         * @returns {string} - 'ptree', 'rtree' –∏–ª–∏ 'vadProcessDia'
         */
        function getTrigContext(trigUri) {
            if (!trigUri) return '';
            if (trigUri === 'vad:ptree' || trigUri === 'http://example.org/vad#ptree' || trigUri.endsWith('#ptree')) {
                return 'ptree';
            }
            if (trigUri === 'vad:rtree' || trigUri === 'http://example.org/vad#rtree' || trigUri.endsWith('#rtree')) {
                return 'rtree';
            }
            return 'vadProcessDia';
        }

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç –≤—ã–ø–∞–¥–∞—é—â–∏–π —Å–ø–∏—Å–æ–∫ Predicate –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ Subject Type
         * –ê–≤—Ç–æ–≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—ã–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã (isSubprocessTrig, hasExecutor) –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è –∫–∞–∫ disabled
         */
        function updatePredicateBySubjectType() {
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const predicateSelect = document.getElementById('smart-design-predicate');
            const trigSelect = document.getElementById('smart-design-trig');

            if (!subjectTypeSelect || !predicateSelect || !trigSelect) return;

            const subjectType = subjectTypeSelect.value;
            const trigUri = trigSelect.value;
            const trigContext = getTrigContext(trigUri);

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            const currentPredicateValue = predicateSelect.value;

            // –í—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–æ–ø—É—Å—Ç–∏–º—ã–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞
            if (!subjectType) {
                // –ï—Å–ª–∏ —Ç–∏–ø –Ω–µ –≤—ã–±—Ä–∞–Ω - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã
                predicateSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Predicate --</option>';
                const allPredicates = getAllPredicates();
                allPredicates.forEach(p => {
                    const option = document.createElement('option');
                    option.value = p.uri;
                    option.textContent = p.label;
                    predicateSelect.appendChild(option);
                });
            } else {
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–æ–ø—É—Å—Ç–∏–º—ã–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã —Å —É—á–µ—Ç–æ–º –∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—ã—Ö
                const allowedPredicates = getPredicatesForSubjectType(subjectType, trigContext);

                predicateSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Predicate --</option>';

                allowedPredicates.forEach(pred => {
                    const option = document.createElement('option');
                    // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å –≤ –ø–æ–ª–Ω—ã–π URI
                    let fullUri = pred;
                    for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                        if (pred.startsWith(prefix + ':')) {
                            fullUri = namespace + pred.substring(prefix.length + 1);
                            break;
                        }
                    }
                    option.value = fullUri;

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø—Ä–µ–¥–∏–∫–∞—Ç –∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—ã–º
                    const isAutoGen = isAutoGeneratedPredicate(pred);
                    if (isAutoGen) {
                        option.textContent = pred + ' (–∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—ã–π)';
                        option.disabled = true;
                        option.style.color = '#999';
                    } else {
                        option.textContent = pred;
                    }

                    predicateSelect.appendChild(option);
                });
            }

            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–±–æ—Ä –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –≤—Å–µ –µ—â–µ –¥–æ—Å—Ç—É–ø–Ω–æ –∏ –Ω–µ disabled
            if (currentPredicateValue) {
                const matchingOption = Array.from(predicateSelect.options).find(o => o.value === currentPredicateValue && !o.disabled);
                if (matchingOption) {
                    predicateSelect.value = currentPredicateValue;
                } else {
                    predicateSelect.value = '';
                }
            } else {
                predicateSelect.value = '';
            }
        }

        /**
         * –ü—Ä–µ–¥–∏–∫–∞—Ç—ã, —Ç—Ä–µ–±—É—é—â–∏–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ Object –ø–æ —Ç–∏–ø—É vad:Process (–∏–∑ ptree)
         */
        const PROCESS_OBJECT_PREDICATES = [
            'vad:hasNext',
            'http://example.org/vad#hasNext'
        ];

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Ç—Ä–µ–±—É–µ—Ç –ª–∏ –ø—Ä–µ–¥–∏–∫–∞—Ç —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ Object –¥–æ —Ç–∏–ø–∞ Process
         * @param {string} predicateUri - URI –∏–ª–∏ prefixed name –ø—Ä–µ–¥–∏–∫–∞—Ç–∞
         * @returns {boolean}
         */
        function isProcessObjectPredicate(predicateUri) {
            return PROCESS_OBJECT_PREDICATES.some(allowed =>
                predicateUri === allowed ||
                predicateUri.endsWith('#hasNext')
            );
        }

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç —Å–ø–∏—Å–æ–∫ Object –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ Predicate
         * –í —Ä–µ–∂–∏–º–µ Filter: –µ—Å–ª–∏ –≤—ã–±—Ä–∞–Ω vad:hasNext, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –æ–±—ä–µ–∫—Ç—ã —Ç–∏–ø–∞ vad:Process –∏–∑ ptree
         */
        function updateObjectsByPredicate() {
            const predicateSelect = document.getElementById('smart-design-predicate');
            const objectSelect = document.getElementById('smart-design-object');

            if (!predicateSelect || !objectSelect) return;

            const predicateValue = predicateSelect.value;

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            const currentObjectValue = objectSelect.value;

            // –í —Ä–µ–∂–∏–º–µ 'full' –Ω–µ —Ñ–∏–ª—å—Ç—Ä—É–µ–º –æ–±—ä–µ–∫—Ç—ã
            if (smartDesignMode === 'full' || !predicateValue) {
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ –æ–±—ä–µ–∫—Ç–æ–≤
                objectSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Object --</option>';
                objectSelect.innerHTML += '<option value="__NEW__">New (—Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ª–∏—Ç–µ—Ä–∞–ª)</option>';
                const allObjects = getAllObjects();
                allObjects.forEach(o => {
                    const option = document.createElement('option');
                    option.value = o.uri;
                    option.textContent = o.label;
                    objectSelect.appendChild(option);
                });
            } else if (isProcessObjectPredicate(predicateValue)) {
                // –†–µ–∂–∏–º 'filtered' –∏ –ø—Ä–µ–¥–∏–∫–∞—Ç —Ç—Ä–µ–±—É–µ—Ç Object —Ç–∏–ø–∞ Process
                objectSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Object --</option>';
                // –î–ª—è hasNext –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–ø—Ü–∏—é "New (—Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ª–∏—Ç–µ—Ä–∞–ª)" —Ç.–∫. –æ–±—ä–µ–∫—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å Process

                // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–ª—å–∫–æ –æ–±—ä–µ–∫—Ç—ã —Ç–∏–ø–∞ vad:Process –∏–∑ ptree
                const processObjects = getProcessSubjects();
                processObjects.forEach(p => {
                    const option = document.createElement('option');
                    option.value = p.uri;
                    option.textContent = p.label;
                    objectSelect.appendChild(option);
                });
            } else {
                // –†–µ–∂–∏–º 'filtered' –Ω–æ –ø—Ä–µ–¥–∏–∫–∞—Ç –Ω–µ —Ç—Ä–µ–±—É–µ—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–π —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
                objectSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Object --</option>';
                objectSelect.innerHTML += '<option value="__NEW__">New (—Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ª–∏—Ç–µ—Ä–∞–ª)</option>';
                const allObjects = getAllObjects();
                allObjects.forEach(o => {
                    const option = document.createElement('option');
                    option.value = o.uri;
                    option.textContent = o.label;
                    objectSelect.appendChild(option);
                });
            }

            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–±–æ—Ä –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –≤—Å–µ –µ—â–µ –¥–æ—Å—Ç—É–ø–Ω–æ
            if (currentObjectValue && Array.from(objectSelect.options).some(o => o.value === currentObjectValue)) {
                objectSelect.value = currentObjectValue;
            } else {
                objectSelect.value = '';
            }
        }

        /**
         * –ü–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç —Ä–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã Smart Design (filtered/full)
         */
        function toggleSmartDesignMode() {
            const toggleBtn = document.getElementById('smart-design-mode-toggle');

            if (smartDesignMode === 'filtered') {
                smartDesignMode = 'full';
                if (toggleBtn) toggleBtn.textContent = '–†–µ–∂–∏–º: –ü–æ–ª–Ω—ã–π';
            } else {
                smartDesignMode = 'filtered';
                if (toggleBtn) toggleBtn.textContent = '–†–µ–∂–∏–º: –§–∏–ª—å—Ç—Ä';
            }

            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–≤
            updatePredicateBySubjectType();
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –æ–±—ä–µ–∫—Ç–æ–≤
            updateObjectsByPredicate();
        }

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª–µ–π Subject/SubjectType/Predicate/Object (–∞–∫—Ç–∏–≤–Ω—ã–µ —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ TriG)
         */
        function updateSmartDesignFieldsState() {
            const trigSelect = document.getElementById('smart-design-trig');
            const subjectSelect = document.getElementById('smart-design-subject');
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const predicateSelect = document.getElementById('smart-design-predicate');
            const objectSelect = document.getElementById('smart-design-object');

            if (!trigSelect || !subjectSelect || !predicateSelect || !objectSelect) return;

            const trigSelected = trigSelect.value && trigSelect.value !== '';
            const newTrigActive = document.getElementById('new-trig-modal')?.style.display === 'block';

            // –ï—Å–ª–∏ –∞–∫—Ç–∏–≤–Ω–æ –æ–∫–Ω–æ New TriG, –¥–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –≤—Å–µ –ø–æ–ª—è
            if (newTrigActive) {
                trigSelect.disabled = true;
                subjectSelect.disabled = true;
                if (subjectTypeSelect) subjectTypeSelect.disabled = true;
                predicateSelect.disabled = true;
                objectSelect.disabled = true;
            } else {
                trigSelect.disabled = false;
                subjectSelect.disabled = !trigSelected;
                if (subjectTypeSelect) subjectTypeSelect.disabled = !trigSelected;
                predicateSelect.disabled = !trigSelected;
                objectSelect.disabled = !trigSelected;
            }
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –≤—ã–±—Ä–∞–Ω–Ω—ã–π TriG –≥—Ä–∞—Ñ–æ–º vad:ptree
         * @returns {boolean}
         */
        function isSelectedTrigPtree() {
            const trigSelect = document.getElementById('smart-design-trig');
            if (!trigSelect || !trigSelect.value) return false;
            const trigValue = trigSelect.value;
            return trigValue === 'vad:ptree' ||
                   trigValue === 'http://example.org/vad#ptree' ||
                   trigValue.endsWith('#ptree');
        }

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç —Å—É–±—ä–µ–∫—Ç—ã —Ç–∏–ø–∞ vad:Process –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –≤ —Ä–µ–∂–∏–º–µ vad:ptree
         * @returns {Array} - –ú–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤ {uri, label}
         */
        function getProcessSubjects() {
            const subjects = [];
            const seen = new Set();

            currentQuads.forEach(quad => {
                const uri = quad.subject.value;
                if (!seen.has(uri) && isSubjectVadProcess(uri)) {
                    seen.add(uri);
                    const label = getPrefixedName(uri, currentPrefixes);
                    subjects.push({ uri: uri, label: label });
                }
            });

            return subjects.sort((a, b) => a.label.localeCompare(b.label));
        }

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç —Å—É–±—ä–µ–∫—Ç—ã –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –≤ —Ä–µ–∂–∏–º–µ Filter
         * @param {string} typeValue - –¢–∏–ø —Å—É–±—ä–µ–∫—Ç–∞ (prefixed name –∏–ª–∏ –ø–æ–ª–Ω—ã–π URI)
         * @returns {Array} - –ú–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤ {uri, label}
         */
        function getSubjectsByType(typeValue) {
            const subjects = [];
            const seen = new Set();

            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º typeValue –≤ –ø–æ–ª–Ω—ã–π URI –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
            let typeUri = typeValue;
            for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                if (typeValue.startsWith(prefix + ':')) {
                    typeUri = namespace + typeValue.substring(prefix.length + 1);
                    break;
                }
            }

            currentQuads.forEach(quad => {
                const uri = quad.subject.value;
                if (seen.has(uri)) return;

                const subjectTypes = nodeTypesCache[uri] || [];
                const hasType = subjectTypes.some(t =>
                    t === typeValue || t === typeUri
                );

                if (hasType) {
                    seen.add(uri);
                    const label = getPrefixedName(uri, currentPrefixes);
                    subjects.push({ uri: uri, label: label });
                }
            });

            return subjects.sort((a, b) => a.label.localeCompare(b.label));
        }

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤—ã–ø–∞–¥–∞—é—â–µ–≥–æ —Å–ø–∏—Å–∫–∞ Subject –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ Subject Type
         * –≤ —Ä–µ–∂–∏–º–µ Filter (smartDesignMode === 'filtered')
         */
        function updateSubjectsBySubjectType() {
            const subjectSelect = document.getElementById('smart-design-subject');
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const trigSelect = document.getElementById('smart-design-trig');

            if (!subjectSelect || !subjectTypeSelect) return;

            const selectedType = subjectTypeSelect.value;
            const trigUri = trigSelect ? trigSelect.value : '';
            if (!selectedType) return; // –ï—Å–ª–∏ —Ç–∏–ø –Ω–µ –≤—ã–±—Ä–∞–Ω, –Ω–µ —Ñ–∏–ª—å—Ç—Ä—É–µ–º

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            const currentSubjectValue = subjectSelect.value;

            // –û—á–∏—â–∞–µ–º –∏ –∑–∞–ø–æ–ª–Ω—è–µ–º Subject
            subjectSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Subject --</option>';
            subjectSelect.innerHTML += '<option value="__NEW__">New (—Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π)</option>';

            // –ò—Å–ø–æ–ª—å–∑—É–µ–º SPARQL-based –ø–æ–¥—Ö–æ–¥ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è —Å—É–±—ä–µ–∫—Ç–æ–≤
            // –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ TriG
            const trigContext = getTrigContext(trigUri);
            let subjects = [];

            if (selectedType === 'vad:TypeProcess') {
                if (trigContext === 'ptree') {
                    // –í ptree –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–Ω—Ü–µ–ø—Ç—ã –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ (Process rdf:type vad:TypeProcess)
                    subjects = funSPARQLvalues(SPARQL_QUERIES.PROCESS_CONCEPTS_IN_PTREE, 'process');
                } else {
                    // –í VADProcessDia –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω–¥–∏–≤–∏–¥—ã –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ TriG
                    subjects = getProcessIndividualsInTriG(trigUri);
                }
            } else if (selectedType === 'vad:ExecutorGroup') {
                // –ì—Ä—É–ø–ø—ã –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ TriG
                subjects = getExecutorGroupsInTriG(trigUri);
            } else if (selectedType === 'vad:TypeExecutor') {
                // –ö–æ–Ω—Ü–µ–ø—Ç—ã –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –∏–∑ rtree
                subjects = funSPARQLvalues(SPARQL_QUERIES.EXECUTOR_CONCEPTS_IN_RTREE, 'executor');
            } else if (selectedType === 'vad:ProcessTree' || selectedType === 'vad:ExecutorTree' || selectedType === 'vad:VADProcessDia') {
                // –î–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—ã–π –ø–æ–¥—Ö–æ–¥
                subjects = getSubjectsByType(selectedType);
            }

            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º URI –≤ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç
            subjects.forEach(uri => {
                const option = document.createElement('option');
                if (typeof uri === 'object' && uri.uri) {
                    option.value = uri.uri;
                    option.textContent = uri.label || getPrefixedName(uri.uri, currentPrefixes);
                } else {
                    option.value = uri;
                    option.textContent = getPrefixedName(uri, currentPrefixes);
                }
                subjectSelect.appendChild(option);
            });

            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–±–æ—Ä –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –≤—Å–µ –µ—â–µ –¥–æ—Å—Ç—É–ø–Ω–æ
            if (currentSubjectValue && Array.from(subjectSelect.options).some(o => o.value === currentSubjectValue)) {
                subjectSelect.value = currentSubjectValue;
            } else {
                subjectSelect.value = '';
            }
        }

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –∏–∑ PTREE_PREDICATES –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –≤ —Ä–µ–∂–∏–º–µ vad:ptree
         * @returns {Array} - –ú–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤ {uri, label}
         */
        function getPtreePredicates() {
            const predicates = [];
            const seen = new Set();

            // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –µ—Å—Ç—å –≤ PTREE_PREDICATES –∏ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç –≤ –¥–∞–Ω–Ω—ã—Ö
            currentQuads.forEach(quad => {
                const uri = quad.predicate.value;
                const prefixedName = getPrefixedName(uri, currentPrefixes);
                if (!seen.has(uri) && (isPtreePredicate(uri) || isPtreePredicate(prefixedName))) {
                    seen.add(uri);
                    predicates.push({ uri: uri, label: prefixedName });
                }
            });

            // –¢–∞–∫–∂–µ –¥–æ–±–∞–≤–ª—è–µ–º –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –∏–∑ PTREE_PREDICATES, –∫–æ—Ç–æ—Ä—ã—Ö –º–æ–∂–µ—Ç –Ω–µ –±—ã—Ç—å –≤ –¥–∞–Ω–Ω—ã—Ö
            PTREE_PREDICATES.forEach(pred => {
                if (!seen.has(pred) && !pred.startsWith('http')) {
                    // –≠—Ç–æ prefixed name, –ø—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —Ç–∞–∫–æ–π –≤ —Å–ø–∏—Å–∫–µ
                    const alreadyInList = predicates.some(p => p.label === pred);
                    if (!alreadyInList) {
                        // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å –≤ –ø–æ–ª–Ω—ã–π URI
                        let fullUri = pred;
                        for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                            if (pred.startsWith(prefix + ':')) {
                                fullUri = namespace + pred.substring(prefix.length + 1);
                                break;
                            }
                        }
                        if (!seen.has(fullUri)) {
                            seen.add(fullUri);
                            predicates.push({ uri: fullUri, label: pred });
                        }
                    }
                }
            });

            return predicates.sort((a, b) => a.label.localeCompare(b.label));
        }

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤—ã–ø–∞–¥–∞—é—â–∏—Ö —Å–ø–∏—Å–∫–æ–≤ Subject –∏ Predicate
         * –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ TriG (vad:ptree –∏–ª–∏ –¥—Ä—É–≥–æ–π)
         */
        function updateSubjectPredicateDropdowns() {
            const subjectSelect = document.getElementById('smart-design-subject');
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const predicateSelect = document.getElementById('smart-design-predicate');

            if (!subjectSelect || !predicateSelect) return;

            const isPtree = isSelectedTrigPtree();

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–µ –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è (–µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ)
            const currentSubjectValue = subjectSelect.value;
            const currentPredicateValue = predicateSelect.value;

            // –û—á–∏—â–∞–µ–º –∏ –∑–∞–ø–æ–ª–Ω—è–µ–º Subject
            subjectSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Subject --</option>';
            subjectSelect.innerHTML += '<option value="__NEW__">New (—Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π)</option>';

            const subjects = isPtree ? getProcessSubjects() : getAllSubjects();
            subjects.forEach(s => {
                const option = document.createElement('option');
                option.value = s.uri;
                option.textContent = s.label;
                subjectSelect.appendChild(option);
            });

            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º Subject Type –ø—Ä–∏ —Å–º–µ–Ω–µ TriG
            if (subjectTypeSelect) {
                subjectTypeSelect.value = '';
            }

            // –û–±–Ω–æ–≤–ª—è–µ–º Predicate —Å —É—á–µ—Ç–æ–º —Ä–µ–∂–∏–º–∞ –∏ Subject Type
            updatePredicateBySubjectType();

            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–±–æ—Ä –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –≤—Å–µ –µ—â–µ –¥–æ—Å—Ç—É–ø–Ω–æ
            if (currentSubjectValue && Array.from(subjectSelect.options).some(o => o.value === currentSubjectValue)) {
                subjectSelect.value = currentSubjectValue;
            } else {
                subjectSelect.value = '';
            }
            if (currentPredicateValue && Array.from(predicateSelect.options).some(o => o.value === currentPredicateValue)) {
                predicateSelect.value = currentPredicateValue;
            } else {
                predicateSelect.value = '';
            }
        }

        /**
         * –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–æ–≤–æ–µ –∏–º—è –∏ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –µ–≥–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å
         * @param {string} fieldName - –ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ–ª—è (TriG, Subject, Predicate, Object)
         * @param {Function} existsChecker - –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è
         * @param {boolean} allowDuplicate - –†–∞–∑—Ä–µ—à–∏—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã (–¥–ª—è Object)
         * @returns {string|null} - –í–≤–µ–¥–µ–Ω–Ω–æ–µ –∏–º—è –∏–ª–∏ null –µ—Å–ª–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ
         */
        function promptForNewValue(fieldName, existsChecker, allowDuplicate = false) {
            const name = prompt(`–í–≤–µ–¥–∏—Ç–µ –∏–º—è –¥–ª—è –Ω–æ–≤–æ–≥–æ ${fieldName}:`);
            if (!name || name.trim() === '') {
                return null;
            }

            const trimmedName = name.trim();

            if (!allowDuplicate && existsChecker(trimmedName)) {
                showSmartDesignMessage(`–û—à–∏–±–∫–∞: ${fieldName} —Å –∏–º–µ–Ω–µ–º "${trimmedName}" —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ RDF –¥–∞–Ω–Ω—ã—Ö`, 'error');
                return null;
            }

            return trimmedName;
        }

        /**
         * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤—ã–±–æ—Ä–∞ –≤ –≤—ã–ø–∞–¥–∞—é—â–µ–º —Å–ø–∏—Å–∫–µ
         * @param {HTMLSelectElement} selectElement - –≠–ª–µ–º–µ–Ω—Ç select
         * @param {string} fieldName - –ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ–ª—è
         * @param {Function} existsChecker - –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è
         * @param {boolean} allowDuplicate - –†–∞–∑—Ä–µ—à–∏—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã
         */
        function handleSelectChange(selectElement, fieldName, existsChecker, allowDuplicate = false) {
            if (selectElement.value === '__NEW__') {
                const newValue = promptForNewValue(fieldName, existsChecker, allowDuplicate);
                if (newValue) {
                    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤ —Å–ø–∏—Å–æ–∫ –∏ –≤—ã–±–∏—Ä–∞–µ–º –µ–≥–æ
                    const option = document.createElement('option');
                    option.value = '__CUSTOM__:' + newValue;
                    option.textContent = newValue + ' (–Ω–æ–≤—ã–π)';
                    selectElement.insertBefore(option, selectElement.options[2]); // –ü–æ—Å–ª–µ "New"
                    selectElement.value = option.value;
                    hideSmartDesignMessage();
                } else {
                    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—ã–±–æ—Ä
                    selectElement.value = '';
                }
            }
        }

        /**
         * –°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–æ–ª—è Subject —Å —É—á—ë—Ç–æ–º –ª–æ–≥–∏–∫–∏ –∫–æ–Ω—Ü–µ–ø—Ç/–∏–Ω–¥–∏–≤–∏–¥
         * @param {HTMLSelectElement} selectElement - –≠–ª–µ–º–µ–Ω—Ç select
         */
        function handleSubjectSelectChange(selectElement) {
            const trigSelect = document.getElementById('smart-design-trig');
            const trigContext = getTrigContext(trigSelect ? trigSelect.value : '');

            if (selectElement.value === '__NEW__') {
                if (trigContext === 'ptree') {
                    // –í ptree –º–æ–∂–Ω–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–æ–≤—ã–µ –∫–æ–Ω—Ü–µ–ø—Ç—ã Process
                    const newValue = promptForNewValue('Process (–∫–æ–Ω—Ü–µ–ø—Ç)', subjectExists, false);
                    if (newValue) {
                        const option = document.createElement('option');
                        option.value = '__CUSTOM__:' + newValue;
                        option.textContent = newValue + ' (–Ω–æ–≤—ã–π –∫–æ–Ω—Ü–µ–ø—Ç)';
                        selectElement.insertBefore(option, selectElement.options[2]);
                        selectElement.value = option.value;
                        hideSmartDesignMessage();
                        showSmartDesignMessage('–°–æ–∑–¥–∞—ë—Ç—Å—è –Ω–æ–≤—ã–π –∫–æ–Ω—Ü–µ–ø—Ç Process –≤ ptree. –ù–µ –∑–∞–±—É–¥—å—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å rdf:type, rdfs:label –∏ –¥—Ä—É–≥–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞.', 'info');
                    } else {
                        selectElement.value = '';
                    }
                } else if (trigContext === 'rtree') {
                    // –í rtree –º–æ–∂–Ω–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–æ–≤—ã–µ –∫–æ–Ω—Ü–µ–ø—Ç—ã Executor
                    const newValue = promptForNewValue('Executor (–∫–æ–Ω—Ü–µ–ø—Ç)', subjectExists, false);
                    if (newValue) {
                        const option = document.createElement('option');
                        option.value = '__CUSTOM__:' + newValue;
                        option.textContent = newValue + ' (–Ω–æ–≤—ã–π –∫–æ–Ω—Ü–µ–ø—Ç)';
                        selectElement.insertBefore(option, selectElement.options[2]);
                        selectElement.value = option.value;
                        hideSmartDesignMessage();
                        showSmartDesignMessage('–°–æ–∑–¥–∞—ë—Ç—Å—è –Ω–æ–≤—ã–π –∫–æ–Ω—Ü–µ–ø—Ç Executor –≤ rtree. –ù–µ –∑–∞–±—É–¥—å—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å rdf:type –∏ rdfs:label.', 'info');
                    } else {
                        selectElement.value = '';
                    }
                } else if (trigContext === 'vadProcessDia') {
                    // –í VADProcessDia –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –≤—ã–±–∏—Ä–∞—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∫–æ–Ω—Ü–µ–ø—Ç—ã –∏–∑ ptree
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–∏–∞–ª–æ–≥ –≤—ã–±–æ—Ä–∞ –∫–æ–Ω—Ü–µ–ø—Ç–∞
                    showConceptSelectionDialog(selectElement);
                } else {
                    // –ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ TriG - —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ
                    handleSelectChange(selectElement, 'Subject', subjectExists, false);
                }
            }
        }

        /**
         * –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥ –≤—ã–±–æ—Ä–∞ –∫–æ–Ω—Ü–µ–ø—Ç–∞ –∏–∑ ptree –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–¥–∏–≤–∏–¥–∞ –≤ VADProcessDia
         * @param {HTMLSelectElement} selectElement - –≠–ª–µ–º–µ–Ω—Ç select –¥–ª—è Subject
         */
        function showConceptSelectionDialog(selectElement) {
            // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ü–µ–ø—Ç–æ–≤ Process –∏–∑ ptree
            const processConcepts = getProcessSubjects();

            if (processConcepts.length === 0) {
                showSmartDesignMessage('–í ptree –Ω–µ—Ç –∫–æ–Ω—Ü–µ–ø—Ç–æ–≤ Process. –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –∫–æ–Ω—Ü–µ–ø—Ç –ø—Ä–æ—Ü–µ—Å—Å–∞ –≤ ptree.', 'error');
                selectElement.value = '';
                return;
            }

            // –°–æ–∑–¥–∞—ë–º —Å–ø–∏—Å–æ–∫ –¥–ª—è –≤—ã–±–æ—Ä–∞
            const conceptNames = processConcepts.map(c => c.label).join('\n');
            const selectedConcept = prompt(
                '–í VADProcessDia –Ω–µ–ª—å–∑—è —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–æ–≤—ã–µ –∏–º–µ–Ω–∞ - —Ç–æ–ª—å–∫–æ –∏–Ω–¥–∏–≤–∏–¥—ã —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∫–æ–Ω—Ü–µ–ø—Ç–æ–≤.\n\n' +
                '–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ü–µ–ø—Ç –∏–∑ ptree (–≤–≤–µ–¥–∏—Ç–µ –∏–º—è):\n\n' +
                conceptNames
            );

            if (selectedConcept && selectedConcept.trim()) {
                const trimmed = selectedConcept.trim();
                // –ò—â–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –∫–æ–Ω—Ü–µ–ø—Ç
                const matchingConcept = processConcepts.find(c =>
                    c.label === trimmed ||
                    c.label.toLowerCase() === trimmed.toLowerCase() ||
                    c.uri.endsWith('#' + trimmed) ||
                    c.uri.endsWith('/' + trimmed)
                );

                if (matchingConcept) {
                    // –í—ã–±–∏—Ä–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–Ω—Ü–µ–ø—Ç
                    selectElement.value = matchingConcept.uri;
                    hideSmartDesignMessage();
                    showSmartDesignMessage(
                        `–í—ã–±—Ä–∞–Ω –∫–æ–Ω—Ü–µ–ø—Ç "${matchingConcept.label}". –î–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–¥–∏–≤–∏–¥–∞ –¥–æ–±–∞–≤—å—Ç–µ vad:isSubprocessTrig –ø–µ—Ä–≤—ã–º.`,
                        'info'
                    );
                } else {
                    showSmartDesignMessage(`–ö–æ–Ω—Ü–µ–ø—Ç "${trimmed}" –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ ptree. –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –µ–≥–æ —Ç–∞–º.`, 'error');
                    selectElement.value = '';
                }
            } else {
                selectElement.value = '';
            }
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –∫–æ–Ω—Ü–µ–ø—Ç Process –≤ ptree
         * @param {string} processUri - URI –ø—Ä–æ—Ü–µ—Å—Å–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
         * @returns {boolean} - true –µ—Å–ª–∏ –∫–æ–Ω—Ü–µ–ø—Ç —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ ptree
         */
        function isProcessConceptInPtree(processUri) {
            const processConcepts = getProcessSubjects();
            return processConcepts.some(c => c.uri === processUri);
        }

        // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –¥–ª—è –≤—ã–ø–∞–¥–∞—é—â–∏—Ö —Å–ø–∏—Å–∫–æ–≤ Smart Design
        document.addEventListener('DOMContentLoaded', function() {
            const trigSelect = document.getElementById('smart-design-trig');
            const subjectSelect = document.getElementById('smart-design-subject');
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const predicateSelect = document.getElementById('smart-design-predicate');
            const objectSelect = document.getElementById('smart-design-object');

            if (trigSelect) {
                trigSelect.addEventListener('change', function() {
                    // TriG —Ç–µ–ø–µ—Ä—å –Ω–µ –∏–º–µ–µ—Ç –æ–ø—Ü–∏–∏ __NEW__, –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª–µ–π
                    updateSmartDesignFieldsState();
                    // –ü–µ—Ä–µ–∑–∞–ø–æ–ª–Ω—è–µ–º Subject Type –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ TriG
                    populateSubjectTypeDropdown();
                    // –ü–µ—Ä–µ–∑–∞–ø–æ–ª–Ω—è–µ–º Subject –∏ Predicate –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ TriG (vad:ptree –∏–ª–∏ –Ω–µ—Ç)
                    updateSubjectPredicateDropdowns();
                });
            }

            if (subjectSelect) {
                subjectSelect.addEventListener('change', function() {
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è Subject —Å –ª–æ–≥–∏–∫–æ–π –∫–æ–Ω—Ü–µ–ø—Ç/–∏–Ω–¥–∏–≤–∏–¥
                    handleSubjectSelectChange(this);
                    // –ü—Ä–∏ –≤—ã–±–æ—Ä–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ Subject, –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –µ–≥–æ —Ç–∏–ø
                    autoDetectSubjectType();
                });
            }

            if (subjectTypeSelect) {
                subjectTypeSelect.addEventListener('change', function() {
                    // –ü—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ Subject Type, –æ–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö Subject –∏ Predicate
                    updateSubjectsBySubjectType();
                    updatePredicateBySubjectType();
                });
            }

            if (predicateSelect) {
                predicateSelect.addEventListener('change', function() {
                    // –ü—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ Predicate, –æ–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö Object
                    updateObjectsByPredicate();
                });
            }

            if (objectSelect) {
                objectSelect.addEventListener('change', function() {
                    // –î–ª—è Object —Ä–∞–∑—Ä–µ—à–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã, –Ω–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è - –ª–∏—Ç–µ—Ä–∞–ª—ã
                    handleSelectChange(this, 'Object', () => false, true);
                });
            }
        });

        /**
         * –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–∏–ø –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ Subject –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –µ–≥–æ –≤ Subject Type
         */
        function autoDetectSubjectType() {
            const subjectSelect = document.getElementById('smart-design-subject');
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');

            if (!subjectSelect || !subjectTypeSelect) return;

            const subjectUri = subjectSelect.value;
            if (!subjectUri || subjectUri === '__NEW__' || subjectUri.startsWith('__CUSTOM__:')) {
                // –î–ª—è –Ω–æ–≤–æ–≥–æ Subject –Ω–µ –º–µ–Ω—è–µ–º Subject Type
                return;
            }

            // –ü–æ–ª—É—á–∞–µ–º —Ç–∏–ø—ã –¥–∞–Ω–Ω–æ–≥–æ Subject –∏–∑ –∫—ç—à–∞
            const types = nodeTypesCache[subjectUri] || [];

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π –∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø
            for (const type of types) {
                const prefixedType = getPrefixedName(type, currentPrefixes);
                // –ò—â–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–∏–ø –≤ –≤—ã–ø–∞–¥–∞—é—â–µ–º —Å–ø–∏—Å–∫–µ
                const options = Array.from(subjectTypeSelect.options);
                const matchingOption = options.find(o =>
                    o.value === prefixedType || o.value === type
                );
                if (matchingOption) {
                    subjectTypeSelect.value = matchingOption.value;
                    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ Predicate
                    updatePredicateBySubjectType();
                    return;
                }
            }
        }

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –≤—ã–ø–∞–¥–∞—é—â–µ–≥–æ —Å–ø–∏—Å–∫–∞ (—Å —É—á–µ—Ç–æ–º –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π)
         * @param {string} selectId - ID —ç–ª–µ–º–µ–Ω—Ç–∞ select
         * @returns {string|null} - URI –∏–ª–∏ –∫–∞—Å—Ç–æ–º–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
         */
        function getSmartDesignValue(selectId) {
            const select = document.getElementById(selectId);
            if (!select || !select.value || select.value === '__NEW__') {
                return null;
            }

            if (select.value.startsWith('__CUSTOM__:')) {
                return select.value.substring('__CUSTOM__:'.length);
            }

            return select.value;
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –≤—ã–ø–∞–¥–∞—é—â–µ–º —Å–ø–∏—Å–∫–µ –∫–∞—Å—Ç–æ–º–Ω—ã–º (–Ω–æ–≤—ã–º –ª–∏—Ç–µ—Ä–∞–ª–æ–º)
         * @param {string} selectId - ID —ç–ª–µ–º–µ–Ω—Ç–∞ select
         * @returns {boolean} - true –µ—Å–ª–∏ —ç—Ç–æ –∫–∞—Å—Ç–æ–º–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
         */
        function isSmartDesignValueCustom(selectId) {
            const select = document.getElementById(selectId);
            if (!select || !select.value) {
                return false;
            }
            return select.value.startsWith('__CUSTOM__:');
        }

        /**
         * –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç URI –∏–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è SPARQL –∑–∞–ø—Ä–æ—Å–∞
         * @param {string} value - –ó–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
         * @param {boolean} isLiteral - –Ø–≤–ª—è–µ—Ç—Å—è –ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –ª–∏—Ç–µ—Ä–∞–ª–æ–º (–¥–ª—è –Ω–æ–≤—ã—Ö Object)
         * @returns {string} - –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
         */
        function formatForSparql(value, isLiteral = false) {
            if (!value) return '';

            // –ï—Å–ª–∏ —ç—Ç–æ –ª–∏—Ç–µ—Ä–∞–ª, –∑–∞–∫–ª—é—á–∞–µ–º –≤ –∫–∞–≤—ã—á–∫–∏
            if (isLiteral) {
                // –≠–∫—Ä–∞–Ω–∏—Ä—É–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –≤ —Å—Ç—Ä–æ–∫–µ
                const escaped = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                return `"${escaped}"`;
            }

            // –ï—Å–ª–∏ —ç—Ç–æ –ø–æ–ª–Ω—ã–π URI
            if (value.startsWith('http://') || value.startsWith('https://')) {
                return `<${value}>`;
            }

            // –ï—Å–ª–∏ —ç—Ç–æ –ø—Ä–µ—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–º—è
            if (value.includes(':')) {
                return value;
            }

            // –ï—Å–ª–∏ —ç—Ç–æ –∫–∞—Å—Ç–æ–º–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –±–µ–∑ –ø—Ä–µ—Ñ–∏–∫—Å–∞, –ø—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å vad: –ø—Ä–µ—Ñ–∏–∫—Å
            if (currentPrefixes['vad']) {
                return `vad:${value}`;
            }

            // –í –∫—Ä–∞–π–Ω–µ–º —Å–ª—É—á–∞–µ —Å–æ–∑–¥–∞–µ–º URI
            return `<http://example.org/vad#${value}>`;
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ç—Ä–∏–ø–ª–µ—Ç –≤ RDF –¥–∞–Ω–Ω—ã—Ö
         * @param {string} subjectUri - URI —Å—É–±—ä–µ–∫—Ç–∞
         * @param {string} predicateUri - URI –ø—Ä–µ–¥–∏–∫–∞—Ç–∞
         * @param {string} objectUri - URI –æ–±—ä–µ–∫—Ç–∞
         * @param {string} graphUri - URI –≥—Ä–∞—Ñ–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
         * @returns {boolean}
         */
        function tripleExists(subjectUri, predicateUri, objectUri, graphUri = null) {
            return currentQuads.some(quad => {
                const subjectMatch = quad.subject.value === subjectUri;
                const predicateMatch = quad.predicate.value === predicateUri;
                const objectMatch = quad.object.value === objectUri;
                const graphMatch = !graphUri || (quad.graph && quad.graph.value === graphUri);
                return subjectMatch && predicateMatch && objectMatch && graphMatch;
            });
        }

        /**
         * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç SPARQL INSERT –∑–∞–ø—Ä–æ—Å
         * @param {string} trigUri - URI TriG –≥—Ä–∞—Ñ–∞
         * @param {string} subjectUri - URI —Å—É–±—ä–µ–∫—Ç–∞
         * @param {string} predicateUri - URI –ø—Ä–µ–¥–∏–∫–∞—Ç–∞
         * @param {string} objectUri - URI –æ–±—ä–µ–∫—Ç–∞
         * @param {boolean} isObjectLiteral - –Ø–≤–ª—è–µ—Ç—Å—è –ª–∏ Object –ª–∏—Ç–µ—Ä–∞–ª–æ–º
         * @returns {string} - SPARQL INSERT –∑–∞–ø—Ä–æ—Å
         */
        function generateInsertSparql(trigUri, subjectUri, predicateUri, objectUri, isObjectLiteral = false) {
            const prefixDeclarations = generateSparqlPrefixes(currentPrefixes);

            const subject = formatForSparql(subjectUri);
            const predicate = formatForSparql(predicateUri);
            const object = formatForSparql(objectUri, isObjectLiteral);
            const graph = formatForSparql(trigUri);

            return `${prefixDeclarations}INSERT DATA {
    GRAPH ${graph} {
        ${subject} ${predicate} ${object} .
    }
}`;
        }

        /**
         * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç SPARQL DELETE –∑–∞–ø—Ä–æ—Å
         * @param {string} trigUri - URI TriG –≥—Ä–∞—Ñ–∞
         * @param {string} subjectUri - URI —Å—É–±—ä–µ–∫—Ç–∞
         * @param {string} predicateUri - URI –ø—Ä–µ–¥–∏–∫–∞—Ç–∞
         * @param {string} objectUri - URI –æ–±—ä–µ–∫—Ç–∞
         * @param {boolean} isObjectLiteral - –Ø–≤–ª—è–µ—Ç—Å—è –ª–∏ Object –ª–∏—Ç–µ—Ä–∞–ª–æ–º
         * @returns {string} - SPARQL DELETE –∑–∞–ø—Ä–æ—Å
         */
        function generateDeleteSparql(trigUri, subjectUri, predicateUri, objectUri, isObjectLiteral = false) {
            const prefixDeclarations = generateSparqlPrefixes(currentPrefixes);

            const subject = formatForSparql(subjectUri);
            const predicate = formatForSparql(predicateUri);
            const object = formatForSparql(objectUri, isObjectLiteral);
            const graph = formatForSparql(trigUri);

            return `${prefixDeclarations}DELETE DATA {
    GRAPH ${graph} {
        ${subject} ${predicate} ${object} .
    }
}`;
        }

        /**
         * –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç URI –∏–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è SPARQL –∑–∞–ø—Ä–æ—Å–∞ –≤ –ø—Ä–µ—Ñ–∏–∫—Å–Ω–æ–π —Ñ–æ—Ä–º–µ (prefix:name)
         * @param {string} value - –ó–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
         * @param {boolean} isLiteral - –Ø–≤–ª—è–µ—Ç—Å—è –ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –ª–∏—Ç–µ—Ä–∞–ª–æ–º (–¥–ª—è –Ω–æ–≤—ã—Ö Object)
         * @returns {string} - –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –ø—Ä–µ—Ñ–∏–∫—Å–Ω–æ–π —Ñ–æ—Ä–º–µ
         */
        function formatForSparqlWithPrefix(value, isLiteral = false) {
            if (!value) return '';

            // –ï—Å–ª–∏ —ç—Ç–æ –ª–∏—Ç–µ—Ä–∞–ª, –∑–∞–∫–ª—é—á–∞–µ–º –≤ –∫–∞–≤—ã—á–∫–∏
            if (isLiteral) {
                // –≠–∫—Ä–∞–Ω–∏—Ä—É–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –≤ —Å—Ç—Ä–æ–∫–µ
                const escaped = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                return `"${escaped}"`;
            }

            // –ï—Å–ª–∏ —ç—Ç–æ –ø–æ–ª–Ω—ã–π URI - –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –ø—Ä–µ—Ñ–∏–∫—Å–Ω—É—é —Ñ–æ—Ä–º—É
            if (value.startsWith('http://') || value.startsWith('https://')) {
                const prefixed = getPrefixedName(value, currentPrefixes);
                // –ï—Å–ª–∏ —É–¥–∞–ª–æ—Å—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤ –ø—Ä–µ—Ñ–∏–∫—Å–Ω—É—é —Ñ–æ—Ä–º—É
                if (prefixed !== value && prefixed.includes(':')) {
                    return prefixed;
                }
                // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ —É–≥–ª–æ–≤—ã—Ö —Å–∫–æ–±–∫–∞—Ö
                return `<${value}>`;
            }

            // –ï—Å–ª–∏ —ç—Ç–æ —É–∂–µ –ø—Ä–µ—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–º—è
            if (value.includes(':')) {
                return value;
            }

            // –ï—Å–ª–∏ —ç—Ç–æ –∫–∞—Å—Ç–æ–º–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –±–µ–∑ –ø—Ä–µ—Ñ–∏–∫—Å–∞, –ø—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å vad: –ø—Ä–µ—Ñ–∏–∫—Å
            if (currentPrefixes['vad']) {
                return `vad:${value}`;
            }

            // –í –∫—Ä–∞–π–Ω–µ–º —Å–ª—É—á–∞–µ —Å–æ–∑–¥–∞–µ–º URI
            return `<http://example.org/vad#${value}>`;
        }

        /**
         * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç SPARQL INSERT –∑–∞–ø—Ä–æ—Å —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤ (prefix:name)
         * @param {string} trigUri - URI TriG –≥—Ä–∞—Ñ–∞
         * @param {string} subjectUri - URI —Å—É–±—ä–µ–∫—Ç–∞
         * @param {string} predicateUri - URI –ø—Ä–µ–¥–∏–∫–∞—Ç–∞
         * @param {string} objectUri - URI –æ–±—ä–µ–∫—Ç–∞
         * @param {boolean} isObjectLiteral - –Ø–≤–ª—è–µ—Ç—Å—è –ª–∏ Object –ª–∏—Ç–µ—Ä–∞–ª–æ–º
         * @returns {string} - SPARQL INSERT –∑–∞–ø—Ä–æ—Å —Å –ø—Ä–µ—Ñ–∏–∫—Å–∞–º–∏
         */
        function generateInsertSparqlWithPrefix(trigUri, subjectUri, predicateUri, objectUri, isObjectLiteral = false) {
            const prefixDeclarations = generateSparqlPrefixes(currentPrefixes);

            const subject = formatForSparqlWithPrefix(subjectUri);
            const predicate = formatForSparqlWithPrefix(predicateUri);
            const object = formatForSparqlWithPrefix(objectUri, isObjectLiteral);
            const graph = formatForSparqlWithPrefix(trigUri);

            return `${prefixDeclarations}INSERT DATA {
    GRAPH ${graph} {
        ${subject} ${predicate} ${object} .
    }
}`;
        }

        /**
         * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–°–æ–∑–¥–∞—Ç—å SPARQL (prefix)" - –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç INSERT SPARQL –∑–∞–ø—Ä–æ—Å —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤
         */
        function smartDesignCreateWithPrefix() {
            hideSmartDesignMessage();

            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ New TriG, —Ç.–∫. —Å–æ–∑–¥–∞–µ–º –æ–±—ã—á–Ω—ã–π SPARQL –∑–∞–ø—Ä–æ—Å
            isNewTrigQuery = false;
            updateSimpleTripleButtonState();

            const trigValue = getSmartDesignValue('smart-design-trig');
            const subjectValue = getSmartDesignValue('smart-design-subject');
            const predicateValue = getSmartDesignValue('smart-design-predicate');
            const objectValue = getSmartDesignValue('smart-design-object');
            const isObjectLiteral = isSmartDesignValueCustom('smart-design-object');

            if (!trigValue || !subjectValue || !predicateValue || !objectValue) {
                showSmartDesignMessage('–û—à–∏–±–∫–∞: –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ —á–µ—Ç—ã—Ä–µ –ø–æ–ª—è (TriG, Subject, Predicate, Object)', 'error');
                return;
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–∞–∫ –ø–æ–ª–Ω—ã–µ URI, —Ç–∞–∫ –∏ prefixed names)
            const duplicate = findDuplicateTriple(subjectValue, predicateValue, objectValue);
            if (duplicate) {
                showSmartDesignMessage(`–û—à–∏–±–∫–∞: –¢—Ä–∏–ø–ª–µ—Ç —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ –≥—Ä–∞—Ñ–µ "${duplicate.graphLabel}"`, 'error');
                return;
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ TriG –ù–ï vad:ptree, –Ω–æ —Å—É–±—ä–µ–∫—Ç vad:Process –∏ –ø—Ä–µ–¥–∏–∫–∞—Ç –∏–∑ PTREE_PREDICATES - –æ—à–∏–±–∫–∞
            const isPtreeTrig = trigValue === 'vad:ptree' ||
                               trigValue === 'http://example.org/vad#ptree' ||
                               trigValue.endsWith('#ptree');

            if (!isPtreeTrig) {
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º subjectValue –≤ URI –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–∏–ø–∞
                let subjectUri = subjectValue;
                for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                    if (subjectValue.startsWith(prefix + ':')) {
                        subjectUri = namespace + subjectValue.substring(prefix.length + 1);
                        break;
                    }
                }

                const subjectIsProcess = isSubjectVadProcess(subjectUri);
                const predicateIsPtree = isPtreePredicate(predicateValue);

                if (subjectIsProcess && predicateIsPtree) {
                    const ptreePredicatesList = PTREE_PREDICATES
                        .filter(p => !p.startsWith('http'))
                        .join(', ');
                    showSmartDesignMessage(
                        `–û—à–∏–±–∫–∞: –î–ª—è —Å—É–±—ä–µ–∫—Ç–∞ —Ç–∏–ø–∞ vad:Process —Å –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–º –∏–∑ —Å–ø–∏—Å–∫–∞ PTREE_PREDICATES ` +
                        `(${ptreePredicatesList}) —Ç—Ä–∏–ø–ª–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω –≤ –≥—Ä–∞—Ñ vad:ptree, –∞ –Ω–µ –≤ "${getPrefixedName(trigValue, currentPrefixes) || trigValue}"`,
                        'error'
                    );
                    return;
                }
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç—Ä–∏–ø–ª–µ—Ç –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –≤ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –≥—Ä–∞—Ñ (–±–µ–∑ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è)
            // –ï—Å–ª–∏ —Å—É–±—ä–µ–∫—Ç —è–≤–ª—è–µ—Ç—Å—è vad:TypeProcess –∏ –ø—Ä–µ–¥–∏–∫–∞—Ç –∏–∑ PTREE_PREDICATES –∏–ª–∏ rdf:type vad:TypeProcess,
            // —Ç—Ä–∏–ø–ª–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω —Ç–æ–ª—å–∫–æ –≤ vad:ptree
            const expectedTargetGraph = determineTargetGraph(subjectValue, predicateValue, trigValue, objectValue);

            // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –æ–±–∞ –∑–Ω–∞—á–µ–Ω–∏—è –∫ prefixed name –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
            const trigLabel = getPrefixedName(trigValue, currentPrefixes) || trigValue;
            const expectedLabel = getPrefixedName(expectedTargetGraph, currentPrefixes) || expectedTargetGraph;

            if (expectedLabel !== trigLabel) {
                showSmartDesignMessage(
                    `–û—à–∏–±–∫–∞: –î–∞–Ω–Ω—ã–π —Ç—Ä–∏–ø–ª–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω –≤ –≥—Ä–∞—Ñ "${expectedLabel}", –∞ –Ω–µ –≤ "${trigLabel}". ` +
                    `–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π TriG.`,
                    'error'
                );
                return;
            }

            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º SPARQL —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤
            const sparqlQuery = generateInsertSparqlWithPrefix(trigValue, subjectValue, predicateValue, objectValue, isObjectLiteral);

            const resultTextarea = document.getElementById('result-sparql-query');
            if (resultTextarea) {
                resultTextarea.value = sparqlQuery;
            }

            // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—à–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
            showSmartDesignMessage('INSERT SPARQL –∑–∞–ø—Ä–æ—Å —Å prefix:name —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω.', 'success');
        }

        /**
         * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–°–æ–∑–¥–∞—Ç—å" - –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç INSERT SPARQL –∑–∞–ø—Ä–æ—Å
         */
        function smartDesignCreate() {
            hideSmartDesignMessage();

            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ New TriG, —Ç.–∫. —Å–æ–∑–¥–∞–µ–º –æ–±—ã—á–Ω—ã–π SPARQL –∑–∞–ø—Ä–æ—Å
            isNewTrigQuery = false;
            updateSimpleTripleButtonState();

            const trigValue = getSmartDesignValue('smart-design-trig');
            const subjectValue = getSmartDesignValue('smart-design-subject');
            const predicateValue = getSmartDesignValue('smart-design-predicate');
            const objectValue = getSmartDesignValue('smart-design-object');
            const isObjectLiteral = isSmartDesignValueCustom('smart-design-object');

            if (!trigValue || !subjectValue || !predicateValue || !objectValue) {
                showSmartDesignMessage('–û—à–∏–±–∫–∞: –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ —á–µ—Ç—ã—Ä–µ –ø–æ–ª—è (TriG, Subject, Predicate, Object)', 'error');
                return;
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–∞–∫ –ø–æ–ª–Ω—ã–µ URI, —Ç–∞–∫ –∏ prefixed names)
            const duplicate = findDuplicateTriple(subjectValue, predicateValue, objectValue);
            if (duplicate) {
                showSmartDesignMessage(`–û—à–∏–±–∫–∞: –¢—Ä–∏–ø–ª–µ—Ç —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ –≥—Ä–∞—Ñ–µ "${duplicate.graphLabel}"`, 'error');
                return;
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ TriG –ù–ï vad:ptree, –Ω–æ —Å—É–±—ä–µ–∫—Ç vad:Process –∏ –ø—Ä–µ–¥–∏–∫–∞—Ç –∏–∑ PTREE_PREDICATES - –æ—à–∏–±–∫–∞
            const isPtreeTrig = trigValue === 'vad:ptree' ||
                               trigValue === 'http://example.org/vad#ptree' ||
                               trigValue.endsWith('#ptree');

            if (!isPtreeTrig) {
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º subjectValue –≤ URI –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–∏–ø–∞
                let subjectUri = subjectValue;
                for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                    if (subjectValue.startsWith(prefix + ':')) {
                        subjectUri = namespace + subjectValue.substring(prefix.length + 1);
                        break;
                    }
                }

                const subjectIsProcess = isSubjectVadProcess(subjectUri);
                const predicateIsPtree = isPtreePredicate(predicateValue);

                if (subjectIsProcess && predicateIsPtree) {
                    const ptreePredicatesList = PTREE_PREDICATES
                        .filter(p => !p.startsWith('http'))
                        .join(', ');
                    showSmartDesignMessage(
                        `–û—à–∏–±–∫–∞: –î–ª—è —Å—É–±—ä–µ–∫—Ç–∞ —Ç–∏–ø–∞ vad:Process —Å –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–º –∏–∑ —Å–ø–∏—Å–∫–∞ PTREE_PREDICATES ` +
                        `(${ptreePredicatesList}) —Ç—Ä–∏–ø–ª–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω –≤ –≥—Ä–∞—Ñ vad:ptree, –∞ –Ω–µ –≤ "${getPrefixedName(trigValue, currentPrefixes) || trigValue}"`,
                        'error'
                    );
                    return;
                }
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç—Ä–∏–ø–ª–µ—Ç –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –≤ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –≥—Ä–∞—Ñ (–±–µ–∑ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è)
            // –ï—Å–ª–∏ —Å—É–±—ä–µ–∫—Ç —è–≤–ª—è–µ—Ç—Å—è vad:TypeProcess –∏ –ø—Ä–µ–¥–∏–∫–∞—Ç –∏–∑ PTREE_PREDICATES –∏–ª–∏ rdf:type vad:TypeProcess,
            // —Ç—Ä–∏–ø–ª–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω —Ç–æ–ª—å–∫–æ –≤ vad:ptree
            const expectedTargetGraph = determineTargetGraph(subjectValue, predicateValue, trigValue, objectValue);

            // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –æ–±–∞ –∑–Ω–∞—á–µ–Ω–∏—è –∫ prefixed name –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
            const trigLabel = getPrefixedName(trigValue, currentPrefixes) || trigValue;
            const expectedLabel = getPrefixedName(expectedTargetGraph, currentPrefixes) || expectedTargetGraph;

            if (expectedLabel !== trigLabel) {
                showSmartDesignMessage(
                    `–û—à–∏–±–∫–∞: –î–∞–Ω–Ω—ã–π —Ç—Ä–∏–ø–ª–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω –≤ –≥—Ä–∞—Ñ "${expectedLabel}", –∞ –Ω–µ –≤ "${trigLabel}". ` +
                    `–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π TriG.`,
                    'error'
                );
                return;
            }

            const sparqlQuery = generateInsertSparql(trigValue, subjectValue, predicateValue, objectValue, isObjectLiteral);

            const resultTextarea = document.getElementById('result-sparql-query');
            if (resultTextarea) {
                resultTextarea.value = sparqlQuery;
            }

            // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—à–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
            let successMessage = 'INSERT SPARQL –∑–∞–ø—Ä–æ—Å —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω';
            showSmartDesignMessage(successMessage, 'success');
        }

        /**
         * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–£–¥–∞–ª–∏—Ç—å —Ç—Ä–∏–ø–ª–µ—Ç" - –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç DELETE SPARQL –∑–∞–ø—Ä–æ—Å —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è
         */
        function smartDesignDelete() {
            hideSmartDesignMessage();

            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ New TriG, —Ç.–∫. —Å–æ–∑–¥–∞–µ–º –æ–±—ã—á–Ω—ã–π SPARQL –∑–∞–ø—Ä–æ—Å
            isNewTrigQuery = false;
            updateSimpleTripleButtonState();

            const trigValue = getSmartDesignValue('smart-design-trig');
            const subjectValue = getSmartDesignValue('smart-design-subject');
            const predicateValue = getSmartDesignValue('smart-design-predicate');
            const objectValue = getSmartDesignValue('smart-design-object');
            const isObjectLiteral = isSmartDesignValueCustom('smart-design-object');

            if (!trigValue || !subjectValue || !predicateValue || !objectValue) {
                showSmartDesignMessage('–û—à–∏–±–∫–∞: –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ —á–µ—Ç—ã—Ä–µ –ø–æ–ª—è (TriG, Subject, Predicate, Object)', 'error');
                return;
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ç—Ä–∏–ø–ª–µ—Ç–∞
            // –ù—É–∂–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –≤ –ø–æ–ª–Ω—ã–µ URI –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
            let subjectUri = subjectValue;
            let predicateUri = predicateValue;
            let objectUri = objectValue;
            let graphUri = trigValue;

            // –ï—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø—Ä–µ—Ñ–∏–∫—Å, –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –ø–æ–ª–Ω—ã–π URI
            for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                if (subjectValue.startsWith(prefix + ':')) {
                    subjectUri = namespace + subjectValue.substring(prefix.length + 1);
                }
                if (predicateValue.startsWith(prefix + ':')) {
                    predicateUri = namespace + predicateValue.substring(prefix.length + 1);
                }
                if (objectValue.startsWith(prefix + ':')) {
                    objectUri = namespace + objectValue.substring(prefix.length + 1);
                }
                if (trigValue.startsWith(prefix + ':')) {
                    graphUri = namespace + trigValue.substring(prefix.length + 1);
                }
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ç—Ä–∏–ø–ª–µ—Ç–∞ –≤ –¥–∞–Ω–Ω—ã—Ö
            const exists = tripleExists(subjectUri, predicateUri, objectUri, graphUri);

            if (!exists) {
                showSmartDesignMessage('–û—à–∏–±–∫–∞: –£–∫–∞–∑–∞–Ω–Ω—ã–π —Ç—Ä–∏–ø–ª–µ—Ç (—É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ) –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ RDF –¥–∞–Ω–Ω—ã—Ö', 'error');
                return;
            }

            const sparqlQuery = generateDeleteSparql(trigValue, subjectValue, predicateValue, objectValue, isObjectLiteral);

            const resultTextarea = document.getElementById('result-sparql-query');
            if (resultTextarea) {
                resultTextarea.value = sparqlQuery;
            }

            showSmartDesignMessage('DELETE SPARQL –∑–∞–ø—Ä–æ—Å —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω', 'success');
        }

        /**
         * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–û—á–∏—Å—Ç–∏—Ç—å" - –æ—á–∏—â–∞–µ—Ç –≤—Å–µ –ø–æ–ª—è
         */
        function smartDesignClear() {
            hideSmartDesignMessage();

            const trigSelect = document.getElementById('smart-design-trig');
            const subjectSelect = document.getElementById('smart-design-subject');
            const predicateSelect = document.getElementById('smart-design-predicate');
            const objectSelect = document.getElementById('smart-design-object');
            const resultTextarea = document.getElementById('result-sparql-query');

            if (trigSelect) trigSelect.value = '';
            if (subjectSelect) subjectSelect.value = '';
            if (predicateSelect) predicateSelect.value = '';
            if (objectSelect) objectSelect.value = '';
            if (resultTextarea) resultTextarea.value = '';

            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ New TriG
            isNewTrigQuery = false;
            updateSimpleTripleButtonState();

            // –ü–µ—Ä–µ–∑–∞–ø–æ–ª–Ω—è–µ–º –≤—ã–ø–∞–¥–∞—é—â–∏–µ —Å–ø–∏—Å–∫–∏ (—É–¥–∞–ª—è–µ–º –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ –∫–∞—Å—Ç–æ–º–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è)
            populateSmartDesignDropdowns();

            showSmartDesignMessage('–í—Å–µ –ø–æ–ª—è –æ—á–∏—â–µ–Ω—ã', 'info');
        }

        /**
         * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ü—Ä–∏–º–µ–Ω–∏—Ç—å SPARQL" - –ø—Ä–∏–º–µ–Ω—è–µ—Ç –∑–∞–ø—Ä–æ—Å –∫ RDF –¥–∞–Ω–Ω—ã–º
         */
        async function smartDesignApply() {
            hideResultSparqlMessage();

            const resultTextarea = document.getElementById('result-sparql-query');
            if (!resultTextarea || !resultTextarea.value.trim()) {
                showResultSparqlMessage('–û—à–∏–±–∫–∞: –°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ SPARQL –∑–∞–ø—Ä–æ—Å (–Ω–∞–∂–º–∏—Ç–µ "–°–æ–∑–¥–∞—Ç—å SPARQL" –∏–ª–∏ "–£–¥–∞–ª–∏—Ç—å —Ç—Ä–∏–ø–ª–µ—Ç")', 'error');
                return;
            }

            const sparqlQuery = resultTextarea.value.trim();
            const rdfInput = document.getElementById('rdf-input');

            if (!rdfInput) {
                showResultSparqlMessage('–û—à–∏–±–∫–∞: –ù–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ–ª–µ RDF –¥–∞–Ω–Ω—ã—Ö', 'error');
                return;
            }

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –∑–∞–ø—Ä–æ—Å–∞ (INSERT –∏–ª–∏ DELETE)
            const isInsert = sparqlQuery.includes('INSERT DATA');
            const isDelete = sparqlQuery.includes('DELETE DATA');

            if (!isInsert && !isDelete) {
                showResultSparqlMessage('–û—à–∏–±–∫–∞: –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø SPARQL –∑–∞–ø—Ä–æ—Å–∞', 'error');
                return;
            }

            // –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è URI/–ø—Ä–µ—Ñ–∏–∫—Å–Ω–æ–≥–æ –∏–º–µ–Ω–∏ (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç <uri> –∏ prefix:name)
            const uriPattern = '(?:<[^>]+>|[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z0-9_-]+)';
            // –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –æ–±—ä–µ–∫—Ç–∞ (–º–æ–∂–µ—Ç –±—ã—Ç—å URI, –ø—Ä–µ—Ñ–∏–∫—Å–Ω–æ–µ –∏–º—è –∏–ª–∏ –ª–∏—Ç–µ—Ä–∞–ª –≤ –∫–∞–≤—ã—á–∫–∞—Ö)
            const objectPattern = '(?:<[^>]+>|[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z0-9_-]+|"[^"]*")';

            // –ò–∑–≤–ª–µ–∫–∞–µ–º GRAPH –∏ —Ç—Ä–∏–ø–ª–µ—Ç—ã –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
            const graphMatch = sparqlQuery.match(new RegExp(`GRAPH\\s+(${uriPattern})\\s*\\{([\\s\\S]*?)\\}`, 'i'));

            if (!graphMatch) {
                showResultSparqlMessage('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å GRAPH –≤ SPARQL –∑–∞–ø—Ä–æ—Å–µ', 'error');
                return;
            }

            const graphRef = graphMatch[1];
            const graphBody = graphMatch[2];

            // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç—Ä–∏–ø–ª–µ—Ç—ã –∏–∑ —Ç–µ–ª–∞ GRAPH
            const triplePattern = new RegExp(`(${uriPattern})\\s+(${uriPattern})\\s+(${objectPattern})\\s*\\.`, 'g');
            const triples = [];
            let tripleMatch;
            while ((tripleMatch = triplePattern.exec(graphBody)) !== null) {
                triples.push({
                    subject: tripleMatch[1],
                    predicate: tripleMatch[2],
                    object: tripleMatch[3]
                });
            }

            if (triples.length === 0) {
                showResultSparqlMessage('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ç—Ä–∏–ø–ª–µ—Ç—ã –≤ SPARQL –∑–∞–ø—Ä–æ—Å–µ', 'error');
                return;
            }

            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º URI/–ø—Ä–µ—Ñ–∏–∫—Å –≤ –ø—Ä–µ—Ñ–∏–∫—Å–Ω—É—é —Ñ–æ—Ä–º—É –¥–ª—è RDF —Ç–µ–∫—Å—Ç–∞
            function toPrefixed(ref) {
                if (ref.startsWith('<') && ref.endsWith('>')) {
                    // –ü–æ–ª–Ω—ã–π URI - –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ –ø—Ä–µ—Ñ–∏–∫—Å–Ω—É—é —Ñ–æ—Ä–º—É
                    const cleanUri = ref.slice(1, -1);
                    return getPrefixedName(cleanUri, currentPrefixes);
                }
                // –£–∂–µ –≤ –ø—Ä–µ—Ñ–∏–∫—Å–Ω–æ–π —Ñ–æ—Ä–º–µ –∏–ª–∏ –ª–∏—Ç–µ—Ä–∞–ª
                return ref;
            }

            const graphPrefixed = toPrefixed(graphRef);

            // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π RDF —Ç–µ–∫—Å—Ç
            let currentRdfText = rdfInput.value;

            if (isInsert) {
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç—Ä–∏–ø–ª–µ—Ç–∞ (–∫—Ä–æ–º–µ —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ TriG)
                if (!isNewTrigQuery) {
                    const duplicateTriples = [];
                    for (const triple of triples) {
                        const subjectPrefixed = toPrefixed(triple.subject);
                        const predicatePrefixed = toPrefixed(triple.predicate);
                        const objectPrefixed = toPrefixed(triple.object);

                        const duplicate = findDuplicateTriple(subjectPrefixed, predicatePrefixed, objectPrefixed);
                        if (duplicate) {
                            duplicateTriples.push({
                                triple: `${subjectPrefixed} ${predicatePrefixed} ${objectPrefixed}`,
                                graph: duplicate.graphLabel
                            });
                        }
                    }

                    // –ï—Å–ª–∏ –µ—Å—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—à–∏–±–∫—É
                    if (duplicateTriples.length > 0) {
                        const duplicateMessages = duplicateTriples.map(d => `"${d.triple}" (–≤ –≥—Ä–∞—Ñ–µ "${d.graph}")`).join(', ');
                        showResultSparqlMessage(`–û—à–∏–±–∫–∞: –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –¥—É–±–ª–∏–∫–∞—Ç—ã —Ç—Ä–∏–ø–ª–µ—Ç–æ–≤: ${duplicateMessages}`, 'error');
                        return;
                    }
                }

                // –§–æ—Ä–º–∏—Ä—É–µ–º —Ç—Ä–∏–ø–ª–µ—Ç—ã –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏
                const triplesForInsert = triples.map(t => {
                    const subjectPrefixed = toPrefixed(t.subject);
                    const predicatePrefixed = toPrefixed(t.predicate);
                    const objectPrefixed = toPrefixed(t.object);
                    return `    ${subjectPrefixed} ${predicatePrefixed} ${objectPrefixed} .`;
                }).join('\n');

                // –ò—â–µ–º —Å–µ–∫—Ü–∏—é –≥—Ä–∞—Ñ–∞ –∏ –¥–æ–±–∞–≤–ª—è–µ–º —Ç—Ä–∏–ø–ª–µ—Ç—ã –í –ö–û–ù–ï–¶ –±–ª–æ–∫–∞ (–ø–µ—Ä–µ–¥ –∑–∞–∫—Ä—ã–≤–∞—é—â–µ–π —Å–∫–æ–±–∫–æ–π)
                let graphEndPattern = new RegExp(`(${escapeRegex(graphPrefixed)}\\s*\\{[^}]*)(\\s*\\})`, 's');
                let graphTextMatch = currentRdfText.match(graphEndPattern);

                if (!graphTextMatch) {
                    // –ü–æ–ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –ø–æ –ø–æ–ª–Ω–æ–º—É URI (–µ—Å–ª–∏ –≤ RDF —Ç–µ–∫—Å—Ç–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø–æ–ª–Ω—ã–π URI)
                    graphEndPattern = new RegExp(`(${escapeRegex(graphRef)}\\s*\\{[^}]*)(\\s*\\})`, 's');
                    graphTextMatch = currentRdfText.match(graphEndPattern);
                }

                if (graphTextMatch) {
                    // –î–æ–±–∞–≤–ª—è–µ–º —Ç—Ä–∏–ø–ª–µ—Ç—ã –≤ –ö–û–ù–ï–¶ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –≥—Ä–∞—Ñ–∞ (–ø–µ—Ä–µ–¥ –∑–∞–∫—Ä—ã–≤–∞—é—â–µ–π —Å–∫–æ–±–∫–æ–π)
                    currentRdfText = currentRdfText.replace(graphEndPattern, `$1\n${triplesForInsert}$2`);
                } else {
                    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –≥—Ä–∞—Ñ —Å —Ç—Ä–∏–ø–ª–µ—Ç–∞–º–∏
                    const newGraph = `\n\n${graphPrefixed} {\n${triplesForInsert}\n}`;
                    currentRdfText += newGraph;
                }

                rdfInput.value = currentRdfText;

                // –ü–µ—Ä–µ—Ä–∞–∑–±–∏—Ä–∞–µ–º RDF –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è currentQuads –∏ –∫—ç—à–∞ —Ç–∏–ø–æ–≤
                // –≠—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±–Ω–∞—Ä—É–∂–∏–≤–∞—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã –ø—Ä–∏ –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏—è—Ö
                await reparseRdfData();

                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ New TriG –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è,
                // —á—Ç–æ–±—ã –ø—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–º –Ω–∞–∂–∞—Ç–∏–∏ —Ä–∞–±–æ—Ç–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã
                isNewTrigQuery = false;
                updateSimpleTripleButtonState();

                showResultSparqlMessage('–¢—Ä–∏–ø–ª–µ—Ç—ã —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ RDF –¥–∞–Ω–Ω—ã–µ. –ù–∞–∂–º–∏—Ç–µ "–ü–æ–∫–∞–∑–∞—Ç—å" –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≥—Ä–∞—Ñ–∞.', 'success');

            } else if (isDelete) {
                // –£–¥–∞–ª—è–µ–º —Ç—Ä–∏–ø–ª–µ—Ç—ã –∏–∑ RDF –¥–∞–Ω–Ω—ã—Ö
                let wasDeleted = false;
                let newRdfText = currentRdfText;

                for (const triple of triples) {
                    const subjectPrefixed = toPrefixed(triple.subject);
                    const predicatePrefixed = toPrefixed(triple.predicate);
                    const objectPrefixed = toPrefixed(triple.object);

                    // –ü—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –∏ —É–¥–∞–ª–∏—Ç—å –≤ –ø—Ä–µ—Ñ–∏–∫—Å–Ω–æ–π —Ñ–æ—Ä–º–µ
                    let deletePattern = new RegExp(`\\s*${escapeRegex(subjectPrefixed)}\\s+${escapeRegex(predicatePrefixed)}\\s+${escapeRegex(objectPrefixed)}\\s*[;.]`, 'g');
                    const prevText = newRdfText;
                    newRdfText = newRdfText.replace(deletePattern, '');

                    if (newRdfText === prevText) {
                        // –ü–æ–ø—Ä–æ–±—É–µ–º —Å –∏—Å—Ö–æ–¥–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ (–Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –≤ RDF —Ç–µ–∫—Å—Ç –ø–æ–ø–∞–ª–∏ –ø–æ–ª–Ω—ã–µ URI)
                        deletePattern = new RegExp(`\\s*${escapeRegex(triple.subject)}\\s+${escapeRegex(triple.predicate)}\\s+${escapeRegex(triple.object)}\\s*[;.]`, 'g');
                        newRdfText = newRdfText.replace(deletePattern, '');
                    }

                    if (newRdfText !== prevText) {
                        wasDeleted = true;
                    }
                }

                if (!wasDeleted) {
                    showResultSparqlMessage('–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: –¢—Ä–∏–ø–ª–µ—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–∏ RDF –¥–∞–Ω–Ω—ã—Ö', 'info');
                } else {
                    rdfInput.value = newRdfText;

                    // –ü–µ—Ä–µ—Ä–∞–∑–±–∏—Ä–∞–µ–º RDF –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è currentQuads –∏ –∫—ç—à–∞ —Ç–∏–ø–æ–≤
                    await reparseRdfData();

                    showResultSparqlMessage('–¢—Ä–∏–ø–ª–µ—Ç—ã —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω—ã –∏–∑ RDF –¥–∞–Ω–Ω—ã—Ö. –ù–∞–∂–º–∏—Ç–µ "–ü–æ–∫–∞–∑–∞—Ç—å" –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≥—Ä–∞—Ñ–∞.', 'success');
                }
            }

            // –ü–æ–ª—è Smart Design –∏ Result in SPARQL –Ω–µ –æ—á–∏—â–∞—é—Ç—Å—è –ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è
            // –û—á–∏—Å—Ç–∫–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Ç–æ–ª—å–∫–æ –ø–æ –∫–Ω–æ–ø–∫–µ "–û—á–∏—Å—Ç–∏—Ç—å"
        }

        /**
         * –ü–µ—Ä–µ—Ä–∞–∑–±–∏—Ä–∞–µ—Ç RDF –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –ø–æ–ª—è –∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç currentQuads –∏ nodeTypesCache.
         * –≠—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∏–ª–∏ —É–¥–∞–ª–µ–Ω–∏—è —Ç—Ä–∏–ø–ª–µ—Ç–æ–≤, —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã
         * —Ä–∞–±–æ—Ç–∞–ª–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π.
         * @returns {Promise<boolean>} - true –µ—Å–ª–∏ –ø–∞—Ä—Å–∏–Ω–≥ –ø—Ä–æ—à–µ–ª —É—Å–ø–µ—à–Ω–æ
         */
        async function reparseRdfData() {
            try {
                const rdfInput = document.getElementById('rdf-input');
                if (!rdfInput || !rdfInput.value.trim()) return false;

                const inputFormat = document.getElementById('input-format').value;
                const parser = new N3.Parser({ format: inputFormat });
                const quads = [];
                let prefixes = {};

                await new Promise((resolve, reject) => {
                    parser.parse(rdfInput.value, (error, quad, parsedPrefixes) => {
                        if (error) {
                            reject(error);
                            return;
                        }
                        if (quad) {
                            quads.push(quad);
                        } else {
                            if (parsedPrefixes) {
                                prefixes = parsedPrefixes;
                            }
                            resolve();
                        }
                    });
                });

                // –û–±–Ω–æ–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
                currentQuads = quads;
                currentPrefixes = prefixes;

                // –ü–µ—Ä–µ—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∫—ç—à —Ç–∏–ø–æ–≤ —É–∑–ª–æ–≤
                buildNodeTypesCache(currentQuads, currentPrefixes);

                // –û–±–Ω–æ–≤–ª—è–µ–º –∏–µ—Ä–∞—Ä—Ö–∏—é TriG –µ—Å–ª–∏ –≤ —Ä–µ–∂–∏–º–µ VAD TriG
                if (currentMode === 'vad-trig') {
                    const hierarchyResult = parseTriGHierarchy(quads, prefixes);
                    if (hierarchyResult.valid) {
                        trigHierarchy = hierarchyResult.hierarchy;
                    }
                }

                return true;
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ä–∞–∑–±–æ—Ä–µ RDF –¥–∞–Ω–Ω—ã—Ö:', error);
                return false;
            }
        }

        /**
         * –≠–∫—Ä–∞–Ω–∏—Ä—É–µ—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã —Ä–µ–≥—É–ª—è—Ä–Ω–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è
         * @param {string} str - –°—Ç—Ä–æ–∫–∞ –¥–ª—è —ç–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
         * @returns {string} - –≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞
         */
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        /**
         * LITERAL_PREDICATES - –ü—Ä–µ–¥–∏–∫–∞—Ç—ã, –¥–ª—è –∫–æ—Ç–æ—Ä—ã—Ö –æ–±—ä–µ–∫—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ª–∏—Ç–µ—Ä–∞–ª–æ–º (–µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ)
         * –ü—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —ç—Ç–∏—Ö –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–≤, —Å—Ç–∞—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∑–∞–º–µ–Ω–µ–Ω–æ
         */
        const LITERAL_PREDICATES = [
            'rdfs:label',
            'http://www.w3.org/2000/01/rdf-schema#label',
            'dcterms:description',
            'http://purl.org/dc/terms/description',
            'dcterms:title',
            'http://purl.org/dc/terms/title',
            'rdfs:comment',
            'http://www.w3.org/2000/01/rdf-schema#comment'
        ];

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø—Ä–µ–¥–∏–∫–∞—Ç –ª–∏—Ç–µ—Ä–∞–ª—å–Ω—ã–º (—Ç—Ä–µ–±—É—é—â–∏–º –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è)
         * @param {string} predicateUri - URI –∏–ª–∏ prefixed name –ø—Ä–µ–¥–∏–∫–∞—Ç–∞
         * @returns {boolean}
         */
        function isLiteralPredicate(predicateUri) {
            return LITERAL_PREDICATES.some(allowed =>
                predicateUri === allowed || predicateUri.endsWith('#' + allowed.split(':')[1])
            );
        }

        /**
         * –ù–∞—Ö–æ–¥–∏—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ª–∏—Ç–µ—Ä–∞–ª—å–Ω–æ–≥–æ –ø—Ä–µ–¥–∏–∫–∞—Ç–∞ –¥–ª—è —Å—É–±—ä–µ–∫—Ç–∞
         * @param {string} subjectValue - URI –∏–ª–∏ prefixed name —Å—É–±—ä–µ–∫—Ç–∞
         * @param {string} predicateValue - URI –∏–ª–∏ prefixed name –ø—Ä–µ–¥–∏–∫–∞—Ç–∞
         * @returns {Object|null} - { value: string, graphUri: string } –µ—Å–ª–∏ –Ω–∞–π–¥–µ–Ω–æ, –∏–Ω–∞—á–µ null
         */
        function findExistingLiteralValue(subjectValue, predicateValue) {
            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º prefixed names –≤ –ø–æ–ª–Ω—ã–µ URI
            let subjectUri = subjectValue;
            let predicateUri = predicateValue;

            for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                if (subjectValue.startsWith(prefix + ':')) {
                    subjectUri = namespace + subjectValue.substring(prefix.length + 1);
                }
                if (predicateValue.startsWith(prefix + ':')) {
                    predicateUri = namespace + predicateValue.substring(prefix.length + 1);
                }
            }

            const subjectPrefixed = getPrefixedName(subjectUri, currentPrefixes);
            const predicatePrefixed = getPrefixedName(predicateUri, currentPrefixes);

            for (const quad of currentQuads) {
                const qSubjectUri = quad.subject.value;
                const qPredicateUri = quad.predicate.value;
                const qSubjectPrefixed = getPrefixedName(qSubjectUri, currentPrefixes);
                const qPredicatePrefixed = getPrefixedName(qPredicateUri, currentPrefixes);

                const subjectMatch = (subjectUri === qSubjectUri) || (subjectPrefixed === qSubjectPrefixed);
                const predicateMatch = (predicateUri === qPredicateUri) || (predicatePrefixed === qPredicatePrefixed);

                if (subjectMatch && predicateMatch && quad.object.termType === 'Literal') {
                    const graphUri = quad.graph ? quad.graph.value : null;
                    return { value: quad.object.value, graphUri: graphUri };
                }
            }

            return null;
        }

        /**
         * –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø–∞–Ω–µ–ª–∏ Result in SPARQL
         * @param {string} message - –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
         * @param {string} type - –¢–∏–ø: 'success', 'error', 'info'
         */
        function showResultSparqlMessage(message, type = 'info') {
            const messageDiv = document.getElementById('result-sparql-message');
            if (messageDiv) {
                messageDiv.textContent = message;
                messageDiv.className = 'smart-design-message ' + type;
                messageDiv.style.display = 'block';
            }
        }

        /**
         * –°–∫—Ä—ã–≤–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø–∞–Ω–µ–ª–∏ Result in SPARQL
         */
        function hideResultSparqlMessage() {
            const messageDiv = document.getElementById('result-sparql-message');
            if (messageDiv) {
                messageDiv.style.display = 'none';
            }
        }

        /**
         * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫–∞–∫ Shorthand Triple"
         * –î–æ–±–∞–≤–ª—è–µ—Ç —Ç—Ä–∏–ø–ª–µ—Ç –≤ shorthand —Ñ–æ—Ä–º–µ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)
         */
        function smartDesignApplyShorthand() {
            const resultTextarea = document.getElementById('result-sparql-query');
            if (!resultTextarea || !resultTextarea.value.trim()) {
                showResultSparqlMessage('–û—à–∏–±–∫–∞: –°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ SPARQL –∑–∞–ø—Ä–æ—Å (–Ω–∞–∂–º–∏—Ç–µ "–°–æ–∑–¥–∞—Ç—å SPARQL" –∏–ª–∏ "–£–¥–∞–ª–∏—Ç—å")', 'error');
                return;
            }

            const sparqlQuery = resultTextarea.value.trim();
            const rdfInput = document.getElementById('rdf-input');

            if (!rdfInput) {
                showResultSparqlMessage('–û—à–∏–±–∫–∞: –ù–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ–ª–µ RDF –¥–∞–Ω–Ω—ã—Ö', 'error');
                return;
            }

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –∑–∞–ø—Ä–æ—Å–∞ (—Ç–æ–ª—å–∫–æ INSERT –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –¥–ª—è shorthand)
            const isInsert = sparqlQuery.includes('INSERT DATA');
            const isDelete = sparqlQuery.includes('DELETE DATA');

            if (isDelete) {
                showResultSparqlMessage('–û—à–∏–±–∫–∞: Shorthand Triple —Ä–µ–∂–∏–º –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç DELETE –æ–ø–µ—Ä–∞—Ü–∏–∏. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ "–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫–∞–∫ Simple Triple".', 'error');
                return;
            }

            if (!isInsert) {
                showResultSparqlMessage('–û—à–∏–±–∫–∞: –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø SPARQL –∑–∞–ø—Ä–æ—Å–∞', 'error');
                return;
            }

            // –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è URI/–ø—Ä–µ—Ñ–∏–∫—Å–Ω–æ–≥–æ –∏–º–µ–Ω–∏
            const uriPattern = '(?:<[^>]+>|[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z0-9_.-]+)';
            const objectPattern = '(?:<[^>]+>|[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z0-9_.-]+|"[^"]*")';

            // –ò–∑–≤–ª–µ–∫–∞–µ–º GRAPH –∏ —Ç—Ä–∏–ø–ª–µ—Ç—ã –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
            const graphMatch = sparqlQuery.match(new RegExp(`GRAPH\\s+(${uriPattern})\\s*\\{([\\s\\S]*?)\\}`, 'i'));

            if (!graphMatch) {
                showResultSparqlMessage('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å GRAPH –≤ SPARQL –∑–∞–ø—Ä–æ—Å–µ', 'error');
                return;
            }

            const graphRef = graphMatch[1];
            const graphBody = graphMatch[2];

            // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç—Ä–∏–ø–ª–µ—Ç—ã –∏–∑ —Ç–µ–ª–∞ GRAPH
            const triplePattern = new RegExp(`(${uriPattern})\\s+(${uriPattern})\\s+(${objectPattern})\\s*\\.`, 'g');
            const triples = [];
            let tripleMatch;
            while ((tripleMatch = triplePattern.exec(graphBody)) !== null) {
                triples.push({
                    subject: tripleMatch[1],
                    predicate: tripleMatch[2],
                    object: tripleMatch[3]
                });
            }

            if (triples.length === 0) {
                showResultSparqlMessage('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ç—Ä–∏–ø–ª–µ—Ç—ã –≤ SPARQL –∑–∞–ø—Ä–æ—Å–µ', 'error');
                return;
            }

            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º URI/–ø—Ä–µ—Ñ–∏–∫—Å –≤ –ø—Ä–µ—Ñ–∏–∫—Å–Ω—É—é —Ñ–æ—Ä–º—É
            function toPrefixed(ref) {
                if (ref.startsWith('<') && ref.endsWith('>')) {
                    const cleanUri = ref.slice(1, -1);
                    return getPrefixedName(cleanUri, currentPrefixes);
                }
                return ref;
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç—Ä–∏–ø–ª–µ—Ç–∞
            const duplicateTriples = [];
            for (const triple of triples) {
                const subjectPrefixed = toPrefixed(triple.subject);
                const predicatePrefixed = toPrefixed(triple.predicate);
                const objectPrefixed = toPrefixed(triple.object);

                const duplicate = findDuplicateTriple(subjectPrefixed, predicatePrefixed, objectPrefixed);
                if (duplicate) {
                    duplicateTriples.push({
                        triple: `${subjectPrefixed} ${predicatePrefixed} ${objectPrefixed}`,
                        graph: duplicate.graphLabel
                    });
                }
            }

            // –ï—Å–ª–∏ –µ—Å—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—à–∏–±–∫—É
            if (duplicateTriples.length > 0) {
                const duplicateMessages = duplicateTriples.map(d => `"${d.triple}" (–≤ –≥—Ä–∞—Ñ–µ "${d.graph}")`).join(', ');
                showResultSparqlMessage(`–û—à–∏–±–∫–∞: –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –¥—É–±–ª–∏–∫–∞—Ç—ã —Ç—Ä–∏–ø–ª–µ—Ç–æ–≤: ${duplicateMessages}`, 'error');
                return;
            }

            const graphPrefixed = toPrefixed(graphRef);
            let currentRdfText = rdfInput.value;
            let successCount = 0;
            let replaceMessages = [];

            // –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ TriG –≤ shorthand —Ñ–æ—Ä–º–∞—Ç–µ
            if (isNewTrigQuery) {
                // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º —Ç—Ä–∏–ø–ª–µ—Ç—ã –ø–æ —Å—É–±—ä–µ–∫—Ç—É –¥–ª—è shorthand –∑–∞–ø–∏—Å–∏
                const triplesBySubject = new Map();
                for (const triple of triples) {
                    const subjectPrefixed = toPrefixed(triple.subject);
                    const predicatePrefixed = toPrefixed(triple.predicate);
                    const objectPrefixed = toPrefixed(triple.object);

                    if (!triplesBySubject.has(subjectPrefixed)) {
                        triplesBySubject.set(subjectPrefixed, []);
                    }
                    triplesBySubject.get(subjectPrefixed).push({ predicate: predicatePrefixed, object: objectPrefixed });
                }

                // –§–æ—Ä–º–∏—Ä—É–µ–º shorthand –∑–∞–ø–∏—Å—å –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å—É–±—ä–µ–∫—Ç–∞
                let shorthandTriples = [];
                for (const [subject, predicateObjects] of triplesBySubject) {
                    if (predicateObjects.length === 1) {
                        // –û–¥–∏–Ω –ø—Ä–µ–¥–∏–∫–∞—Ç-–æ–±—ä–µ–∫—Ç - –ø—Ä–æ—Å—Ç–∞—è –∑–∞–ø–∏—Å—å
                        shorthandTriples.push(`    ${subject} ${predicateObjects[0].predicate} ${predicateObjects[0].object} .`);
                    } else {
                        // –ù–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–≤-–æ–±—ä–µ–∫—Ç–æ–≤ - shorthand —á–µ—Ä–µ–∑ —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π
                        const firstPO = predicateObjects[0];
                        let shorthandLine = `    ${subject} ${firstPO.predicate} ${firstPO.object}`;
                        for (let i = 1; i < predicateObjects.length; i++) {
                            shorthandLine += ` ;\n        ${predicateObjects[i].predicate} ${predicateObjects[i].object}`;
                        }
                        shorthandLine += ' .';
                        shorthandTriples.push(shorthandLine);
                    }
                }

                // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –≥—Ä–∞—Ñ —Å shorthand –∑–∞–ø–∏—Å—è–º–∏
                const newGraph = `\n\n${graphPrefixed} {\n${shorthandTriples.join('\n')}\n}`;
                currentRdfText += newGraph;
                rdfInput.value = currentRdfText;

                // –ü–µ—Ä–µ—Ä–∞–∑–±–∏—Ä–∞–µ–º RDF –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è currentQuads –∏ –∫—ç—à–∞ —Ç–∏–ø–æ–≤
                // –≠—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±–Ω–∞—Ä—É–∂–∏–≤–∞—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã –ø—Ä–∏ –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏—è—Ö
                reparseRdfData();

                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ New TriG
                isNewTrigQuery = false;
                updateSimpleTripleButtonState();

                showResultSparqlMessage(`–ù–æ–≤—ã–π TriG "${graphPrefixed}" —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω –≤ shorthand —Ñ–æ—Ä–º–∞—Ç–µ. –ù–∞–∂–º–∏—Ç–µ "–ü–æ–∫–∞–∑–∞—Ç—å" –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≥—Ä–∞—Ñ–∞.`, 'success');
                return;
            }

            for (const triple of triples) {
                const subjectPrefixed = toPrefixed(triple.subject);
                const predicatePrefixed = toPrefixed(triple.predicate);
                const objectPrefixed = toPrefixed(triple.object);

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø—Ä–µ–¥–∏–∫–∞—Ç –ª–∏—Ç–µ—Ä–∞–ª—å–Ω—ã–º
                const isLiteralPred = isLiteralPredicate(predicatePrefixed);

                if (isLiteralPred) {
                    // –î–ª—è –ª–∏—Ç–µ—Ä–∞–ª—å–Ω—ã—Ö –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–≤ - –∏—â–µ–º –∏ –∑–∞–º–µ–Ω—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                    const existingValue = findExistingLiteralValue(subjectPrefixed, predicatePrefixed);
                    if (existingValue) {
                        // –ù—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏ –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ –≤ shorthand —Å—Ç–∏–ª–µ
                        const oldValueEscaped = escapeRegex(`"${existingValue.value}"`);

                        // –ü–∞—Ç—Ç–µ—Ä–Ω 1: –ü—Ä–æ—Å—Ç–æ–π —Ç—Ä–∏–ø–ª–µ—Ç "subject predicate value"
                        let replacePattern = new RegExp(
                            `(${escapeRegex(subjectPrefixed)}\\s+${escapeRegex(predicatePrefixed)}\\s+)${oldValueEscaped}`,
                            'g'
                        );
                        let newText = currentRdfText.replace(replacePattern, `$1${objectPrefixed}`);

                        // –ü–∞—Ç—Ç–µ—Ä–Ω 2: Shorthand —Ñ–æ—Ä–º–∞—Ç - –ø—Ä–µ–¥–∏–∫–∞—Ç –ø–æ—Å–ª–µ —Ç–æ—á–∫–∏ —Å –∑–∞–ø—è—Ç–æ–π "... ; predicate value"
                        if (newText === currentRdfText) {
                            replacePattern = new RegExp(
                                `(;\\s*${escapeRegex(predicatePrefixed)}\\s+)${oldValueEscaped}`,
                                'g'
                            );
                            newText = currentRdfText.replace(replacePattern, `$1${objectPrefixed}`);
                        }

                        if (newText !== currentRdfText) {
                            currentRdfText = newText;
                            replaceMessages.push(`–ü—Ä–µ–∂–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ "${existingValue.value}" –∑–∞–º–µ–Ω–µ–Ω–æ`);
                            successCount++;
                            continue;
                        }
                    }
                }

                // –°–Ω–∞—á–∞–ª–∞ –∏–∑–≤–ª–µ–∫–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ü–µ–ª–µ–≤–æ–≥–æ –≥—Ä–∞—Ñ–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
                const graphContentPattern = new RegExp(`(${escapeRegex(graphPrefixed)}\\s*\\{)([\\s\\S]*?)(\\})`, 's');
                const graphContentMatch = currentRdfText.match(graphContentPattern);

                if (!graphContentMatch) {
                    // –ì—Ä–∞—Ñ –Ω–µ –Ω–∞–π–¥–µ–Ω - —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –≥—Ä–∞—Ñ —Å —Ç—Ä–∏–ø–ª–µ—Ç–æ–º
                    const newGraph = `\n\n${graphPrefixed} {\n    ${subjectPrefixed} ${predicatePrefixed} ${objectPrefixed} .\n}`;
                    currentRdfText += newGraph;
                    successCount++;
                    continue;
                }

                const graphContent = graphContentMatch[2];

                // –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ç—Ä–∏–ø–ª–µ—Ç —Å —Ç–µ–º –∂–µ subject –∏ predicate –í –ü–†–ï–î–ï–õ–ê–• –¶–ï–õ–ï–í–û–ì–û –ì–†–ê–§–ê –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é
                const subjectPredicateInGraphPattern = new RegExp(
                    `(${escapeRegex(subjectPrefixed)}\\s+${escapeRegex(predicatePrefixed)}\\s+)([^;.]+)([;.])`,
                    'g'
                );

                const existingMatchInGraph = graphContent.match(subjectPredicateInGraphPattern);
                if (existingMatchInGraph) {
                    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é –í –ü–†–ï–î–ï–õ–ê–• –¶–ï–õ–ï–í–û–ì–û –ì–†–ê–§–ê
                    const newGraphContent = graphContent.replace(
                        subjectPredicateInGraphPattern,
                        `$1$2, ${objectPrefixed}$3`
                    );
                    currentRdfText = currentRdfText.replace(graphContentPattern, `$1${newGraphContent}$3`);
                    successCount++;
                } else {
                    // –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Å—É–±—ä–µ–∫—Ç –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ –ø—Ä–µ–¥–∏–∫–∞—Ç–∞ –í –ü–†–ï–î–ï–õ–ê–• –¶–ï–õ–ï–í–û–ì–û –ì–†–ê–§–ê
                    const subjectInGraphPattern = new RegExp(
                        `(${escapeRegex(subjectPrefixed)}\\s+[^}]*?)([;.])(?=\\s|$|\\n)`,
                        's'
                    );
                    const subjectMatchInGraph = graphContent.match(subjectInGraphPattern);

                    if (subjectMatchInGraph) {
                        // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π –ø—Ä–µ–¥–∏–∫–∞—Ç –∏ –æ–±—ä–µ–∫—Ç –í –ü–†–ï–î–ï–õ–ê–• –¶–ï–õ–ï–í–û–ì–û –ì–†–ê–§–ê
                        const newGraphContent = graphContent.replace(
                            subjectInGraphPattern,
                            `$1 ;\n        ${predicatePrefixed} ${objectPrefixed}$2`
                        );
                        currentRdfText = currentRdfText.replace(graphContentPattern, `$1${newGraphContent}$3`);
                        successCount++;
                    } else {
                        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —Å—É–±—ä–µ–∫—Ç –≤ —Ü–µ–ª–µ–≤–æ–º –≥—Ä–∞—Ñ–µ
                        const newTriple = `\n    ${subjectPrefixed} ${predicatePrefixed} ${objectPrefixed} .`;
                        const newGraphContent = graphContent + newTriple;
                        currentRdfText = currentRdfText.replace(graphContentPattern, `$1${newGraphContent}$3`);
                        successCount++;
                    }
                }
            }

            if (successCount > 0) {
                rdfInput.value = currentRdfText;
                let message = `Shorthand Triple: ${successCount} –∑–Ω–∞—á–µ–Ω–∏–µ(–π) —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ.`;
                if (replaceMessages.length > 0) {
                    message += ' ' + replaceMessages.join('. ') + '.';
                }
                message += ' –ù–∞–∂–º–∏—Ç–µ "–ü–æ–∫–∞–∑–∞—Ç—å" –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≥—Ä–∞—Ñ–∞.';
                showResultSparqlMessage(message, 'success');
            } else {
                showResultSparqlMessage('–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –≤ shorthand —Ñ–æ—Ä–º–∞—Ç–µ', 'error');
            }

            // –ü–æ–ª—è Smart Design –∏ Result in SPARQL –Ω–µ –æ—á–∏—â–∞—é—Ç—Å—è –ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è
            // –û—á–∏—Å—Ç–∫–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Ç–æ–ª—å–∫–æ –ø–æ –∫–Ω–æ–ø–∫–µ "–û—á–∏—Å—Ç–∏—Ç—å"
        }

        /**
         * –û—Ç–∫—Ä—ã–≤–∞–µ—Ç –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ TriG
         */
        function openNewTrigModal() {
            const modal = document.getElementById('new-trig-modal');
            const parentSelect = document.getElementById('new-trig-parent');

            // –ó–∞–ø–æ–ª–Ω—è–µ–º —Å–ø–∏—Å–æ–∫ —Ä–æ–¥–∏—Ç–µ–ª–µ–π —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ TriG
            parentSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–¥–∏—Ç–µ–ª—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) --</option>';
            const trigs = getAllTriGs();
            trigs.forEach(t => {
                const option = document.createElement('option');
                option.value = t.uri;
                const id = getPrefixedName(t.uri, currentPrefixes);
                const displayText = t.label && t.label !== id ? `${id} (${t.label})` : id;
                option.textContent = displayText;
                parentSelect.appendChild(option);
            });

            // –û—á–∏—â–∞–µ–º –ø–æ–ª—è –≤–≤–æ–¥–∞
            document.getElementById('new-trig-id').value = '';
            document.getElementById('new-trig-label').value = '';

            // –û—á–∏—â–∞–µ–º –≤—ã–±–æ—Ä –∫–æ–Ω—Ü–µ–ø—Ç–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞
            const processConceptSelect = document.getElementById('new-trig-process-concept');
            if (processConceptSelect) {
                processConceptSelect.value = '';
            }

            // –ó–∞–ø–æ–ª–Ω—è–µ–º –≤—ã–ø–∞–¥–∞—é—â–∏–π —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ü–µ–ø—Ç–æ–≤ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
            populateNewTrigProcessConcepts();

            modal.style.display = 'block';

            // –î–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–ª—è Smart Design
            updateSmartDesignFieldsState();
        }

        /**
         * –ó–∞–∫—Ä—ã–≤–∞–µ—Ç –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ TriG
         */
        function closeNewTrigModal() {
            const modal = document.getElementById('new-trig-modal');
            modal.style.display = 'none';

            // –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–ª—è Smart Design
            updateSmartDesignFieldsState();
        }

        /**
         * –°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π TriG –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç SPARQL –∑–∞–ø—Ä–æ—Å
         * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã–π –∫–æ–Ω—Ü–µ–ø—Ç –ø—Ä–æ—Ü–µ—Å—Å–∞ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ ID
         */
        function createNewTrig() {
            const processConcept = document.getElementById('new-trig-process-concept').value;
            const trigId = document.getElementById('new-trig-id').value.trim();
            const label = document.getElementById('new-trig-label').value.trim();
            const parentUri = document.getElementById('new-trig-parent').value;

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—ã–±—Ä–∞–Ω –∫–æ–Ω—Ü–µ–ø—Ç –ø—Ä–æ—Ü–µ—Å—Å–∞
            if (!processConcept) {
                alert('–û—à–∏–±–∫–∞: –í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ü–µ–ø—Ç –ø—Ä–æ—Ü–µ—Å—Å–∞');
                return;
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ ID –∑–∞–ø–æ–ª–Ω–µ–Ω
            if (!trigId) {
                alert('–û—à–∏–±–∫–∞: ID –Ω–æ–≤–æ–≥–æ TriG –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º');
                return;
            }

            // –ü–æ–ª—É—á–∞–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ –∏–º—è –ø—Ä–æ—Ü–µ—Å—Å–∞ –∏–∑ URI
            // processConcept –º–æ–∂–µ—Ç –±—ã—Ç—å –≤ —Ñ–æ—Ä–º–µ "vad:ProcessX" –∏–ª–∏ "<http://...#ProcessX>"
            let processLocalName;
            if (processConcept.startsWith('vad:')) {
                processLocalName = processConcept.substring(4);
            } else if (processConcept.includes('#')) {
                processLocalName = processConcept.split('#').pop().replace('>', '');
            } else if (processConcept.includes('/')) {
                processLocalName = processConcept.split('/').pop().replace('>', '');
            } else {
                processLocalName = processConcept;
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ —Ç–∞–∫–æ–π TriG
            if (trigExists(trigId)) {
                alert(`–û—à–∏–±–∫–∞: TriG —Å ID "${trigId}" —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–π –∫–æ–Ω—Ü–µ–ø—Ç –ø—Ä–æ—Ü–µ—Å—Å–∞.`);
                return;
            }

            // –§–æ—Ä–º–∏—Ä—É–µ–º URI –Ω–æ–≤–æ–≥–æ TriG
            let trigUri;
            if (currentPrefixes['vad']) {
                trigUri = `vad:${trigId}`;
            } else {
                trigUri = `<http://example.org/vad#${trigId}>`;
            }

            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º SPARQL –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è TriG —Å –Ω—É–∂–Ω—ã–º–∏ –ø—Ä–µ–¥–∏–∫–∞—Ç–∞–º–∏
            const prefixDeclarations = generateSparqlPrefixes(currentPrefixes);

            let triples = [];

            // –í—Å–µ–≥–¥–∞ –¥–æ–±–∞–≤–ª—è–µ–º rdf:type VADProcessDia (—Ç–∏–ø —Å—Ö–µ–º—ã –ø—Ä–æ—Ü–µ—Å—Å–∞)
            triples.push(`        ${trigUri} rdf:type vad:VADProcessDia .`);

            // rdfs:label (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)
            if (label) {
                const escapedLabel = label.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                triples.push(`        ${trigUri} rdfs:label "${escapedLabel}" .`);
            }

            // vad:hasParentTrig (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
            if (parentUri) {
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º URI —Ä–æ–¥–∏—Ç–µ–ª—è –≤ –ø—Ä–µ—Ñ–∏–∫—Å–Ω—É—é —Ñ–æ—Ä–º—É
                const parentPrefixed = getPrefixedName(parentUri, currentPrefixes);
                triples.push(`        ${trigUri} vad:hasParentTrig ${parentPrefixed} .`);
            }

            // –î–æ–±–∞–≤–ª—è–µ–º –∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—ã–µ —Ç—Ä–∏–ø–ª—ã –¥–ª—è –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
            // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—ã–π URI —Ç—Ä–∏–ì–∞ –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–∏ generateAutoTriples
            const fullTrigUri = currentPrefixes['vad']
                ? currentPrefixes['vad'] + trigId
                : `http://example.org/vad#${trigId}`;

            // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—ã–π URI –ø—Ä–æ—Ü–µ—Å—Å–∞
            const processUri = currentPrefixes['vad']
                ? currentPrefixes['vad'] + processLocalName
                : processConcept.replace(/^<|>$/g, '');

            // –ü–æ–ª—É—á–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ç—Ä–∏–ø–ª–µ—Ç—ã (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è —Å—Ç—Ä–æ–∫–∞)
            const autoTriplesStr = generateAutoTriples(processUri, fullTrigUri);
            // –î–æ–±–∞–≤–ª—è–µ–º –∞–≤—Ç–æ—Ç—Ä–∏–ø–ª–µ—Ç—ã –Ω–∞–ø—Ä—è–º—É—é –≤ –º–∞—Å—Å–∏–≤ (–æ–Ω–∏ —É–∂–µ –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω—ã)
            if (autoTriplesStr && autoTriplesStr.trim().length > 0) {
                triples.push(autoTriplesStr);
            }

            // –§–æ—Ä–º–∏—Ä—É–µ–º URI –ø—Ä–æ—Ü–µ—Å—Å–∞ –≤ –ø—Ä–µ—Ñ–∏–∫—Å–Ω–æ–π —Ñ–æ—Ä–º–µ
            const processPrefixed = getPrefixedName(processUri, currentPrefixes);

            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π SPARQL –∑–∞–ø—Ä–æ—Å:
            // 1. DELETE vad:hasParentProcess –∏–∑ ptree (–µ—Å–ª–∏ –µ—Å—Ç—å) - –ø—Ä–∞–≤–∏–ª–æ –≤–∑–∞–∏–º–æ–∏—Å–∫–ª—é—á–µ–Ω–∏—è
            // 2. INSERT vad:hasTrig –≤ ptree
            // 3. INSERT —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –Ω–æ–≤–æ–≥–æ TriG –≥—Ä–∞—Ñ–∞
            const sparqlQuery = `${prefixDeclarations}# –ü—Ä–∞–≤–∏–ª–æ: vad:hasTrig –∏ vad:hasParentProcess - –≤–∑–∞–∏–º–æ–∏—Å–∫–ª—é—á–∞—é—â–∏–µ
# –ü—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ TriG –¥–ª—è –ø—Ä–æ—Ü–µ—Å—Å–∞ —É–¥–∞–ª—è–µ–º vad:hasParentProcess

DELETE {
    GRAPH vad:ptree {
        ${processPrefixed} vad:hasParentProcess ?oldParent .
    }
}
WHERE {
    GRAPH vad:ptree {
        ${processPrefixed} vad:hasParentProcess ?oldParent .
    }
};

# –î–æ–±–∞–≤–ª—è–µ–º —Å–≤—è–∑—å –ø—Ä–æ—Ü–µ—Å—Å–∞ —Å –Ω–æ–≤—ã–º TriG –≤ –¥–µ—Ä–µ–≤–µ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
INSERT DATA {
    GRAPH vad:ptree {
        ${processPrefixed} vad:hasTrig ${trigUri} .
    }
};

# –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π TriG –≥—Ä–∞—Ñ
INSERT DATA {
    GRAPH ${trigUri} {
${triples.join('\n')}
    }
}`;

            // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º SPARQL –≤ –ø–æ–ª–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            const resultTextarea = document.getElementById('result-sparql-query');
            if (resultTextarea) {
                resultTextarea.value = sparqlQuery;
            }

            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥, —á—Ç–æ —ç—Ç–æ –∑–∞–ø—Ä–æ—Å New TriG
            isNewTrigQuery = true;
            updateSimpleTripleButtonState();

            closeNewTrigModal();
            showSmartDesignMessage('SPARQL –∑–∞–ø—Ä–æ—Å –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ TriG —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω. –ù–∞–∂–º–∏—Ç–µ "–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫–∞–∫ Simple Triple" (–æ—Ç–¥–µ–ª—å–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏) –∏–ª–∏ "–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫–∞–∫ Shorthand Triple" (—Å–æ—Å—Ç–∞–≤–Ω–∞—è –∑–∞–ø–∏—Å—å —á–µ—Ä–µ–∑ ;).', 'success');
        }

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ "–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫–∞–∫ Simple Triple"
         * –û–±–µ –∫–Ω–æ–ø–∫–∏ –∞–∫—Ç–∏–≤–Ω—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ TriG
         */
        function updateSimpleTripleButtonState() {
            const simpleTripleBtn = document.querySelector('.apply-btn[onclick="smartDesignApply()"]');
            if (simpleTripleBtn) {
                // –ö–Ω–æ–ø–∫–∞ Simple Triple –≤—Å–µ–≥–¥–∞ –∞–∫—Ç–∏–≤–Ω–∞
                simpleTripleBtn.disabled = false;
                simpleTripleBtn.style.opacity = '1';
                simpleTripleBtn.style.cursor = 'pointer';
                simpleTripleBtn.title = '';
            }
        }

        // ============================================================================
        // –§–£–ù–ö–¶–ò–ò –î–õ–Ø –£–î–ê–õ–ï–ù–ò–Ø TriG (Del TriG)
        // ============================================================================

        /**
         * –û—Ç–∫—Ä—ã–≤–∞–µ—Ç –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ —É–¥–∞–ª–µ–Ω–∏—è TriG
         */
        function openDelTrigModal() {
            const modal = document.getElementById('del-trig-modal');
            const trigSelect = document.getElementById('del-trig-select');
            const warningDiv = document.getElementById('del-trig-warning');
            const confirmBtn = document.getElementById('del-trig-confirm-btn');

            // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            warningDiv.style.display = 'none';
            confirmBtn.disabled = true;

            // –ó–∞–ø–æ–ª–Ω—è–µ–º —Å–ø–∏—Å–æ–∫ TriG –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è (—Ç–æ–ª—å–∫–æ VADProcessDia)
            trigSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ TriG --</option>';

            const trigs = getAllTriGs();
            trigs.forEach(t => {
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –≥—Ä–∞—Ñ—ã (ptree, rtree)
                if (t.uri === PTREE_GRAPH_URI || t.uri === RTREE_GRAPH_URI) return;

                const option = document.createElement('option');
                option.value = t.uri;
                const id = getPrefixedName(t.uri, currentPrefixes);
                const displayText = t.label && t.label !== id ? `${id} (${t.label})` : id;
                option.textContent = displayText;
                trigSelect.appendChild(option);
            });

            // –û—á–∏—â–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–π –±–ª–æ–∫
            document.getElementById('del-trig-info').innerHTML = '–í—ã–±–µ—Ä–∏—Ç–µ TriG –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏';

            modal.style.display = 'block';
        }

        /**
         * –ó–∞–∫—Ä—ã–≤–∞–µ—Ç –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ —É–¥–∞–ª–µ–Ω–∏—è TriG
         */
        function closeDelTrigModal() {
            const modal = document.getElementById('del-trig-modal');
            modal.style.display = 'none';
        }

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º TriG –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
         */
        function updateDelTrigInfo() {
            const trigUri = document.getElementById('del-trig-select').value;
            const infoDiv = document.getElementById('del-trig-info');
            const warningDiv = document.getElementById('del-trig-warning');
            const confirmBtn = document.getElementById('del-trig-confirm-btn');

            if (!trigUri) {
                infoDiv.innerHTML = '–í—ã–±–µ—Ä–∏—Ç–µ TriG –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏';
                warningDiv.style.display = 'none';
                confirmBtn.disabled = true;
                return;
            }

            // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ TriG
            const graphInfo = trigHierarchy[trigUri];
            if (!graphInfo) {
                infoDiv.innerHTML = '–û—à–∏–±–∫–∞: TriG –Ω–µ –Ω–∞–π–¥–µ–Ω';
                warningDiv.style.display = 'none';
                confirmBtn.disabled = true;
                return;
            }

            const trigLabel = getPrefixedName(trigUri, currentPrefixes);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –¥–æ—á–µ—Ä–Ω–∏–µ TriG
            const childTrigs = [];
            Object.entries(trigHierarchy).forEach(([uri, info]) => {
                if (info.hasParent === trigUri) {
                    childTrigs.push({
                        uri: uri,
                        label: getPrefixedName(uri, currentPrefixes)
                    });
                }
            });

            // –§–æ—Ä–º–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
            let infoHtml = `<strong>ID:</strong> ${trigLabel}<br>`;
            infoHtml += `<strong>Label:</strong> ${graphInfo.label || '–Ω–µ —É–∫–∞–∑–∞–Ω'}<br>`;
            infoHtml += `<strong>Parent:</strong> ${graphInfo.hasParent ? getPrefixedName(graphInfo.hasParent, currentPrefixes) : '–Ω–µ —É–∫–∞–∑–∞–Ω'}<br>`;
            infoHtml += `<strong>–ü—Ä–æ—Ü–µ—Å—Å–æ–≤:</strong> ${graphInfo.processes ? graphInfo.processes.length : 0}`;

            infoDiv.innerHTML = infoHtml;

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –¥–æ—á–µ—Ä–Ω–∏—Ö TriG
            if (childTrigs.length > 0) {
                const childLabels = childTrigs.map(c => c.label).join(', ');
                warningDiv.innerHTML = `<strong>‚ö†Ô∏è –û–®–ò–ë–ö–ê:</strong> –£–¥–∞–ª–µ–Ω–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ!<br><br>` +
                    `–î–∞–Ω–Ω—ã–π TriG (${trigLabel}) —è–≤–ª—è–µ—Ç—Å—è —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–º –¥–ª—è —Å–ª–µ–¥—É—é—â–∏—Ö TriG:<br>` +
                    `<strong>${childLabels}</strong><br><br>` +
                    `–°–Ω–∞—á–∞–ª–∞ –∏–∑–º–µ–Ω–∏—Ç–µ —Å—Å—ã–ª–∫—É vad:hasParentTrig —É –¥–æ—á–µ—Ä–Ω–∏—Ö TriG –∏–ª–∏ —É–¥–∞–ª–∏—Ç–µ –∏—Ö.`;
                warningDiv.style.display = 'block';
                confirmBtn.disabled = true;
            } else {
                warningDiv.style.display = 'none';
                confirmBtn.disabled = false;
            }
        }

        /**
         * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç SPARQL –∑–∞–ø—Ä–æ—Å –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è TriG
         * –ü—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏:
         * 1. –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ –¥–æ—á–µ—Ä–Ω–∏—Ö TriG (–µ—Å–ª–∏ –µ—Å—Ç—å - –æ—à–∏–±–∫–∞)
         * 2. –£–¥–∞–ª—è–µ—Ç vad:hasTrig –∏–∑ ptree
         * 3. –î–æ–±–∞–≤–ª—è–µ—Ç vad:hasParentProcess –∫ –ø—Ä–æ—Ü–µ—Å—Å—É (—Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ —Ä–æ–¥–∏—Ç–µ–ª—è —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–≥–æ TriG)
         * 4. –£–¥–∞–ª—è–µ—Ç –≥—Ä–∞—Ñ TriG
         * 5. –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ—Ç virtualRDFdata
         */
        function deleteTriG() {
            const trigUri = document.getElementById('del-trig-select').value;

            if (!trigUri) {
                alert('–û—à–∏–±–∫–∞: –í—ã–±–µ—Ä–∏—Ç–µ TriG –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è');
                return;
            }

            const graphInfo = trigHierarchy[trigUri];
            if (!graphInfo) {
                alert('–û—à–∏–±–∫–∞: TriG –Ω–µ –Ω–∞–π–¥–µ–Ω');
                return;
            }

            // –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å, –∫–æ—Ç–æ—Ä—ã–π –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —ç—Ç–∏–º TriG
            let definingProcess = null;
            graphInfo.quads.forEach(quad => {
                const predicateLabel = getPrefixedName(quad.predicate.value, currentPrefixes);
                if (predicateLabel === 'vad:definesProcess' || quad.predicate.value === 'http://example.org/vad#definesProcess') {
                    definingProcess = quad.object.value;
                }
            });

            if (!definingProcess) {
                alert('–û—à–∏–±–∫–∞: –ù–µ –Ω–∞–π–¥–µ–Ω –ø—Ä–æ—Ü–µ—Å—Å, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º—ã–π —ç—Ç–∏–º TriG (vad:definesProcess)');
                return;
            }

            // –ü–æ–ª—É—á–∞–µ–º —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π TriG
            const parentTrigUri = graphInfo.hasParent;
            if (!parentTrigUri || parentTrigUri === 'http://example.org/vad#root') {
                // –ï—Å–ª–∏ —Ä–æ–¥–∏—Ç–µ–ª—å root, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º hasParentProcess = NotDefined
                // (–∏–ª–∏ –º–æ–∂–Ω–æ –∑–∞–ø—Ä–µ—Ç–∏—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ –∫–æ—Ä–Ω–µ–≤—ã—Ö TriG)
            }

            // –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å-–≤–ª–∞–¥–µ–ª—å—Ü–∞ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–≥–æ TriG (–¥–ª—è hasParentProcess)
            let parentDefiningProcess = null;
            if (parentTrigUri && parentTrigUri !== 'http://example.org/vad#root') {
                const parentGraphInfo = trigHierarchy[parentTrigUri];
                if (parentGraphInfo) {
                    parentGraphInfo.quads.forEach(quad => {
                        const predicateLabel = getPrefixedName(quad.predicate.value, currentPrefixes);
                        if (predicateLabel === 'vad:definesProcess' || quad.predicate.value === 'http://example.org/vad#definesProcess') {
                            parentDefiningProcess = quad.object.value;
                        }
                    });
                }
            }

            // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π –ø—Ä–æ—Ü–µ—Å—Å, –∏—Å–ø–æ–ª—å–∑—É–µ–º NotDefined
            if (!parentDefiningProcess) {
                parentDefiningProcess = 'http://example.org/vad#NotDefined';
            }

            // –§–æ—Ä–º–∏—Ä—É–µ–º SPARQL –∑–∞–ø—Ä–æ—Å
            const trigLabel = getPrefixedName(trigUri, currentPrefixes);
            const processLabel = getPrefixedName(definingProcess, currentPrefixes);
            const parentProcessLabel = getPrefixedName(parentDefiningProcess, currentPrefixes);

            const prefixDeclarations = generateSparqlPrefixes(currentPrefixes);

            const sparqlQuery = `${prefixDeclarations}# –ü—Ä–∞–≤–∏–ª–æ: –ü—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ TriG –≤–æ–∑–≤—Ä–∞—â–∞–µ–º vad:hasParentProcess
# –£–¥–∞–ª—è–µ–º TriG "${trigLabel}" –∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–≤—è–∑–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞

# 1. –£–¥–∞–ª—è–µ–º vad:hasTrig –∏–∑ ptree
DELETE {
    GRAPH vad:ptree {
        ${processLabel} vad:hasTrig ${trigLabel} .
    }
}
WHERE {
    GRAPH vad:ptree {
        ${processLabel} vad:hasTrig ${trigLabel} .
    }
};

# 2. –î–æ–±–∞–≤–ª—è–µ–º vad:hasParentProcess –∫ –ø—Ä–æ—Ü–µ—Å—Å—É
INSERT DATA {
    GRAPH vad:ptree {
        ${processLabel} vad:hasParentProcess ${parentProcessLabel} .
    }
};

# 3. –£–¥–∞–ª—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ TriG –≥—Ä–∞—Ñ–∞
# –ü–†–ò–ú–ï–ß–ê–ù–ò–ï: DROP GRAPH –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é –≤ N3.js/Comunica
# –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ —É–¥–∞–ª—è–µ–º –≤—Å–µ —Ç—Ä–∏–ø–ª–µ—Ç—ã –∏–∑ –≥—Ä–∞—Ñ–∞
DELETE {
    GRAPH ${trigLabel} {
        ?s ?p ?o .
    }
}
WHERE {
    GRAPH ${trigLabel} {
        ?s ?p ?o .
    }
}`;

            // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º SPARQL –≤ –ø–æ–ª–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            const resultTextarea = document.getElementById('result-sparql-query');
            if (resultTextarea) {
                resultTextarea.value = sparqlQuery;
            }

            closeDelTrigModal();
            showSmartDesignMessage(
                `SPARQL –∑–∞–ø—Ä–æ—Å –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è TriG "${trigLabel}" —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω.\n` +
                `–ü–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–µ—Ä–µ—Å—á–∏—Ç–∞—Ç—å virtualRDFdata.`,
                'warning'
            );
        }

        /**
         * –û—Ç–∫—Ä—ã–≤–∞–µ—Ç RDF –¥–∞–Ω–Ω—ã–µ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –æ–∫–Ω–µ –±—Ä–∞—É–∑–µ—Ä–∞
         */
        function showRdfInSeparateWindow() {
            const rdfInput = document.getElementById('rdf-input');
            if (!rdfInput) return;

            const rdfContent = rdfInput.value;

            // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ –æ–∫–Ω–æ
            const newWindow = window.open('', '_blank', 'width=800,height=600,scrollbars=yes,resizable=yes');

            if (newWindow) {
                // –§–æ—Ä–º–∏—Ä—É–µ–º HTML –¥–ª—è –Ω–æ–≤–æ–≥–æ –æ–∫–Ω–∞
                const htmlContent = '<!DOCTYPE html>' +
                    '<html><head><title>RDF –¥–∞–Ω–Ω—ã–µ</title>' +
                    '<style>' +
                    'body { font-family: Consolas, Monaco, monospace; padding: 20px; background-color: #f5f5f5; margin: 0; }' +
                    '.container { background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }' +
                    'h1 { color: #333; font-size: 18px; margin-top: 0; border-bottom: 2px solid #4CAF50; padding-bottom: 10px; }' +
                    'pre { white-space: pre-wrap; word-wrap: break-word; font-size: 13px; line-height: 1.5; margin: 0; color: #333; }' +
                    '.copy-btn { background-color: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-bottom: 15px; }' +
                    '.copy-btn:hover { background-color: #45a049; }' +
                    '</style></head>' +
                    '<body><div class="container">' +
                    '<h1>RDF –¥–∞–Ω–Ω—ã–µ</h1>' +
                    '<button class="copy-btn" id="copy-btn">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤ –±—É—Ñ–µ—Ä</button>' +
                    '<pre id="rdf-content"></pre>' +
                    '</div></body></html>';

                newWindow.document.write(htmlContent);
                newWindow.document.close();

                // –ó–∞–ø–æ–ª–Ω—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø–æ—Å–ª–µ –∑–∞–ø–∏—Å–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞
                const preElement = newWindow.document.getElementById('rdf-content');
                if (preElement) {
                    preElement.textContent = rdfContent;
                }

                // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
                const copyBtn = newWindow.document.getElementById('copy-btn');
                if (copyBtn) {
                    copyBtn.onclick = function() {
                        newWindow.navigator.clipboard.writeText(rdfContent).then(function() {
                            newWindow.alert('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞');
                        }).catch(function() {
                            // Fallback –¥–ª—è —Å—Ç–∞—Ä—ã—Ö –±—Ä–∞—É–∑–µ—Ä–æ–≤
                            const textarea = newWindow.document.createElement('textarea');
                            textarea.value = rdfContent;
                            newWindow.document.body.appendChild(textarea);
                            textarea.select();
                            newWindow.document.execCommand('copy');
                            newWindow.document.body.removeChild(textarea);
                            newWindow.alert('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞');
                        });
                    };
                }
            } else {
                alert('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –Ω–æ–≤–æ–µ –æ–∫–Ω–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –≤—Å–ø–ª—ã–≤–∞—é—â–∏—Ö –æ–∫–æ–Ω.');
            }
        }

        // –ó–∞–∫—Ä—ã—Ç–∏–µ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ –ø—Ä–∏ –∫–ª–∏–∫–µ –≤–Ω–µ –µ–≥–æ
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('new-trig-modal');
            if (event.target === modal) {
                closeNewTrigModal();
            }
        });

        function updateModeDescription() {
            const mode = document.getElementById('visualization-mode').value;
            const description = document.getElementById('mode-description');
            const maxVadRowLengthGroup = document.getElementById('max-vad-row-length-group');
            const sparqlModeSelect = document.getElementById('sparql-mode');
            const smartDesignOption = sparqlModeSelect ? sparqlModeSelect.querySelector('option[value="smart-design"]') : null;

            const descriptions = {
                'notation': '–° –≤—ã–¥–µ–ª–µ–Ω–∏–µ–º —Ç–∏–ø–æ–≤ –æ–±—ä–µ–∫—Ç–æ–≤ –∏ –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–≤ —Ü–≤–µ—Ç–æ–º –∏ —Ñ–æ—Ä–º–∞–º–∏',
                'base': '–ë–∞–∑–æ–≤—ã–π —Ä–µ–∂–∏–º –±–µ–∑ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å—Ç–∏–ª–µ–π',
                'aggregation': '–õ–∏—Ç–µ—Ä–∞–ª—ã –∞–≥—Ä–µ–≥–∏—Ä—É—é—Ç—Å—è –≤ —É–∑–µ–ª —Å—É–±—ä–µ–∫—Ç–∞',
                'vad': 'VAD: –ø—Ä–æ—Ü–µ—Å—Å—ã –∫–∞–∫ cds-—Ñ–∏–≥—É—Ä—ã —Å –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è–º–∏',
                'vad-trig': 'VAD TriG: –∏–µ—Ä–∞—Ä—Ö–∏—è TriG —Å –¥–µ—Ä–µ–≤–æ–º –∏ —Å–≤–æ–π—Å—Ç–≤–∞–º–∏'
            };

            description.textContent = descriptions[mode] || '';

            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º/—Å–∫—Ä—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä "–ú–∞–∫—Å. –¥–ª–∏–Ω–∞ VAD" –¥–ª—è —Ä–µ–∂–∏–º–æ–≤ VAD –∏ VAD TriG
            if (mode === 'vad' || mode === 'vad-trig') {
                maxVadRowLengthGroup.style.display = 'block';
            } else {
                maxVadRowLengthGroup.style.display = 'none';
            }

            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º/—Å–∫—Ä—ã–≤–∞–µ–º –æ–ø—Ü–∏—é "SPARQL Smart Design" –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
            if (smartDesignOption) {
                if (mode === 'vad-trig') {
                    smartDesignOption.style.display = '';
                } else {
                    smartDesignOption.style.display = 'none';
                    // –ï—Å–ª–∏ –±—ã–ª –≤—ã–±—Ä–∞–Ω smart-design, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω–∞ 'no'
                    if (sparqlModeSelect.value === 'smart-design') {
                        sparqlModeSelect.value = 'no';
                    }
                }
            }

            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ SPARQL –ø–∞–Ω–µ–ª–∏
            toggleSparqlPanel();
        }

        function toggleSparqlPanel() {
            const sparqlMode = document.getElementById('sparql-mode').value;
            const visualizationMode = document.getElementById('visualization-mode').value;
            const sparqlPanel = document.getElementById('sparql-panel');
            const smartDesignContainer = document.getElementById('smart-design-container');

            // –°–∫—Ä—ã–≤–∞–µ–º –æ–±–∞ –ø–∞–Ω–µ–ª–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            sparqlPanel.classList.remove('visible');
            smartDesignContainer.classList.remove('visible');

            if (sparqlMode === 'smart-design') {
                // SPARQL Smart Design –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ —Ä–µ–∂–∏–º–µ VAD TriG
                if (visualizationMode === 'vad-trig') {
                    smartDesignContainer.classList.add('visible');
                    // –í —Ä–µ–∂–∏–º–µ SPARQL Smart Design –≤—Å–µ–≥–¥–∞ —Ç–∞–∫–∂–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –æ–∫–Ω–æ SPARQL –∑–∞–ø—Ä–æ—Å
                    sparqlPanel.classList.add('visible');
                    // –ó–∞–ø–æ–ª–Ω—è–µ–º –≤—ã–ø–∞–¥–∞—é—â–∏–µ —Å–ø–∏—Å–∫–∏ –ø—Ä–∏ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ Smart Design
                    populateSmartDesignDropdowns();
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ø—Ä–∞–≤–æ—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –ø–∞–Ω–µ–ª–∏
                    showSmartDesignMessage('–í—ã–±–µ—Ä–∏—Ç–µ TriG, –∑–∞—Ç–µ–º Subject, Predicate –∏ Object. –ù–∞–∂–º–∏—Ç–µ "–°–æ–∑–¥–∞—Ç—å SPARQL" –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∑–∞–ø—Ä–æ—Å–∞.', 'info');
                    showResultSparqlMessage('–ü–æ—Å–ª–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ SPARQL –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞–∂–º–∏—Ç–µ "–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫–∞–∫ Simple Triple" –∏–ª–∏ "–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫–∞–∫ Shorthand Triple" –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ RDF –¥–∞–Ω–Ω—ã–µ.', 'info');
                } else {
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ, —á—Ç–æ Smart Design –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –≤ VAD TriG
                    showSmartDesignMessage('SPARQL Smart Design –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –≤ —Ä–µ–∂–∏–º–µ "–†–µ–∂–∏–º VAD TriG"', 'info');
                }
            }
        }

        // ============================================================================
        // –û–°–ù–û–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–ò
        // ============================================================================

        async function visualize() {
            const rdfInput = document.getElementById('rdf-input').value.trim();
            const inputFormat = document.getElementById('input-format').value;
            const outputFormat = document.getElementById('output-format').value;
            const layoutEngine = document.getElementById('layout-engine').value;
            const visualizationMode = document.getElementById('visualization-mode').value;

            const maxLabelLengthInput = document.getElementById('max-label-length');
            const maxLabelLengthValue = parseInt(maxLabelLengthInput.value, 10);
            if (!isNaN(maxLabelLengthValue) && maxLabelLengthValue >= 5 && maxLabelLengthValue <= 200) {
                currentMaxLabelLength = maxLabelLengthValue;
            } else {
                currentMaxLabelLength = DEFAULT_MAX_LABEL_LENGTH;
                maxLabelLengthInput.value = DEFAULT_MAX_LABEL_LENGTH;
            }

            // –ß—Ç–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ "–ú–∞–∫—Å. –¥–ª–∏–Ω–∞ VAD" –¥–ª—è —Ä–µ–∂–∏–º–∞ VAD
            const maxVadRowLengthInput = document.getElementById('max-vad-row-length');
            const maxVadRowLengthValue = parseInt(maxVadRowLengthInput.value, 10);
            if (!isNaN(maxVadRowLengthValue) && maxVadRowLengthValue >= 2 && maxVadRowLengthValue <= 20) {
                currentMaxVadRowLength = maxVadRowLengthValue;
            } else {
                currentMaxVadRowLength = DEFAULT_MAX_VAD_ROW_LENGTH;
                maxVadRowLengthInput.value = DEFAULT_MAX_VAD_ROW_LENGTH;
            }

            currentMode = visualizationMode;

            if (!rdfInput) {
                showError('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ RDF –¥–∞–Ω–Ω—ã–µ');
                return;
            }

            showLoading();

            const button = document.getElementById('visualize-btn');
            button.disabled = true;
            button.textContent = '–û–±—Ä–∞–±–æ—Ç–∫–∞...';

            try {
                const parser = new N3.Parser({ format: inputFormat });
                const quads = [];
                let prefixes = {};

                await new Promise((resolve, reject) => {
                    parser.parse(rdfInput, (error, quad, parsedPrefixes) => {
                        if (error) {
                            reject(error);
                            return;
                        }
                        if (quad) {
                            quads.push(quad);
                        } else {
                            if (parsedPrefixes) {
                                prefixes = parsedPrefixes;
                            }
                            resolve();
                        }
                    });
                });

                currentPrefixes = prefixes;
                currentQuads = quads;
                currentStore = null;

                if (quads.length === 0) {
                    showError('–ù–µ –Ω–∞–π–¥–µ–Ω–æ RDF —Ç—Ä–∏–ø–ª–µ—Ç–æ–≤ –≤ –¥–∞–Ω–Ω—ã—Ö');
                    return;
                }

                // –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–ª—è —Ä–µ–∂–∏–º–∞ VAD
                if (currentMode === 'vad') {
                    const validation = validateVAD(quads, prefixes);
                    if (!validation.valid) {
                        showValidationError(formatVADErrors(validation.errors));
                        button.disabled = false;
                        button.textContent = '–ü–æ–∫–∞–∑–∞—Ç—å';
                        return;
                    }
                }

                // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∂–∏–º–∞ VAD TriG
                if (currentMode === 'vad-trig') {
                    // –ü–∞—Ä—Å–∏–º –∏–µ—Ä–∞—Ä—Ö–∏—é TriG –≥—Ä–∞—Ñ–æ–≤
                    const hierarchyResult = parseTriGHierarchy(quads, prefixes);

                    if (!hierarchyResult.valid) {
                        showValidationError(formatVADTriGErrors(hierarchyResult.errors));
                        toggleVADTriGPanels(false);
                        button.disabled = false;
                        button.textContent = '–ü–æ–∫–∞–∑–∞—Ç—å';
                        return;
                    }

                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–µ—Ä–∞—Ä—Ö–∏—é
                    trigHierarchy = hierarchyResult.hierarchy;

                    // –í—ã–±–∏—Ä–∞–µ–º –∫–æ—Ä–Ω–µ–≤–æ–π TriG –¥–ª—è –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—ã–π –∏–∑ –∫–æ—Ä–Ω–µ–≤—ã—Ö TriG, –µ—Å–ª–∏ –µ—Å—Ç—å
                    selectedTrigUri = hierarchyResult.rootTrigUris.length > 0 ? hierarchyResult.rootTrigUris[0] : null;

                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª–∏ VAD TriG
                    toggleVADTriGPanels(true);

                    // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –¥–µ—Ä–µ–≤–æ TriG (–ø–µ—Ä–µ–¥–∞—ë–º –º–∞—Å—Å–∏–≤ –≤—Å–µ—Ö –∫–æ—Ä–Ω–µ–≤—ã—Ö TriG)
                    displayTriGTree(trigHierarchy, hierarchyResult.rootTrigUris, prefixes);

                    // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ –∫–æ—Ä–Ω–µ–≤–æ–≥–æ TriG
                    if (selectedTrigUri) {
                        displayTriGProperties(selectedTrigUri, trigHierarchy, prefixes);
                    }

                    // –í–∞–ª–∏–¥–∞—Ü–∏—è VAD –¥–ª—è –∫–≤–∞–¥–æ–≤ –∫–æ—Ä–Ω–µ–≤–æ–≥–æ –≥—Ä–∞—Ñ–∞
                    const rootGraphInfo = trigHierarchy[selectedTrigUri];
                    if (rootGraphInfo) {
                        const validation = validateVAD(rootGraphInfo.quads, prefixes);
                        if (!validation.valid) {
                            showValidationError(formatVADErrors(validation.errors));
                            button.disabled = false;
                            button.textContent = '–ü–æ–∫–∞–∑–∞—Ç—å';
                            return;
                        }
                    }

                    // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å –∫–≤–∞–¥–∞–º–∏ —Ç–æ–ª—å–∫–æ –∏–∑ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞
                    activeFilters = [...getFilterConfig('vad').hiddenPredicates];

                    const filteredQuads = rootGraphInfo.quads.filter(quad => {
                        const predicateUri = quad.predicate.value;
                        const predicateLabel = getPrefixedName(predicateUri, prefixes);
                        return !isPredicateHidden(predicateUri, predicateLabel);
                    });

                    // –í—Ä–µ–º–µ–Ω–Ω–æ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –≤ —Ä–µ–∂–∏–º VAD –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ DOT
                    const originalQuads = currentQuads;
                    currentQuads = rootGraphInfo.quads;
                    currentMode = 'vad';

                    const dotCode = rdfToDot(filteredQuads, prefixes);
                    currentDotCode = dotCode;
                    console.log('VAD TriG - –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π DOT-–∫–æ–¥:', dotCode);

                    currentQuads = originalQuads;
                    currentMode = 'vad-trig';

                    const viz = await Viz.instance();
                    const svgString = viz.renderString(dotCode, {
                        format: 'svg',
                        engine: layoutEngine
                    });

                    // –í —Ä–µ–∂–∏–º–µ VAD TriG –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä vad-trig-output
                    const output = document.getElementById('vad-trig-output');
                    currentScale = 1.0;
                    applyZoom();

                    if (outputFormat === 'svg') {
                        output.innerHTML = svgString;
                        currentSvgElement = output.querySelector('svg');
                        document.getElementById('export-buttons').style.display = 'block';
                        document.getElementById('vad-trig-zoom-controls').style.display = 'flex';
                    } else if (outputFormat === 'png') {
                        const pngDataUrl = await svgToPng(svgString);
                        output.innerHTML = `<img src="${pngDataUrl}" alt="RDF Graph" style="max-width: 100%;">`;
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = svgString;
                        currentSvgElement = tempDiv.querySelector('svg');
                        document.getElementById('export-buttons').style.display = 'block';
                        document.getElementById('vad-trig-zoom-controls').style.display = 'flex';
                    }

                    displayLegend();
                    displayPrefixes(prefixes);
                    displayFilters();
                    addNodeClickHandlers();
                    closeAllPropertiesPanels();

                    // –û–±–Ω–æ–≤–ª—è–µ–º SPARQL –∑–∞–ø—Ä–æ—Å –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ TriG
                    updateSparqlQueryForTriG();

                    // –û–±–Ω–æ–≤–ª—è–µ–º –≤—ã–ø–∞–¥–∞—é—â–∏–µ —Å–ø–∏—Å–∫–∏ Smart Design, –µ—Å–ª–∏ —Ä–µ–∂–∏–º –∞–∫—Ç–∏–≤–µ–Ω
                    if (document.getElementById('sparql-mode').value === 'smart-design') {
                        populateSmartDesignDropdowns();
                    }

                    console.log(`VAD TriG: –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ ${quads.length} —Ç—Ä–∏–ø–ª–µ—Ç–æ–≤, –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –≥—Ä–∞—Ñ ${getPrefixedName(selectedTrigUri, prefixes)}`);

                    button.disabled = false;
                    button.textContent = '–ü–æ–∫–∞–∑–∞—Ç—å';
                    return;
                }

                // –°–∫—Ä—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª–∏ VAD TriG –¥–ª—è –¥—Ä—É–≥–∏—Ö —Ä–µ–∂–∏–º–æ–≤
                toggleVADTriGPanels(false);

                activeFilters = [...getFilterConfig(currentMode).hiddenPredicates];

                const filteredQuads = quads.filter(quad => {
                    const predicateUri = quad.predicate.value;
                    const predicateLabel = getPrefixedName(predicateUri, prefixes);
                    return !isPredicateHidden(predicateUri, predicateLabel);
                });

                const dotCode = rdfToDot(filteredQuads, prefixes);
                currentDotCode = dotCode;
                console.log('–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π DOT-–∫–æ–¥:', dotCode);

                const viz = await Viz.instance();
                const svgString = viz.renderString(dotCode, {
                    format: 'svg',
                    engine: layoutEngine
                });

                const output = document.getElementById('output');
                currentScale = 1.0;
                applyZoom();

                if (outputFormat === 'svg') {
                    output.innerHTML = svgString;
                    currentSvgElement = output.querySelector('svg');
                    document.getElementById('export-buttons').style.display = 'block';
                    document.getElementById('zoom-controls').style.display = 'flex';
                } else if (outputFormat === 'png') {
                    const pngDataUrl = await svgToPng(svgString);
                    output.innerHTML = `<img src="${pngDataUrl}" alt="RDF Graph" style="max-width: 100%;">`;
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = svgString;
                    currentSvgElement = tempDiv.querySelector('svg');
                    document.getElementById('export-buttons').style.display = 'block';
                    document.getElementById('zoom-controls').style.display = 'flex';
                }

                if (currentMode !== 'base') {
                    displayLegend();
                } else {
                    document.getElementById('legend-panel').style.display = 'none';
                }

                displayPrefixes(prefixes);
                displayFilters();
                addNodeClickHandlers();
                closeAllPropertiesPanels();

                console.log(`–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ ${quads.length} —Ç—Ä–∏–ø–ª–µ—Ç–æ–≤`);

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏:', error);
                const enhancedMessage = enhanceParseError(error.message, rdfInput);
                showError(enhancedMessage);
            } finally {
                button.disabled = false;
                button.textContent = '–ü–æ–∫–∞–∑–∞—Ç—å';
            }
        }

        // ============================================================================
        // –§–£–ù–ö–¶–ò–ò –≠–ö–°–ü–û–†–¢–ê
        // ============================================================================

        function svgToPng(svgString) {
            return new Promise((resolve, reject) => {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = svgString;
                const svgElement = tempDiv.querySelector('svg');

                let width = parseInt(svgElement.getAttribute('width')) || 800;
                let height = parseInt(svgElement.getAttribute('height')) || 600;

                const widthStr = svgElement.getAttribute('width') || '';
                const heightStr = svgElement.getAttribute('height') || '';

                if (widthStr.includes('pt')) {
                    width = Math.ceil(parseFloat(widthStr) * 1.33);
                }
                if (heightStr.includes('pt')) {
                    height = Math.ceil(parseFloat(heightStr) * 1.33);
                }

                const canvas = document.createElement('canvas');
                canvas.width = width * 2;
                canvas.height = height * 2;
                const ctx = canvas.getContext('2d');
                ctx.scale(2, 2);
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, width, height);

                const img = new Image();
                const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);

                img.onload = function() {
                    ctx.drawImage(img, 0, 0, width, height);
                    URL.revokeObjectURL(url);
                    resolve(canvas.toDataURL('image/png'));
                };

                img.onerror = function() {
                    URL.revokeObjectURL(url);
                    reject(new Error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ SVG –≤ PNG'));
                };

                img.src = url;
            });
        }

        function downloadSVG() {
            if (!currentSvgElement) {
                alert('–°–Ω–∞—á–∞–ª–∞ –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ RDF –¥–∞–Ω–Ω—ã–µ');
                return;
            }

            const svgData = new XMLSerializer().serializeToString(currentSvgElement);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });

            const downloadLink = document.createElement('a');
            downloadLink.href = URL.createObjectURL(svgBlob);
            downloadLink.download = 'rdf-graph.svg';

            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(downloadLink.href);
        }

        async function downloadPNG() {
            if (!currentSvgElement) {
                alert('–°–Ω–∞—á–∞–ª–∞ –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ RDF –¥–∞–Ω–Ω—ã–µ');
                return;
            }

            try {
                const svgData = new XMLSerializer().serializeToString(currentSvgElement);
                const pngDataUrl = await svgToPng(svgData);

                const downloadLink = document.createElement('a');
                downloadLink.href = pngDataUrl;
                downloadLink.download = 'rdf-graph.png';

                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ PNG:', error);
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ PNG —Ñ–∞–π–ª–∞');
            }
        }

        /**
         * –ú–∞–ø–ø–∏–Ω–≥ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤ –Ω–∞ —Å–æ–∫—Ä–∞—â–µ–Ω–Ω—ã–µ –∏–º–µ–Ω–∞ –¥–ª—è URL
         */
        const formatMapping = {
            'turtle': 'ttl',
            'n-triples': 'nt',
            'n-quads': 'nq',
            'trig': 'trig'
        };

        /**
         * –û—Ç–∫—Ä—ã–≤–∞–µ—Ç –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é –≤ –Ω–æ–≤–æ–º –æ–∫–Ω–µ —á–µ—Ä–µ–∑ –≤–Ω–µ—à–Ω–∏–π LDF —Å–µ—Ä–≤–∏—Å
         * –§–æ—Ä–º–∏—Ä—É–µ—Ç URL —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏: rdf=–¥–∞–Ω–Ω—ã–µ&from=—Ñ–æ—Ä–º–∞—Ç&to=png
         */
        function openInNewWindowLdfFi() {
            // –ü–æ–ª—É—á–∞–µ–º –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            const rdfInput = document.getElementById('rdf-input').value.trim();
            const inputFormat = document.getElementById('input-format').value;

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –≤–≤–µ–¥–µ–Ω—ã
            if (!rdfInput) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ RDF –¥–∞–Ω–Ω—ã–µ');
                return;
            }

            // –ü–æ–ª—É—á–∞–µ–º —Ñ–æ—Ä–º–∞—Ç –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ URL
            const fromFormat = formatMapping[inputFormat] || 'ttl';

            // –ö–æ–¥–∏—Ä—É–µ–º RDF –¥–∞–Ω–Ω—ã–µ –¥–ª—è URL
            // –ó–∞–º–µ–Ω—è–µ–º –ø—Ä–æ–±–µ–ª—ã –Ω–∞ + –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å LDF —Å–µ—Ä–≤–∏—Å–æ–º
            const encodedRdf = encodeURIComponent(rdfInput).replace(/%20/g, '+');

            // –§–æ—Ä–º–∏—Ä—É–µ–º URL –¥–ª—è –≤–Ω–µ—à–Ω–µ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
            const serviceUrl = `https://www.ldf.fi/service/rdf-grapher?rdf=${encodedRdf}&from=${fromFormat}&to=png`;

            // –û—Ç–∫—Ä—ã–≤–∞–µ–º –≤ –Ω–æ–≤–æ–º –æ–∫–Ω–µ
            window.open(serviceUrl, '_blank');
        }

        /**
         * –û—Ç–∫—Ä—ã–≤–∞–µ—Ç –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é –≤ –Ω–æ–≤–æ–º –æ–∫–Ω–µ —á–µ—Ä–µ–∑ GitHub Pages (–±–µ–∑ –≤–Ω–µ—à–Ω–µ–≥–æ —Å–µ—Ä–≤–∏—Å–∞)
         * –§–æ—Ä–º–∏—Ä—É–µ—Ç URL —Å –¥–∞–Ω–Ω—ã–º–∏ –≤ —Ö–µ—à–µ: #rdf=–¥–∞–Ω–Ω—ã–µ&from=—Ñ–æ—Ä–º–∞—Ç&to=—Ñ–æ—Ä–º–∞—Ç&mode=—Ä–µ–∂–∏–º
         * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç URL fragment (hash) –≤–º–µ—Å—Ç–æ query params –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –æ—à–∏–±–∫–∏ URI Too Long
         */
        function openInNewWindowGitHub() {
            // –ü–æ–ª—É—á–∞–µ–º –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            const rdfInput = document.getElementById('rdf-input').value.trim();
            const inputFormat = document.getElementById('input-format').value;
            const outputFormat = document.getElementById('output-format').value;
            const visualizationMode = document.getElementById('visualization-mode').value;

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –≤–≤–µ–¥–µ–Ω—ã
            if (!rdfInput) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ RDF –¥–∞–Ω–Ω—ã–µ');
                return;
            }

            // –ü–æ–ª—É—á–∞–µ–º —Ñ–æ—Ä–º–∞—Ç –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ URL
            const fromFormat = formatMapping[inputFormat] || 'ttl';

            // –ö–æ–¥–∏—Ä—É–µ–º RDF –¥–∞–Ω–Ω—ã–µ –¥–ª—è URL
            const encodedRdf = encodeURIComponent(rdfInput);

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –±–∞–∑–æ–≤—ã–π URL –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–µ–≥–æ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è HTML —Ñ–∞–π–ª–∞
            // –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Ä–∞–±–æ—Ç–∞—Ç—å –∫–∞–∫ –Ω–∞ GitHub Pages, —Ç–∞–∫ –∏ –ª–æ–∫–∞–ª—å–Ω–æ
            let baseUrl;
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é HTML —Ñ–∞–π–ª–∞ –∫–∞–∫ –±–∞–∑–æ–≤—ã–π URL
            baseUrl = window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, '/');

            // –§–æ—Ä–º–∏—Ä—É–µ–º URL —Å –¥–∞–Ω–Ω—ã–º–∏ –≤ —Ö–µ—à–µ (–∏–∑–±–µ–≥–∞–µ—Ç –æ—à–∏–±–∫–∏ URI Too Long)
            const hashParams = `rdf=${encodedRdf}&from=${fromFormat}&to=${outputFormat}&mode=${visualizationMode}`;
            const serviceUrl = `${baseUrl}#${hashParams}`;

            // –û—Ç–∫—Ä—ã–≤–∞–µ–º –≤ –Ω–æ–≤–æ–º –æ–∫–Ω–µ
            window.open(serviceUrl, '_blank');
        }

        /**
         * –û—Ç–∫—Ä—ã–≤–∞–µ—Ç DOT-–∫–æ–¥ –≤ GraphvizOnline –¥–ª—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
         * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç —Ö–µ—à URL –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ DOT-–∫–æ–¥–∞
         */
        function openInNewWindowGraphvizOnline() {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ DOT-–∫–æ–¥ –±—ã–ª —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω
            if (!currentDotCode) {
                alert('–°–Ω–∞—á–∞–ª–∞ –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ RDF –¥–∞–Ω–Ω—ã–µ');
                return;
            }

            // –ö–æ–¥–∏—Ä—É–µ–º DOT-–∫–æ–¥ –¥–ª—è URL
            const encodedDot = encodeURIComponent(currentDotCode);

            // –§–æ—Ä–º–∏—Ä—É–µ–º URL —Å DOT-–∫–æ–¥–æ–º –≤ —Ö–µ—à–µ
            const graphvizUrl = `https://dreampuf.github.io/GraphvizOnline/#${encodedDot}`;

            // –û—Ç–∫—Ä—ã–≤–∞–µ–º –≤ –Ω–æ–≤–æ–º –æ–∫–Ω–µ
            window.open(graphvizUrl, '_blank');
        }

        // ============================================================================
        // SPARQL –§–£–ù–ö–¶–ò–ò
        // ============================================================================

        async function initSparqlEngine() {
            if (!currentStore) {
                currentStore = new N3.Store();
                currentQuads.forEach(quad => currentStore.addQuad(quad));
            }

            if (!comunicaEngine) {
                if (typeof Comunica !== 'undefined' && Comunica.QueryEngine) {
                    comunicaEngine = new Comunica.QueryEngine();
                }
            }

            return { store: currentStore, engine: comunicaEngine };
        }

        async function executeSparqlQuery() {
            const queryInput = document.getElementById('sparql-query');
            const resultsDiv = document.getElementById('sparql-results');
            const resultsContent = document.getElementById('sparql-results-content');

            const query = queryInput.value.trim();
            if (!query) {
                resultsContent.innerHTML = '<div class="sparql-error">–í–≤–µ–¥–∏—Ç–µ SPARQL –∑–∞–ø—Ä–æ—Å</div>';
                resultsDiv.style.display = 'block';
                return;
            }

            if (currentQuads.length === 0) {
                resultsContent.innerHTML = '<div class="sparql-error">–°–Ω–∞—á–∞–ª–∞ –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ RDF –¥–∞–Ω–Ω—ã–µ</div>';
                resultsDiv.style.display = 'block';
                return;
            }

            resultsContent.innerHTML = '<div class="sparql-loading"><div class="spinner"></div><p>–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞...</p></div>';
            resultsDiv.style.display = 'block';

            try {
                const { store, engine } = await initSparqlEngine();

                if (!engine) {
                    throw new Error('SPARQL –¥–≤–∏–∂–æ–∫ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
                }

                const bindingsStream = await engine.queryBindings(query, {
                    sources: [store]
                });

                const bindings = await bindingsStream.toArray();

                if (bindings.length === 0) {
                    resultsContent.innerHTML = '<p>–ó–∞–ø—Ä–æ—Å –Ω–µ –≤–µ—Ä–Ω—É–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤</p>';
                    return;
                }

                const variables = [...bindings[0].keys()].map(k => k.value);

                let html = '<table class="sparql-results-table">';
                html += '<thead><tr>';
                variables.forEach(v => {
                    html += `<th>?${v}</th>`;
                });
                html += '</tr></thead>';
                html += '<tbody>';

                let rowIndex = 0;
                bindings.forEach(binding => {
                    // –°–æ–±–∏—Ä–∞–µ–º URI –∏–∑ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –∫ —É–∑–ª—É
                    const uris = [];
                    variables.forEach(v => {
                        const term = binding.get(v);
                        if (term && term.termType !== 'Literal') {
                            uris.push(term.value);
                        }
                    });

                    // –ö–æ–¥–∏—Ä—É–µ–º URI –≤ base64 –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ —á–µ—Ä–µ–∑ data-–∞—Ç—Ä–∏–±—É—Ç
                    const urisData = btoa(encodeURIComponent(JSON.stringify(uris)));

                    html += `<tr class="clickable" data-row-index="${rowIndex}" data-uris="${urisData}" onclick="highlightNodeFromSparqlResult(this)">`;
                    variables.forEach(v => {
                        const term = binding.get(v);
                        if (term) {
                            const value = term.value;
                            const isLiteral = term.termType === 'Literal';
                            const displayValue = isLiteral ? `"${value}"` : getPrefixedName(value, currentPrefixes);
                            const cssClass = isLiteral ? 'literal' : 'uri';
                            html += `<td class="${cssClass}">${escapeHtml(displayValue)}</td>`;
                        } else {
                            html += '<td>-</td>';
                        }
                    });
                    html += '</tr>';
                    rowIndex++;
                });

                html += '</tbody></table>';
                html += `<p style="margin-top: 10px; font-size: 12px; color: #666;">–ù–∞–π–¥–µ–Ω–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤: ${bindings.length}</p>`;

                resultsContent.innerHTML = html;

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ SPARQL:', error);
                resultsContent.innerHTML = `<div class="sparql-error">–û—à–∏–±–∫–∞: ${error.message}</div>`;
            }
        }

        /**
         * –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ—Ç —É–∑–µ–ª –Ω–∞ –≥—Ä–∞—Ñ–µ –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–∞ —Å—Ç—Ä–æ–∫—É –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞—Ö SPARQL
         * –∏ –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç –ø–∞–Ω–µ–ª—å —Å–≤–æ–π—Å—Ç–≤ –¥–ª—è –ø–µ—Ä–≤–æ–≥–æ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ URI
         *
         * @param {HTMLElement} rowElement - –≠–ª–µ–º–µ–Ω—Ç —Å—Ç—Ä–æ–∫–∏ —Ç–∞–±–ª–∏—Ü—ã
         */
        function highlightNodeFromSparqlResult(rowElement) {
            // –°–Ω–∏–º–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É —Å–æ –≤—Å–µ—Ö —Å—Ç—Ä–æ–∫
            const allRows = document.querySelectorAll('.sparql-results-table tr.highlighted');
            allRows.forEach(row => row.classList.remove('highlighted'));

            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —Ç–µ–∫—É—â—É—é —Å—Ç—Ä–æ–∫—É
            rowElement.classList.add('highlighted');

            // –ü–æ–ª—É—á–∞–µ–º URI –∏–∑ –¥–∞–Ω–Ω—ã—Ö —Å—Ç—Ä–æ–∫–∏ (base64 –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π JSON)
            const urisData = rowElement.getAttribute('data-uris');
            if (!urisData) return;

            let uris;
            try {
                // –î–µ–∫–æ–¥–∏—Ä—É–µ–º base64 –∏ –∑–∞—Ç–µ–º URL-–¥–µ–∫–æ–¥–∏—Ä—É–µ–º
                uris = JSON.parse(decodeURIComponent(atob(urisData)));
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ URI:', e);
                return;
            }

            if (uris.length === 0) return;

            // –°–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —É–∑–ª–∞
            if (selectedNodeElement) {
                selectedNodeElement.classList.remove('selected');
                selectedNodeElement = null;
            }

            // –ò—â–µ–º —É–∑–ª—ã –Ω–∞ –≥—Ä–∞—Ñ–µ –ø–æ URI (–≤ –æ–±–æ–∏—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞—Ö: regular –∏ VAD TriG)
            const regularOutput = document.getElementById('output');
            const vadTrigOutput = document.getElementById('vad-trig-output');
            const regularSvg = regularOutput ? regularOutput.querySelector('svg') : null;
            const vadTrigSvg = vadTrigOutput ? vadTrigOutput.querySelector('svg') : null;

            // Collect all nodes from both SVG containers
            let allNodes = [];
            if (regularSvg) {
                allNodes = allNodes.concat(Array.from(regularSvg.querySelectorAll('.node')));
            }
            if (vadTrigSvg) {
                allNodes = allNodes.concat(Array.from(vadTrigSvg.querySelectorAll('.node')));
            }

            if (allNodes.length === 0) return;

            let foundNode = null;
            let foundUri = null;
            let foundLabel = null;

            // –ü—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ —É–∑–µ–ª –¥–ª—è –ø–µ—Ä–≤–æ–≥–æ URI
            for (const uri of uris) {
                for (const [label, info] of Object.entries(nodeLabelToUri)) {
                    if (info.uri === uri) {
                        // –ù–∞—à–ª–∏ –º–∞–ø–ø–∏–Ω–≥, –∏—â–µ–º —É–∑–µ–ª –ø–æ dotId
                        for (const node of allNodes) {
                            const titleElement = node.querySelector('title');
                            if (titleElement && titleElement.textContent === info.dotId) {
                                foundNode = node;
                                foundUri = uri;
                                foundLabel = label;
                                break;
                            }
                        }
                        if (foundNode) break;
                    }
                }
                if (foundNode) break;
            }

            if (foundNode) {
                // –í—ã–¥–µ–ª—è–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–π —É–∑–µ–ª
                foundNode.classList.add('selected');
                selectedNodeElement = foundNode;

                // –ü—Ä–æ–∫—Ä—É—á–∏–≤–∞–µ–º –∫ —É–∑–ª—É
                foundNode.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });

                // –û—Ç–∫—Ä—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª—å —Å–≤–æ–π—Å—Ç–≤ –¥–ª—è –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ URI
                if (foundUri) {
                    const displayLabel = foundLabel || getPrefixedName(foundUri, currentPrefixes);
                    showNodeProperties(foundUri, displayLabel);
                }
            } else if (uris.length > 0) {
                // –ï—Å–ª–∏ —É–∑–µ–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–∞ –≥—Ä–∞—Ñ–µ, –≤—Å–µ —Ä–∞–≤–Ω–æ –æ—Ç–∫—Ä—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª—å —Å–≤–æ–π—Å—Ç–≤ –¥–ª—è –ø–µ—Ä–≤–æ–≥–æ URI
                const uri = uris[0];
                const displayLabel = getPrefixedName(uri, currentPrefixes);
                showNodeProperties(uri, displayLabel);
            }
        }

        function resetSparqlQuery() {
            // –í —Ä–µ–∂–∏–º–µ VAD TriG –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–ø—Ä–æ—Å —Å GRAPH clause
            if (currentMode === 'vad-trig' && selectedTrigUri) {
                document.getElementById('sparql-query').value = getSparqlQueryForTriG(selectedTrigUri);
            } else {
                document.getElementById('sparql-query').value = defaultSparqlQuery;
            }
            document.getElementById('sparql-results').style.display = 'none';
        }

        /**
         * –ü–∞—Ä—Å–∏—Ç URL –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä–µ–∫—Ç —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
         * –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∫–∞–∫ –≤ query string (?...), —Ç–∞–∫ –∏ –≤ hash (#...)
         * Hash –∏–º–µ–µ—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –Ω–∞–¥ query string –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –æ—à–∏–±–∫–∏ URI Too Long
         *
         * –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:
         * - rdf: RDF –¥–∞–Ω–Ω—ã–µ (URL-encoded)
         * - from: –≤—Ö–æ–¥–Ω–æ–π —Ñ–æ—Ä–º–∞—Ç (ttl, nt, nq, trig)
         * - to: –≤—ã—Ö–æ–¥–Ω–æ–π —Ñ–æ—Ä–º–∞—Ç (svg, png)
         * - mode: —Ä–µ–∂–∏–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ (notation, base, aggregation, vad)
         *
         * @returns {Object} - –û–±—ä–µ–∫—Ç —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
         */
        function parseUrlParams() {
            // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ hash (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
            let urlParams;
            if (window.location.hash && window.location.hash.length > 1) {
                // –£–±–∏—Ä–∞–µ–º # –∏ –ø–∞—Ä—Å–∏–º –∫–∞–∫ URLSearchParams
                urlParams = new URLSearchParams(window.location.hash.substring(1));
            } else {
                // Fallback –Ω–∞ query string –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                urlParams = new URLSearchParams(window.location.search);
            }

            const params = {};

            // –ú–∞–ø–ø–∏–Ω–≥ –æ–±—Ä–∞—Ç–Ω—ã–π: –ø–∞—Ä–∞–º–µ—Ç—Ä—ã URL -> –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Ñ–æ—Ä–º–∞—Ç—ã
            const reverseFormatMapping = {
                'ttl': 'turtle',
                'turtle': 'turtle',
                'nt': 'n-triples',
                'n-triples': 'n-triples',
                'nq': 'n-quads',
                'n-quads': 'n-quads',
                'trig': 'trig'
            };

            // –ü–æ–ª—É—á–∞–µ–º RDF –¥–∞–Ω–Ω—ã–µ –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
            if (urlParams.has('rdf')) {
                params.rdf = urlParams.get('rdf');
            }

            // –ü–æ–ª—É—á–∞–µ–º –≤—Ö–æ–¥–Ω–æ–π —Ñ–æ—Ä–º–∞—Ç
            if (urlParams.has('from')) {
                const fromParam = urlParams.get('from');
                params.from = reverseFormatMapping[fromParam] || 'turtle';
            }

            // –ü–æ–ª—É—á–∞–µ–º –≤—ã—Ö–æ–¥–Ω–æ–π —Ñ–æ—Ä–º–∞—Ç
            if (urlParams.has('to')) {
                const toParam = urlParams.get('to');
                if (toParam === 'png' || toParam === 'svg') {
                    params.to = toParam;
                }
            }

            // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∂–∏–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
            if (urlParams.has('mode')) {
                const modeParam = urlParams.get('mode');
                const validModes = ['notation', 'base', 'aggregation', 'vad', 'vad-trig'];
                if (validModes.includes(modeParam)) {
                    params.mode = modeParam;
                }
            }

            return params;
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        document.addEventListener('DOMContentLoaded', function() {
            updateModeDescription();

            // –ü–∞—Ä—Å–∏–º URL –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
            const params = parseUrlParams();

            // –ï—Å–ª–∏ –µ—Å—Ç—å RDF –¥–∞–Ω–Ω—ã–µ –≤ URL, –∑–∞–ø–æ–ª–Ω—è–µ–º —Ñ–æ—Ä–º—É –∏ –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ–º
            if (params.rdf) {
                console.log('–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã RDF –¥–∞–Ω–Ω—ã–µ –≤ URL, –∑–∞–≥—Ä—É–∂–∞–µ–º...');

                // –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø–æ–ª–µ RDF –¥–∞–Ω–Ω—ã–º–∏
                document.getElementById('rdf-input').value = params.rdf;

                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Ö–æ–¥–Ω–æ–π —Ñ–æ—Ä–º–∞—Ç, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω
                if (params.from) {
                    document.getElementById('input-format').value = params.from;
                }

                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã—Ö–æ–¥–Ω–æ–π —Ñ–æ—Ä–º–∞—Ç, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω
                if (params.to) {
                    document.getElementById('output-format').value = params.to;
                }

                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–µ–∂–∏–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω
                if (params.mode) {
                    document.getElementById('visualization-mode').value = params.mode;
                    updateModeDescription();
                }

                // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏, —á—Ç–æ –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã
                setTimeout(function() {
                    visualize();
                }, 100);
            }
        });

        // ==============================================================================
        // –ú–û–î–£–õ–¨ SPARQL –ó–ê–ü–†–û–°–û–í –î–õ–Ø SMART DESIGN
        // ==============================================================================
        // –î–∞–Ω–Ω—ã–π –º–æ–¥—É–ª—å —Å–æ–¥–µ—Ä–∂–∏—Ç —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –∑–∞–ø—Ä–æ—Å—ã –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è
        // —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–æ–≤ –≤ –æ–∫–Ω–µ Smart Design –Ω–∞ –æ—Å–Ω–æ–≤–µ RDF-–¥–∞–Ω–Ω—ã—Ö –∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö
        // –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ vad-basic-ontology_tech_Appendix.ttl
        // ==============================================================================

        /**
         * –•—Ä–∞–Ω–∏–ª–∏—â–µ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ vad-basic-ontology_tech_Appendix.ttl
         * –ó–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
         */
        let techAppendixData = {
            loaded: false,
            predicateGroups: {}, // –ì—Ä—É–ø–ø—ã –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–≤ –ø–æ —Ç–∏–ø–∞–º –æ–±—ä–µ–∫—Ç–æ–≤
            autoGeneratedPredicates: {}, // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—ã–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã
            contextTriGTypes: {} // –°–≤—è–∑—å —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤ —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞–º–∏
        };

        /**
         * –í—ã–ø–æ–ª–Ω—è–µ—Ç SPARQL-–ø–æ–¥–æ–±–Ω—ã–π –∑–∞–ø—Ä–æ—Å –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è —É–∫–∞–∑–∞–Ω–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
         *
         * –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–ø–æ–ª–Ω—è–µ—Ç —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π SPARQL SELECT –∑–∞–ø—Ä–æ—Å, –∞–Ω–∞–ª–∏–∑–∏—Ä—É—è —Ç–µ–∫—É—â–∏–µ –∫–≤–∞–¥—ã (currentQuads).
         * –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã SPARQL, –≤–∫–ª—é—á–∞—è GRAPH –±–ª–æ–∫–∏ –¥–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤ –ø–æ –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–º –≥—Ä–∞—Ñ–∞–º.
         * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–æ–≤ –≤ –æ–∫–Ω–µ Smart Design.
         *
         * @param {string} sparqlQuery - SPARQL SELECT –∑–∞–ø—Ä–æ—Å
         * @param {string} variableName - –ò–º—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è (–±–µ–∑ '?'). –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 'value'
         * @returns {Array<{uri: string, label: string}>} –ú–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤ —Å URI –∏ –º–µ—Ç–∫–∞–º–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
         *
         * @example
         * // –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø—Ä–æ—Ü–µ—Å—Å—ã —Ç–∏–ø–∞ TypeProcess
         * const processes = funSPARQLvalues('SELECT ?p WHERE { ?p rdf:type vad:TypeProcess }', 'p');
         * // –†–µ–∑—É–ª—å—Ç–∞—Ç: [{ uri: 'http://example.org/vad#Process1', label: 'Process 1' }, ...]
         *
         * @example
         * // –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å—ã —Å –º–µ—Ç–∫–∞–º–∏ –∏–∑ ptree
         * const processesWithLabels = funSPARQLvalues(`
         *   SELECT ?process ?label WHERE {
         *     GRAPH vad:ptree {
         *       ?process rdf:type vad:TypeProcess .
         *       ?process rdfs:label ?label .
         *     }
         *   }
         * `, 'process');
         *
         * @see SPARQL_QUERIES - –ö–æ–ª–ª–µ–∫—Ü–∏—è –≥–æ—Ç–æ–≤—ã—Ö SPARQL –∑–∞–ø—Ä–æ—Å–æ–≤
         * @see currentQuads - –ì–ª–æ–±–∞–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤ –∫–≤–∞–¥–æ–≤ –¥–ª—è –ø–æ–∏—Å–∫–∞
         * @see currentPrefixes - –ì–ª–æ–±–∞–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤ –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è URI
         */
        function funSPARQLvalues(sparqlQuery, variableName = 'value') {
            const results = [];

            // –ï—Å–ª–∏ –Ω–µ—Ç —Ç–µ–∫—É—â–µ–≥–æ store, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤
            if (!currentStore || currentQuads.length === 0) {
                console.log('funSPARQLvalues: No data in store');
                return results;
            }

            try {
                // –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ –∞–Ω–∞–ª–∏–∑ —Ç–µ–∫—É—â–∏—Ö –∫–≤–∞–¥–æ–≤
                // –î–ª—è —Å–ª–æ–∂–Ω—ã—Ö SPARQL –∑–∞–ø—Ä–æ—Å–æ–≤ –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Comunica
                // –ù–æ –¥–ª—è –±–∞–∑–æ–≤—ã—Ö SELECT –∑–∞–ø—Ä–æ—Å–æ–≤ –º–æ–∂–Ω–æ –æ–±–æ–π—Ç–∏—Å—å –∞–Ω–∞–ª–∏–∑–æ–º –∫–≤–∞–¥–æ–≤

                // –ü–∞—Ä—Å–∏–º —Ç–∏–ø –∑–∞–ø—Ä–æ—Å–∞
                const selectMatch = sparqlQuery.match(/SELECT\s+(\?[\w]+(?:\s+\?[\w]+)*)/i);
                if (!selectMatch) {
                    console.log('funSPARQLvalues: Not a SELECT query');
                    return results;
                }

                const variables = selectMatch[1].split(/\s+/).map(v => v.substring(1));

                // –ü–∞—Ä—Å–∏–º WHERE —É—Å–ª–æ–≤–∏–µ (–ø—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–∏–Ω–≥)
                const whereMatch = sparqlQuery.match(/WHERE\s*\{([^}]+)\}/i);
                if (!whereMatch) {
                    console.log('funSPARQLvalues: No WHERE clause found');
                    return results;
                }

                const whereClause = whereMatch[1].trim();

                // –ü–∞—Ä—Å–∏–º triple patterns (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
                const triplePatterns = parseTriplePatterns(whereClause);

                // –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å —á–µ—Ä–µ–∑ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
                const bindings = executeSimpleSelect(triplePatterns, variables);

                // –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                const seen = new Set();
                bindings.forEach(binding => {
                    const valueVar = variableName in binding ? variableName : variables[0];
                    const value = binding[valueVar];
                    if (value && !seen.has(value)) {
                        seen.add(value);
                        const label = binding['label'] || getPrefixedName(value, currentPrefixes);
                        results.push({
                            uri: value,
                            label: label
                        });
                    }
                });

            } catch (error) {
                console.error('funSPARQLvalues error:', error);
            }

            return results;
        }

        /**
         * –ü–∞—Ä—Å–∏—Ç –ø—Ä–æ—Å—Ç—ã–µ triple patterns –∏–∑ WHERE –∫–ª–∞—É–∑—ã
         * @param {string} whereClause - –°—Ç—Ä–æ–∫–∞ —Å triple patterns
         * @returns {Array} - –ú–∞—Å—Å–∏–≤ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ {subject, predicate, object, graph}
         */
        function parseTriplePatterns(whereClause) {
            const patterns = [];

            // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥: —Ä–∞–∑–±–∏–≤–∞–µ–º –ø–æ —Ç–æ—á–∫–∞–º –∏ —Ç–æ—á–∫–∞–º —Å –∑–∞–ø—è—Ç—ã–º–∏
            const statements = whereClause.split(/\s*\.\s*/).filter(s => s.trim());

            statements.forEach(statement => {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º GRAPH –±–ª–æ–∫
                const graphMatch = statement.match(/GRAPH\s+(\S+)\s*\{([^}]+)\}/i);
                if (graphMatch) {
                    const graphUri = resolveValue(graphMatch[1]);
                    const innerStatements = graphMatch[2].split(/\s*\.\s*/).filter(s => s.trim());
                    innerStatements.forEach(inner => {
                        const parts = inner.trim().split(/\s+/);
                        if (parts.length >= 3) {
                            patterns.push({
                                subject: resolveValue(parts[0]),
                                predicate: resolveValue(parts[1]),
                                object: resolveValue(parts.slice(2).join(' ')),
                                graph: graphUri
                            });
                        }
                    });
                } else {
                    const parts = statement.trim().split(/\s+/);
                    if (parts.length >= 3) {
                        patterns.push({
                            subject: resolveValue(parts[0]),
                            predicate: resolveValue(parts[1]),
                            object: resolveValue(parts.slice(2).join(' ')),
                            graph: null
                        });
                    }
                }
            });

            return patterns;
        }

        /**
         * –†–∞–∑—Ä–µ—à–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ (prefix:local -> –ø–æ–ª–Ω—ã–π URI, –∏–ª–∏ –æ—Å—Ç–∞–≤–ª—è–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é)
         */
        function resolveValue(value) {
            if (!value) return null;
            value = value.trim();

            // –ï—Å–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è
            if (value.startsWith('?')) {
                return { type: 'variable', name: value.substring(1) };
            }

            // –ï—Å–ª–∏ –ø–æ–ª–Ω—ã–π URI –≤ —É–≥–ª–æ–≤—ã—Ö —Å–∫–æ–±–∫–∞—Ö
            if (value.startsWith('<') && value.endsWith('>')) {
                return { type: 'uri', value: value.slice(1, -1) };
            }

            // –ï—Å–ª–∏ prefixed name
            const colonIndex = value.indexOf(':');
            if (colonIndex > 0) {
                const prefix = value.substring(0, colonIndex);
                const local = value.substring(colonIndex + 1);
                const namespace = currentPrefixes[prefix];
                if (namespace) {
                    return { type: 'uri', value: namespace + local };
                }
            }

            // –ï—Å–ª–∏ –ª–∏—Ç–µ—Ä–∞–ª –≤ –∫–∞–≤—ã—á–∫–∞—Ö
            if (value.startsWith('"') || value.startsWith("'")) {
                return { type: 'literal', value: value.replace(/^["']|["']$/g, '') };
            }

            // –ò–Ω–∞—á–µ —Å—á–∏—Ç–∞–µ–º —á—Ç–æ —ç—Ç–æ prefixed name –±–µ–∑ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è
            return { type: 'uri', value: value };
        }

        /**
         * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø—Ä–æ—Å—Ç–æ–π SELECT –∑–∞–ø—Ä–æ—Å —á–µ—Ä–µ–∑ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ —Å –∫–≤–∞–¥–∞–º–∏
         */
        function executeSimpleSelect(patterns, variables) {
            const bindings = [{}];

            patterns.forEach(pattern => {
                const newBindings = [];

                bindings.forEach(binding => {
                    // –§–∏–ª—å—Ç—Ä—É–µ–º –∫–≤–∞–¥—ã –ø–æ –ø–∞—Ç—Ç–µ—Ä–Ω—É
                    currentQuads.forEach(quad => {
                        const match = matchQuadToPattern(quad, pattern, binding);
                        if (match) {
                            newBindings.push({...binding, ...match});
                        }
                    });
                });

                // –ó–∞–º–µ–Ω—è–µ–º bindings –Ω–æ–≤—ã–º–∏
                bindings.length = 0;
                bindings.push(...newBindings);
            });

            return bindings;
        }

        /**
         * –°–æ–ø–æ—Å—Ç–∞–≤–ª—è–µ—Ç –∫–≤–∞–¥ —Å –ø–∞—Ç—Ç–µ—Ä–Ω–æ–º
         */
        function matchQuadToPattern(quad, pattern, currentBinding) {
            const newBinding = {};

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞—Ñ
            if (pattern.graph) {
                if (pattern.graph.type === 'variable') {
                    const boundValue = currentBinding[pattern.graph.name];
                    if (boundValue && boundValue !== quad.graph.value) return null;
                    newBinding[pattern.graph.name] = quad.graph.value;
                } else if (pattern.graph.type === 'uri') {
                    if (quad.graph.value !== pattern.graph.value) return null;
                }
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É–±—ä–µ–∫—Ç
            if (pattern.subject) {
                if (pattern.subject.type === 'variable') {
                    const boundValue = currentBinding[pattern.subject.name];
                    if (boundValue && boundValue !== quad.subject.value) return null;
                    newBinding[pattern.subject.name] = quad.subject.value;
                } else if (pattern.subject.type === 'uri') {
                    if (quad.subject.value !== pattern.subject.value) return null;
                }
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–µ–¥–∏–∫–∞—Ç
            if (pattern.predicate) {
                if (pattern.predicate.type === 'variable') {
                    const boundValue = currentBinding[pattern.predicate.name];
                    if (boundValue && boundValue !== quad.predicate.value) return null;
                    newBinding[pattern.predicate.name] = quad.predicate.value;
                } else if (pattern.predicate.type === 'uri') {
                    if (quad.predicate.value !== pattern.predicate.value) return null;
                }
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—ä–µ–∫—Ç
            if (pattern.object) {
                if (pattern.object.type === 'variable') {
                    const boundValue = currentBinding[pattern.object.name];
                    const quadObjectValue = quad.object.value;
                    if (boundValue && boundValue !== quadObjectValue) return null;
                    newBinding[pattern.object.name] = quadObjectValue;
                } else if (pattern.object.type === 'uri') {
                    if (quad.object.value !== pattern.object.value) return null;
                } else if (pattern.object.type === 'literal') {
                    if (quad.object.value !== pattern.object.value) return null;
                }
            }

            return newBinding;
        }

        // ==============================================================================
        // SPARQL –ó–ê–ü–†–û–°–´ –î–õ–Ø SMART DESIGN
        // ==============================================================================
        // SPARQL –∑–∞–ø—Ä–æ—Å—ã –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω—ã –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π —Ñ–∞–π–ª sparql-queries.js

        // ==============================================================================
        // –§–£–ù–ö–¶–ò–ò –ö–û–ü–ò–†–û–í–ê–ù–ò–Ø –í –ë–£–§–ï–† –û–ë–ú–ï–ù–ê
        // ==============================================================================

        /**
         * –ö–æ–ø–∏—Ä—É–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—è –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞
         * @param {string} selectId - ID —ç–ª–µ–º–µ–Ω—Ç–∞ select
         */
        async function copyFieldValue(selectId) {
            const select = document.getElementById(selectId);
            if (!select) return;

            const value = select.value;
            if (!value || value === '' || value === '__NEW__') {
                showSmartDesignMessage('–í—ã–±–µ—Ä–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è', 'info');
                return;
            }

            // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–π –æ–ø—Ü–∏–∏
            const selectedOption = select.options[select.selectedIndex];
            const textToCopy = selectedOption ? selectedOption.textContent : value;

            try {
                await navigator.clipboard.writeText(textToCopy);

                // –í–∏–∑—É–∞–ª—å–Ω–∞—è –∏–Ω–¥–∏–∫–∞—Ü–∏—è —É—Å–ø–µ—Ö–∞
                const btn = select.parentElement.querySelector('.copy-to-clipboard-btn');
                if (btn) {
                    btn.classList.add('copied');
                    btn.textContent = '‚úì';
                    setTimeout(() => {
                        btn.classList.remove('copied');
                        btn.textContent = 'üìã';
                    }, 1500);
                }

                showSmartDesignMessage(`–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ: ${textToCopy}`, 'success');
            } catch (error) {
                console.error('Copy failed:', error);
                showSmartDesignMessage('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞', 'error');
            }
        }

        // ==============================================================================
        // –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ú–û–î–ê–õ–¨–ù–û–ì–û –û–ö–ù–ê NEW TRIG
        // ==============================================================================

        /**
         * –û–±–Ω–æ–≤–ª—è–µ—Ç –ø–æ–ª—è ID –∏ label –≤ –º–æ–¥–∞–ª—å–Ω–æ–º –æ–∫–Ω–µ New TriG
         * –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ü–µ–ø—Ç–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞
         */
        function updateNewTrigFields() {
            const processConceptSelect = document.getElementById('new-trig-process-concept');
            const trigIdInput = document.getElementById('new-trig-id');
            const trigLabelInput = document.getElementById('new-trig-label');

            if (!processConceptSelect || !trigIdInput || !trigLabelInput) return;

            const selectedUri = processConceptSelect.value;
            if (!selectedUri) {
                trigIdInput.value = '';
                trigLabelInput.value = '';
                return;
            }

            // –ü–æ–ª—É—á–∞–µ–º ID –ø—Ä–æ—Ü–µ—Å—Å–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∏–∑ vad:p1 -> p1)
            const processId = getPrefixedName(selectedUri, currentPrefixes).replace('vad:', '');

            // –§–æ—Ä–º–∏—Ä—É–µ–º ID TriG
            const trigId = `t_${processId}`;
            trigIdInput.value = trigId;

            // –ü–æ–ª—É—á–∞–µ–º label –ø—Ä–æ—Ü–µ—Å—Å–∞
            const selectedOption = processConceptSelect.options[processConceptSelect.selectedIndex];
            const processLabel = selectedOption ? selectedOption.textContent : processId;

            // –§–æ—Ä–º–∏—Ä—É–µ–º label TriG –≤ —Ñ–æ—Ä–º–∞—Ç–µ "–°—Ö–µ–º–∞ t_{processId} –ø—Ä–æ—Ü–µ—Å—Å–∞ {processId}"
            trigLabelInput.value = `–°—Ö–µ–º–∞ ${trigId} –ø—Ä–æ—Ü–µ—Å—Å–∞ ${processId}`;
        }

        /**
         * –ó–∞–ø–æ–ª–Ω—è–µ—Ç –≤—ã–ø–∞–¥–∞—é—â–∏–π —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ü–µ–ø—Ç–æ–≤ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –≤ –º–æ–¥–∞–ª—å–Ω–æ–º –æ–∫–Ω–µ New TriG
         * –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∏–∑ ptree —Ç–æ–ª—å–∫–æ —Ç–µ –ø—Ä–æ—Ü–µ—Å—Å—ã, —É –∫–æ—Ç–æ—Ä—ã—Ö –µ—â—ë –Ω–µ—Ç TriG —Å—Ö–µ–º—ã
         */
        function populateNewTrigProcessConcepts() {
            const processConceptSelect = document.getElementById('new-trig-process-concept');
            if (!processConceptSelect) return;

            processConceptSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ü–µ–ø—Ç –ø—Ä–æ—Ü–µ—Å—Å–∞ --</option>';

            // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∫–æ–Ω—Ü–µ–ø—Ç—ã –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –∏–∑ ptree
            const processConcepts = getProcessSubjects();

            // –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å—ã, –∫–æ—Ç–æ—Ä—ã–µ —É–∂–µ –∏–º–µ—é—Ç TriG —Å—Ö–µ–º—É
            const processesWithTrig = new Set();
            currentQuads.forEach(quad => {
                const predicate = quad.predicate.value;
                if (predicate === 'http://example.org/vad#hasTrig' ||
                    predicate.endsWith('#hasTrig')) {
                    processesWithTrig.add(quad.subject.value);
                }
            });

            // –§–∏–ª—å—Ç—Ä—É–µ–º - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–æ—Ü–µ—Å—Å—ã –±–µ–∑ TriG
            processConcepts.forEach(p => {
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ –ø—Ä–æ—Ü–µ—Å—Å—ã, –Ω–æ –ø–æ–º–µ—á–∞–µ–º —Ç–µ, —É –∫–æ—Ç–æ—Ä—ã—Ö —É–∂–µ –µ—Å—Ç—å TriG
                const option = document.createElement('option');
                option.value = p.uri;

                if (processesWithTrig.has(p.uri)) {
                    option.textContent = `${p.label} (—É–∂–µ –∏–º–µ–µ—Ç TriG)`;
                    option.disabled = true;
                    option.style.color = '#999';
                } else {
                    option.textContent = p.label;
                }

                processConceptSelect.appendChild(option);
            });
        }

        // ==============================================================================
        // –ó–ê–ì–†–£–ó–ö–ê –¢–ï–•–ù–û–õ–û–ì–ò–ß–ï–°–ö–û–ì–û –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø
        // ==============================================================================

        /**
         * –ó–∞–≥—Ä—É–∂–∞–µ—Ç vad-basic-ontology_tech_Appendix.ttl –∏ –ø–∞—Ä—Å–∏—Ç —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –æ–±—ä–µ–∫—Ç—ã
         * –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
         */
        async function loadTechAppendix() {
            try {
                const response = await fetch('vad-basic-ontology_tech_Appendix.ttl');
                if (!response.ok) {
                    console.warn('Tech appendix file not found, using default configuration');
                    return;
                }

                const ttlContent = await response.text();

                // –ü–∞—Ä—Å–∏–º TTL —Ñ–∞–π–ª —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Promise –¥–ª—è –æ–∂–∏–¥–∞–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
                const techQuads = await new Promise((resolve, reject) => {
                    const parser = new N3.Parser({ format: 'text/turtle' });
                    const quads = [];

                    parser.parse(ttlContent, (error, quad, prefixes) => {
                        if (error) {
                            reject(error);
                            return;
                        }
                        if (quad) {
                            quads.push(quad);
                        } else {
                            // quad is null, parsing is complete
                            resolve(quads);
                        }
                    });
                });

                // –ò–∑–≤–ª–µ–∫–∞–µ–º –≥—Ä—É–ø–ø—ã –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–≤
                extractPredicateGroups(techQuads);

                techAppendixData.loaded = true;
                console.log('Tech appendix loaded successfully');
                console.log('Predicate groups:', Object.keys(techAppendixData.predicateGroups).length);
                console.log('Auto-generated predicates:', Object.keys(techAppendixData.autoGeneratedPredicates).length);

            } catch (error) {
                console.error('Error loading tech appendix:', error);
            }
        }

        /**
         * –ò–∑–≤–ª–µ–∫–∞–µ—Ç –≥—Ä—É–ø–ø—ã –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–≤ –∏–∑ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤
         */
        function extractPredicateGroups(quads) {
            const VAD_NS = 'http://example.org/vad#';

            quads.forEach(quad => {
                const subject = quad.subject.value;
                const predicate = quad.predicate.value;
                const object = quad.object.value;

                // –ò–∑–≤–ª–µ–∫–∞–µ–º includePredicate
                if (predicate === VAD_NS + 'includePredicate' ||
                    predicate.endsWith('#includePredicate')) {
                    if (!techAppendixData.predicateGroups[subject]) {
                        techAppendixData.predicateGroups[subject] = [];
                    }
                    techAppendixData.predicateGroups[subject].push(object);
                }

                // –ò–∑–≤–ª–µ–∫–∞–µ–º autoGeneratedPredicate
                if (predicate === VAD_NS + 'autoGeneratedPredicate' ||
                    predicate.endsWith('#autoGeneratedPredicate')) {
                    if (!techAppendixData.autoGeneratedPredicates[subject]) {
                        techAppendixData.autoGeneratedPredicates[subject] = [];
                    }
                    techAppendixData.autoGeneratedPredicates[subject].push(object);
                }

                // –ò–∑–≤–ª–µ–∫–∞–µ–º contextTriGType
                if (predicate === VAD_NS + 'contextTriGType' ||
                    predicate.endsWith('#contextTriGType')) {
                    techAppendixData.contextTriGTypes[subject] = object;
                }
            });
        }

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –¥–ª—è –∑–∞–¥–∞–Ω–Ω–æ–≥–æ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
         * @param {string} techObjectUri - URI —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
         * @returns {Array} - –ú–∞—Å—Å–∏–≤ URI –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–≤
         */
        function getPredicatesFromTechObject(techObjectUri) {
            // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º URI
            let normalizedUri = techObjectUri;
            if (techObjectUri.startsWith('vad:')) {
                normalizedUri = 'http://example.org/vad#' + techObjectUri.substring(4);
            }

            return techAppendixData.predicateGroups[normalizedUri] || [];
        }

        /**
         * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø—Ä–µ–¥–∏–∫–∞—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—ã–º
         * –ï—Å–ª–∏ techObjectUri –Ω–µ —É–∫–∞–∑–∞–Ω, –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –≤–æ –≤—Å–µ—Ö —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –æ–±—ä–µ–∫—Ç–∞—Ö
         * @param {string} predicateUri - URI –ø—Ä–µ–¥–∏–∫–∞—Ç–∞
         * @param {string} [techObjectUri] - URI —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
         * @returns {boolean}
         */
        function isAutoGeneratedPredicate(predicateUri, techObjectUri) {
            if (!predicateUri) return false;

            let normalizedPredUri = predicateUri;
            if (predicateUri.startsWith('vad:')) {
                normalizedPredUri = 'http://example.org/vad#' + predicateUri.substring(4);
            }

            // –ï—Å–ª–∏ techObjectUri —É–∫–∞–∑–∞–Ω, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ–º –æ–±—ä–µ–∫—Ç–µ
            if (techObjectUri) {
                let normalizedTechUri = techObjectUri;
                if (techObjectUri.startsWith('vad:')) {
                    normalizedTechUri = 'http://example.org/vad#' + techObjectUri.substring(4);
                }
                const autoGenerated = techAppendixData.autoGeneratedPredicates[normalizedTechUri] || [];
                return autoGenerated.includes(normalizedPredUri);
            }

            // –ï—Å–ª–∏ techObjectUri –Ω–µ —É–∫–∞–∑–∞–Ω, –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ –≤—Å–µ—Ö —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –æ–±—ä–µ–∫—Ç–∞—Ö
            for (const techUri in techAppendixData.autoGeneratedPredicates) {
                const autoGenerated = techAppendixData.autoGeneratedPredicates[techUri];
                if (autoGenerated && autoGenerated.includes(normalizedPredUri)) {
                    return true;
                }
            }
            return false;
        }

        // ==============================================================================
        // –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –§–£–ù–ö–¶–ò–ò SMART DESIGN
        // ==============================================================================

        /**
         * –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è Subject dropdown
         * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç SPARQL –∑–∞–ø—Ä–æ—Å—ã –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞
         */
        function updateSubjectsBySubjectTypeWithSPARQL() {
            const subjectSelect = document.getElementById('smart-design-subject');
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const trigSelect = document.getElementById('smart-design-trig');

            if (!subjectSelect || !subjectTypeSelect || !trigSelect) return;

            const subjectType = subjectTypeSelect.value;
            const trigUri = trigSelect.value;

            subjectSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Subject --</option>';
            subjectSelect.innerHTML += '<option value="__NEW__">New (—Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π)</option>';

            if (!subjectType || !trigUri) return;

            const trigContext = getTrigContext(trigUri);
            let subjects = [];

            // –ò—Å–ø–æ–ª—å–∑—É–µ–º SPARQL-–ø–æ–¥–æ–±–Ω—ã–π –∑–∞–ø—Ä–æ—Å –∫ –¥–∞–Ω–Ω—ã–º
            if (subjectType === 'vad:TypeProcess') {
                if (trigContext === 'ptree') {
                    // –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ü–µ–ø—Ç—ã –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –∏–∑ ptree
                    subjects = getProcessSubjects();
                } else if (trigContext === 'vadProcessDia') {
                    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω–¥–∏–≤–∏–¥—ã –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ TriG
                    subjects = getProcessIndividualsInTriG(trigUri);
                }
            } else if (subjectType === 'vad:ExecutorGroup') {
                // –ü–æ–ª—É—á–∞–µ–º –≥—Ä—É–ø–ø—ã –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ TriG
                subjects = getExecutorGroupsInTriG(trigUri);
            } else if (subjectType === 'vad:TypeExecutor') {
                if (trigContext === 'rtree') {
                    // –ü–æ–ª—É—á–∞–µ–º –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –∏–∑ rtree
                    subjects = getExecutorSubjects();
                }
            } else if (subjectType === 'vad:VADProcessDia') {
                // –î–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–∞–º–æ–≥–æ TriG
                subjects = [{
                    uri: trigUri,
                    label: getPrefixedName(trigUri, currentPrefixes)
                }];
            } else if (subjectType === 'vad:ProcessTree') {
                subjects = [{
                    uri: 'http://example.org/vad#ptree',
                    label: 'vad:ptree'
                }];
            } else if (subjectType === 'vad:ExecutorTree') {
                subjects = [{
                    uri: 'http://example.org/vad#rtree',
                    label: 'vad:rtree'
                }];
            }

            subjects.forEach(s => {
                const option = document.createElement('option');
                option.value = s.uri;
                option.textContent = s.label;
                subjectSelect.appendChild(option);
            });
        }

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç –∏–Ω–¥–∏–≤–∏–¥—ã –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º TriG (VADProcessDia)
         * –ò–Ω–¥–∏–≤–∏–¥—ã –æ–ø—Ä–µ–¥–µ–ª—è—é—Ç—Å—è –Ω–∞–ª–∏—á–∏–µ–º –ø—Ä–µ–¥–∏–∫–∞—Ç–∞ vad:isSubprocessTrig
         */
        function getProcessIndividualsInTriG(trigUri) {
            const individuals = [];
            const seen = new Set();

            // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º URI
            const normalizedTrigUri = normalizeUri(trigUri);

            currentQuads.forEach(quad => {
                const predicate = quad.predicate.value;

                // –ò—â–µ–º —Ç—Ä–∏–ø–ª–µ—Ç—ã —Å vad:isSubprocessTrig
                if (predicate === 'http://example.org/vad#isSubprocessTrig' ||
                    predicate.endsWith('#isSubprocessTrig')) {

                    const objectUri = normalizeUri(quad.object.value);

                    if (objectUri === normalizedTrigUri) {
                        const subjectUri = quad.subject.value;
                        if (!seen.has(subjectUri)) {
                            seen.add(subjectUri);

                            // –ü–æ–ª—É—á–∞–µ–º label –∏–∑ ptree
                            const label = getLabelFromPtree(subjectUri) ||
                                         getPrefixedName(subjectUri, currentPrefixes);

                            individuals.push({
                                uri: subjectUri,
                                label: label
                            });
                        }
                    }
                }
            });

            return individuals;
        }

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç –≥—Ä—É–ø–ø—ã –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º TriG
         */
        function getExecutorGroupsInTriG(trigUri) {
            const groups = [];
            const seen = new Set();

            const normalizedTrigUri = normalizeUri(trigUri);

            currentQuads.forEach(quad => {
                if (quad.graph.value === normalizedTrigUri) {
                    const predicate = quad.predicate.value;

                    // –ò—â–µ–º rdf:type vad:ExecutorGroup
                    if ((predicate === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' ||
                         predicate.endsWith('#type')) &&
                        (quad.object.value === 'http://example.org/vad#ExecutorGroup' ||
                         quad.object.value.endsWith('#ExecutorGroup'))) {

                        const subjectUri = quad.subject.value;
                        if (!seen.has(subjectUri)) {
                            seen.add(subjectUri);

                            // –ò—â–µ–º label
                            const label = getLabelInGraph(subjectUri, normalizedTrigUri) ||
                                         getPrefixedName(subjectUri, currentPrefixes);

                            groups.push({
                                uri: subjectUri,
                                label: label
                            });
                        }
                    }
                }
            });

            return groups;
        }

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç label –æ–±—ä–µ–∫—Ç–∞ –∏–∑ ptree
         */
        function getLabelFromPtree(subjectUri) {
            const ptreeUri = 'http://example.org/vad#ptree';

            for (const quad of currentQuads) {
                if (quad.graph.value === ptreeUri &&
                    quad.subject.value === subjectUri &&
                    (quad.predicate.value === 'http://www.w3.org/2000/01/rdf-schema#label' ||
                     quad.predicate.value.endsWith('#label'))) {
                    return quad.object.value;
                }
            }
            return null;
        }

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç label –æ–±—ä–µ–∫—Ç–∞ –≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º –≥—Ä–∞—Ñ–µ
         */
        function getLabelInGraph(subjectUri, graphUri) {
            for (const quad of currentQuads) {
                if (quad.graph.value === graphUri &&
                    quad.subject.value === subjectUri &&
                    (quad.predicate.value === 'http://www.w3.org/2000/01/rdf-schema#label' ||
                     quad.predicate.value.endsWith('#label'))) {
                    return quad.object.value;
                }
            }
            return null;
        }

        /**
         * –ù–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç URI (—É–±–∏—Ä–∞–µ—Ç prefix, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
         */
        function normalizeUri(uri) {
            if (!uri) return '';

            // –ï—Å–ª–∏ —É–∂–µ –ø–æ–ª–Ω—ã–π URI
            if (uri.startsWith('http://') || uri.startsWith('https://')) {
                return uri;
            }

            // –ï—Å–ª–∏ prefixed name
            const colonIndex = uri.indexOf(':');
            if (colonIndex > 0) {
                const prefix = uri.substring(0, colonIndex);
                const local = uri.substring(colonIndex + 1);
                const namespace = currentPrefixes[prefix];
                if (namespace) {
                    return namespace + local;
                }
            }

            return uri;
        }

        /**
         * –ü–æ–ª—É—á–∞–µ—Ç —Å—É–±—ä–µ–∫—Ç—ã-–∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–∏ –∏–∑ rtree
         */
        function getExecutorSubjects() {
            const subjects = [];
            const seen = new Set();
            const rtreeUri = 'http://example.org/vad#rtree';

            currentQuads.forEach(quad => {
                if (quad.graph.value === rtreeUri) {
                    const predicate = quad.predicate.value;

                    // –ò—â–µ–º rdf:type vad:Executor
                    if ((predicate === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' ||
                         predicate.endsWith('#type')) &&
                        (quad.object.value === 'http://example.org/vad#Executor' ||
                         quad.object.value.endsWith('#Executor'))) {

                        const subjectUri = quad.subject.value;
                        if (!seen.has(subjectUri)) {
                            seen.add(subjectUri);

                            const label = getLabelInGraph(subjectUri, rtreeUri) ||
                                         getPrefixedName(subjectUri, currentPrefixes);

                            subjects.push({
                                uri: subjectUri,
                                label: label
                            });
                        }
                    }
                }
            });

            return subjects;
        }

        /**
         * –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è Predicate dropdown —Å —É—á–µ—Ç–æ–º –∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—ã—Ö –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–≤
         */
        function updatePredicateBySubjectTypeWithAutoGen() {
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const predicateSelect = document.getElementById('smart-design-predicate');
            const trigSelect = document.getElementById('smart-design-trig');

            if (!subjectTypeSelect || !predicateSelect || !trigSelect) return;

            const subjectType = subjectTypeSelect.value;
            const trigUri = trigSelect.value;
            const trigContext = getTrigContext(trigUri);

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            const currentPredicateValue = predicateSelect.value;

            predicateSelect.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ Predicate --</option>';

            if (!subjectType) {
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –µ—Å–ª–∏ —Ç–∏–ø –Ω–µ –≤—ã–±—Ä–∞–Ω
                const allPredicates = getAllPredicates();
                allPredicates.forEach(p => {
                    const option = document.createElement('option');
                    option.value = p.uri;
                    option.textContent = p.label;
                    predicateSelect.appendChild(option);
                });
                return;
            }

            // –ü–æ–ª—É—á–∞–µ–º –¥–æ–ø—É—Å—Ç–∏–º—ã–µ –ø—Ä–µ–¥–∏–∫–∞—Ç—ã –¥–ª—è —Ç–∏–ø–∞
            const allowedPredicates = getPredicatesForSubjectType(subjectType, trigContext);

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π –æ–±—ä–µ–∫—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
            let techObjectUri = '';
            if (subjectType === 'vad:TypeProcess' && trigContext === 'vadProcessDia') {
                techObjectUri = 'http://example.org/vad#IndividProcessPredicate';
            } else if (subjectType === 'vad:ExecutorGroup') {
                techObjectUri = 'http://example.org/vad#ConceptExecutorGroupPredicate';
            } else if (subjectType === 'vad:VADProcessDia') {
                techObjectUri = 'http://example.org/vad#ConceptTriGPredicate';
            }

            allowedPredicates.forEach(pred => {
                const option = document.createElement('option');

                // –†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –≤ –ø–æ–ª–Ω—ã–π URI
                let fullUri = pred;
                for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                    if (pred.startsWith(prefix + ':')) {
                        fullUri = namespace + pred.substring(prefix.length + 1);
                        break;
                    }
                }
                option.value = fullUri;

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø—Ä–µ–¥–∏–∫–∞—Ç –∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—ã–º
                const isAutoGen = techObjectUri && isAutoGeneratedPredicate(techObjectUri, fullUri);

                if (isAutoGen) {
                    option.textContent = pred + ' (–∞–≤—Ç–æ)';
                    option.disabled = true;
                    option.style.color = '#999';
                    option.style.fontStyle = 'italic';
                } else {
                    option.textContent = pred;
                }

                predicateSelect.appendChild(option);
            });

            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–±–æ—Ä –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –≤—Å–µ –µ—â–µ –¥–æ—Å—Ç—É–ø–Ω–æ –∏ –Ω–µ disabled
            const availableOption = Array.from(predicateSelect.options).find(
                o => o.value === currentPredicateValue && !o.disabled
            );
            if (availableOption) {
                predicateSelect.value = currentPredicateValue;
            }
        }

        /**
         * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ç—Ä–∏–ø–ª–µ—Ç—ã –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ –∏–Ω–¥–∏–≤–∏–¥–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞
         * @param {string} processUri - URI –Ω–æ–≤–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
         * @param {string} trigUri - URI —Ç–µ–∫—É—â–µ–≥–æ TriG
         * @returns {string} - –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ç—Ä–∏–ø–ª–µ—Ç—ã –¥–ª—è SPARQL INSERT
         */
        function generateAutoTriples(processUri, trigUri) {
            // –ò–∑–≤–ª–µ–∫–∞–µ–º ID –ø—Ä–æ—Ü–µ—Å—Å–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è ExecutorGroup
            const processId = getPrefixedName(processUri, currentPrefixes).replace('vad:', '');
            const executorGroupUri = `vad:ExecutorGroup_${processId}`;

            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ç—Ä–∏–ø–ª–µ—Ç—ã
            const autoTriples = `
    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞–Ω–Ω—ã–µ —Ç—Ä–∏–ø–ª–µ—Ç—ã –¥–ª—è –Ω–æ–≤–æ–≥–æ –∏–Ω–¥–∏–≤–∏–¥–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞
    ${getPrefixedName(processUri, currentPrefixes)} vad:isSubprocessTrig ${getPrefixedName(trigUri, currentPrefixes)} .
    ${getPrefixedName(processUri, currentPrefixes)} vad:hasExecutor ${executorGroupUri} .
    ${executorGroupUri} rdf:type vad:ExecutorGroup .
    ${executorGroupUri} rdfs:label "–ì—Ä—É–ø–ø–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –ø—Ä–æ—Ü–µ—Å—Å–∞ ${processId}" .`;

            return autoTriples;
        }

        // ==============================================================================
        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
        // ==============================================================================

        // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
        document.addEventListener('DOMContentLoaded', function() {
            loadTechAppendix();
        });
    </script>
</body>
</html>
