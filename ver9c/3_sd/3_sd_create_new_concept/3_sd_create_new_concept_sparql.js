// Ссылка на issue: https://github.com/bpmbpm/rdf-grapher/issues/252

/**
 * SPARQL Queries for Create New Concept module
 *
 * Модуль содержит все SPARQL запросы, используемые при создании
 * новых Концептов (процессов и исполнителей) в соответствии с
 * концепцией SPARQL-driven Programming.
 *
 * @file 3_sd_create_new_concept_sparql.js
 * @version 1.0
 * @date 2026-02-02
 * @see sparql-driven-programming_min1.md - Концепция SPARQL-driven Programming
 * @see io_concept_individ_v2.md - Алгоритмы создания концептов (v2)
 */

/**
 * SPARQL запросы для модуля создания концептов
 * Использует концепцию максимального использования SPARQL-запросов
 */
const NEW_CONCEPT_SPARQL = {
    /**
     * Запрос для получения предикатов из технологического объекта
     * Формирует список полей для окна New Concept
     *
     * @param {string} techObjectUri - URI технологического объекта (vad:ConceptProcessPredicate)
     * @returns {string} SPARQL SELECT запрос
     *
     * Пример результата для vad:ConceptProcessPredicate:
     * - rdf:type
     * - rdfs:label
     * - dcterms:description
     * - vad:hasParentObj
     * - vad:hasTrig
     */
    GET_PREDICATES_FROM_TECH_OBJECT: (techObjectUri) => `
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX vad: <http://example.org/vad#>

SELECT ?predicate WHERE {
    <${techObjectUri}> vad:includePredicate ?predicate .
}`,

    /**
     * Запрос для получения автоматически генерируемых предикатов
     * Такие предикаты отображаются серым и недоступны для редактирования
     *
     * @param {string} techObjectUri - URI технологического объекта
     * @returns {string} SPARQL SELECT запрос
     */
    GET_AUTO_GENERATED_PREDICATES: (techObjectUri) => `
PREFIX vad: <http://example.org/vad#>

SELECT ?predicate WHERE {
    <${techObjectUri}> vad:autoGeneratedPredicate ?predicate .
}`,

    /**
     * Запрос для получения существующих объектов определённого типа
     * Используется для формирования справочника родительских объектов
     *
     * @param {string} typeUri - URI типа (vad:TypeProcess или vad:TypeExecutor)
     * @param {string} graphUri - URI графа (vad:ptree или vad:rtree)
     * @returns {string} SPARQL SELECT запрос
     */
    GET_OBJECTS_BY_TYPE_IN_GRAPH: (typeUri, graphUri) => `
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX vad: <http://example.org/vad#>

SELECT ?object ?label WHERE {
    GRAPH <${graphUri}> {
        ?object rdf:type <${typeUri}> .
        OPTIONAL { ?object rdfs:label ?label }
    }
}`,

    /**
     * Запрос для проверки уникальности ID нового концепта
     *
     * @param {string} newUri - Предполагаемый URI нового объекта
     * @returns {string} SPARQL ASK запрос
     */
    CHECK_ID_EXISTS: (newUri) => `
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

ASK WHERE {
    { <${newUri}> ?p ?o } UNION { ?s ?p <${newUri}> }
}`,

    /**
     * Генерирует INSERT SPARQL запрос для создания нового концепта
     *
     * @param {string} graphUri - URI целевого графа
     * @param {Array<{predicate: string, object: string, isLiteral: boolean}>} triples - Массив триплетов
     * @param {string} subjectUri - URI нового субъекта
     * @param {Object} prefixes - Объект префиксов
     * @returns {string} SPARQL INSERT DATA запрос
     */
    GENERATE_INSERT_QUERY: (graphUri, triples, subjectUri, prefixes) => {
        const prefixDeclarations = Object.entries(prefixes)
            .map(([prefix, uri]) => `PREFIX ${prefix}: <${uri}>`)
            .join('\n');

        const triplesStr = triples
            .map(t => {
                const obj = t.isLiteral ? `"${t.object}"` : t.object;
                return `    ${subjectUri} ${t.predicate} ${obj} .`;
            })
            .join('\n');

        return `${prefixDeclarations}

INSERT DATA {
    GRAPH ${graphUri} {
${triplesStr}
    }
}`;
    }
};
