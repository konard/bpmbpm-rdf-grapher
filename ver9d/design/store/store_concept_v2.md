# Концепция хранилища techtree и currentQuads (версия 2)
design/store/store_concept_v2.md 04/02/26  
Ссылка на issue: https://github.com/bpmbpm/rdf-grapher/issues/264

## Содержание

1. [Введение](#введение)
2. [Ответы на вопросы из issue #264](#ответы-на-вопросы-из-issue-264)
   - [2.1 Почему currentQuads и currentStore?](#21-почему-currentquads-и-currentstore)
   - [2.2 techAppendixData и SPARQL-driven programming](#22-techappendixdata-и-sparql-driven-programming)
   - [2.3 virtualRDFdata и vad:Virtual](#23-virtualrdfdata-и-vadvirtal)
3. [Обновлённая архитектура](#обновлённая-архитектура)
4. [Изменения в фильтрации](#изменения-в-фильтрации)

---

## Введение

Документ дополняет [store_concept.md](store_concept.md) и содержит ответы на вопросы из issue #264 по архитектуре хранилища данных RDF Grapher ver9d.

---

## Ответы на вопросы из issue #264

### 2.1 Почему currentQuads и currentStore?

**Вопрос:** Зачем нужны и currentQuads, и currentStore? Почему не одно единое?

**Ответ:**

`currentQuads` и `currentStore` выполняют разные функции в архитектуре приложения:

| Компонент | Тип | Назначение |
|-----------|-----|------------|
| `currentQuads` | `Array<N3.Quad>` | Хранит **сырые данные** — массив RDF квадов в формате N3.js |
| `currentStore` | `N3.Store` | **Индексированное хранилище** для выполнения SPARQL-запросов |

**Причины разделения:**

1. **Производительность сериализации**
   - Для сериализации данных в TriG формат (кнопка "Сохранить как", отображение в textarea)
     требуется массив квадов `currentQuads`
   - N3.Store не предоставляет эффективного способа получения всех квадов в исходном порядке

2. **Фильтрация данных**
   - `currentQuads` позволяет быстро фильтровать данные по графу через `.filter()`
   - Функция `getFilteredQuads(filterMode)` работает с массивом `currentQuads`
   - Фильтрация нужна для:
     - Отображения в окне quadstore (разные режимы фильтрации)
     - Экспорта данных без TechnoTree графов
     - Отображения только определённых типов TriG

3. **SPARQL-запросы**
   - `currentStore` — это индексированная структура данных, оптимизированная для SPARQL-запросов
   - Функция `funSPARQLvalues()` использует `currentStore` для выполнения SELECT-запросов
   - Индексация по subject/predicate/object/graph ускоряет поиск

4. **Синхронизация**
   - При загрузке данных оба хранилища обновляются синхронно:
   ```javascript
   // В функции parseAndLoadRdf():
   currentQuads = parsedQuads;
   currentStore = new N3.Store(parsedQuads);
   ```

**Альтернативы (почему не подходят):**

- **Только N3.Store**: невозможно эффективно получить все квады для сериализации и фильтрации
- **Только Array**: невозможно выполнять SPARQL-запросы без индексированного хранилища

**Вывод:** Разделение на `currentQuads` и `currentStore` — это компромисс между производительностью SPARQL-запросов и удобством работы с данными (фильтрация, сериализация).

---

### 2.2 techAppendixData и SPARQL-driven programming

**Вопрос:** Зачем нужен объект `techAppendixData`, если мы используем SPARQL-driven programming? Можно ли использовать SPARQL-запросы к `vad:techtree` вместо него?

**Ответ:**

Объект `techAppendixData` был создан исторически для быстрого доступа к технологическим данным. Согласно концепции [SPARQL-driven programming](../requirements/sparql-driven-programming_min1.md), рекомендуется использовать SPARQL-запросы к `vad:techtree` вместо прямого доступа к `techAppendixData`.

**Текущая структура techAppendixData:**

```javascript
let techAppendixData = {
    loaded: false,                    // Флаг успешной загрузки
    predicateGroups: {},              // Группы предикатов по технологическим объектам
    autoGeneratedPredicates: {},      // Автоматически генерируемые предикаты
    contextTriGTypes: {},             // Контексты применения технологических объектов
    nodeStyles: {},                   // Стили узлов для визуализации
    quads: []                         // Квады из tech_Appendix.ttl
};
```

**Рекомендуемый подход (SPARQL-driven):**

Вместо прямого обращения к `techAppendixData.predicateGroups[uri]` следует использовать SPARQL-запросы к графу `vad:techtree`:

```sparql
# Получение предикатов из технологического объекта (п. 1 из io_concept_individ_v2.md)
SELECT ?predicate WHERE {
    GRAPH <http://example.org/vad#techtree> {
        <http://example.org/vad#ConceptProcessPredicate> vad:includePredicate ?predicate .
    }
}

# Получение автоматически генерируемых предикатов (п. 3)
SELECT ?predicate WHERE {
    GRAPH <http://example.org/vad#techtree> {
        <http://example.org/vad#IndividProcessPredicate> vad:autoGeneratedPredicate ?predicate .
    }
}

# Получение стилей узлов для визуализации
SELECT ?class ?style WHERE {
    GRAPH <http://example.org/vad#techtree> {
        ?class vad:hasNodeStyle ?style .
    }
}
```

**Преимущества SPARQL-подхода:**

1. **Единый API** — все данные доступны через `funSPARQLvalues()`
2. **Консистентность** — нет дублирования данных в разных структурах
3. **Гибкость** — возможность сложных SPARQL-запросов с объединениями
4. **Соответствие концепции** — реализация SPARQL-driven programming

**План миграции:**

1. Технологические данные из `vad-basic-ontology_tech_Appendix.ttl` загружаются в `currentQuads` с графом `vad:techtree`
2. Функции, использующие `techAppendixData`, постепенно переписываются на SPARQL-запросы
3. Объект `techAppendixData` может быть использован как кэш для оптимизации (гибридный подход)

---

### 2.3 virtualRDFdata и vad:Virtual

**Вопрос:**
- Зачем создавали `vad:vtree`, если уже были TriG типа `vad:Virtual` (кнопка virtualRDFdata)?
- Нужно ли удалять `vad:vtree`?

**Ответ:**

В issue #264 запрошено:
1. Удалить `vad:vtree` (и его описание в онтологиях)
2. Использовать TriG типа `vad:Virtual` для виртуальных вычисляемых данных
3. Добавить виртуальные TriG в общий quadstore

**Что такое виртуальные данные:**

Виртуальные данные (virtualRDFdata) — это автоматически вычисляемые свойства объектов:
- `vad:processSubtype` — подтип процесса (DetailedChild, DetailedExternal, notDetailedChild, notDetailedExternal, NotDefinedType)

Виртуальные данные пересчитываются:
- При запуске index.html
- При изменении схемы процесса

**Структура виртуальных TriG:**

Каждый виртуальный TriG имеет формат `vad:vt_{processId}` (v=virtual, t=trig):

```turtle
# Виртуальный контейнер для vad:t_p1
vad:vt_p1 {
    vad:vt_p1 rdf:type vad:Virtual ;
        vad:hasParentObj vad:t_p1 .  # Родительский физический TriG

    vad:p1.1 vad:processSubtype vad:DetailedChild .
    vad:p1.2 vad:processSubtype vad:notDetailedChild .
}
```

**Изменения в issue #264:**

1. **Удаление vad:vtree**
   - Удалить объявление `vad:vtree` из `vad-basic-ontology_tech_Appendix.ttl`
   - Удалить ссылки на `vad:vtree` из `vad-basic-ontology.ttl`

2. **Использование vad:Virtual**
   - Виртуальные TriG получают тип `vad:Virtual` (уже существующий класс)
   - Каждый виртуальный TriG имеет `vad:hasParentObj`, указывающий на родительский `VADProcessDia`

3. **Интеграция в quadstore**
   - Виртуальные TriG добавляются в общий `currentQuads`
   - Фильтр "Virtual" в окне quadstore показывает все TriG типа `vad:Virtual`

**Правило удаления:**

При удалении схемы процесса (TriG типа `VADProcessDia`) должен удаляться соответствующий дочерний TriG типа `vad:Virtual`:

```javascript
// При удалении vad:t_p1 (VADProcessDia):
// 1. Удалить vad:t_p1 из quadstore
// 2. Найти виртуальный TriG с hasParentObj = vad:t_p1
// 3. Удалить найденный vad:vt_p1 (Virtual)
```

---

## Обновлённая архитектура

### Структура данных в quadstore (после issue #264)

```
currentQuads содержит:
├── vad:root (TechTree) - корень дерева, hasParentObj = null
├── vad:ptree (ObjectTree) - дерево процессов, hasParentObj = vad:root
├── vad:rtree (ObjectTree) - дерево исполнителей, hasParentObj = vad:root
├── vad:techroot (TechnoTree) - корень техно-дерева, hasParentObj = null (issue #266)
├── vad:techtree (TechnoTree) - данные из tech_Appendix.ttl, hasParentObj = vad:techroot
├── vad:t_p1 (VADProcessDia) - схема процесса p1, hasParentObj = vad:p1
├── vad:vt_p1 (Virtual) - виртуальные данные для t_p1, hasParentObj = vad:t_p1
├── vad:t_p1.1 (VADProcessDia) - схема процесса p1.1, hasParentObj = vad:p1.1
├── vad:vt_p1.1 (Virtual) - виртуальные данные для t_p1.1, hasParentObj = vad:t_p1.1
└── ...
```

### Правила hasParentObj

Только два TriG могут иметь `vad:hasParentObj = null`:
1. `vad:root` — корень всего дерева объектов
2. `vad:techroot` — корень технологического дерева (issue #266: всегда hasParentObj = null)

Все остальные TriG должны иметь `vad:hasParentObj`:
- `ObjectTree` → `vad:root`
- `TechnoTree` (кроме techroot) → `vad:techroot`
- `VADProcessDia` → концепт процесса (TypeProcess)
- `Virtual` → родительский `VADProcessDia`

---

## Изменения в фильтрации

### Режимы фильтрации (issue #264)

| Режим | Значение select | Описание |
|-------|-----------------|----------|
| ObjectTree + VADProcessDia | `objectTreePlusVad` | **По умолчанию** — ptree, rtree и все схемы процессов |
| ObjectTree | `objectTree` | Концепты процесса и исполнителя (ptree, rtree) |
| VADProcessDia | `vadProcessDia` | Схемы процессов с индивидами |
| TechTree | `techtree` | Данные из vad-basic-ontology_tech_Appendix.ttl |
| Virtual | `virtual` | Виртуальный TriG вычисляемых параметров |
| Все TriG | `all` | Full quadstore без фильтров |

### Функция isVirtualGraph

```javascript
/**
 * Проверяет, является ли граф виртуальным (vad:Virtual)
 * Виртуальные графы имеют имя vt_* (например, vad:vt_p1)
 */
function isVirtualGraph(graphUri) {
    if (!graphUri) return false;
    const localName = getLocalName(graphUri);
    return localName.startsWith('vt_');
}
```

---

*Документ создан: 2026-02-03*
*Автор: AI Assistant*
*Версия: 2.0*
*Ссылка на issue: https://github.com/bpmbpm/rdf-grapher/issues/264*
