# Предложения по оптимизации (comment8a.md)

## 1. Архитектура данных и технологического приложения

### 1.1 Структура Tech Appendix

**Текущая реализация:**
Технологическое приложение `vad-basic-ontology_tech_Appendix.ttl` содержит классы для группировки предикатов по контекстам использования (ptree, rtree, VADProcessDia).

**Предложения по оптимизации:**

1. **Добавить явные связи между контекстами TriG и группами предикатов:**
   ```turtle
   vad:PtreeContext rdf:type vad:Tech ;
       rdfs:label "ptree Context" ;
       vad:allowsPredicateGroup vad:ConceptProcessPredicate, vad:ConceptTreePredicate .
   ```
   Это позволит программно определять, какие группы предикатов допустимы в каком контексте.

2. **Добавить класс для описания валидации значений:**
   ```turtle
   vad:hasExecutor
       vad:expectsObjectType vad:ExecutorGroup ;
       vad:validationRule "Object должен быть ExecutorGroup из текущего TriG" .
   ```

### 1.2 Кэширование данных

**Предложение:**
При загрузке `vad-basic-ontology_tech_Appendix.ttl` создавать индексированные структуры для быстрого доступа:

```javascript
const techCache = {
    predicatesByGroup: Map<groupUri, Set<predicateUri>>,
    autoGeneratedPredicates: Set<predicateUri>,
    contextToGroups: Map<contextType, Array<groupUri>>
};
```

## 2. SPARQL-запросы и производительность

### 2.1 Текущие ограничения

Реализованная функция `funSPARQLvalues` использует упрощенный pattern matching по `currentQuads`, что работает для базовых случаев, но имеет ограничения:

1. Не поддерживает OPTIONAL, FILTER, UNION
2. Нет оптимизации порядка выполнения паттернов
3. Не использует индексы для быстрого поиска

### 2.2 Предложения по оптимизации

1. **Использовать библиотеку Comunica для полноценного SPARQL:**
   ```javascript
   import { QueryEngine } from '@comunica/query-sparql';
   const engine = new QueryEngine();
   const result = await engine.queryBindings(sparqlQuery, { sources: [currentStore] });
   ```

2. **Создать индексы по предикатам для частых запросов:**
   ```javascript
   const predicateIndex = new Map();
   currentQuads.forEach(quad => {
       if (!predicateIndex.has(quad.predicate.value)) {
           predicateIndex.set(quad.predicate.value, []);
       }
       predicateIndex.get(quad.predicate.value).push(quad);
   });
   ```

3. **Кэшировать результаты частых запросов:**
   ```javascript
   const queryCache = new Map();
   function funSPARQLvalues(query, variable) {
       const cacheKey = query + '|' + variable;
       if (queryCache.has(cacheKey)) {
           return queryCache.get(cacheKey);
       }
       // ... выполнение запроса
       queryCache.set(cacheKey, results);
       return results;
   }
   ```

## 3. Пользовательский интерфейс

### 3.1 Окно Smart Design

**Предложения:**

1. **Добавить автодополнение (autocomplete) для выпадающих списков:**
   При большом количестве элементов (>20) использовать компонент с поиском.

2. **Показывать подсказки (tooltips) с описанием предикатов:**
   ```html
   <option value="vad:hasNext" title="Связывает процесс со следующим процессом в последовательности">
       vad:hasNext
   </option>
   ```

3. **Добавить визуальную индикацию обязательных полей:**
   Например, отмечать красной звездочкой поля, которые должны быть заполнены.

4. **Реализовать предварительный просмотр результата:**
   Показывать, как будет выглядеть граф после добавления триплета.

### 3.2 Модальное окно New TriG

**Предложения:**

1. **Добавить валидацию на клиентской стороне:**
   - Проверка уникальности ID до создания
   - Проверка формата метки

2. **Показывать preview генерируемого SPARQL запроса:**
   В реальном времени обновлять предпросмотр по мере заполнения полей.

## 4. Формализация VAD-схем

### 4.1 Правила консистентности

**Предложение добавить автоматическую проверку правил:**

1. **Правило 1: Каждый индивид процесса должен иметь isSubprocessTrig:**
   ```sparql
   SELECT ?process WHERE {
       ?process rdf:type vad:TypeProcess .
       FILTER NOT EXISTS { ?process vad:isSubprocessTrig ?trig }
   }
   ```

2. **Правило 2: Каждый индивид процесса должен иметь hasExecutor:**
   ```sparql
   SELECT ?process WHERE {
       ?process rdf:type vad:TypeProcess .
       FILTER NOT EXISTS { ?process vad:hasExecutor ?exec }
   }
   ```

3. **Правило 3: ExecutorGroup должен быть связан с конкретным TriG:**
   Все ExecutorGroup должны быть определены внутри соответствующего именованного графа.

### 4.2 Иерархия TriG

**Предложение:**
Формализовать типы TriG и их взаимосвязи:

```turtle
vad:StructuralTriG rdf:type rdfs:Class ;
    rdfs:comment "Базовый класс для структурных TriG (ptree, rtree)" .

vad:ContentTriG rdf:type rdfs:Class ;
    rdfs:comment "Базовый класс для TriG с содержимым (VADProcessDia)" .

vad:ptree rdf:type vad:StructuralTriG .
vad:rtree rdf:type vad:StructuralTriG .
```

## 5. Модульность кода

### 5.1 Текущая структура

Весь код находится в одном файле `index.html`, что затрудняет поддержку.

### 5.2 Предложения по рефакторингу

1. **Вынести JavaScript в отдельные модули:**
   ```
   js/
   ├── core/
   │   ├── rdf-parser.js
   │   ├── sparql-engine.js
   │   └── store.js
   ├── ui/
   │   ├── smart-design.js
   │   ├── graph-view.js
   │   └── modals.js
   ├── ontology/
   │   ├── tech-loader.js
   │   └── validation.js
   └── main.js
   ```

2. **Использовать ES6 модули:**
   ```javascript
   // sparql-engine.js
   export function funSPARQLvalues(query, variable) { ... }

   // smart-design.js
   import { funSPARQLvalues } from './sparql-engine.js';
   ```

3. **Добавить TypeScript для типизации:**
   Улучшит автодополнение в IDE и снизит количество runtime ошибок.

## 6. Расширяемость

### 6.1 Поддержка новых типов TriG

**Предложение:**
Создать механизм регистрации новых типов TriG без изменения кода:

```javascript
const trigTypeRegistry = new Map();

function registerTrigType(typeUri, config) {
    trigTypeRegistry.set(typeUri, {
        allowedSubjectTypes: config.subjectTypes,
        predicateGroups: config.predicateGroups,
        autoGeneratedTriples: config.autoTriples
    });
}

// Регистрация из Tech appendix
registerTrigType('vad:VADProcessDia', {
    subjectTypes: ['vad:TypeProcess', 'vad:ExecutorGroup'],
    predicateGroups: ['vad:IndividProcessPredicate', 'vad:ExecutorGroupPredicate'],
    autoTriples: (processUri, trigUri) => [
        { s: processUri, p: 'vad:isSubprocessTrig', o: trigUri },
        { s: processUri, p: 'vad:hasExecutor', o: `${trigUri}_EGP` }
    ]
});
```

### 6.2 Плагины для визуализации

**Предложение:**
Создать API для добавления кастомных визуализаций:

```javascript
const visualizationPlugins = [];

function registerVisualization(plugin) {
    visualizationPlugins.push(plugin);
}

// Пример плагина
registerVisualization({
    name: 'Process Flow',
    matches: (trigType) => trigType === 'vad:VADProcessDia',
    render: (container, quads) => { /* ... */ }
});
```

## 7. Документация

### 7.1 Предложения

1. **Добавить JSDoc комментарии ко всем функциям:**
   ```javascript
   /**
    * Выполняет SPARQL-подобный запрос и возвращает значения указанной переменной
    * @param {string} sparqlQuery - SPARQL SELECT запрос
    * @param {string} variableName - Имя переменной для извлечения (без '?')
    * @returns {Array<string>} Массив URI значений
    * @example
    * const processes = funSPARQLvalues('SELECT ?p WHERE { ?p rdf:type vad:TypeProcess }', 'p');
    */
   function funSPARQLvalues(sparqlQuery, variableName) { ... }
   ```

2. **Создать README с описанием архитектуры:**
   - Диаграмма компонентов
   - Описание потока данных
   - Примеры использования

3. **Документировать онтологию:**
   Добавить rdfs:comment к каждому классу и свойству в TTL файлах.

## 8. Тестирование

### 8.1 Предложения

1. **Добавить unit-тесты для SPARQL функций:**
   ```javascript
   describe('funSPARQLvalues', () => {
       it('should return process URIs for TypeProcess query', () => {
           // setup test data
           const result = funSPARQLvalues(
               'SELECT ?p WHERE { ?p rdf:type vad:TypeProcess }',
               'p'
           );
           expect(result).toContain('vad:Process1');
       });
   });
   ```

2. **Создать интеграционные тесты для UI:**
   Использовать Playwright или Cypress для тестирования взаимодействия с интерфейсом.

3. **Добавить тесты валидации онтологии:**
   Проверять консистентность данных при загрузке файлов.

---

*Файл создан: 2026-01-24*
*Версия: 8a*
