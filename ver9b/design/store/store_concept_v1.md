# Концепция хранилища techtree и currentQuads
design/store/store_concept_v1.md 04/02/26  
Ссылка на issue: https://github.com/bpmbpm/rdf-grapher/issues/260

## Содержание

1. [Введение](#введение)
2. [Текущая архитектура](#текущая-архитектура)
3. [Проблема хранения techtree](#проблема-хранения-techtree)
4. [Варианты решения](#варианты-решения)
5. [Сравнительная таблица](#сравнительная-таблица)
6. [Рекомендуемый вариант](#рекомендуемый-вариант)
7. [Фильтрация в окне RDF данные](#фильтрация-в-окне-rdf-данные)
8. [Параметр quadstore в funSPARQLvalues](#параметр-quadstore-в-funsparqlvalues)
9. [Обработка ошибок загрузки файлов](#обработка-ошибок-загрузки-файлов)

---

## Введение

Документ описывает концепцию использования techtree и currentQuads в приложении RDF Grapher ver9b. Основная задача — определить оптимальный способ хранения технологических данных из файла `vad-basic-ontology_tech_Appendix.ttl` и их взаимодействие с основным quadstore.

### Ключевые компоненты

| Компонент | Описание | Файл |
|-----------|----------|------|
| `currentQuads` | Основное хранилище RDF-данных (пользовательские TriG) | vadlib.js |
| `currentStore` | N3.Store для выполнения SPARQL-запросов | vadlib.js |
| `techAppendixData` | Объект с распарсенными данными из tech_Appendix.ttl | vadlib.js |
| `virtualRDFdata` | Виртуальные вычисляемые данные (vad:processSubtype) | vadlib.js |

---

## Текущая архитектура

### Загрузка технологического приложения

Файл `vad-basic-ontology_tech_Appendix.ttl` загружается асинхронно при старте приложения функцией `loadTechAppendix()` в `vadlib.js`:

```javascript
async function loadTechAppendix() {
    try {
        const response = await fetch('ontology/vad-basic-ontology_tech_Appendix.ttl');
        if (!response.ok) {
            console.warn('Tech appendix file not found, using default configuration');
            return;
        }
        // ... парсинг и извлечение данных
        techAppendixData.loaded = true;
    } catch (error) {
        console.error('Error loading tech appendix:', error);
    }
}
```

### Структура techAppendixData

```javascript
let techAppendixData = {
    loaded: false,                    // Флаг успешной загрузки
    predicateGroups: {},              // Группы предикатов по технологическим объектам
    autoGeneratedPredicates: {},      // Автоматически генерируемые предикаты
    contextTriGTypes: {},             // Контексты применения технологических объектов
    nodeStyles: {}                    // Стили узлов для визуализации
};
```

### Использование techtree в SPARQL-запросах

Согласно документу `io_concept_individ_v2.md`, запросы к techtree используются для:

1. **Получение предикатов из технологического объекта** (п. 1)
   ```sparql
   SELECT ?predicate WHERE {
       <http://example.org/vad#ConceptProcessPredicate> vad:includePredicate ?predicate .
   }
   ```

2. **Получение автоматически генерируемых предикатов** (п. 3)
   ```sparql
   SELECT ?predicate WHERE {
       <http://example.org/vad#ConceptProcessPredicate> vad:autoGeneratedPredicate ?predicate .
   }
   ```

---

## Проблема хранения techtree

### Текущая реализация

Сейчас techtree хранится **отдельно** в объекте `techAppendixData`, а не в общем `currentQuads`. Это создает следующие проблемы:

1. **Дублирование логики** — для получения данных из techtree используется прямое обращение к `techAppendixData`, а не SPARQL-запросы через `funSPARQLvalues`

2. **Несогласованность API** — разные источники данных требуют разных функций:
   - `currentQuads` → `funSPARQLvalues()`
   - `techAppendixData` → `getPredicatesFromTechObject()`

3. **Ограничения SPARQL** — невозможно выполнить объединенный SPARQL-запрос, охватывающий и пользовательские данные, и techtree

### Вопрос из issue #260

> Не понятно, что такое techtree. Где оно хранится? Видимо нужно сделать отдельный triplestore для хранения содержимого vad-basic-ontology_tech_Appendix.ttl? Или добавить отдельным TriG (techtree) в общий quadstore?

---

## Варианты решения

### Вариант 1: Отдельный quadstore для techtree

```javascript
// Два независимых хранилища
let currentStore = null;      // Пользовательские данные (ptree, rtree, VADProcessDia)
let techStore = null;         // Технологические данные (vad:techtree)
```

#### Плюсы
- Четкое разделение пользовательских и технологических данных
- Techtree не засоряет пользовательский quadstore
- Простая логика очистки — при загрузке нового файла очищается только currentStore
- Технологические данные неизменны и загружаются один раз при старте

#### Минусы
- Требуется модификация `funSPARQLvalues` для указания целевого quadstore
- Невозможно выполнить SPARQL-запрос, объединяющий данные из обоих store
- Дополнительная сложность в управлении двумя store

#### Реализация

```javascript
// Добавить параметр storeName в funSPARQLvalues
function funSPARQLvalues(sparqlQuery, variableName = 'value', storeName = 'current') {
    const store = storeName === 'tech' ? techStore : currentStore;
    const quads = storeName === 'tech' ? techQuads : currentQuads;
    // ... выполнение запроса
}

// Пример использования
const predicates = funSPARQLvalues(GET_PREDICATES_QUERY, 'predicate', 'tech');
```

### Вариант 2: Общий quadstore с отдельным TriG (vad:techtree)

```javascript
// Один объединенный quadstore
let currentQuads = [];        // Все данные, включая vad:techtree
let currentStore = null;      // N3.Store для SPARQL-запросов
```

Структура данных:
```
currentQuads содержит:
├── vad:techtree (технологические объекты из tech_Appendix.ttl)
├── vad:ptree (дерево процессов)
├── vad:rtree (дерево исполнителей)
├── vad:t_p1 (схема процесса p1)
├── vad:t_p1.1 (схема процесса p1.1)
└── ...
```

#### Плюсы
- Единый API для всех SPARQL-запросов — не требуется параметр storeName
- Возможность выполнять объединенные SPARQL-запросы
- Соответствие SPARQL-driven programming — все данные доступны через единый механизм
- Простая архитектура — один store, один набор функций

#### Минусы
- Techtree отображается в окне "RDF данные" (требуется фильтрация)
- При очистке quadstore нужно сохранять techtree
- Смешивание изменяемых (пользовательских) и неизменяемых (технологических) данных
- Риск случайного изменения/удаления технологических данных

#### Реализация

```javascript
// При загрузке tech_Appendix.ttl добавляем квады в общий store
async function loadTechAppendix() {
    // ... парсинг TTL
    techQuads.forEach(quad => {
        // Добавляем с указанием графа vad:techtree
        const techQuad = N3.DataFactory.quad(
            quad.subject,
            quad.predicate,
            quad.object,
            N3.DataFactory.namedNode('http://example.org/vad#techtree')
        );
        currentQuads.push(techQuad);
    });
    // Обновляем store
    currentStore.addQuads(techQuads);
}
```

### Вариант 3: Гибридный подход (рекомендуемый)

Технологические данные хранятся **в объекте techAppendixData** для быстрого прямого доступа, но также **добавляются в currentQuads как vad:techtree** для поддержки SPARQL-запросов.

```javascript
let techAppendixData = {
    loaded: false,
    predicateGroups: {},          // Быстрый доступ к группам предикатов
    autoGeneratedPredicates: {},  // Быстрый доступ к автогенерируемым предикатам
    quads: []                     // Исходные квады для добавления в currentQuads
};
```

#### Плюсы
- Быстрый прямой доступ через `techAppendixData` для критических операций
- SPARQL-доступ через `currentQuads` для сложных запросов
- Гибкость — можно выбрать оптимальный способ доступа в зависимости от задачи
- Обратная совместимость с текущим кодом

#### Минусы
- Дублирование данных (в techAppendixData и в currentQuads)
- Необходимость синхронизации при изменениях
- Более сложная архитектура

---

## Сравнительная таблица

| Критерий | Вариант 1 (Отдельный store) | Вариант 2 (Общий quadstore) | Вариант 3 (Гибридный) |
|----------|----------------------------|-----------------------------|-----------------------|
| Разделение данных | ✅ Полное | ❌ Смешаны | ⚠️ Частичное |
| Единый SPARQL API | ⚠️ Требуется параметр | ✅ Да | ✅ Да |
| Объединенные запросы | ❌ Невозможно | ✅ Возможно | ✅ Возможно |
| Производительность | ✅ Быстрый прямой доступ | ⚠️ Только через SPARQL | ✅ Оба способа |
| Простота реализации | ⚠️ Средняя | ✅ Простая | ⚠️ Средняя |
| Обратная совместимость | ⚠️ Требуются изменения | ⚠️ Требуются изменения | ✅ Минимальные изменения |
| Фильтрация в UI | ✅ Не требуется | ⚠️ Требуется | ⚠️ Требуется |
| Защита от изменений | ✅ Полная | ❌ Нет | ⚠️ Частичная |

---

## Рекомендуемый вариант

**Рекомендуется Вариант 2** (Общий quadstore с отдельным TriG vad:techtree) по следующим причинам:

1. **Соответствие SPARQL-driven programming** — все данные доступны через единый механизм SPARQL-запросов, что соответствует концепции проекта (см. `sparql-driven-programming_min1.md`)

2. **Простота реализации** — не требуется модификация сигнатур функций `funSPARQLvalues` и `funSPARQLvaluesComunica`

3. **Возможность объединенных запросов** — можно выполнять SPARQL-запросы, охватывающие и пользовательские данные, и технологические объекты

4. **Единый API** — для разработчика не имеет значения, откуда берутся данные — все доступно через SPARQL

### Требуемые изменения для Варианта 2

1. **Модификация loadTechAppendix()** — добавлять квады в currentQuads с графом vad:techtree
2. **Фильтрация в UI** — не отображать vad:techtree в окне "RDF данные"
3. **Защита от очистки** — при очистке quadstore сохранять vad:techtree

---

## Фильтрация в окне RDF данные

При использовании общего quadstore (Вариант 2) необходимо реализовать фильтрацию в окне "RDF данные" для исключения технологического TriG.

### Предлагаемые режимы фильтрации

| Режим | Описание | Отображаемые TriG |
|-------|----------|-------------------|
| **Все TriG** | Полный просмотр всех данных | vad:techtree + ptree + rtree + VADProcessDia |
| **Без технологического** (по умолчанию) | Только пользовательские данные | ptree + rtree + VADProcessDia |
| **Только технологический** | Просмотр технологических объектов | vad:techtree |

### Реализация фильтра

```javascript
// Функция фильтрации квадов по режиму
function getFilteredQuads(filterMode = 'noTech') {
    const TECH_GRAPH = 'http://example.org/vad#techtree';

    switch(filterMode) {
        case 'all':
            return currentQuads;
        case 'noTech':
            return currentQuads.filter(quad => quad.graph.value !== TECH_GRAPH);
        case 'onlyTech':
            return currentQuads.filter(quad => quad.graph.value === TECH_GRAPH);
        default:
            return currentQuads.filter(quad => quad.graph.value !== TECH_GRAPH);
    }
}

// Сериализация с учетом фильтра
function serializeQuadsToTrig(filterMode = 'noTech') {
    const filteredQuads = getFilteredQuads(filterMode);
    // ... сериализация через N3.Writer
}
```

### UI для выбора фильтра

```html
<!-- Добавить в окно "RDF данные" -->
<div class="filter-selector">
    <label for="quadstore-filter">Фильтр TriG:</label>
    <select id="quadstore-filter" onchange="updateQuadstoreDisplay()">
        <option value="noTech" selected>Без технологического</option>
        <option value="all">Все TriG</option>
        <option value="onlyTech">Только технологический</option>
    </select>
</div>
```

---

## Параметр quadstore в funSPARQLvalues

### Текущее состояние

Функции `funSPARQLvalues` и `funSPARQLvaluesComunica` работают только с глобальным `currentStore`:

```javascript
function funSPARQLvalues(sparqlQuery, variableName = 'value') {
    if (!currentStore || currentQuads.length === 0) {
        console.log('funSPARQLvalues: No data in store');
        return results;
    }
    // ... выполнение запроса
}
```

### Предложение: Добавить параметр для возврата ошибки

Для улучшения диагностики рекомендуется добавить опциональный параметр `errorCallback`:

```javascript
/**
 * Выполняет SPARQL SELECT запрос
 *
 * @param {string} sparqlQuery - SPARQL SELECT запрос
 * @param {string} variableName - Имя переменной для извлечения (без '?')
 * @param {Object} options - Дополнительные параметры
 * @param {Function} options.onError - Callback для обработки ошибок
 * @returns {Array<{uri: string, label: string}>} Массив результатов
 */
function funSPARQLvalues(sparqlQuery, variableName = 'value', options = {}) {
    const results = [];
    const { onError } = options;

    if (!currentStore || currentQuads.length === 0) {
        const errorMsg = 'funSPARQLvalues: No data in store';
        console.log(errorMsg);
        if (onError) onError(new Error(errorMsg));
        return results;
    }

    try {
        // ... выполнение запроса
    } catch (error) {
        console.error('funSPARQLvalues error:', error);
        if (onError) onError(error);
    }

    return results;
}

// Пример использования с обработкой ошибок
const predicates = funSPARQLvalues(query, 'predicate', {
    onError: (err) => {
        showUserNotification(`Ошибка выполнения SPARQL: ${err.message}`);
    }
});
```

### Альтернатива: Возврат объекта результата

```javascript
/**
 * @returns {{results: Array, error: Error|null}} Объект с результатами и ошибкой
 */
function funSPARQLvaluesWithError(sparqlQuery, variableName = 'value') {
    const response = { results: [], error: null };

    if (!currentStore || currentQuads.length === 0) {
        response.error = new Error('No data in store');
        return response;
    }

    try {
        // ... выполнение запроса
        response.results = results;
    } catch (error) {
        response.error = error;
    }

    return response;
}

// Пример использования
const { results, error } = funSPARQLvaluesWithError(query, 'predicate');
if (error) {
    showUserNotification(`Ошибка: ${error.message}`);
}
```

---

## Обработка ошибок загрузки файлов

### Требования из issue #260

> При старте программы должна быть его загрузка и если файла нет, то сообщение с путем, где не был найден файл, и диалоговым окном с предложением указать расположение файла.

> «Используются предикаты по умолчанию» - не нужно, т.е. только загруженные, fallback не требуется.

> Также сделай с примерами Trig_VADv5 Trig_VADv6, т.е. удали их из кода и если загрузка из файла не удалась, то сообщение с путем, где не был найден файл, и диалоговым окном с предложением указать расположение файла.

### Реализация для vad-basic-ontology_tech_Appendix.ttl

```javascript
/**
 * Загружает vad-basic-ontology_tech_Appendix.ttl с обработкой ошибок
 * При ошибке показывает диалог выбора файла
 */
async function loadTechAppendix() {
    const defaultPath = 'ontology/vad-basic-ontology_tech_Appendix.ttl';

    try {
        const response = await fetch(defaultPath);
        if (!response.ok) {
            throw new Error(`Файл не найден: ${defaultPath}`);
        }

        const ttlContent = await response.text();
        await parseTechAppendix(ttlContent);

        techAppendixData.loaded = true;
        console.log('Tech appendix loaded successfully');

    } catch (error) {
        console.error('Error loading tech appendix:', error);

        // Показываем диалог с ошибкой и предложением выбрать файл
        showFileNotFoundDialog({
            title: 'Ошибка загрузки технологического приложения',
            message: `Файл не найден по пути: ${defaultPath}`,
            fileType: '.ttl',
            onFileSelected: async (file) => {
                try {
                    const content = await file.text();
                    await parseTechAppendix(content);
                    techAppendixData.loaded = true;
                    showSuccessNotification('Технологическое приложение загружено');
                } catch (parseError) {
                    showErrorNotification(`Ошибка парсинга: ${parseError.message}`);
                }
            }
        });
    }
}

/**
 * Показывает диалог при ошибке загрузки файла
 */
function showFileNotFoundDialog(options) {
    const { title, message, fileType, onFileSelected } = options;

    // Создаем модальное окно
    const modal = document.createElement('div');
    modal.className = 'file-not-found-modal';
    modal.innerHTML = `
        <div class="modal-content">
            <h3>${title}</h3>
            <p>${message}</p>
            <div class="modal-actions">
                <label class="file-select-btn">
                    Выбрать файл
                    <input type="file" accept="${fileType}" style="display: none;">
                </label>
                <button class="cancel-btn">Отмена</button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    // Обработчики событий
    const fileInput = modal.querySelector('input[type="file"]');
    fileInput.addEventListener('change', (e) => {
        if (e.target.files[0]) {
            onFileSelected(e.target.files[0]);
            modal.remove();
        }
    });

    modal.querySelector('.cancel-btn').addEventListener('click', () => {
        modal.remove();
    });
}
```

### Реализация для примеров Trig_VADv5/Trig_VADv6

```javascript
/**
 * Загружает пример данных из файла с обработкой ошибок
 */
async function loadExampleFromFile(exampleName) {
    const filePath = `${exampleName}.ttl`;

    try {
        const response = await fetch(filePath);
        if (!response.ok) {
            throw new Error(`Файл не найден: ${filePath}`);
        }

        const content = await response.text();
        await loadRdfData(content);
        showSuccessNotification(`Пример ${exampleName} загружен`);

    } catch (error) {
        console.error(`Error loading example ${exampleName}:`, error);

        showFileNotFoundDialog({
            title: `Ошибка загрузки примера ${exampleName}`,
            message: `Файл не найден по пути: ${filePath}`,
            fileType: '.ttl,.trig',
            onFileSelected: async (file) => {
                try {
                    const content = await file.text();
                    await loadRdfData(content);
                    showSuccessNotification(`Пример загружен из файла: ${file.name}`);
                } catch (parseError) {
                    showErrorNotification(`Ошибка парсинга: ${parseError.message}`);
                }
            }
        });
    }
}

// Обновленные функции загрузки примеров
function loadExampleTrigVADv5() {
    loadExampleFromFile('Trig_VADv5');
}

function loadExampleTrigVADv6() {
    loadExampleFromFile('Trig_VADv6');
}
```

### Удаление встроенных примеров

Согласно требованию issue #260, следует:

1. **Удалить** константу `EXAMPLE_DATA` из `1_example_data_logic.js`
2. **Заменить** функции `loadExampleTrigVADv5()` и `loadExampleTrigVADv6()` на загрузку из файлов
3. **Сохранить** файлы `Trig_VADv5.ttl` и `Trig_VADv6.ttl` в папке `ver9b/`

---

## Заключение

### Итоговые рекомендации

1. **Хранение techtree**: Использовать общий quadstore с отдельным TriG `vad:techtree` (Вариант 2)

2. **Фильтрация**: Реализовать фильтры в окне "RDF данные" для отображения/скрытия технологического TriG

3. **SPARQL функции**:
   - Добавить опциональный параметр `onError` в `funSPARQLvalues` для обработки ошибок
   - Не добавлять параметр `storeName`, так как используется единый quadstore

4. **Удаление fallback**: Убрать использование предикатов по умолчанию при отсутствии techtree

5. **Загрузка файлов**: Реализовать диалог выбора файла при ошибке загрузки tech_Appendix.ttl и примеров

### Файлы для модификации

| Файл | Изменения |
|------|-----------|
| `9_vadlib/vadlib.js` | Модификация `loadTechAppendix()`, добавление фильтрации |
| `9_vadlib/vadlib_sparql.js` | Добавление параметра `onError` |
| `1_example_data/1_example_data_logic.js` | Удаление `EXAMPLE_DATA`, загрузка из файлов |
| `2_triplestore/2_triplestore_ui.js` | Добавление UI фильтра TriG |
| `index.html` | Добавление HTML для фильтра и модального окна |

---

*Документ создан: 2026-02-03*
*Автор: AI Assistant*
*Версия: 1.0*
