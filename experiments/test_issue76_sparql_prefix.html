<!DOCTYPE html>
<html>
<head>
    <title>Test Issue #76 - SPARQL Prefix Generation</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-result { padding: 10px; margin: 10px 0; border-radius: 5px; }
        .pass { background: #d4edda; color: #155724; }
        .fail { background: #f8d7da; color: #721c24; }
        pre { background: #f5f5f5; padding: 10px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>Test Issue #76 - SPARQL Prefix Generation</h1>
    <p>This test verifies that SPARQL queries include PREFIX declarations when using prefixed URIs.</p>

    <div id="results"></div>

    <script>
        /**
         * Simplified version of getPrefixedName for testing
         */
        function getPrefixedName(uri, prefixes) {
            for (const [prefix, namespace] of Object.entries(prefixes)) {
                if (uri.startsWith(namespace)) {
                    return prefix + ':' + uri.substring(namespace.length);
                }
            }
            return uri;
        }

        /**
         * Генерирует SPARQL PREFIX декларации из объекта префиксов
         * @param {Object} prefixes - Объект с префиксами {prefix: uri}
         * @returns {string} - Строка с PREFIX декларациями
         */
        function generateSparqlPrefixes(prefixes) {
            if (!prefixes || Object.keys(prefixes).length === 0) {
                return '';
            }

            let prefixLines = [];
            for (const [prefix, uri] of Object.entries(prefixes)) {
                prefixLines.push(`PREFIX ${prefix}: <${uri}>`);
            }
            return prefixLines.join('\n') + '\n\n';
        }

        /**
         * Генерирует SPARQL запрос с GRAPH clause для указанного TriG
         * @param {string} trigUri - URI TriG для фильтрации
         * @param {Object} currentPrefixes - Текущие префиксы
         * @returns {string} - SPARQL запрос с GRAPH clause и PREFIX декларациями
         */
        function getSparqlQueryForTriG(trigUri, currentPrefixes) {
            const defaultSparqlQuery = `SELECT ?s ?p ?o
WHERE {
    ?s ?p ?o .
}`;
            if (!trigUri) return defaultSparqlQuery;

            const prefixedUri = getPrefixedName(trigUri, currentPrefixes);
            // Если URI имеет префикс, используем его, иначе используем полный URI в угловых скобках
            const graphRef = prefixedUri.includes(':') && !prefixedUri.startsWith('http')
                ? prefixedUri
                : `<${trigUri}>`;

            // Генерируем PREFIX декларации для SPARQL запроса
            const prefixDeclarations = generateSparqlPrefixes(currentPrefixes);

            return `${prefixDeclarations}SELECT ?s ?p ?o
WHERE {
    GRAPH ${graphRef} {
        ?s ?p ?o .
    }
}`;
        }

        // Test cases
        const tests = [];

        // Test 1: With vad prefix
        const prefixes1 = {
            'vad': 'http://example.org/vad#',
            'rdf': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
            'rdfs': 'http://www.w3.org/2000/01/rdf-schema#'
        };
        const trigUri1 = 'http://example.org/vad#Trig1';
        const query1 = getSparqlQueryForTriG(trigUri1, prefixes1);

        const hasVadPrefix = query1.includes('PREFIX vad: <http://example.org/vad#>');
        const hasGraphClause = query1.includes('GRAPH vad:Trig1');

        tests.push({
            name: 'Test 1: SPARQL query with vad:Trig1 includes PREFIX declaration',
            passed: hasVadPrefix && hasGraphClause,
            expected: 'Query should include PREFIX vad: declaration and GRAPH vad:Trig1',
            actual: query1
        });

        // Test 2: Query should have all prefixes from input
        const hasRdfPrefix = query1.includes('PREFIX rdf:');
        const hasRdfsPrefix = query1.includes('PREFIX rdfs:');

        tests.push({
            name: 'Test 2: All prefixes from input are included',
            passed: hasRdfPrefix && hasRdfsPrefix,
            expected: 'Query should include PREFIX rdf: and PREFIX rdfs: declarations',
            actual: query1
        });

        // Test 3: Without prefixes, should use full URI
        const query3 = getSparqlQueryForTriG('http://example.org/unknown#Graph1', {});
        const useFullUri = query3.includes('GRAPH <http://example.org/unknown#Graph1>');

        tests.push({
            name: 'Test 3: Without matching prefix, uses full URI in angle brackets',
            passed: useFullUri,
            expected: 'Query should use GRAPH <http://example.org/unknown#Graph1>',
            actual: query3
        });

        // Test 4: Empty trigUri returns default query
        const query4 = getSparqlQueryForTriG(null, prefixes1);
        const isDefaultQuery = query4.includes('?s ?p ?o') && !query4.includes('GRAPH');

        tests.push({
            name: 'Test 4: Empty trigUri returns default query without GRAPH',
            passed: isDefaultQuery,
            expected: 'Query should be default SELECT without GRAPH clause',
            actual: query4
        });

        // Render results
        const resultsDiv = document.getElementById('results');
        let allPassed = true;

        tests.forEach(test => {
            const resultClass = test.passed ? 'pass' : 'fail';
            if (!test.passed) allPassed = false;

            resultsDiv.innerHTML += `
                <div class="test-result ${resultClass}">
                    <strong>${test.passed ? 'PASS' : 'FAIL'}: ${test.name}</strong>
                    <p><strong>Expected:</strong> ${test.expected}</p>
                    <pre>${test.actual}</pre>
                </div>
            `;
        });

        // Summary
        resultsDiv.innerHTML = `
            <div class="test-result ${allPassed ? 'pass' : 'fail'}">
                <h2>Summary: ${allPassed ? 'All tests passed!' : 'Some tests failed'}</h2>
            </div>
        ` + resultsDiv.innerHTML;

        console.log('Test results:', tests);
    </script>
</body>
</html>
