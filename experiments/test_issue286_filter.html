<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Issue #286 - SPARQL-driven Filter Process Concepts without VADProcessDia</title>
    <!-- –°—Å—ã–ª–∫–∞ –Ω–∞ issue: https://github.com/bpmbpm/rdf-grapher/issues/286 -->
    <style>
        body { font-family: Consolas, Monaco, monospace; padding: 20px; background-color: #f5f5f5; }
        h1 { color: #333; border-bottom: 2px solid #1976D2; padding-bottom: 10px; }
        .test-result { padding: 10px 15px; margin: 5px 0; border-radius: 4px; font-size: 14px; }
        .test-passed { background-color: #d4edda; border-left: 4px solid #28a745; color: #155724; }
        .test-failed { background-color: #f8d7da; border-left: 4px solid #dc3545; color: #721c24; }
        .test-info { background-color: #cce5ff; border-left: 4px solid #007bff; color: #004085; }
        pre { background: #272822; color: #f8f8f2; padding: 15px; border-radius: 5px; overflow-x: auto; }
        .summary { margin-top: 20px; padding: 15px; border-radius: 4px; font-size: 16px; font-weight: bold; }
        .summary-passed { background-color: #d4edda; color: #155724; }
        .summary-failed { background-color: #f8d7da; color: #721c24; }
        .sparql-query { background: #1e1e1e; color: #9cdcfe; padding: 15px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; font-size: 12px; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Issue #286: SPARQL-driven Filter Process Concepts without VADProcessDia</h1>
    <p>Testing SPARQL-driven Programming approach: filtering processes via SPARQL FILTER NOT EXISTS</p>

    <h3>SPARQL Query:</h3>
    <pre class="sparql-query">SELECT ?process ?label WHERE {
    GRAPH vad:ptree {
        ?process rdf:type vad:TypeProcess .
        ?process rdfs:label ?label .
        FILTER NOT EXISTS {
            ?process vad:hasTrig ?trig .
            GRAPH ?trig {
                ?trig rdf:type vad:VADProcessDia .
            }
        }
    }
}</pre>

    <div id="test-log"></div>
    <div id="test-summary"></div>

    <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ N3.js -->
    <script src="https://unpkg.com/n3@1.17.2/browser/n3.min.js"></script>

    <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ Comunica –¥–ª—è SPARQL -->
    <script src="https://unpkg.com/@comunica/query-sparql@2.10.0/comunica-browser.js"></script>

    <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ -->
    <script src="../ver9b/9_vadlib/vadlib.js"></script>
    <script src="../ver9b/9_vadlib/vadlib_sparql.js"></script>
    <script src="../ver9b/2_triplestore/2_triplestore_logic.js"></script>
    <script src="../ver9b/3_sd/3_sd_sparql.js"></script>
    <script src="../ver9b/3_sd/3_sd_create_new_trig/3_sd_create_new_trig_logic.js"></script>

    <script>
        // –°—Å—ã–ª–∫–∞ –Ω–∞ issue: https://github.com/bpmbpm/rdf-grapher/issues/286

        const testLog = document.getElementById('test-log');
        const testSummary = document.getElementById('test-summary');
        let testResults = [];

        function logTest(name, status, message) {
            const div = document.createElement('div');
            div.className = `test-result test-${status}`;
            const statusText = status === 'passed' ? '‚úÖ PASSED' : status === 'failed' ? '‚ùå FAILED' : 'üìã INFO';
            div.textContent = `${statusText}: ${name} - ${message}`;
            testLog.appendChild(div);
            if (status !== 'info') {
                testResults.push({ name, passed: status === 'passed', message });
            }
        }

        function showSummary() {
            const passed = testResults.filter(t => t.passed).length;
            const total = testResults.length;
            const allPassed = passed === total;
            testSummary.className = `summary ${allPassed ? 'summary-passed' : 'summary-failed'}`;
            testSummary.textContent = `–†–µ–∑—É–ª—å—Ç–∞—Ç: ${passed}/${total} —Ç–µ—Å—Ç–æ–≤ –ø—Ä–æ–π–¥–µ–Ω–æ ${allPassed ? '‚úÖ' : '‚ùå'}`;
        }

        async function runTests() {
            let testData = null;
            let testQuads = [];
            let testPrefixes = {};

            // –¢–µ—Å—Ç 1: –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
            logTest('–ó–∞–≥—Ä—É–∑–∫–∞ Trig_VADv7.ttl', 'info', '–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞...');
            try {
                const response = await fetch('../ver9b/dia/Trig_VADv7.ttl');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                testData = await response.text();
                logTest('–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞', 'passed', `–§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω (${testData.length} —Å–∏–º–≤–æ–ª–æ–≤)`);
            } catch (error) {
                logTest('–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞', 'failed', `–û—à–∏–±–∫–∞: ${error.message}`);
                showSummary();
                return;
            }

            // –¢–µ—Å—Ç 2: –ü–∞—Ä—Å–∏–Ω–≥ RDF
            try {
                await new Promise((resolve, reject) => {
                    const parser = new N3.Parser({ format: 'trig' });
                    parser.parse(testData, (error, quad, parsedPrefixes) => {
                        if (error) { reject(error); return; }
                        if (quad) { testQuads.push(quad); }
                        else {
                            if (parsedPrefixes) testPrefixes = parsedPrefixes;
                            resolve();
                        }
                    });
                });
                logTest('–ü–∞—Ä—Å–∏–Ω–≥ RDF', 'passed', `–†–∞—Å–ø–∞—Ä—Å–µ–Ω–æ ${testQuads.length} –∫–≤–∞–¥–æ–≤`);
            } catch (error) {
                logTest('–ü–∞—Ä—Å–∏–Ω–≥ RDF', 'failed', `–û—à–∏–±–∫–∞: ${error.message}`);
                showSummary();
                return;
            }

            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
            currentQuads = testQuads;
            currentPrefixes = testPrefixes;
            currentStore = new N3.Store();
            testQuads.forEach(q => currentStore.addQuad(q));

            // –¢–µ—Å—Ç 3: –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å funSPARQLvaluesComunica
            logTest('funSPARQLvaluesComunica', 'info', '–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏...');
            if (typeof funSPARQLvaluesComunica === 'function') {
                logTest('funSPARQLvaluesComunica –¥–æ—Å—Ç—É–ø–Ω–∞', 'passed', '–§—É–Ω–∫—Ü–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞');
            } else {
                logTest('funSPARQLvaluesComunica –¥–æ—Å—Ç—É–ø–Ω–∞', 'failed', '–§—É–Ω–∫—Ü–∏—è –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞');
                showSummary();
                return;
            }

            // –¢–µ—Å—Ç 4: –ü—Ä–æ–≤–µ—Ä—è–µ–º SPARQL –∑–∞–ø—Ä–æ—Å –Ω–∞ –≤—Å–µ –ø—Ä–æ—Ü–µ—Å—Å—ã
            logTest('–í—Å–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤', 'info', '–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –∏–∑ ptree...');
            try {
                const allConcepts = await funSPARQLvaluesComunica(`
                    SELECT ?process ?label WHERE {
                        GRAPH vad:ptree {
                            ?process rdf:type vad:TypeProcess .
                            ?process rdfs:label ?label .
                        }
                    }
                `, 'process');

                logTest('–í—Å–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –≤ ptree', 'passed', `${allConcepts.length} –ø—Ä–æ—Ü–µ—Å—Å–æ–≤`);
            } catch (error) {
                logTest('–í—Å–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –≤ ptree', 'failed', `–û—à–∏–±–∫–∞: ${error.message}`);
            }

            // –¢–µ—Å—Ç 5: SPARQL-driven —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å FILTER NOT EXISTS
            logTest('SPARQL-driven —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è', 'info', '–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ SPARQL —Å FILTER NOT EXISTS...');
            try {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ SPARQL –∑–∞–ø—Ä–æ—Å, —á—Ç–æ –∏ –≤ openNewTrigModal
                const filteredConcepts = await funSPARQLvaluesComunica(
                    SPARQL_PROCESSES_WITHOUT_VADPROCESSDIA,
                    'process'
                );

                logTest('–ü–æ—Å–ª–µ SPARQL —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏', 'info', `${filteredConcepts.length} –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –±–µ–∑ VADProcessDia`);

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º: –ø—Ä–æ—Ü–µ—Å—Å—ã p1_2, p1_1_1, p1_1_2, p2_1, p2_2, px_x, pNotDefined, pDel –ù–ï –∏–º–µ—é—Ç VADProcessDia
                const processesWithoutDia = filteredConcepts.map(c => c.uri);
                const shouldNotHaveDia = [
                    'http://example.org/vad#p1_2',
                    'http://example.org/vad#p1_1_1',
                    'http://example.org/vad#p1_1_2',
                    'http://example.org/vad#p2_1',
                    'http://example.org/vad#p2_2'
                ];

                // –ü—Ä–æ–≤–µ—Ä–∫–∞: p1, p1_1, p2 –ù–ï –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã—Ö
                const shouldBeFiltered = [
                    'http://example.org/vad#p1',
                    'http://example.org/vad#p1_1',
                    'http://example.org/vad#p2'
                ];

                const correctlyFiltered = shouldBeFiltered.every(uri => !processesWithoutDia.includes(uri));
                const correctlyKept = shouldNotHaveDia.every(uri => processesWithoutDia.includes(uri));

                if (correctlyFiltered && correctlyKept) {
                    logTest('–ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å SPARQL —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏', 'passed',
                        `p1, p1_1, p2 –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω—ã; p1_2, p1_1_1, p1_1_2, p2_1, p2_2 –æ—Å—Ç–∞–≤–ª–µ–Ω—ã`);
                } else {
                    let msg = '';
                    if (!correctlyFiltered) {
                        const notFiltered = shouldBeFiltered.filter(uri => processesWithoutDia.includes(uri));
                        msg += `–ù–µ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω—ã: ${notFiltered.map(u => u.split('#')[1]).join(', ')}. `;
                    }
                    if (!correctlyKept) {
                        const wronglyFiltered = shouldNotHaveDia.filter(uri => !processesWithoutDia.includes(uri));
                        msg += `–û—à–∏–±–æ—á–Ω–æ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω—ã: ${wronglyFiltered.map(u => u.split('#')[1]).join(', ')}`;
                    }
                    logTest('–ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å SPARQL —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏', 'failed', msg);
                }

                // –í—ã–≤–æ–¥–∏–º —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è TriG
                logTest('–î–æ—Å—Ç—É–ø–Ω—ã–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è TriG', 'info',
                    filteredConcepts.map(c => c.label || c.uri.split('#')[1]).join(', '));

            } catch (error) {
                logTest('SPARQL-driven —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è', 'failed', `–û—à–∏–±–∫–∞: ${error.message}`);
            }

            // –¢–µ—Å—Ç 6: –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ SPARQL_PROCESSES_WITHOUT_VADPROCESSDIA –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞
            logTest('SPARQL –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞', 'info', '–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã SPARQL_PROCESSES_WITHOUT_VADPROCESSDIA...');
            if (typeof SPARQL_PROCESSES_WITHOUT_VADPROCESSDIA === 'string') {
                logTest('SPARQL_PROCESSES_WITHOUT_VADPROCESSDIA –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞', 'passed',
                    '–ö–æ–Ω—Å—Ç–∞–Ω—Ç–∞ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞ –∏ –¥–æ—Å—Ç—É–ø–Ω–∞');
            } else {
                logTest('SPARQL_PROCESSES_WITHOUT_VADPROCESSDIA –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞', 'failed',
                    '–ö–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –∏–ª–∏ –Ω–µ —Å—Ç—Ä–æ–∫–∞');
            }

            showSummary();
        }

        // –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤
        runTests();
    </script>
</body>
</html>
