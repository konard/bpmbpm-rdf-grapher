{"version":3,"file":"SparqlJsonParser.js","sourceRoot":"","sources":["SparqlJsonParser.ts"],"names":[],"mappings":"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","sourcesContent":["import {DataFactory} from \"rdf-data-factory\";\nimport * as RDF from \"@rdfjs/types\";\nimport {Transform} from \"readable-stream\";\n\n// tslint:disable-next-line:no-var-requires\nconst JsonParser = require('@bergos/jsonparse');\n\n/**\n * Parser for the SPARQL 1.1 Query Results JSON format.\n * @see https://www.w3.org/TR/sparql11-results-json/\n */\nexport class SparqlJsonParser {\n\n  public static SUPPORTED_VERSIONS: string[] = [\n    '1.2',\n    '1.2-basic',\n    '1.1',\n  ];\n\n  private readonly dataFactory: RDF.DataFactory;\n  private readonly prefixVariableQuestionMark?: boolean;\n  private readonly suppressMissingStreamResultsError: boolean;\n  private readonly parseUnsupportedVersions: boolean;\n\n  constructor(settings?: ISettings) {\n    settings = settings || {};\n    this.dataFactory = settings.dataFactory || new DataFactory();\n    this.prefixVariableQuestionMark = !!settings.prefixVariableQuestionMark;\n    this.suppressMissingStreamResultsError = settings.suppressMissingStreamResultsError ?? true;\n    this.parseUnsupportedVersions = !!settings.parseUnsupportedVersions;\n  }\n\n  /**\n   * If the given version is valid for this parser to handle.\n   * @param version A version string.\n   */\n  public isValidVersion(version: string): boolean {\n    return this.parseUnsupportedVersions || SparqlJsonParser.SUPPORTED_VERSIONS.includes(version);\n  }\n\n  /**\n   * Convert a SPARQL JSON bindings response to an array of bindings objects.\n   * @param sparqlResponse A SPARQL JSON response.\n   * @param version The version that was supplied as a media type parameter\n   * @return {IBindings[]} An array of bindings.\n   */\n  public parseJsonResults(sparqlResponse: any, version?: string): IBindings[] {\n    if (version && !this.isValidVersion(version)) {\n      throw new Error(`Detected unsupported version as media type parameter: ${version}`);\n    }\n    return sparqlResponse.results.bindings.map((rawBindings: any) => this.parseJsonBindings(rawBindings));\n  }\n\n  /**\n   * Convert a SPARQL JSON bindings response stream to a stream of bindings objects.\n   *\n   * The bindings stream will emit a 'variables' event that will contain\n   * the array of variables (as RDF.Variable[]), as defined in the response head.\n   *\n   * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL JSON response stream.\n   * @param version The version that was supplied as a media type parameter\n   * @return {NodeJS.ReadableStream} A stream of bindings.\n   */\n  public parseJsonResultsStream(sparqlResponseStream: NodeJS.ReadableStream, version?: string): NodeJS.ReadableStream {\n    const errorListener = (error: Error) => resultStream.emit('error', error);\n    sparqlResponseStream.on('error', errorListener);\n\n    const jsonParser = new JsonParser();\n    jsonParser.onError = errorListener;\n    let variablesFound = false;\n    let resultsFound = false;\n    jsonParser.onValue = (value: any) => {\n      if(jsonParser.key === \"vars\" && jsonParser.stack.length === 2 && jsonParser.stack[1].key === 'head') {\n        resultStream.emit('variables', value.map((v: string) => this.dataFactory.variable(v)));\n        variablesFound = true;\n      } else if(jsonParser.key === \"link\" && jsonParser.stack.length === 2 && jsonParser.stack[1].key === 'head') {\n        resultStream.emit('link', value);\n      } else if(jsonParser.key === \"version\" && jsonParser.stack.length === 2 && jsonParser.stack[1].key === 'head') {\n        if (!this.isValidVersion(value)) {\n          resultStream.emit(\"error\", new Error(`Detected unsupported version: ${value}`));\n        }\n        resultStream.emit('version', value);\n      } else if(jsonParser.key === \"results\" && jsonParser.stack.length === 1) {\n        resultsFound = true;\n      } else if(typeof jsonParser.key === 'number' && jsonParser.stack.length === 3 && jsonParser.stack[1].key === 'results' && jsonParser.stack[2].key === 'bindings') {\n        try {\n          resultStream.push(this.parseJsonBindings(value))\n        } catch (error) {\n          resultStream.emit(\"error\", error);\n        }\n      } else if(jsonParser.key === \"metadata\" && jsonParser.stack.length === 1) {\n        resultStream.emit('metadata', value);\n      }\n    }\n\n    const resultStream = sparqlResponseStream\n      .on(\"end\", _ => {\n        if (!resultsFound && !this.suppressMissingStreamResultsError) {\n          resultStream.emit(\"error\", new Error(\"No valid SPARQL query results were found.\"))\n        } else if (!variablesFound) {\n          resultStream.emit('variables', []);\n        }\n      })\n      .pipe(new Transform({\n        objectMode: true,\n        transform(chunk: any, encoding: string, callback: (error?: Error | null, data?: any) => void) {\n          jsonParser.write(chunk);\n          callback();\n        }\n      }));\n\n    if (version && !this.isValidVersion(version)) {\n      resultStream.destroy(new Error(`Detected unsupported version as media type parameter: ${version}`));\n    }\n\n    return resultStream;\n  }\n\n  /**\n   * Convert a SPARQL JSON result binding to a bindings object.\n   * @param rawBindings A SPARQL JSON result binding.\n   * @return {IBindings} A bindings object.\n   */\n  public parseJsonBindings(rawBindings: any): IBindings {\n    const bindings: IBindings = {};\n    for (const key in rawBindings) {\n      const rawValue: any = rawBindings[key];\n      bindings[this.prefixVariableQuestionMark ? ('?' + key) : key] = this.parseJsonValue(rawValue);\n    }\n    return bindings;\n  }\n\n  /**\n   * Convert a SPARQL JSON result value to an RDF term.\n   * @param rawValue A SPARQL JSON result value\n   * @return {RDF.Term} An RDF term.\n   */\n  public parseJsonValue(rawValue: any): RDF.Term {\n    let value: RDF.Term;\n    switch (rawValue.type) {\n    case 'bnode':\n      value = this.dataFactory.blankNode(rawValue.value);\n      break;\n    case 'literal':\n      if (rawValue['xml:lang']) {\n        const language = rawValue['xml:lang'];\n        const direction = rawValue['its:dir'];\n        value = this.dataFactory.literal(rawValue.value, { language, direction });\n      } else if (rawValue.datatype) {\n        value = this.dataFactory.literal(rawValue.value, this.dataFactory.namedNode(rawValue.datatype));\n      } else {\n        value = this.dataFactory.literal(rawValue.value);\n      }\n      break;\n    case 'typed-literal':\n      // Virtuoso uses this non-spec-compliant way of defining typed literals\n      value = this.dataFactory.literal(rawValue.value, this.dataFactory.namedNode(rawValue.datatype));\n      break;\n    case 'triple':\n      const tripleValue = rawValue.value;\n      if (!tripleValue || !tripleValue.subject || !tripleValue.predicate || !tripleValue.object) {\n        throw new Error('Invalid quoted triple: ' + JSON.stringify(rawValue));\n      }\n      value = this.dataFactory.quad(\n        <RDF.Quad_Subject> this.parseJsonValue(tripleValue.subject),\n        <RDF.Quad_Predicate> this.parseJsonValue(tripleValue.predicate),\n        <RDF.Quad_Object> this.parseJsonValue(tripleValue.object),\n      );\n      break;\n    default:\n      value = this.dataFactory.namedNode(rawValue.value);\n      break;\n    }\n    return value;\n  }\n\n  /**\n   * Convert a SPARQL JSON boolean response to a boolean.\n   * This will throw an error if the given reponse was not a valid boolean response.\n   * @param sparqlResponse A SPARQL JSON response.\n   * @param version The version that was supplied as a media type parameter\n   * @return {IBindings[]} An array of bindings.\n   */\n  public parseJsonBoolean(sparqlResponse: any, version?: string): boolean {\n    if (version && !this.isValidVersion(version)) {\n      throw new Error(`Detected unsupported version as media type parameter: ${version}`);\n    }\n    if ('boolean' in sparqlResponse) {\n      return sparqlResponse.boolean;\n    }\n    throw new Error('No valid ASK response was found.');\n  }\n\n  /**\n   * Convert a SPARQL JSON boolean response stream to a promise resolving to a boolean.\n   * This will reject if the given reponse was not a valid boolean response.\n   * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL JSON response stream.\n   * @param version The version that was supplied as a media type parameter\n   * @return {Promise<boolean>} The response boolean.\n   */\n  public parseJsonBooleanStream(sparqlResponseStream: NodeJS.ReadableStream, version?: string): Promise<boolean> {\n    if (version && !this.isValidVersion(version)) {\n      return Promise.reject(new Error(`Detected unsupported version as media type parameter: ${version}`));\n    }\n    return new Promise((resolve, reject) => {\n      const parser = new JsonParser();\n      parser.onError = reject;\n      parser.onValue = (value: any) => {\n        if(parser.key === \"boolean\" && typeof value === 'boolean' && parser.stack.length === 1) {\n          resolve(value);\n        }\n      }\n      sparqlResponseStream\n          .on('error', reject)\n          .on('data', d => parser.write(d))\n          .on('end', () => reject(new Error('No valid ASK response was found.')));\n    });\n  }\n\n}\n\n/**\n * Constructor settings object interface for {@link SparqlJsonParser}.\n */\nexport interface ISettings {\n  /**\n   * A custom datafactory.\n   */\n  dataFactory?: RDF.DataFactory;\n  /**\n   * If variable names should be prefixed with a quotation mark.\n   */\n  prefixVariableQuestionMark?: boolean;\n  /**\n   * If the error about missing results in a result stream should be suppressed.\n   */\n  suppressMissingStreamResultsError?: boolean;\n  /**\n   * If no error should be emitted on unsupported versions.\n   */\n  parseUnsupportedVersions?: boolean;\n}\n\n/**\n * A bindings object.\n */\nexport interface IBindings {\n  [key: string]: RDF.Term;\n}\n\n"]}