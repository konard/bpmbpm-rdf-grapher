{"version":3,"file":"TermUtil.js","sourceRoot":"","sources":["TermUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\n\nconst FACTORY = new DataFactory();\n\n/**\n * Utility methods for converting between string-based RDF representations and RDFJS objects.\n *\n * RDF Terms are represented as follows:\n * * Blank nodes: '_:myBlankNode'\n * * Variables: '_myVariable'\n * * Literals: '\"myString\"', '\"myLanguageString\"@en-us', '\"myLanguageString\"@en-us--ltr',\n *             '\"<p>e</p>\"^^<http://www.w3.org/1999/02/22-rdf-syntax-ns#HTML>'\n * * URIs: '<http://example.org>'\n *\n * Quads/triples are represented as hashes with 'subject', 'predicate', 'object' and 'graph' (optional)\n * as keys, and string-based RDF terms as values.\n */\n\n/**\n * Convert an RDFJS term to a string-based representation.\n * @param {RDF.Term} term An RDFJS term.\n * @return {string} A string-based term representation.\n */\nexport function termToString<T extends RDF.Term | undefined | null>(term: T): T extends RDF.Term ? string : undefined {\n  // TODO: remove nasty any casts when this TS bug has been fixed: https://github.com/microsoft/TypeScript/issues/26933\n  if (!term) {\n    return <any> undefined;\n  }\n  switch (term.termType) {\n    case 'NamedNode': return <any> (`<${escapeIRI(term.value)}>`);\n    case 'BlankNode': return <any> (`_:${term.value}`);\n    case 'Literal': {\n      const literalValue: RDF.Literal = term;\n      return <any> (`\"${escapeStringRDF(literalValue.value)}\"${\n        literalValue.datatype &&\n        literalValue.datatype.value !== 'http://www.w3.org/2001/XMLSchema#string' &&\n        literalValue.datatype.value !== 'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString' &&\n        literalValue.datatype.value !== 'http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString' ?\n          `^^<${literalValue.datatype.value}>` :\n          ''\n      }${literalValue.language ? `@${literalValue.language}` : ''}${\n        literalValue.direction ? `--${literalValue.direction}` : ''}`);\n    }\n    case 'Quad': return <any> (`<<${termToString(term.subject)} ${termToString(term.predicate)} ${termToString(term.object)}${term.graph.termType === 'DefaultGraph' ? '' : ` ${termToString(term.graph)}`}>>`);\n    case 'Variable': return <any> (`?${term.value}`);\n    case 'DefaultGraph': return <any> term.value;\n  }\n}\n\n/**\n * Get the string value of a literal.\n * @param {string} literalValue An RDF literal enclosed by '\"'.\n * @return {string} The literal value inside the '\"'.\n */\nexport function getLiteralValue(literalValue: string): string {\n  const match = /^\"([^]*)\"((\\^\\^.*)|(@.*))?$/u.exec(literalValue);\n  if (!match) {\n    throw new Error(`${literalValue} is not a literal`);\n  }\n  // eslint-disable-next-line unicorn/prefer-string-replace-all\n  return match[1].replace(/\\\\\"/ug, '\"');\n}\n\n/**\n * Get the datatype of the given literal.\n * @param {string} literalValue An RDF literal.\n * @return {string} The datatype of the literal.\n */\nexport function getLiteralType(literalValue: string): string {\n  const match = /^\"[^]*\"(?:\\^\\^<([^\"]+)>|(@)[^@\"]+)?$/u.exec(literalValue);\n  if (!match) {\n    throw new Error(`${literalValue} is not a literal`);\n  }\n  return match[1] || (match[2] ?\n    'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString' :\n    'http://www.w3.org/2001/XMLSchema#string');\n}\n\n/**\n * Get the language of the given literal.\n * @param {string} literalValue An RDF literal.\n * @return {string} The language of the literal.\n */\nexport function getLiteralLanguage(literalValue: string): string {\n  const match = /^\"[^]*\"(?:@([^@\"]+)|\\^\\^[^\"]+)?$/u.exec(literalValue);\n  if (!match) {\n    throw new Error(`${literalValue} is not a literal`);\n  }\n  if (match[1]) {\n    let ret = match[1].toLowerCase();\n\n    // Remove everything after --, since this indicates the base direction, which will be parsed later.\n    const doubleDashPos = ret.indexOf('--');\n    if (doubleDashPos >= 0) {\n      ret = ret.slice(0, doubleDashPos);\n    }\n\n    return ret;\n  }\n  return '';\n}\n\n/**\n * Get the direction of the given literal.\n * @param {string} literalValue An RDF literal.\n * @return {string} The direction of the literal.\n */\nexport function getLiteralDirection(literalValue: string): 'ltr' | 'rtl' | '' {\n  const doubleDashPos = literalValue.indexOf('--', literalValue.lastIndexOf('\"'));\n  if (doubleDashPos >= 0) {\n    const direction = literalValue.slice(doubleDashPos + 2, literalValue.length);\n    if (direction === 'ltr' || direction === 'rtl') {\n      return direction;\n    }\n    throw new Error(`${literalValue} is not a literal with a valid direction`);\n  }\n  return '';\n}\n\n/**\n * Transform a string-based RDF term to an RDFJS term.\n * @param {string} value A string-based RDF-term.\n * @param {RDF.DataFactory} dataFactory An optional datafactory to create terms with.\n * @return {RDF.Term} An RDF-JS term.\n */\nexport function stringToTerm(value: string | undefined, dataFactory?: RDF.DataFactory<RDF.BaseQuad>): RDF.Term {\n  dataFactory = dataFactory || FACTORY;\n  if (!value || (value.length === 0)) {\n    return dataFactory.defaultGraph();\n  }\n  switch (value[0]) {\n    case '_': return dataFactory.blankNode(value.slice(2));\n    case '?':\n      if (!dataFactory.variable) {\n        throw new Error(`Missing 'variable()' method on the given DataFactory`);\n      }\n      return dataFactory.variable(value.slice(1));\n    case '\"': {\n      const language: string = getLiteralLanguage(value);\n      const direction = getLiteralDirection(value);\n      const type: RDF.NamedNode = dataFactory.namedNode(getLiteralType(value));\n      return dataFactory.literal(getLiteralValue(value), language ? { language, direction } : type);\n    }\n    case '<':\n    default:\n      if (value.startsWith('<<') && value.endsWith('>>')) {\n        // Iterate character-by-character to detect spaces that are *not* wrapped in <<>>\n        const terms = value.slice(2, -2);\n        const stringTerms: string[] = [];\n        let ignoreTags = 0;\n        let lastIndex = 0;\n        for (let i = 0; i < terms.length; i++) {\n          const char = terms[i];\n          if (char === '<') {\n            ignoreTags++;\n          }\n          if (char === '>') {\n            if (ignoreTags === 0) {\n              throw new Error(`Found closing tag without opening tag in ${value}`);\n            } else {\n              ignoreTags--;\n            }\n          }\n          if (char === ' ' && ignoreTags === 0) {\n            stringTerms.push(terms.slice(lastIndex, i));\n            lastIndex = i + 1;\n          }\n        }\n        if (ignoreTags !== 0) {\n          throw new Error(`Found opening tag without closing tag in ${value}`);\n        }\n        stringTerms.push(terms.slice(lastIndex, terms.length));\n\n        // We require 3 or 4 components\n        if (stringTerms.length !== 3 && stringTerms.length !== 4) {\n          throw new Error(`Nested quad syntax error ${value}`);\n        }\n\n        return dataFactory.quad(\n          stringToTerm(stringTerms[0]),\n          stringToTerm(stringTerms[1]),\n          stringToTerm(stringTerms[2]),\n          stringTerms[3] ? stringToTerm(stringTerms[3]) : undefined,\n        );\n      }\n      if (!value.startsWith('<') || !value.endsWith('>')) {\n        throw new Error(`Detected invalid iri for named node (must be wrapped in <>): ${value}`);\n      }\n      return dataFactory.namedNode(value.slice(1, -1));\n  }\n}\n\n/**\n * Convert an RDFJS quad to a string-based quad representation.\n * @param {Quad} q An RDFJS quad.\n * @return {IStringQuad} A hash with string-based quad terms.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\nexport function quadToStringQuad<Q extends RDF.BaseQuad = RDF.Quad>(quad: Q): IStringQuad {\n  return {\n    subject: termToString(quad.subject),\n    predicate: termToString(quad.predicate),\n    object: termToString(quad.object),\n    graph: termToString(quad.graph),\n  };\n}\n\n/**\n * Convert a string-based quad representation to an RDFJS quad.\n * @param {IStringQuad} stringQuad A hash with string-based quad terms.\n * @param {RDF.DataFactory} dataFactory An optional datafactory to create terms with.\n * @return {Q} An RDFJS quad.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\nexport function stringQuadToQuad<Q extends RDF.BaseQuad = RDF.Quad>(\n  stringQuad: IStringQuad,\n  dataFactory?: RDF.DataFactory<Q>,\n): Q {\n  dataFactory = dataFactory! || FACTORY;\n  return dataFactory.quad(\n    stringToTerm(stringQuad.subject, dataFactory),\n    stringToTerm(stringQuad.predicate, dataFactory),\n    stringToTerm(stringQuad.object, dataFactory),\n    stringToTerm(stringQuad.graph, dataFactory),\n  );\n}\n\nfunction escapeIRI(iriValue: string): string {\n  return iriValue.replace(escapePattern, replaceEscapedCharacter);\n}\n\nfunction escapeStringRDF(stringValue: string): string {\n  if (escapePattern.test(stringValue)) {\n    stringValue = stringValue.replace(escapePattern, replaceEscapedCharacter);\n  }\n  return stringValue;\n}\n\n// Characters in literals and IRIs that require escaping\n// Also containing potential surrogate pairs\n/* eslint-disable require-unicode-regexp */ /* eslint-disable unicorn/better-regex */\nconst escapePattern = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n/* eslint-enable require-unicode-regexp */ /* eslint-enable unicorn/better-regex */\nconst escapes = new Map([\n  [ '\\\\', '\\\\\\\\' ],\n  [ '\"', '\\\\\"' ],\n  [ '\\t', '\\\\t' ],\n  [ '\\n', '\\\\n' ],\n  [ '\\r', '\\\\r' ],\n  [ '\\b', '\\\\b' ],\n  [ '\\f', '\\\\f' ],\n]);\n\nfunction replaceEscapedCharacter(character: string): string {\n  // Try simplest case first, get replacement for character\n  const result = escapes.get(character);\n  if (!result) {\n    if (character.length === 1) {\n      // Single unicode charachters, i.e. not a surrogate pair\n      const code = character.charCodeAt(0).toString(16);\n      return `${'\\\\u0000'.slice(0, -code.length)}${code}`;\n    }\n    // Surrogate pairs\n    const code = ((character.charCodeAt(0) - 0xD8_00) * 0x4_00 + character.charCodeAt(1) + 0x24_00).toString(16);\n    return `${'\\\\U00000000'.slice(0, -code.length)}${code}`;\n  }\n  return result;\n}\n\nexport interface IStringQuad {\n  subject: string;\n  predicate: string;\n  object: string;\n  graph?: string;\n}\n"]}