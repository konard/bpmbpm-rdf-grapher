{"version":3,"file":"NodeHandlerDocument.js","sourceRoot":"","sources":["NodeHandlerDocument.ts"],"names":[],"mappings":"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","sourcesContent":["import {DocumentNode} from \"graphql\";\nimport {DefinitionNode} from \"graphql/language\";\nimport * as RDF from \"@rdfjs/types\";\nimport {Algebra} from \"@traqula/algebra-transformations-1-2\";\nimport {AlgebraFactory, algebraUtils} from \"@traqula/algebra-transformations-1-2\";\nimport {IConvertContext} from \"../IConvertContext\";\nimport {IConvertSettings} from \"../IConvertSettings\";\nimport {Util} from \"../Util\";\nimport {INodeQuadContext, NodeHandlerAdapter} from \"./NodeHandlerAdapter\";\n\n/**\n * Converts GraphQL documents to joined operations for all its definitions.\n */\nexport class NodeHandlerDocument extends NodeHandlerAdapter<DocumentNode> {\n  constructor(util: Util, settings: IConvertSettings) {\n    super('Document', util, settings);\n  }\n\n  public handle(document: DocumentNode, convertContext: IConvertContext): Algebra.Operation {\n    const definitionOperations = document.definitions\n      .map((definition) => {\n        const subjectOutput = this.getNodeQuadContextDefinitionNode(definition,\n          {...convertContext, ignoreUnknownVariables: true});\n        const queryParseContext: IConvertContext = {\n          ...convertContext,\n          graph: subjectOutput.graph || convertContext.graph,\n          subject: subjectOutput.subject || this.util.dataFactory.blankNode(),\n        };\n        let definitionOperation = this.util.handleNode(definition, queryParseContext);\n        if (subjectOutput && subjectOutput.auxiliaryPatterns) {\n          definitionOperation = this.util.joinOperations([\n            definitionOperation,\n            this.util.operationFactory.createBgp(subjectOutput.auxiliaryPatterns),\n          ]);\n        }\n        return definitionOperation;\n      });\n    const operation = this.util.operationFactory.createProject(\n      definitionOperations.length === 1 ? definitionOperations[0] : this.util.operationFactory.createUnion(definitionOperations),\n      convertContext.terminalVariables);\n\n    // Convert blank nodes to variables\n    return this.translateBlankNodesToVariables(operation);\n  }\n\n  /**\n   * Get the quad context of a definition node that should be used for the whole definition node.\n   * @param {DefinitionNode} definition A definition node.\n   * @param {IConvertContext} convertContext A convert context.\n   * @return {INodeQuadContext} The subject and optional auxiliary patterns.\n   */\n  public getNodeQuadContextDefinitionNode(definition: DefinitionNode, convertContext: IConvertContext)\n    : INodeQuadContext {\n    if (definition.kind === 'OperationDefinition') {\n      return this.getNodeQuadContextSelectionSet(definition.selectionSet,\n        definition.name ? definition.name.value : '', convertContext);\n    }\n    throw new Error(`Unsupported definition: ${definition.kind}`);\n  }\n\n  /**\n   * Translates blank nodes inside the query to variables.\n   * @param {Project} operation The operation to translate.\n   * @return {Operation} The transformed operation.\n   */\n  public translateBlankNodesToVariables(operation: Algebra.Project): Algebra.Operation {\n    const blankToVariableMapping: {[bLabel: string]: RDF.Variable} = {};\n    const variablesRaw = new Set(operation.variables.map(x => x.value));\n\n    const uniqueVar = (label: string, variables: Set<string>): RDF.Variable => {\n      let counter = 0;\n      let labelLoop = label;\n      while (variablesRaw.has(labelLoop)) {\n        labelLoop = `${label}${counter++}`;\n      }\n      return this.util.dataFactory.variable!(labelLoop);\n    }\n\n    const blankToVariable = (term: RDF.Term): RDF.Term => {\n      if (term.termType === 'BlankNode') {\n        let variable = blankToVariableMapping[term.value];\n        if (!variable) {\n          variable = uniqueVar(term.value, variablesRaw);\n          variablesRaw.add(variable.value)\n          blankToVariableMapping[term.value] = variable;\n        }\n        return variable;\n      }\n      return term;\n    }\n\n    return algebraUtils.mapOperation<'unsafe', typeof operation>(operation, {\n      [Algebra.Types.PATH]: {\n        preVisitor: () => ({continue: false}),\n        transform: (op: Algebra.Path) => this.util.operationFactory.createPath(\n          blankToVariable(op.subject),\n          op.predicate,\n          blankToVariable(op.object),\n          blankToVariable(op.graph),\n        )\n      },\n      [Algebra.Types.PATTERN]: {\n        preVisitor: () => ({continue: false}),\n        transform: (op: Algebra.Pattern) => this.util.operationFactory.createPattern(\n            blankToVariable(op.subject),\n            blankToVariable(op.predicate),\n            blankToVariable(op.object),\n            blankToVariable(op.graph),\n          ),\n      },\n    });\n  }\n}\n"]}