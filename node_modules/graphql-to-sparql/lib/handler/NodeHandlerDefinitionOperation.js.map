{"version":3,"file":"NodeHandlerDefinitionOperation.js","sourceRoot":"","sources":["NodeHandlerDefinitionOperation.ts"],"names":[],"mappings":";;;AAKA,iFAA4E;AAE5E;;GAEG;AACH,MAAa,8BAA+B,SAAQ,2DAAqD;IAEvG,YAAY,IAAU,EAAE,QAA0B;QAChD,KAAK,CAAC,qBAAqB,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC/C,CAAC;IAEM,MAAM,CAAC,mBAA4C,EAAE,cAA+B;QACzF,IAAI,mBAAmB,CAAC,SAAS,KAAK,OAAO,EAAE,CAAC;YAC9C,MAAM,IAAI,KAAK,CAAC,oCAAoC,GAAG,mBAAmB,CAAC,SAAS,CAAC,CAAC;QACxF,CAAC;QACD,sEAAsE;QAEtE,YAAY;QACZ,IAAI,mBAAmB,CAAC,mBAAmB,EAAE,CAAC;YAC5C,KAAK,MAAM,kBAAkB,IAAI,mBAAmB,CAAC,mBAAmB,EAAE,CAAC;gBACzE,MAAM,IAAI,GAAW,kBAAkB,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC;gBAC5D,sEAAsE;gBACtE,IAAI,kBAAkB,CAAC,YAAY,EAAE,CAAC;oBACpC,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,CAAC;wBACxC,cAAc,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,kBAAkB,CAAC,YAAY,CAAC;oBACvE,CAAC;gBACH,CAAC;gBAED,cAAc;gBACd,IAAI,QAAQ,GAAa,kBAAkB,CAAC,IAAI,CAAC;gBACjD,MAAM,SAAS,GAAY,QAAQ,CAAC,IAAI,KAAK,aAAa,CAAC;gBAC3D,IAAI,SAAS,EAAE,CAAC;oBACd,QAAQ,GAAsB,QAAS,CAAC,IAAI,CAAC;gBAC/C,CAAC;gBACD,MAAM,IAAI,GAAY,QAAQ,CAAC,IAAI,KAAK,UAAU,CAAC;gBACnD,IAAI,IAAI,EAAE,CAAC;oBACT,QAAQ,GAAmB,QAAS,CAAC,IAAI,CAAC;gBAC5C,CAAC;gBACD,MAAM,IAAI,GAA4B,QAAS,CAAC,IAAI,CAAC,KAAK,CAAC;gBAC3D,cAAc,CAAC,iBAAiB,CAAC,IAAI,CAAC,GAAG,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;YACrE,CAAC;QACH,CAAC;QAED,aAAa;QACb,MAAM,gBAAgB,GAAG,IAAI,CAAC,mBAAmB,CAAC,mBAAmB,CAAC,UAAU,EAC9E,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC,mBAAmB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,cAAc,CAAC,CAAC;QAClF,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACtB,OAAO,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;QAClD,CAAC;QAED,uBAAuB;QACvB,MAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,mBAAmB,CAAC,YAAY,CAAC,UAAU;aACnF,GAAG,CAAC,CAAC,aAAa,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC;QAEhF,+BAA+B;QAC/B,OAAO,IAAI,CAAC,sBAAsB,CAAC,gBAAgB,EAAE,SAAS,CAAC,CAAC;IAClE,CAAC;CAEF;AArDD,wEAqDC","sourcesContent":["import {ListTypeNode, NamedTypeNode, NonNullTypeNode, OperationDefinitionNode, TypeNode} from \"graphql/language\";\nimport type {Algebra} from \"@traqula/algebra-transformations-1-2\";\nimport {IConvertContext} from \"../IConvertContext\";\nimport {IConvertSettings} from \"../IConvertSettings\";\nimport {Util} from \"../Util\";\nimport {NodeHandlerDefinitionAdapter} from \"./NodeHandlerDefinitionAdapter\";\n\n/**\n * Converts GraphQL definitions to joined operations for all its selections.\n */\nexport class NodeHandlerDefinitionOperation extends NodeHandlerDefinitionAdapter<OperationDefinitionNode> {\n\n  constructor(util: Util, settings: IConvertSettings) {\n    super('OperationDefinition', util, settings);\n  }\n\n  public handle(operationDefinition: OperationDefinitionNode, convertContext: IConvertContext): Algebra.Operation {\n    if (operationDefinition.operation !== 'query') {\n      throw new Error('Unsupported definition operation: ' + operationDefinition.operation);\n    }\n    // We ignore the query name, as SPARQL doesn't support naming queries.\n\n    // Variables\n    if (operationDefinition.variableDefinitions) {\n      for (const variableDefinition of operationDefinition.variableDefinitions) {\n        const name: string = variableDefinition.variable.name.value;\n        // Put the default value in the context if it hasn't been defined yet.\n        if (variableDefinition.defaultValue) {\n          if (!convertContext.variablesDict[name]) {\n            convertContext.variablesDict[name] = variableDefinition.defaultValue;\n          }\n        }\n\n        // Handle type\n        let typeNode: TypeNode = variableDefinition.type;\n        const mandatory: boolean = typeNode.kind === 'NonNullType';\n        if (mandatory) {\n          typeNode = (<NonNullTypeNode> typeNode).type;\n        }\n        const list: boolean = typeNode.kind === 'ListType';\n        if (list) {\n          typeNode = (<ListTypeNode> typeNode).type;\n        }\n        const type: string = (<NamedTypeNode> typeNode).name.value;\n        convertContext.variablesMetaDict[name] = { mandatory, list, type };\n      }\n    }\n\n    // Directives\n    const directiveOutputs = this.getDirectiveOutputs(operationDefinition.directives,\n      operationDefinition.name ? operationDefinition.name.value : '', convertContext);\n    if (!directiveOutputs) {\n      return this.util.operationFactory.createBgp([]);\n    }\n\n    // Handle the operation\n    const operation = this.util.joinOperations(operationDefinition.selectionSet.selections\n      .map((selectionNode) => this.util.handleNode(selectionNode, convertContext)));\n\n    // Override operation if needed\n    return this.handleDirectiveOutputs(directiveOutputs, operation);\n  }\n\n}\n"]}