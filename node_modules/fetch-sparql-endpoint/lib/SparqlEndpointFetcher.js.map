{"version":3,"file":"SparqlEndpointFetcher.js","sourceRoot":"","sources":["SparqlEndpointFetcher.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { Parser as SparqlParser } from '@traqula/parser-sparql-1-2';\nimport type { UpdateOperation } from '@traqula/rules-sparql-1-2';\nimport * as isStream from 'is-stream';\nimport { StreamParser } from 'n3';\nimport { readableFromWeb } from 'readable-from-web';\nimport type { Readable } from 'readable-stream';\nimport { type ISettings as ISparqlJsonParserArgs, SparqlJsonParser } from 'sparqljson-parse';\nimport { type ISettings as ISparqlXmlParserArgs, SparqlXmlParser } from 'sparqlxml-parse';\nimport * as stringifyStream from 'stream-to-string';\n\n/**\n * A SparqlEndpointFetcher can send queries to SPARQL endpoints,\n * and retrieve and parse the results.\n */\nexport class SparqlEndpointFetcher {\n  public static readonly CONTENTTYPE_SPARQL_JSON = 'application/sparql-results+json';\n  public static readonly CONTENTTYPE_SPARQL_XML = 'application/sparql-results+xml';\n  public static readonly CONTENTTYPE_TURTLE = 'text/turtle';\n  public static readonly CONTENTTYPE_SPARQL = `${SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON};q=1.0,${SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML};q=0.7`;\n  private static readonly REGEX_VERSION_HEADER = /version=([^ ;]*)/u;\n\n  protected readonly method: 'GET' | 'POST';\n  protected readonly timeout?: number;\n  protected readonly forceGetIfUrlLengthBelow: number;\n  protected readonly directPost: boolean;\n  public additionalUrlParams: URLSearchParams;\n  protected readonly defaultHeaders: Headers;\n  public readonly fetchCb?: (input: Request | string, init?: RequestInit) => Promise<Response>;\n  protected readonly parseUnsupportedVersions: boolean;\n\n  protected readonly sparqlQueryParser: SparqlParser;\n  protected readonly sparqlParsers: Record<string, ISparqlResultsParser>;\n  protected readonly sparqlJsonParser: SparqlJsonParser;\n  protected readonly sparqlXmlParser: SparqlXmlParser;\n\n  public constructor(args?: ISparqlEndpointFetcherArgs) {\n    this.method = args?.method ?? 'POST';\n    this.timeout = args?.timeout;\n    this.forceGetIfUrlLengthBelow = args?.forceGetIfUrlLengthBelow ?? 0;\n    this.directPost = args?.directPost ?? false;\n    this.additionalUrlParams = args?.additionalUrlParams ?? new URLSearchParams();\n    this.defaultHeaders = args?.defaultHeaders ?? new Headers();\n    this.fetchCb = args?.fetch;\n    this.parseUnsupportedVersions = Boolean(args?.parseUnsupportedVersions);\n    this.sparqlQueryParser = args?.sparqlQueryParser ?? new SparqlParser({\n      lexerConfig: {\n        positionTracking: 'onlyOffset',\n      },\n    });\n    this.sparqlJsonParser = new SparqlJsonParser(args);\n    this.sparqlXmlParser = new SparqlXmlParser(args);\n    this.sparqlParsers = {\n      [SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON]: {\n        parseBooleanStream: (sparqlResponseStream, version) =>\n          this.sparqlJsonParser.parseJsonBooleanStream(sparqlResponseStream, version),\n        parseResultsStream: (sparqlResponseStream, version) =>\n          this.sparqlJsonParser.parseJsonResultsStream(sparqlResponseStream, version),\n      },\n      [SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML]: {\n        parseBooleanStream: (sparqlResponseStream, version) =>\n          this.sparqlXmlParser.parseXmlBooleanStream(sparqlResponseStream, version),\n        parseResultsStream: (sparqlResponseStream, version) =>\n          this.sparqlXmlParser.parseXmlResultsStream(sparqlResponseStream, version),\n      },\n    };\n  }\n\n  /**\n   * Get the query type of the given query.\n   *\n   * This will parse the query and thrown an exception on syntax errors.\n   *\n   * @param {string} query A query.\n   * @return {'SELECT' | 'ASK' | 'CONSTRUCT' | 'UNKNOWN'} The query type.\n   */\n  public getQueryType(query: string): 'SELECT' | 'ASK' | 'CONSTRUCT' | 'UNKNOWN' {\n    const parsedQuery = this.sparqlQueryParser.parse(query);\n    if (parsedQuery.type === 'query') {\n      return parsedQuery.subType === 'describe' ?\n        'CONSTRUCT' :\n        <Uppercase<typeof parsedQuery.subType>>parsedQuery.subType.toUpperCase();\n    }\n    return 'UNKNOWN';\n  }\n\n  /**\n   * Get the query type of the given update query.\n   *\n   * This will parse the update query and thrown an exception on syntax errors.\n   *\n   * @param {string} query An update query.\n   * @return {'UNKNOWN' | IUpdateTypes} The included update operations.\n   */\n  public getUpdateTypes(query: string): 'UNKNOWN' | IUpdateTypes {\n    const parsedQuery = this.sparqlQueryParser.parse(query);\n    if (parsedQuery.type === 'update') {\n      const operations: IUpdateTypes = {};\n      for (const update of parsedQuery.updates) {\n        if (update.operation) {\n          operations[update.operation.subType] = true;\n        }\n      }\n      return operations;\n    }\n    return 'UNKNOWN';\n  }\n\n  /**\n   * Send a SELECT query to the given endpoint URL and return the resulting bindings stream.\n   * @see IBindings\n   * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query    A SPARQL query string.\n   * @return {Promise<NodeJS.ReadableStream>} A stream of {@link IBindings}.\n   */\n  public async fetchBindings(endpoint: string, query: string): Promise<NodeJS.ReadableStream> {\n    const [ contentType, version, responseStream ] = await this.fetchRawStream(\n      endpoint,\n      query,\n      SparqlEndpointFetcher.CONTENTTYPE_SPARQL,\n    );\n    const parser: ISparqlResultsParser | undefined = this.sparqlParsers[contentType];\n    if (!parser) {\n      throw new Error(`Unknown SPARQL results content type: ${contentType}`);\n    }\n    return parser.parseResultsStream(responseStream, version);\n  }\n\n  /**\n   * Send an ASK query to the given endpoint URL and return a promise resolving to the boolean answer.\n   * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query    A SPARQL query string.\n   * @return {Promise<boolean>} A boolean resolving to the answer.\n   */\n  public async fetchAsk(endpoint: string, query: string): Promise<boolean> {\n    const [ contentType, version, responseStream ] = await this.fetchRawStream(\n      endpoint,\n      query,\n      SparqlEndpointFetcher.CONTENTTYPE_SPARQL,\n    );\n    const parser: ISparqlResultsParser | undefined = this.sparqlParsers[contentType];\n    if (!parser) {\n      throw new Error(`Unknown SPARQL results content type: ${contentType}`);\n    }\n    return parser.parseBooleanStream(responseStream, version);\n  }\n\n  /**\n   * Send a CONSTRUCT/DESCRIBE query to the given endpoint URL and return the resulting triple stream.\n   * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query    A SPARQL query string.\n   * @return {Promise<Stream>} A stream of triples.\n   */\n  public async fetchTriples(endpoint: string, query: string): Promise<Readable & RDF.Stream> {\n    const [ contentType, version, responseStream ] = await this.fetchRawStream(\n      endpoint,\n      query,\n      SparqlEndpointFetcher.CONTENTTYPE_TURTLE,\n    );\n    return <Readable> <unknown> responseStream.pipe(new StreamParser({\n      format: contentType,\n      // eslint-disable-next-line ts/ban-ts-comment\n      // @ts-expect-error // TODO: remove this once n3.js typings have been updated to include version option\n      version,\n      parseUnsupportedVersions: this.parseUnsupportedVersions,\n    }));\n  }\n\n  /**\n   * Send an update query to the given endpoint URL using POST.\n   *\n   * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query        A SPARQL query string.\n   */\n  public async fetchUpdate(endpoint: string, query: string): Promise<void> {\n    const abortController = new AbortController();\n    const defaultHeadersRaw: Record<string, string> = {};\n\n    // Headers object does not have other means to iterate it according to the typings\n    // eslint-disable-next-line unicorn/no-array-for-each\n    this.defaultHeaders.forEach((value, key) => {\n      defaultHeadersRaw[key] = value;\n    });\n\n    const init: RequestInit = {\n      method: 'POST',\n      headers: {\n        ...defaultHeadersRaw,\n        'content-type': 'application/sparql-update',\n      },\n      body: query,\n      signal: abortController.signal,\n    };\n\n    await this.handleFetchCall(endpoint, init, { ignoreBody: true });\n    abortController.abort();\n  }\n\n  /**\n   * Send a query to the given endpoint URL and return the resulting stream.\n   *\n   * This will only accept responses with the application/sparql-results+json content type.\n   *\n   * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query        A SPARQL query string.\n   * @param {string} acceptHeader The HTTP accept to use.\n   * @return {Promise<[string, NodeJS.ReadableStream]>} The media type, version, and SPARQL endpoint response stream.\n   */\n  public async fetchRawStream(\n    endpoint: string,\n    query: string,\n    acceptHeader: string,\n  ): Promise<[ string, string | undefined, NodeJS.ReadableStream ]> {\n    let method: 'GET' | 'POST';\n    let url: string;\n\n    if (this.method === 'POST' && this.forceGetIfUrlLengthBelow <= endpoint.length) {\n      method = this.method;\n      url = endpoint;\n    } else {\n      const getEndpoint = `${endpoint}?query=${encodeURIComponent(query)}`;\n      method = this.method === 'GET' || getEndpoint.length < this.forceGetIfUrlLengthBelow ? 'GET' : 'POST';\n      url = method === 'POST' ? endpoint : getEndpoint;\n    }\n\n    // Initiate request\n    let body: URLSearchParams | string | undefined;\n    const headers: Headers = new Headers(this.defaultHeaders);\n    headers.append('Accept', acceptHeader);\n\n    if (method === 'POST') {\n      if (this.directPost) {\n        headers.append('Content-Type', 'application/sparql-query');\n        body = query;\n        if (this.additionalUrlParams.toString().length > 0) {\n          url += `?${this.additionalUrlParams.toString()}`;\n        }\n      } else {\n        headers.append('Content-Type', 'application/x-www-form-urlencoded');\n        body = new URLSearchParams();\n        body.set('query', query);\n        for (const [ key, value ] of this.additionalUrlParams.entries()) {\n          body.set(key, value);\n        }\n      }\n      headers.append('Content-Length', body.toString().length.toString());\n    } else if (this.additionalUrlParams.toString().length > 0) {\n      url += `&${this.additionalUrlParams.toString()}`;\n    }\n\n    return this.handleFetchCall(url, { headers, method, body });\n  }\n\n  /**\n   * Helper function to generalize internal fetch calls.\n   *\n   * @param {string}      url     The URL to call.\n   * @param {RequestInit} init    Options to pass along to the fetch call.\n   * @param {any}         options Other specific fetch options.\n   * @return {Promise<[string, NodeJS.ReadableStream]>} The media type, version, and SPARQL endpoint response stream.\n   */\n  private async handleFetchCall(\n    url: string,\n    init: RequestInit,\n    options?: { ignoreBody: boolean },\n  ): Promise<[ string, string | undefined, NodeJS.ReadableStream ]> {\n    let timeout;\n    let responseStream: NodeJS.ReadableStream | undefined;\n\n    if (this.timeout) {\n      const controller = new AbortController();\n      init.signal = controller.signal;\n      timeout = setTimeout(() => controller.abort(), this.timeout);\n    }\n\n    const httpResponse: Response = await (this.fetchCb ?? fetch)(url, init);\n\n    clearTimeout(timeout);\n\n    // Handle response body\n    if (!options?.ignoreBody && httpResponse.body) {\n      // Wrap WhatWG readable stream into a Node.js readable stream\n      // If the body already is a Node.js stream (in the case of node-fetch), don't do explicit conversion.\n      responseStream = <NodeJS.ReadableStream> (\n        isStream(httpResponse.body) ? httpResponse.body : readableFromWeb(httpResponse.body)\n      );\n    }\n\n    // Emit an error if the server returned an invalid response\n    if (!httpResponse.ok || (!responseStream && !options?.ignoreBody)) {\n      const simpleUrl = url.split('?').at(0);\n      const bodyString = responseStream ? await stringifyStream(responseStream) : 'empty response';\n      throw new Error(`Invalid SPARQL endpoint response from ${simpleUrl} (HTTP status ${httpResponse.status}):\\n${bodyString}`);\n    }\n\n    // Determine the media type\n    const contentType = httpResponse.headers.get('Content-Type');\n    const mediaType = contentType?.split(';').at(0) ?? '';\n\n    // Determine the optional version parameter\n    let version: string | undefined;\n    if (contentType) {\n      const matches = SparqlEndpointFetcher.REGEX_VERSION_HEADER.exec(contentType);\n      if (matches) {\n        version = matches[1];\n      }\n    }\n\n    return [ mediaType, version, responseStream! ];\n  }\n}\n\nexport interface ISparqlEndpointFetcherArgs extends ISparqlJsonParserArgs, ISparqlXmlParserArgs {\n  /**\n   * A custom HTTP method for issuing (non-update) queries, defaults to POST.\n   * Update queries are always issued via POST.\n   */\n  method?: 'POST' | 'GET';\n  additionalUrlParams?: URLSearchParams;\n  timeout?: number;\n  forceGetIfUrlLengthBelow?: number;\n  directPost?: boolean;\n  defaultHeaders?: Headers;\n  /**\n   * A custom fetch function.\n   */\n  fetch?: (input: Request | string, init?: RequestInit) => Promise<Response>;\n  /**\n   * A SPARQL query parser used by the endpoint fetcher to detect query types.\n   */\n  sparqlQueryParser?: SparqlParser;\n  /**\n   * If no error should be emitted on unsupported versions.\n   * By default, an error will be emitted.\n   */\n  parseUnsupportedVersions?: boolean;\n}\n\nexport interface ISparqlResultsParser {\n  parseResultsStream: (\n    sparqlResponseStream: NodeJS.ReadableStream,\n    version: string | undefined\n  ) => NodeJS.ReadableStream;\n  parseBooleanStream: (sparqlResponseStream: NodeJS.ReadableStream, version: string | undefined) => Promise<boolean>;\n}\n\nexport type IBindings = Record<string, RDF.Term>;\n\nexport type IUpdateTypes = {\n  [K in UpdateOperation['subType']]?: boolean;\n};\n"]}