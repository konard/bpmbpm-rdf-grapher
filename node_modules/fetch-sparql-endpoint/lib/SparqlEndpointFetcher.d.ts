import type * as RDF from '@rdfjs/types';
import { Parser as SparqlParser } from '@traqula/parser-sparql-1-2';
import type { UpdateOperation } from '@traqula/rules-sparql-1-2';
import type { Readable } from 'readable-stream';
import { type ISettings as ISparqlJsonParserArgs, SparqlJsonParser } from 'sparqljson-parse';
import { type ISettings as ISparqlXmlParserArgs, SparqlXmlParser } from 'sparqlxml-parse';
/**
 * A SparqlEndpointFetcher can send queries to SPARQL endpoints,
 * and retrieve and parse the results.
 */
export declare class SparqlEndpointFetcher {
    static readonly CONTENTTYPE_SPARQL_JSON = "application/sparql-results+json";
    static readonly CONTENTTYPE_SPARQL_XML = "application/sparql-results+xml";
    static readonly CONTENTTYPE_TURTLE = "text/turtle";
    static readonly CONTENTTYPE_SPARQL: string;
    private static readonly REGEX_VERSION_HEADER;
    protected readonly method: 'GET' | 'POST';
    protected readonly timeout?: number;
    protected readonly forceGetIfUrlLengthBelow: number;
    protected readonly directPost: boolean;
    additionalUrlParams: URLSearchParams;
    protected readonly defaultHeaders: Headers;
    readonly fetchCb?: (input: Request | string, init?: RequestInit) => Promise<Response>;
    protected readonly parseUnsupportedVersions: boolean;
    protected readonly sparqlQueryParser: SparqlParser;
    protected readonly sparqlParsers: Record<string, ISparqlResultsParser>;
    protected readonly sparqlJsonParser: SparqlJsonParser;
    protected readonly sparqlXmlParser: SparqlXmlParser;
    constructor(args?: ISparqlEndpointFetcherArgs);
    /**
     * Get the query type of the given query.
     *
     * This will parse the query and thrown an exception on syntax errors.
     *
     * @param {string} query A query.
     * @return {'SELECT' | 'ASK' | 'CONSTRUCT' | 'UNKNOWN'} The query type.
     */
    getQueryType(query: string): 'SELECT' | 'ASK' | 'CONSTRUCT' | 'UNKNOWN';
    /**
     * Get the query type of the given update query.
     *
     * This will parse the update query and thrown an exception on syntax errors.
     *
     * @param {string} query An update query.
     * @return {'UNKNOWN' | IUpdateTypes} The included update operations.
     */
    getUpdateTypes(query: string): 'UNKNOWN' | IUpdateTypes;
    /**
     * Send a SELECT query to the given endpoint URL and return the resulting bindings stream.
     * @see IBindings
     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query    A SPARQL query string.
     * @return {Promise<NodeJS.ReadableStream>} A stream of {@link IBindings}.
     */
    fetchBindings(endpoint: string, query: string): Promise<NodeJS.ReadableStream>;
    /**
     * Send an ASK query to the given endpoint URL and return a promise resolving to the boolean answer.
     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query    A SPARQL query string.
     * @return {Promise<boolean>} A boolean resolving to the answer.
     */
    fetchAsk(endpoint: string, query: string): Promise<boolean>;
    /**
     * Send a CONSTRUCT/DESCRIBE query to the given endpoint URL and return the resulting triple stream.
     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query    A SPARQL query string.
     * @return {Promise<Stream>} A stream of triples.
     */
    fetchTriples(endpoint: string, query: string): Promise<Readable & RDF.Stream>;
    /**
     * Send an update query to the given endpoint URL using POST.
     *
     * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query        A SPARQL query string.
     */
    fetchUpdate(endpoint: string, query: string): Promise<void>;
    /**
     * Send a query to the given endpoint URL and return the resulting stream.
     *
     * This will only accept responses with the application/sparql-results+json content type.
     *
     * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query        A SPARQL query string.
     * @param {string} acceptHeader The HTTP accept to use.
     * @return {Promise<[string, NodeJS.ReadableStream]>} The media type, version, and SPARQL endpoint response stream.
     */
    fetchRawStream(endpoint: string, query: string, acceptHeader: string): Promise<[string, string | undefined, NodeJS.ReadableStream]>;
    /**
     * Helper function to generalize internal fetch calls.
     *
     * @param {string}      url     The URL to call.
     * @param {RequestInit} init    Options to pass along to the fetch call.
     * @param {any}         options Other specific fetch options.
     * @return {Promise<[string, NodeJS.ReadableStream]>} The media type, version, and SPARQL endpoint response stream.
     */
    private handleFetchCall;
}
export interface ISparqlEndpointFetcherArgs extends ISparqlJsonParserArgs, ISparqlXmlParserArgs {
    /**
     * A custom HTTP method for issuing (non-update) queries, defaults to POST.
     * Update queries are always issued via POST.
     */
    method?: 'POST' | 'GET';
    additionalUrlParams?: URLSearchParams;
    timeout?: number;
    forceGetIfUrlLengthBelow?: number;
    directPost?: boolean;
    defaultHeaders?: Headers;
    /**
     * A custom fetch function.
     */
    fetch?: (input: Request | string, init?: RequestInit) => Promise<Response>;
    /**
     * A SPARQL query parser used by the endpoint fetcher to detect query types.
     */
    sparqlQueryParser?: SparqlParser;
    /**
     * If no error should be emitted on unsupported versions.
     * By default, an error will be emitted.
     */
    parseUnsupportedVersions?: boolean;
}
export interface ISparqlResultsParser {
    parseResultsStream: (sparqlResponseStream: NodeJS.ReadableStream, version: string | undefined) => NodeJS.ReadableStream;
    parseBooleanStream: (sparqlResponseStream: NodeJS.ReadableStream, version: string | undefined) => Promise<boolean>;
}
export type IBindings = Record<string, RDF.Term>;
export type IUpdateTypes = {
    [K in UpdateOperation['subType']]?: boolean;
};
