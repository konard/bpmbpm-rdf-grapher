{"version":3,"file":"SparqlXmlParser.js","sourceRoot":"","sources":["SparqlXmlParser.ts"],"names":[],"mappings":";;;AAAA,uDAA6C;AAE7C,8CAA+C;AAC/C,qDAA0C;AAE1C;;;GAGG;AACH,MAAa,eAAe;IAY1B,YAAY,QAAoB;QAC9B,QAAQ,GAAG,QAAQ,IAAI,EAAE,CAAC;QAC1B,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,WAAW,IAAI,IAAI,8BAAW,EAAE,CAAC;QAC7D,IAAI,CAAC,0BAA0B,GAAG,CAAC,CAAC,QAAQ,CAAC,0BAA0B,CAAC;QACxE,IAAI,CAAC,wBAAwB,GAAG,CAAC,CAAC,QAAQ,CAAC,wBAAwB,CAAC;IACtE,CAAC;IAED;;;OAGG;IACI,cAAc,CAAC,OAAe;QACnC,OAAO,IAAI,CAAC,wBAAwB,IAAI,eAAe,CAAC,kBAAkB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IAC/F,CAAC;IAED;;;;;;;;;OASG;IACI,qBAAqB,CAAC,oBAA2C,EAAE,OAAgB;QACxF,MAAM,aAAa,GAAG,CAAC,KAAY,EAAE,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QAC1E,oBAAoB,CAAC,EAAE,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;QAEhD,MAAM,MAAM,GAAG,IAAI,mBAAW,EAAE,CAAC;QACjC,MAAM,KAAK,GAAa,EAAE,CAAC;QAC3B,IAAI,cAAc,GAAG,KAAK,CAAC;QAC3B,IAAI,YAAY,GAAG,KAAK,CAAC;QACzB,MAAM,SAAS,GAAmB,EAAE,CAAC;QACrC,IAAI,eAAe,GAAc,EAAE,CAAC;QACpC,IAAI,kBAAkB,GAAW,EAAE,CAAC;QACpC,IAAI,kBAAkB,GAAW,EAAE,CAAC;QACpC,IAAI,wBAAqG,CAAC;QAC1G,IAAI,WAAW,GAAW,EAAE,CAAC;QAC7B,IAAI,oBAAoB,GAA6I,EAAE,CAAC;QACxK,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;QAClC,MAAM,CAAC,EAAE,CAAC,SAAS,EAAE,GAAG,CAAC,EAAE;YACzB,IAAG,GAAG,CAAC,IAAI,KAAK,UAAU,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,EAAC,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,EAAE,CAAC;gBACzE,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;YACjE,CAAC;iBAAM,IAAG,GAAG,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC;gBACxE,YAAY,GAAG,IAAI,CAAC;YACtB,CAAC;iBAAM,IAAG,GAAG,CAAC,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC,EAAE,CAAC;gBAClF,eAAe,GAAG,EAAE,CAAC;YACvB,CAAC;iBAAM,IAAG,GAAG,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC,EAAE,CAAC;gBAC7F,kBAAkB,GAAG,GAAG,CAAC,UAAU,CAAC,IAAI,IAAI,EAAE,CAAC;gBAC/C,kBAAkB,GAAG,EAAE,CAAC;gBACxB,wBAAwB,GAAG,SAAS,CAAC;gBACrC,WAAW,GAAG,EAAE,CAAC;gBACjB,oBAAoB,GAAG,EAAE,CAAC;YAC5B,CAAC;iBAAM,IAAG,GAAG,CAAC,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC,EAAE,CAAC;gBAChG,oBAAoB,CAAC,IAAI,CAAC,EAAE,UAAU,EAAE,EAAE,EAAE,CAAC,CAAC;YAChD,CAAC;iBAAM,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,QAAQ,IAAI,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC,EAAE,CAAC;gBAC3H,kBAAkB,GAAG,EAAE,CAAC;gBACxB,wBAAwB,GAAG,SAAS,CAAC;gBACrC,WAAW,GAAG,EAAE,CAAC;gBACjB,IAAI,CAAC,CAAC,SAAS,EAAE,WAAW,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;oBAC3D,aAAa,CAAC,IAAI,KAAK,CAAC,oCAAoC,GAAG,CAAC,IAAI,mBAAmB,MAAM,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC7G,CAAC;qBAAM,CAAC;oBACN,oBAAoB,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,gBAAgB,GAAQ,GAAG,CAAC,IAAI,CAAC;gBACzF,CAAC;YACH,CAAC;iBAAM,IAAG,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC,EAAE,CAAC;gBAClF,kBAAkB,GAAG,GAAG,CAAC,IAAI,CAAC;gBAC9B,IAAG,UAAU,IAAI,GAAG,CAAC,UAAU,EAAE,CAAC;oBAChC,wBAAwB,GAAG;wBACzB,QAAQ,EAAE,GAAG,CAAC,UAAU,CAAC,UAAU,CAAC;wBACpC,SAAS,EAA8B,GAAG,CAAC,UAAU,CAAC,SAAS,CAAC;qBACjE,CAAC;gBACJ,CAAC;qBAAM,IAAG,UAAU,IAAI,GAAG,CAAC,UAAU,EAAE,CAAC;oBACvC,wBAAwB,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;gBACjF,CAAC;qBAAM,CAAC;oBACN,wBAAwB,GAAG,SAAS,CAAC;gBACvC,CAAC;YACH,CAAC;iBAAM,IAAI,GAAG,CAAC,IAAI,KAAK,QAAQ,IAAI,GAAG,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC;gBAC3D,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE,CAAC;oBACjD,YAAY,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,KAAK,CAAC,iCAAiC,GAAG,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;gBACnG,CAAC;gBACD,YAAY,CAAC,IAAI,CAAC,SAAS,EAAE,GAAG,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;YACvD,CAAC;YACD,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACvB,CAAC,CAAC,CAAA;QACF,MAAM,CAAC,EAAE,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE;YAC1B,IAAG,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,EAAE,CAAC;gBAC/C,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;gBAC1C,cAAc,GAAG,IAAI,CAAC;YACxB,CAAC;YACD,IAAG,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC,EAAE,CAAC;gBAC5D,YAAY,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;YACrC,CAAC;YACD,IAAG,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC,EAAE,CAAC;gBAC3E,mCAAmC;gBACnC,IAAI,IAA0B,CAAC;gBAC/B,IAAG,CAAC,kBAAkB,IAAI,kBAAkB,EAAE,CAAC;oBAC7C,aAAa,CAAC,IAAI,KAAK,CAAC,oCAAoC,MAAM,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;gBAClF,CAAC;qBAAM,IAAG,kBAAkB,KAAK,KAAK,EAAE,CAAC;oBACvC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;gBACjD,CAAC;qBAAM,IAAG,kBAAkB,KAAK,OAAO,EAAE,CAAC;oBACzC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;gBACjD,CAAC;qBAAM,IAAI,kBAAkB,KAAK,SAAS,EAAE,CAAC;oBAC5C,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW,EAAE,wBAAwB,CAAC,CAAC;gBACzE,CAAC;qBAAM,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,QAAQ,EAAE,CAAC;oBAChD,MAAM,mBAAmB,GAAG,oBAAoB,CAAC,GAAG,EAAE,CAAC;oBACvD,IAAI,mBAAmB,IAAI,mBAAmB,CAAC,UAAU,CAAC,OAAO,IAAI,mBAAmB,CAAC,UAAU,CAAC,SAAS,IAAI,mBAAmB,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;wBACvJ,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CACP,mBAAmB,CAAC,UAAU,CAAC,OAAO,EACpC,mBAAmB,CAAC,UAAU,CAAC,SAAS,EAC3C,mBAAmB,CAAC,UAAU,CAAC,MAAM,CACxD,CAAC;oBACJ,CAAC;yBAAM,CAAC;wBACN,aAAa,CAAC,IAAI,KAAK,CAAC,oCAAoC,MAAM,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;oBAClF,CAAC;gBACH,CAAC;qBAAM,IAAG,kBAAkB,EAAE,CAAC;oBAC7B,aAAa,CAAC,IAAI,KAAK,CAAC,sBAAsB,kBAAkB,aAAa,MAAM,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;gBACnG,CAAC;gBAED,IAAI,IAAI,EAAE,CAAC;oBACT,IAAI,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;wBACpC,8EAA8E;wBAC9E,MAAM,mBAAmB,GAAG,oBAAoB,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;wBAClF,IAAI,mBAAmB,CAAC,UAAU,CAAC,mBAAmB,CAAC,gBAAgB,CAAC,EAAE,CAAC;4BACzE,aAAa,CAAC,IAAI,KAAK,CAAC,OAAO,mBAAmB,CAAC,gBAAgB,+BAA+B,MAAM,CAAC,IAAI,GAAG,CAAC,6BAA6B,CAAC,CAAC,CAAC;wBACnJ,CAAC;wBACD,mBAAmB,CAAC,UAAU,CAAC,mBAAmB,CAAC,gBAAgB,CAAC,GAAG,IAAI,CAAC;oBAC9E,CAAC;yBAAM,CAAC;wBACN,iDAAiD;wBACjD,MAAM,GAAG,GAAG,IAAI,CAAC,0BAA0B,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,kBAAkB,CAAC,CAAC,CAAC,CAAC,kBAAkB,CAAC;wBAC9F,eAAe,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;oBAC9B,CAAC;gBACH,CAAC;gBAED,kBAAkB,GAAG,SAAS,CAAC;YACjC,CAAC;YACD,KAAK,CAAC,GAAG,EAAE,CAAC;QACd,CAAC,CAAC,CAAA;QACF,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE;YACvB,IAAG,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,kBAAkB,EAAE,CAAC;gBAC7H,WAAW,GAAG,IAAI,CAAC;YACrB,CAAC;QACH,CAAC,CAAC,CAAA;QAEF,MAAM,YAAY,GAAG,oBAAoB;aACpC,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE;YACb,IAAI,CAAC,YAAY,EAAE,CAAC;gBAClB,YAAY,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC,CAAA;YACpF,CAAC;iBAAM,IAAI,CAAC,cAAc,EAAE,CAAC;gBAC3B,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;YACrC,CAAC;QACH,CAAC,CAAC;aACD,IAAI,CAAC,IAAI,2BAAS,CAAC;YAClB,UAAU,EAAE,IAAI;YAChB,SAAS,CAAC,KAAU,EAAE,QAAgB,EAAE,QAAoD;gBAC1F,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBACpB,QAAQ,EAAE,CAAC;YACb,CAAC;SACF,CAAC,CAAC,CAAC;QAER,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE,CAAC;YAC7C,YAAY,CAAC,OAAO,CAAC,IAAI,KAAK,CAAC,yDAAyD,OAAO,EAAE,CAAC,CAAC,CAAC;QACtG,CAAC;QAED,OAAO,YAAY,CAAC;IACtB,CAAC;IAED;;;;;;OAMG;IACI,qBAAqB,CAAC,oBAA2C,EAAE,OAAgB;QACxF,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE,CAAC;YAC7C,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,yDAAyD,OAAO,EAAE,CAAC,CAAC,CAAC;QACvG,CAAC;QACD,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,MAAM,MAAM,GAAG,IAAI,mBAAW,EAAE,CAAC;YACjC,MAAM,KAAK,GAAa,EAAE,CAAC;YAC3B,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;YAC3B,MAAM,CAAC,EAAE,CAAC,SAAS,EAAE,GAAG,CAAC,EAAE;gBACzB,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACvB,CAAC,CAAC,CAAA;YACF,MAAM,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC,CAAC,EAAE;gBACxB,KAAK,CAAC,GAAG,EAAE,CAAC;YACd,CAAC,CAAC,CAAA;YACF,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE;gBACvB,IAAG,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC,EAAE,CAAC;oBAClD,OAAO,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC;gBAC3B,CAAC;YACH,CAAC,CAAC,CAAA;YACF,oBAAoB;iBACf,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC;iBACnB,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;iBAChC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC,CAAC,CAAC;QAC9E,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,WAAW,CAAC,CAAW,EAAE,CAAW;QAC1C,OAAO,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;IAChE,CAAC;IAEO,eAAe,CAAC,CAAW,EAAE,CAAW;QAC9C,OAAO,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;IAC/D,CAAC;;AA1NH,0CA2NC;AAzNe,kCAAkB,GAAa;IAC3C,KAAK;IACL,WAAW;IACX,KAAK;CACN,CAAC","sourcesContent":["import {DataFactory} from \"rdf-data-factory\";\nimport * as RDF from \"@rdfjs/types\";\nimport {SaxesParser} from \"@rubensworks/saxes\";\nimport {Transform} from \"readable-stream\";\n\n/**\n * Parser for the SPARQL Query Results XML format.\n * @see https://www.w3.org/TR/rdf-sparql-XMLres/\n */\nexport class SparqlXmlParser {\n\n  public static SUPPORTED_VERSIONS: string[] = [\n    '1.2',\n    '1.2-basic',\n    '1.1',\n  ];\n\n  private readonly dataFactory: RDF.DataFactory;\n  private readonly prefixVariableQuestionMark?: boolean;\n  private readonly parseUnsupportedVersions: boolean;\n\n  constructor(settings?: ISettings) {\n    settings = settings || {};\n    this.dataFactory = settings.dataFactory || new DataFactory();\n    this.prefixVariableQuestionMark = !!settings.prefixVariableQuestionMark;\n    this.parseUnsupportedVersions = !!settings.parseUnsupportedVersions;\n  }\n\n  /**\n   * If the given version is valid for this parser to handle.\n   * @param version A version string.\n   */\n  public isValidVersion(version: string): boolean {\n    return this.parseUnsupportedVersions || SparqlXmlParser.SUPPORTED_VERSIONS.includes(version);\n  }\n\n  /**\n   * Convert a SPARQL XML bindings response stream to a stream of bindings objects.\n   *\n   * The bindings stream will emit a 'variables' event that will contain\n   * the array of variables (as RDF.Variable[]), as defined in the response head.\n   *\n   * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL XML response stream.\n   * @param version The version that was supplied as a media type parameter\n   * @return {NodeJS.ReadableStream} A stream of bindings.\n   */\n  public parseXmlResultsStream(sparqlResponseStream: NodeJS.ReadableStream, version?: string): NodeJS.ReadableStream {\n    const errorListener = (error: Error) => resultStream.emit('error', error);\n    sparqlResponseStream.on('error', errorListener);\n\n    const parser = new SaxesParser();\n    const stack: string[] = [];\n    let variablesFound = false;\n    let resultsFound = false;\n    const variables: RDF.Variable[] = [];\n    let currentBindings: IBindings = {};\n    let currentBindingName: string = '';\n    let currentBindingType: string = '';\n    let currentBindingAnnotation: { language: string, direction?: 'ltr' | 'rtl' } | RDF.NamedNode | undefined;\n    let currentText: string = '';\n    let currentQuotedTriples: { currentComponent?: 'subject' | 'predicate' | 'object'; components: { subject?: RDF.Term; predicate?: RDF.Term; object?: RDF.Term } }[] = [];\n    parser.on(\"error\", errorListener);\n    parser.on(\"opentag\", tag => {\n      if(tag.name === \"variable\" && this.stackEquals(stack,['sparql', 'head'])) {\n        variables.push(this.dataFactory.variable(tag.attributes.name));\n      } else if(tag.name === \"results\" && this.stackEquals(stack, ['sparql'])) {\n        resultsFound = true;\n      } else if(tag.name === 'result' && this.stackEquals(stack, ['sparql', 'results'])) {\n        currentBindings = {};\n      } else if(tag.name === 'binding' && this.stackEquals(stack, ['sparql', 'results', 'result'])) {\n        currentBindingName = tag.attributes.name || '';\n        currentBindingType = '';\n        currentBindingAnnotation = undefined;\n        currentText = '';\n        currentQuotedTriples = [];\n      } else if(tag.name === 'triple' && this.stackBeginsWith(stack, ['sparql', 'results', 'result'])) {\n        currentQuotedTriples.push({ components: {} });\n      } else if (stack[stack.length - 1] === 'triple' && this.stackBeginsWith(stack, ['sparql', 'results', 'result', 'binding'])) {\n        currentBindingType = '';\n        currentBindingAnnotation = undefined;\n        currentText = '';\n        if (!['subject', 'predicate', 'object'].includes(tag.name)) {\n          errorListener(new Error(`Illegal quoted triple component '${tag.name}' found on line ${parser.line + 1}`));\n        } else {\n          currentQuotedTriples[currentQuotedTriples.length - 1].currentComponent = <any>tag.name;\n        }\n      } else if(this.stackBeginsWith(stack, ['sparql', 'results', 'result', 'binding'])) {\n        currentBindingType = tag.name;\n        if('xml:lang' in tag.attributes) {\n          currentBindingAnnotation = {\n            language: tag.attributes['xml:lang'],\n            direction: <'ltr' | 'rtl' | undefined> tag.attributes['its:dir'],\n          };\n        } else if('datatype' in tag.attributes) {\n          currentBindingAnnotation = this.dataFactory.namedNode(tag.attributes.datatype);\n        } else {\n          currentBindingAnnotation = undefined;\n        }\n      } else if (tag.name === 'sparql' && tag.attributes.version) {\n        if (!this.isValidVersion(tag.attributes.version)) {\n          resultStream.emit(\"error\", new Error(`Detected unsupported version: ${tag.attributes.version}`));\n        }\n        resultStream.emit('version', tag.attributes.version);\n      }\n      stack.push(tag.name);\n    })\n    parser.on(\"closetag\", tag => {\n      if(this.stackEquals(stack, ['sparql', 'head'])) {\n        resultStream.emit(\"variables\", variables);\n        variablesFound = true;\n      }\n      if(this.stackEquals(stack, ['sparql', 'results', 'result'])) {\n        resultStream.push(currentBindings);\n      }\n      if(this.stackBeginsWith(stack, ['sparql', 'results', 'result', 'binding'])) {\n        // Determine current RDF term value\n        let term: RDF.Term | undefined;\n        if(!currentBindingName && currentBindingType) {\n          errorListener(new Error(`Terms should have a name on line ${parser.line + 1}`));\n        } else if(currentBindingType === 'uri') {\n          term = this.dataFactory.namedNode(currentText);\n        } else if(currentBindingType === 'bnode') {\n          term = this.dataFactory.blankNode(currentText);\n        } else if (currentBindingType === 'literal') {\n          term = this.dataFactory.literal(currentText, currentBindingAnnotation);\n        } else if (stack[stack.length - 1] === 'triple') {\n          const currentQuotedTriple = currentQuotedTriples.pop();\n          if (currentQuotedTriple && currentQuotedTriple.components.subject && currentQuotedTriple.components.predicate && currentQuotedTriple.components.object) {\n            term = this.dataFactory.quad(\n              <RDF.Quad_Subject> currentQuotedTriple.components.subject,\n              <RDF.Quad_Predicate> currentQuotedTriple.components.predicate,\n              <RDF.Quad_Object> currentQuotedTriple.components.object,\n            );\n          } else {\n            errorListener(new Error(`Incomplete quoted triple on line ${parser.line + 1}`));\n          }\n        } else if(currentBindingType) {\n          errorListener(new Error(`Invalid term type '${currentBindingType}' on line ${parser.line + 1}`));\n        }\n\n        if (term) {\n          if (currentQuotedTriples.length > 0) {\n            // If we're in a quoted triple, store the term inside the active quoted triple\n            const currentQuotedTriple = currentQuotedTriples[currentQuotedTriples.length - 1];\n            if (currentQuotedTriple.components[currentQuotedTriple.currentComponent]) {\n              errorListener(new Error(`The ${currentQuotedTriple.currentComponent} in a quoted triple on line ${parser.line + 1} was already defined before`));\n            }\n            currentQuotedTriple.components[currentQuotedTriple.currentComponent] = term;\n          } else {\n            // Store the value in the current bindings object\n            const key = this.prefixVariableQuestionMark ? ('?' + currentBindingName) : currentBindingName;\n            currentBindings[key] = term;\n          }\n        }\n\n        currentBindingType = undefined;\n      }\n      stack.pop();\n    })\n    parser.on(\"text\", text => {\n      if(this.stackBeginsWith(stack, ['sparql', 'results', 'result', 'binding']) && stack[stack.length - 1] === currentBindingType) {\n        currentText = text;\n      }\n    })\n\n    const resultStream = sparqlResponseStream\n        .on(\"end\", _ => {\n          if (!resultsFound) {\n            resultStream.emit(\"error\", new Error(\"No valid SPARQL query results were found.\"))\n          } else if (!variablesFound) {\n            resultStream.emit('variables', []);\n          }\n        })\n        .pipe(new Transform({\n          objectMode: true,\n          transform(chunk: any, encoding: string, callback: (error?: Error | null, data?: any) => void) {\n            parser.write(chunk);\n            callback();\n          }\n        }));\n\n    if (version && !this.isValidVersion(version)) {\n      resultStream.destroy(new Error(`Detected unsupported version as media type parameter: ${version}`));\n    }\n\n    return resultStream;\n  }\n\n  /**\n   * Convert a SPARQL XML boolean response stream to a promise resolving to a boolean.\n   * This will reject if the given response was not a valid boolean response.\n   * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL XML response stream.\n   * @param version The version that was supplied as a media type parameter\n   * @return {Promise<boolean>} The response boolean.\n   */\n  public parseXmlBooleanStream(sparqlResponseStream: NodeJS.ReadableStream, version?: string): Promise<boolean> {\n    if (version && !this.isValidVersion(version)) {\n      return Promise.reject(new Error(`Detected unsupported version as media type parameter: ${version}`));\n    }\n    return new Promise((resolve, reject) => {\n      const parser = new SaxesParser();\n      const stack: string[] = [];\n      parser.on(\"error\", reject);\n      parser.on(\"opentag\", tag => {\n        stack.push(tag.name);\n      })\n      parser.on(\"closetag\", _ => {\n        stack.pop();\n      })\n      parser.on(\"text\", text => {\n        if(this.stackEquals(stack, ['sparql', 'boolean'])) {\n          resolve(text === 'true');\n        }\n      })\n      sparqlResponseStream\n          .on('error', reject)\n          .on('data', d => parser.write(d))\n          .on('end', () => reject(new Error('No valid ASK response was found.')));\n    });\n  }\n\n  private stackEquals(a: string[], b: string[]) {\n    return a.length === b.length && a.every((v, i) => b[i] === v);\n  }\n\n  private stackBeginsWith(a: string[], b: string[]) {\n    return a.length >= b.length && b.every((v, i) => a[i] === v);\n  }\n}\n\n/**\n * Constructor settings object interface for {@link SparqlXmlParser}.\n */\nexport interface ISettings {\n  /**\n   * A custom datafactory.\n   */\n  dataFactory?: RDF.DataFactory;\n  /**\n   * If variable names should be prefixed with a quotation mark.\n   */\n  prefixVariableQuestionMark?: boolean;\n  /**\n   * If no error should be emitted on unsupported versions.\n   */\n  parseUnsupportedVersions?: boolean;\n}\n\n/**\n * A bindings object.\n */\nexport interface IBindings {\n  [key: string]: RDF.Term;\n}\n"]}