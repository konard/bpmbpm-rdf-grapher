{"version":3,"file":"ActorOptimizeQueryOperationQuerySourceIdentify.js","sourceRoot":"","sources":["ActorOptimizeQueryOperationQuerySourceIdentify.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MediatorContextPreprocess } from '@comunica/bus-context-preprocess';\nimport type { ActorHttpInvalidateListenable, IActionHttpInvalidate } from '@comunica/bus-http-invalidate';\nimport type {\n  IActionOptimizeQueryOperation,\n  IActorOptimizeQueryOperationOutput,\n  IActorOptimizeQueryOperationArgs,\n} from '@comunica/bus-optimize-query-operation';\nimport { ActorOptimizeQueryOperation } from '@comunica/bus-optimize-query-operation';\nimport type { MediatorQuerySourceIdentify } from '@comunica/bus-query-source-identify';\nimport { KeysInitQuery, KeysQueryOperation, KeysStatistics } from '@comunica/context-entries';\nimport type { TestResult, IActorTest } from '@comunica/core';\nimport { passTestVoid, ActionContext } from '@comunica/core';\nimport type {\n  IActionContext,\n  ILink,\n  IQuerySourceUnidentifiedExpanded,\n  IQuerySourceWrapper,\n  IStatisticBase,\n  QuerySourceUnidentified,\n  QuerySourceUnidentifiedExpanded,\n} from '@comunica/types';\nimport { Algebra, algebraUtils } from '@comunica/utils-algebra';\nimport { passFullOperationToSource } from '@comunica/utils-query-operation';\nimport { LRUCache } from 'lru-cache';\n\n/**\n * A comunica Query Source Identify Optimize Query Operation Actor.\n */\nexport class ActorOptimizeQueryOperationQuerySourceIdentify extends ActorOptimizeQueryOperation {\n  public readonly serviceForceSparqlEndpoint: boolean;\n  public readonly cacheSize: number;\n  public readonly httpInvalidator: ActorHttpInvalidateListenable;\n  public readonly mediatorQuerySourceIdentify: MediatorQuerySourceIdentify;\n  public readonly mediatorContextPreprocess: MediatorContextPreprocess;\n  public readonly cache?: LRUCache<string, Promise<IQuerySourceWrapper>>;\n\n  public constructor(args: IActorOptimizeQueryOperationQuerySourceIdentifyArgs) {\n    super(args);\n    this.serviceForceSparqlEndpoint = args.serviceForceSparqlEndpoint;\n    this.cacheSize = args.cacheSize;\n    this.httpInvalidator = args.httpInvalidator;\n    this.mediatorQuerySourceIdentify = args.mediatorQuerySourceIdentify;\n    this.mediatorContextPreprocess = args.mediatorContextPreprocess;\n    this.cache = this.cacheSize ? new LRUCache<string, any>({ max: this.cacheSize }) : undefined;\n    const cache = this.cache;\n    if (cache) {\n      this.httpInvalidator.addInvalidateListener(\n        ({ url }: IActionHttpInvalidate) => url ? cache.delete(url) : cache.clear(),\n      );\n    }\n  }\n\n  public async test(_action: IActionOptimizeQueryOperation): Promise<TestResult<IActorTest>> {\n    return passTestVoid();\n  }\n\n  public async run(action: IActionOptimizeQueryOperation): Promise<IActorOptimizeQueryOperationOutput> {\n    let context = action.context;\n\n    // Rewrite sources\n    let querySources: IQuerySourceWrapper[] | undefined;\n    if (context.has(KeysInitQuery.querySourcesUnidentified)) {\n      const querySourcesUnidentified: QuerySourceUnidentified[] = action.context\n        .get(KeysInitQuery.querySourcesUnidentified)!;\n      const querySourcesUnidentifiedExpanded = await Promise.all(querySourcesUnidentified\n        .map(querySource => this.expandSource(querySource)));\n      querySources = await Promise.all(querySourcesUnidentifiedExpanded\n        .map(async querySourceUnidentified => this.identifySource(querySourceUnidentified, action.context)));\n\n      // When identifying sources in preprocess actor, we record this as a dereference seed document event\n      const statisticDereferenceLinks: IStatisticBase<ILink> | undefined = action.context\n        .get(KeysStatistics.dereferencedLinks);\n      if (statisticDereferenceLinks) {\n        for (const querySource of querySources) {\n          statisticDereferenceLinks.updateStatistic({\n            url: <string> querySource.source.referenceValue,\n            metadata: {\n              seed: true,\n            },\n          }, querySource.source);\n        }\n      }\n\n      context = context\n        .delete(KeysInitQuery.querySourcesUnidentified)\n        .set(KeysQueryOperation.querySources, querySources);\n    }\n\n    // Identify sources of SERVICE targets, unless the whole query is passed to the source (e.g. for SPARQL endpoints)\n    if (!await passFullOperationToSource(action.operation, querySources ?? [], context)) {\n      const services: Set<string> = new Set();\n      algebraUtils.visitOperation(action.operation, {\n        [Algebra.Types.SERVICE]: {\n          preVisitor: () => ({ continue: false }),\n          visitor: (serviceOperation) => {\n            if (serviceOperation.name.termType === 'NamedNode') {\n              services.add(serviceOperation.name.value);\n            }\n          },\n        },\n      });\n      const serviceSources: Record<string, IQuerySourceWrapper> = Object.fromEntries(await Promise.all([ ...services ]\n        .map(async service => [ service, await this.identifySource({\n          type: this.serviceForceSparqlEndpoint ? 'sparql' : undefined,\n          value: service,\n        }, context) ])));\n      if (services.size > 0) {\n        context = context.set(KeysQueryOperation.serviceSources, serviceSources);\n      }\n    }\n\n    return { context, operation: action.operation };\n  }\n\n  public async expandSource(querySource: QuerySourceUnidentified): Promise<QuerySourceUnidentifiedExpanded> {\n    if (typeof querySource === 'string' || 'match' in querySource) {\n      return { value: querySource };\n    }\n    return {\n      ...<Omit<IQuerySourceUnidentifiedExpanded, 'context'>>querySource,\n      context: (await this.mediatorContextPreprocess.mediate({\n        context: ActionContext.ensureActionContext(querySource.context ?? {}),\n      })).context,\n    };\n  }\n\n  public identifySource(\n    querySourceUnidentified: QuerySourceUnidentifiedExpanded,\n    context: IActionContext,\n  ): Promise<IQuerySourceWrapper> {\n    let sourcePromise: Promise<IQuerySourceWrapper> | undefined;\n\n    // Try to read from cache\n    // Only sources based on string values (e.g. URLs) are supported!\n    if (typeof querySourceUnidentified.value === 'string' && this.cache) {\n      sourcePromise = this.cache.get(querySourceUnidentified.value)!;\n    }\n\n    // If not in cache, identify the source\n    if (!sourcePromise) {\n      sourcePromise = this.mediatorQuerySourceIdentify.mediate({ querySourceUnidentified, context })\n        .then(({ querySource }) => querySource);\n\n      // Set in cache\n      if (typeof querySourceUnidentified.value === 'string' && this.cache) {\n        this.cache.set(querySourceUnidentified.value, sourcePromise);\n      }\n    }\n\n    return sourcePromise;\n  }\n}\n\nexport interface IActorOptimizeQueryOperationQuerySourceIdentifyArgs extends IActorOptimizeQueryOperationArgs {\n  /**\n   * If the SERVICE target should be assumed to be a SPARQL endpoint.\n   * @default {false}\n   */\n  serviceForceSparqlEndpoint: boolean;\n  /**\n   * The maximum number of entries in the LRU cache, set to 0 to disable.\n   * @range {integer}\n   * @default {100}\n   */\n  cacheSize: number;\n  /* eslint-disable max-len */\n  /**\n   * An actor that listens to HTTP invalidation events\n   * @default {<default_invalidator> a <npmd:@comunica/bus-http-invalidate/^5.0.0/components/ActorHttpInvalidateListenable.jsonld#ActorHttpInvalidateListenable>}\n   */\n  httpInvalidator: ActorHttpInvalidateListenable;\n  /* eslint-enable max-len */\n  /**\n   * Mediator for identifying query sources.\n   */\n  mediatorQuerySourceIdentify: MediatorQuerySourceIdentify;\n  /**\n   * The context processing combinator\n   */\n  mediatorContextPreprocess: MediatorContextPreprocess;\n}\n"]}