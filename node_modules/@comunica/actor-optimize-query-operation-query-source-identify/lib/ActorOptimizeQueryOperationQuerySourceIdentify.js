"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorOptimizeQueryOperationQuerySourceIdentify = void 0;
const bus_optimize_query_operation_1 = require("@comunica/bus-optimize-query-operation");
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const utils_algebra_1 = require("@comunica/utils-algebra");
const utils_query_operation_1 = require("@comunica/utils-query-operation");
const lru_cache_1 = require("lru-cache");
/**
 * A comunica Query Source Identify Optimize Query Operation Actor.
 */
class ActorOptimizeQueryOperationQuerySourceIdentify extends bus_optimize_query_operation_1.ActorOptimizeQueryOperation {
    serviceForceSparqlEndpoint;
    cacheSize;
    httpInvalidator;
    mediatorQuerySourceIdentify;
    mediatorContextPreprocess;
    cache;
    constructor(args) {
        super(args);
        this.serviceForceSparqlEndpoint = args.serviceForceSparqlEndpoint;
        this.cacheSize = args.cacheSize;
        this.httpInvalidator = args.httpInvalidator;
        this.mediatorQuerySourceIdentify = args.mediatorQuerySourceIdentify;
        this.mediatorContextPreprocess = args.mediatorContextPreprocess;
        this.cache = this.cacheSize ? new lru_cache_1.LRUCache({ max: this.cacheSize }) : undefined;
        const cache = this.cache;
        if (cache) {
            this.httpInvalidator.addInvalidateListener(({ url }) => url ? cache.delete(url) : cache.clear());
        }
    }
    async test(_action) {
        return (0, core_1.passTestVoid)();
    }
    async run(action) {
        let context = action.context;
        // Rewrite sources
        let querySources;
        if (context.has(context_entries_1.KeysInitQuery.querySourcesUnidentified)) {
            const querySourcesUnidentified = action.context
                .get(context_entries_1.KeysInitQuery.querySourcesUnidentified);
            const querySourcesUnidentifiedExpanded = await Promise.all(querySourcesUnidentified
                .map(querySource => this.expandSource(querySource)));
            querySources = await Promise.all(querySourcesUnidentifiedExpanded
                .map(async (querySourceUnidentified) => this.identifySource(querySourceUnidentified, action.context)));
            // When identifying sources in preprocess actor, we record this as a dereference seed document event
            const statisticDereferenceLinks = action.context
                .get(context_entries_1.KeysStatistics.dereferencedLinks);
            if (statisticDereferenceLinks) {
                for (const querySource of querySources) {
                    statisticDereferenceLinks.updateStatistic({
                        url: querySource.source.referenceValue,
                        metadata: {
                            seed: true,
                        },
                    }, querySource.source);
                }
            }
            context = context
                .delete(context_entries_1.KeysInitQuery.querySourcesUnidentified)
                .set(context_entries_1.KeysQueryOperation.querySources, querySources);
        }
        // Identify sources of SERVICE targets, unless the whole query is passed to the source (e.g. for SPARQL endpoints)
        if (!await (0, utils_query_operation_1.passFullOperationToSource)(action.operation, querySources ?? [], context)) {
            const services = new Set();
            utils_algebra_1.algebraUtils.visitOperation(action.operation, {
                [utils_algebra_1.Algebra.Types.SERVICE]: {
                    preVisitor: () => ({ continue: false }),
                    visitor: (serviceOperation) => {
                        if (serviceOperation.name.termType === 'NamedNode') {
                            services.add(serviceOperation.name.value);
                        }
                    },
                },
            });
            const serviceSources = Object.fromEntries(await Promise.all([...services]
                .map(async (service) => [service, await this.identifySource({
                    type: this.serviceForceSparqlEndpoint ? 'sparql' : undefined,
                    value: service,
                }, context)])));
            if (services.size > 0) {
                context = context.set(context_entries_1.KeysQueryOperation.serviceSources, serviceSources);
            }
        }
        return { context, operation: action.operation };
    }
    async expandSource(querySource) {
        if (typeof querySource === 'string' || 'match' in querySource) {
            return { value: querySource };
        }
        return {
            ...querySource,
            context: (await this.mediatorContextPreprocess.mediate({
                context: core_1.ActionContext.ensureActionContext(querySource.context ?? {}),
            })).context,
        };
    }
    identifySource(querySourceUnidentified, context) {
        let sourcePromise;
        // Try to read from cache
        // Only sources based on string values (e.g. URLs) are supported!
        if (typeof querySourceUnidentified.value === 'string' && this.cache) {
            sourcePromise = this.cache.get(querySourceUnidentified.value);
        }
        // If not in cache, identify the source
        if (!sourcePromise) {
            sourcePromise = this.mediatorQuerySourceIdentify.mediate({ querySourceUnidentified, context })
                .then(({ querySource }) => querySource);
            // Set in cache
            if (typeof querySourceUnidentified.value === 'string' && this.cache) {
                this.cache.set(querySourceUnidentified.value, sourcePromise);
            }
        }
        return sourcePromise;
    }
}
exports.ActorOptimizeQueryOperationQuerySourceIdentify = ActorOptimizeQueryOperationQuerySourceIdentify;
//# sourceMappingURL=ActorOptimizeQueryOperationQuerySourceIdentify.js.map