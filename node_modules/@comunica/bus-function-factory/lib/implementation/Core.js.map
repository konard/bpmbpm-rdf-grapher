{"version":3,"file":"Core.js","sourceRoot":"","sources":["Core.ts"],"names":[],"mappings":";;;AAAA,+DAAmF;AAMnF,qFAC8C;AAa9C,MAAa,sBAAsB;IACd,KAAK,CAAoB;IAC5B,QAAQ,CAAkB;IAC1B,KAAK,CAAyD;IAE9E,YAAmB,EAAE,KAAK,EAAE,QAAQ,EAAE,KAAK,EAA8B;QACvE,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACrB,CAAC;IAEM,UAAU,CAAC,IAAkB;QAClC,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;YAC9B,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC1C,CAAC;QACD,IAAI,IAAI,CAAC,KAAK,KAAK,MAAM,CAAC,iBAAiB,EAAE,CAAC;YAC5C,kEAAkE;YAClE,OAAO,IAAI,CAAC;QACd,CAAC;QAED,OAAO,IAAI,CAAC,MAAM,KAAK,IAAI,CAAC,KAAK,CAAC;IACpC,CAAC;CACF;AAtBD,wDAsBC;AAQD;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAa,gBAAiB,SAAQ,sBAAsB;IAC1C,uBAAuB,GAAG,IAAI,CAAC;IAC5B,SAAS,CAAe;IAE3C,YAAmB,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,EAA0B;QACvE,KAAK,CAAC;YACJ,KAAK;YACL,QAAQ;YACR,KAAK,EAAE,KAAK,EAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAgB,EAA2B,EAAE,CAAC,IAAI,CAAC,YAAY,CACnG,MAAM,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,QAAQ,CAAC,6BAA6B,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC,CAAC,EACxF,QAAQ,CACT;SACF,CAAC,CAAC;QAEH,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC7B,CAAC;IAEM,YAAY,CAAC,IAAsB,EAAE,QAA4B;QACtE,MAAM,gBAAgB,GACpB,IAAI,CAAC,SAAS,CAAC,MAAM,CACnB,IAAI,EACJ,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,yCAAuB,CAAC,iBAAiB,CAAC,EACnE,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,+BAAa,CAAC,sBAAsB,CAAC,CAC/D,IAAI,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;QACrC,OAAO,gBAAgB,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,CAAC;IAC1C,CAAC;IAES,kBAAkB,CAAC,IAAsB;QACjD,MAAM,IAAI,iDAAoB,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;IACtD,CAAC;CACF;AA9BD,4CA8BC","sourcesContent":["import { KeysExpressionEvaluator, KeysInitQuery } from '@comunica/context-entries';\nimport type { Expression, IEvalContext, IInternalEvaluator, TermExpression } from '@comunica/types';\nimport type {\n  GeneralOperator,\n  OverloadTree,\n} from '@comunica/utils-expression-evaluator';\nimport { InvalidArgumentTypes,\n} from '@comunica/utils-expression-evaluator';\nimport type { IExpressionFunction, ITermFunction } from '../ActorFunctionFactory';\n\n// ----------------------------------------------------------------------------\n// Overloaded Functions\n// ----------------------------------------------------------------------------\n\ninterface BaseFunctionDefinitionArgs {\n  arity: number | number[];\n  operator: GeneralOperator;\n  apply: (evalContext: IEvalContext) => Promise<TermExpression>;\n}\n\nexport class ExpressionFunctionBase implements IExpressionFunction {\n  protected readonly arity: number | number[];\n  public readonly operator: GeneralOperator;\n  public readonly apply: (evalContext: IEvalContext) => Promise<TermExpression>;\n\n  public constructor({ arity, operator, apply }: BaseFunctionDefinitionArgs) {\n    this.arity = arity;\n    this.operator = operator;\n    this.apply = apply;\n  }\n\n  public checkArity(args: Expression[]): boolean {\n    if (Array.isArray(this.arity)) {\n      return this.arity.includes(args.length);\n    }\n    if (this.arity === Number.POSITIVE_INFINITY) {\n      // Infinity is used to represent var-args, so it's always correct.\n      return true;\n    }\n\n    return args.length === this.arity;\n  }\n}\n\ninterface TermSparqlFunctionArgs {\n  arity: number | number[];\n  operator: GeneralOperator;\n  overloads: OverloadTree;\n}\n\n/**\n * Varying kinds of functions take arguments of different types on which the\n * specific behaviour is dependant. Although their behaviour is often varying,\n * it is always relatively simple, and better suited for synced behaviour.\n * The types of their arguments are always terms, but might differ in\n * their term-type (eg: iri, literal),\n * their specific literal type (eg: string, integer),\n * their arity (see BNODE),\n * or even their specific numeric type (eg: integer, float).\n *\n * Examples include:\n *  - Arithmetic operations such as: *, -, /, +\n *  - Bool operators such as: =, !=, <=, <, ...\n *  - Functions such as: str, IRI\n *\n * See also: https://www.w3.org/TR/definitionTypesparql11-query/#func-rdfTerms\n * and https://www.w3.org/TR/sparql11-query/#OperatorMapping\n */\nexport class TermFunctionBase extends ExpressionFunctionBase implements ITermFunction {\n  public readonly supportsTermExpressions = true;\n  protected readonly overloads: OverloadTree;\n\n  public constructor({ arity, operator, overloads }: TermSparqlFunctionArgs) {\n    super({\n      arity,\n      operator,\n      apply: async({ args, exprEval, mapping }: IEvalContext): Promise<TermExpression> => this.applyOnTerms(\n        await Promise.all(args.map(arg => exprEval.evaluatorExpressionEvaluation(arg, mapping))),\n        exprEval,\n      ),\n    });\n\n    this.overloads = overloads;\n  }\n\n  public applyOnTerms(args: TermExpression[], exprEval: IInternalEvaluator): TermExpression {\n    const concreteFunction =\n      this.overloads.search(\n        args,\n        exprEval.context.getSafe(KeysExpressionEvaluator.superTypeProvider),\n        exprEval.context.getSafe(KeysInitQuery.functionArgumentsCache),\n      ) ?? this.handleInvalidTypes(args);\n    return concreteFunction(exprEval)(args);\n  }\n\n  protected handleInvalidTypes(args: TermExpression[]): never {\n    throw new InvalidArgumentTypes(args, this.operator);\n  }\n}\n"]}