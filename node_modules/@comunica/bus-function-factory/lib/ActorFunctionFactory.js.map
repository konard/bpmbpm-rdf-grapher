{"version":3,"file":"ActorFunctionFactory.js","sourceRoot":"","sources":["ActorFunctionFactory.ts"],"names":[],"mappings":";;;AACA,yCAAiD;AAIjD;;;;;;;;;;;GAWG;AACH,MAAsB,oBAAqC,SACzD,YAA0E;IAC1E,4BAA4B;IAC5B;;;;OAIG;IACH,2BAA2B;IAC3B,YAAmB,IAAmC;QACpD,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;CAIF;AAfD,oDAeC;AA2CD,MAAsB,uBAAwB,SAAQ,eAKrD;CAGA;AARD,0DAQC","sourcesContent":["import type { IAction, IActorArgs, IActorOutput, IActorTest, Mediate } from '@comunica/core';\nimport { Actor, Mediator } from '@comunica/core';\nimport type { Expression, IEvalContext, IInternalEvaluator, TermExpression } from '@comunica/types';\nimport type { Algebra as Alg } from '@comunica/utils-algebra';\n\n/**\n * A comunica actor for function factory events.\n *\n * Actor types:\n * * Input:  IActionFunctions: A request to receive a function implementation for a given function name\n * and potentially the function arguments.\n * * Test:   <none>\n * * Output: IActorFunctionsOutput: A function implementation.\n *\n * @see IActionFunctionFactory\n * @see IActorFunctionFactoryOutput\n */\nexport abstract class ActorFunctionFactory<TS = undefined> extends\n  Actor<IActionFunctionFactory, IActorTest, IActorFunctionFactoryOutput, TS> {\n  /* eslint-disable max-len */\n  /**\n   * @param args -\n   * \\ @defaultNested {<default_bus> a <cbff:components/BusFunctionFactory.jsonld#BusFunctionFactory>} bus\n   * \\ @defaultNested {Creation of function evaluator failed: no configured actor was able to evaluate function ${action.functionName}} busFailMessage\n   */\n  /* eslint-enable max-len */\n  public constructor(args: IActorFunctionFactoryArgs<TS>) {\n    super(args);\n  }\n\n  public abstract override run<T extends IActionFunctionFactory>(action: T):\n  Promise<T extends { requireTermExpression: true } ? IActorFunctionFactoryOutputTerm : IActorFunctionFactoryOutput>;\n}\n\nexport interface IExpressionFunction {\n  apply: (evalContext: IEvalContext) => Promise<TermExpression>;\n  /**\n   * The arity of the function will be checked when parsing and preparing a function.\n   * This allows us to check if the query is correct even before we process any bindings.\n   */\n  checkArity: (args: Expression[]) => boolean;\n}\n\nexport interface ITermFunction extends IExpressionFunction {\n  supportsTermExpressions: true;\n  applyOnTerms: (args: TermExpression[], exprEval: IInternalEvaluator) => TermExpression;\n}\nexport interface IActionFunctionFactory extends IAction {\n  /**\n   * The name of the function to retrieve. Can be any string, a function name, or a URL.\n   */\n  functionName: string;\n  /**\n   * The arguments of the function, if they are known, and don't change.\n   */\n  arguments?: Alg.Expression[];\n  /**\n   * Whether the function should return a term expression.\n   */\n  requireTermExpression?: boolean;\n}\n\nexport interface IActorFunctionFactoryOutput extends IActorOutput, IExpressionFunction {}\n\nexport interface IActorFunctionFactoryOutputTerm extends IActorOutput, ITermFunction {}\n\nexport type IActorFunctionFactoryArgs<TS = undefined> = IActorArgs<\nIActionFunctionFactory,\nIActorTest,\nIActorFunctionFactoryOutput,\nTS\n>;\n\nexport type MediatorFunctionFactoryUnsafe = Mediate<IActionFunctionFactory, IActorFunctionFactoryOutput>;\n\nexport abstract class MediatorFunctionFactory extends Mediator<\nActor<IActionFunctionFactory, IActorTest, IActorFunctionFactoryOutput>,\nIActionFunctionFactory,\nIActorTest,\nIActorFunctionFactoryOutput\n> {\n  public abstract override mediate: <T extends IActionFunctionFactory>(action: T) =>\n  Promise<T extends { requireTermExpression: true } ? IActorFunctionFactoryOutputTerm : IActorFunctionFactoryOutput>;\n}\n"]}