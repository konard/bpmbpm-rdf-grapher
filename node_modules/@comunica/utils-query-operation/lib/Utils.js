"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSafeBindings = getSafeBindings;
exports.getSafeQuads = getSafeQuads;
exports.getSafeBoolean = getSafeBoolean;
exports.getSafeVoid = getSafeVoid;
exports.validateQueryOutput = validateQueryOutput;
exports.testReadOnly = testReadOnly;
exports.getOperationSource = getOperationSource;
exports.assignOperationSource = assignOperationSource;
exports.removeOperationSource = removeOperationSource;
exports.isDataDestinationRawType = isDataDestinationRawType;
exports.getDataDestinationType = getDataDestinationType;
exports.getDataDestinationValue = getDataDestinationValue;
exports.getDataDestinationContext = getDataDestinationContext;
exports.getContextDestination = getContextDestination;
exports.getContextDestinationUrl = getContextDestinationUrl;
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
/**
 * Safely cast a query operation output to a bindings output.
 * This will throw a runtime error if the output is of the incorrect type.
 * @param {IQueryOperationResult} output A query operation output.
 * @return {IQueryOperationResultBindings} A bindings query operation output.
 */
function getSafeBindings(output) {
    validateQueryOutput(output, 'bindings');
    return output;
}
/**
 * Safely cast a query operation output to a quads output.
 * This will throw a runtime error if the output is of the incorrect type.
 * @param {IQueryOperationResult} output A query operation output.
 * @return {IQueryOperationResultQuads} A quads query operation output.
 */
function getSafeQuads(output) {
    validateQueryOutput(output, 'quads');
    return output;
}
/**
 * Safely cast a query operation output to a boolean output.
 * This will throw a runtime error if the output is of the incorrect type.
 * @param {IQueryOperationResult} output A query operation output.
 * @return {IQueryOperationResultBoolean} A boolean query operation output.
 */
function getSafeBoolean(output) {
    validateQueryOutput(output, 'boolean');
    return output;
}
/**
 * Safely cast a query operation output to a void output.
 * This will throw a runtime error if the output is of the incorrect type.
 * @param {IQueryOperationResult} output A query operation output.
 * @return {IQueryOperationResultVoid} A void query operation output.
 */
function getSafeVoid(output) {
    validateQueryOutput(output, 'void');
    return output;
}
/**
 * Throw an error if the output type does not match the expected type.
 * @param {IQueryOperationResult} output A query operation output.
 * @param {string} expectedType The expected output type.
 */
function validateQueryOutput(output, expectedType) {
    if (output.type !== expectedType) {
        throw new Error(`Invalid query output type: Expected '${expectedType}' but got '${output.type}'`);
    }
}
/**
 * Test if the context contains the readOnly flag.
 * @param context An action context.
 */
function testReadOnly(context) {
    if (context.get(context_entries_1.KeysQueryOperation.readOnly)) {
        return (0, core_1.failTest)(`Attempted a write operation in read-only mode`);
    }
    return (0, core_1.passTestVoid)();
}
/**
 * Obtain the query source attached to the given operation.
 * @param operation An algebra operation.
 */
function getOperationSource(operation) {
    return operation.metadata?.scopedSource;
}
/**
 * Assign a source wrapper to the given operation.
 * The operation is copied and returned.
 * @param operation An operation.
 * @param source A source wrapper.
 */
function assignOperationSource(operation, source) {
    operation = { ...operation };
    operation.metadata = operation.metadata ? { ...operation.metadata } : {};
    operation.metadata.scopedSource = source;
    return operation;
}
/**
 * Remove the source wrapper from the given operation.
 * The operation is mutated.
 * @param operation An operation.
 */
function removeOperationSource(operation) {
    delete operation.metadata?.scopedSource;
    if (operation.metadata && Object.keys(operation.metadata).length === 0) {
        delete operation.metadata;
    }
}
/**
 * Check if the given data destination is a string or RDF store.
 * @param dataDestination A data destination.
 */
function isDataDestinationRawType(dataDestination) {
    return typeof dataDestination === 'string' || 'remove' in dataDestination;
}
/**
 * Get the data destination type.
 * @param dataDestination A data destination.
 */
function getDataDestinationType(dataDestination) {
    if (typeof dataDestination === 'string') {
        return '';
    }
    return 'remove' in dataDestination ? 'rdfjsStore' : dataDestination.type;
}
/**
 * Get the data destination value.
 * @param dataDestination A data destination.
 */
function getDataDestinationValue(dataDestination) {
    return isDataDestinationRawType(dataDestination) ? dataDestination : dataDestination.value;
}
/**
 * Get the context of the given destination, merged with the given context.
 * @param dataDestination A data destination.
 * @param context A context to merge with.
 */
function getDataDestinationContext(dataDestination, context) {
    if (typeof dataDestination === 'string' || 'remove' in dataDestination || !dataDestination.context) {
        return context;
    }
    return context.merge(dataDestination.context);
}
/**
 * Get the source destination from the given context.
 * @param {ActionContext} context An optional context.
 * @return {IDataDestination} The destination or undefined.
 */
function getContextDestination(context) {
    return context.get(context_entries_1.KeysRdfUpdateQuads.destination);
}
/**
 * Get the destination's raw URL value from the given context.
 * @param {IDataDestination} destination A destination.
 * @return {string} The URL or undefined.
 */
function getContextDestinationUrl(destination) {
    if (destination) {
        let fileUrl = getDataDestinationValue(destination);
        if (typeof fileUrl === 'string') {
            // Remove hashes from source
            const hashPosition = fileUrl.indexOf('#');
            if (hashPosition >= 0) {
                fileUrl = fileUrl.slice(0, hashPosition);
            }
            return fileUrl;
        }
    }
}
//# sourceMappingURL=Utils.js.map