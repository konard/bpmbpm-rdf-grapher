"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.estimateCardinality = estimateCardinality;
exports.estimateMinusCardinality = estimateMinusCardinality;
exports.estimateSliceCardinality = estimateSliceCardinality;
exports.estimateUnionCardinality = estimateUnionCardinality;
exports.estimateJoinCardinality = estimateJoinCardinality;
exports.estimateNpsCardinality = estimateNpsCardinality;
const utils_algebra_1 = require("@comunica/utils-algebra");
const rdf_data_factory_1 = require("rdf-data-factory");
// These are only used internally for estimates
const DF = new rdf_data_factory_1.DataFactory();
const AF = new utils_algebra_1.AlgebraFactory(DF);
/**
 * Estimate the cardinality of the provided operation using the specified dataset metadata.
 * This is the primary function that should be called to perform cardinality estimation.
 */
async function estimateCardinality(operation, dataset) {
    const estimate = await dataset.getCardinality(operation);
    if (estimate) {
        return estimate;
    }
    switch (operation.type) {
        case utils_algebra_1.Algebra.Types.ASK:
            return { type: 'exact', value: 1, dataset: dataset.uri };
        case utils_algebra_1.Algebra.Types.LOAD:
        case utils_algebra_1.Algebra.Types.DELETE_INSERT:
        case utils_algebra_1.Algebra.Types.ADD:
        case utils_algebra_1.Algebra.Types.COMPOSITE_UPDATE:
        case utils_algebra_1.Algebra.Types.CLEAR:
        case utils_algebra_1.Algebra.Types.NOP:
        case utils_algebra_1.Algebra.Types.DROP:
        case utils_algebra_1.Algebra.Types.CREATE:
        case utils_algebra_1.Algebra.Types.MOVE:
        case utils_algebra_1.Algebra.Types.COPY:
            return { type: 'exact', value: 0, dataset: dataset.uri };
        case utils_algebra_1.Algebra.Types.PROJECT:
        case utils_algebra_1.Algebra.Types.FILTER:
        case utils_algebra_1.Algebra.Types.ORDER_BY:
        case utils_algebra_1.Algebra.Types.GROUP:
        case utils_algebra_1.Algebra.Types.CONSTRUCT:
        case utils_algebra_1.Algebra.Types.DISTINCT:
        case utils_algebra_1.Algebra.Types.REDUCED:
        case utils_algebra_1.Algebra.Types.EXTEND:
        case utils_algebra_1.Algebra.Types.FROM:
        case utils_algebra_1.Algebra.Types.GRAPH:
            return estimateCardinality(operation.input, dataset);
        case utils_algebra_1.Algebra.Types.ZERO_OR_ONE_PATH:
        case utils_algebra_1.Algebra.Types.ZERO_OR_MORE_PATH:
        case utils_algebra_1.Algebra.Types.ONE_OR_MORE_PATH:
        case utils_algebra_1.Algebra.Types.INV:
            return estimateCardinality(operation.path, dataset);
        case utils_algebra_1.Algebra.Types.PATH:
            return estimateCardinality(operation.predicate, dataset);
        case utils_algebra_1.Algebra.Types.NPS:
            return estimateNpsCardinality(operation, dataset);
        case utils_algebra_1.Algebra.Types.LINK:
            return estimateCardinality(AF.createPattern(DF.variable('s'), operation.iri, DF.variable('o')), dataset);
        case utils_algebra_1.Algebra.Types.UNION:
        case utils_algebra_1.Algebra.Types.SEQ:
        case utils_algebra_1.Algebra.Types.ALT:
            return estimateUnionCardinality(operation.input, dataset);
        case utils_algebra_1.Algebra.Types.BGP:
            return estimateJoinCardinality(operation.patterns, dataset);
        case utils_algebra_1.Algebra.Types.JOIN:
        case utils_algebra_1.Algebra.Types.LEFT_JOIN:
            return estimateJoinCardinality(operation.input, dataset);
        case utils_algebra_1.Algebra.Types.SLICE:
            return estimateSliceCardinality(operation, dataset);
        case utils_algebra_1.Algebra.Types.MINUS:
            return estimateMinusCardinality(operation, dataset);
        case utils_algebra_1.Algebra.Types.VALUES:
            return { type: 'exact', value: operation.bindings.length, dataset: dataset.uri };
        case utils_algebra_1.Algebra.Types.SERVICE:
        case utils_algebra_1.Algebra.Types.DESCRIBE:
        case utils_algebra_1.Algebra.Types.EXPRESSION:
        case utils_algebra_1.Algebra.Types.PATTERN:
            return { type: 'estimate', value: Number.POSITIVE_INFINITY, dataset: dataset.uri };
    }
    return { type: 'estimate', value: Number.POSITIVE_INFINITY, dataset: dataset.uri };
}
/**
 * Estimate the cardinality of a minus, by taking into account the input cardinalities.
 */
async function estimateMinusCardinality(minus, dataset) {
    const estimateFirst = await estimateCardinality(minus.input[0], dataset);
    const estimateSecond = await estimateCardinality(minus.input[1], dataset);
    return {
        type: 'estimate',
        value: Math.max(estimateFirst.value - estimateSecond.value, 0),
        dataset: dataset.uri,
    };
}
/**
 * Estimate the cardinality of a slice operation, taking into account the input cardinality and the slice range.
 */
async function estimateSliceCardinality(slice, dataset) {
    const estimate = await estimateCardinality(slice.input, dataset);
    if (estimate.value > 0) {
        estimate.value = Math.max(estimate.value - slice.start, 0);
        if (slice.length !== undefined) {
            estimate.value = Math.min(estimate.value, slice.length);
        }
    }
    return estimate;
}
/**
 * Estimate the cardinality of a union, using a sum of the individual input cardinalities.
 */
async function estimateUnionCardinality(input, dataset) {
    const estimate = { type: 'exact', value: 0, dataset: dataset.uri };
    for (const operation of input) {
        const cardinality = await estimateCardinality(operation, dataset);
        if (cardinality.type === 'estimate' && estimate.type === 'exact') {
            estimate.type = cardinality.type;
        }
        estimate.value += cardinality.value;
    }
    return estimate;
}
/**
 * Estimate the cardinality of a join. This estimation is done by:
 *  1. Grouping operations together based on variables.
 *  2. Selecting the minimum op cardinality in each group as the cardinality of that group.
 *  3. Multiplying cardinalities of these (detached) groups.
 *
 * This should provide a good balance between selective groups of operations,
 * as well as cartesian joins between groups that do not overlap.
 */
async function estimateJoinCardinality(operations, dataset) {
    const operationGroups = [];
    for (const operation of operations) {
        const vars = utils_algebra_1.algebraUtils.inScopeVariables(operation).map(v => v.value);
        const group = operationGroups.find(g => vars.some(v => g.vars.has(v)));
        if (group) {
            group.ops.push(operation);
            for (const v of vars) {
                group.vars.add(v);
            }
        }
        else {
            operationGroups.push({ ops: [operation], vars: new Set(vars) });
        }
    }
    const cardinality = {
        type: 'estimate',
        value: (await Promise.all(operationGroups
            .map(async (g) => Math.min(...await Promise.all(g.ops.map(async (o) => (await estimateCardinality(o, dataset)).value))))))
            .reduce((acc, cur) => acc * cur, 1),
        dataset: dataset.uri,
    };
    return cardinality;
}
/**
 * Estimate the cardinality of a negated property set, by subtracting the non-inversed
 * estimate from the total number of triples.
 */
async function estimateNpsCardinality(nps, dataset) {
    const seq = AF.createSeq([...nps.iris].reverse().map(iri => AF.createLink(iri)));
    const seqCardinality = await estimateCardinality(seq, dataset);
    const pattern = AF.createPattern(DF.variable('s'), DF.variable('p'), DF.variable('o'));
    const patternCardinality = await estimateCardinality(pattern, dataset);
    return {
        type: 'estimate',
        value: Math.max(0, patternCardinality.value - seqCardinality.value),
        dataset: dataset.uri,
    };
}
//# sourceMappingURL=CardinalityEstimators.js.map