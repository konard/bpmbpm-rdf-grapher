{"version":3,"file":"MaterializeBindings.js","sourceRoot":"","sources":["MaterializeBindings.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Bindings } from '@comunica/types';\nimport type { AlgebraFactory } from '@comunica/utils-algebra';\nimport { Algebra, algebraUtils } from '@comunica/utils-algebra';\nimport type { BindingsFactory } from '@comunica/utils-bindings-factory';\nimport type * as RDF from '@rdfjs/types';\nimport type { Variable } from 'rdf-data-factory';\nimport { termToString } from 'rdf-string';\nimport { mapTermsNested, someTermsNested } from 'rdf-terms';\n\n/**\n * Materialize a term with the given binding.\n *\n * If the given term is a variable,\n * and that variable exist in the given bindings object,\n * the value of that binding is returned.\n * In all other cases, the term itself is returned.\n *\n * @param {RDF.Term} term A term.\n * @param {Bindings} bindings A bindings object.\n * @return {RDF.Term} The materialized term.\n */\nexport function materializeTerm(term: RDF.Term, bindings: Bindings): RDF.Term {\n  if (term.termType === 'Variable') {\n    const value = bindings.get(term);\n    if (value) {\n      return value;\n    }\n  }\n  if (term.termType === 'Quad' && someTermsNested(term, value => value.termType === 'Variable')) {\n    return mapTermsNested(term, subTerm => materializeTerm(subTerm, bindings));\n  }\n  return term;\n}\n\n/**\n * Materialize the given operation (recursively) with the given bindings.\n * Essentially, the variables in the given operation\n * which don't appear in the projection operation will be replaced\n * by the terms bound to the variables in the given bindings.\n * @param {Algebra.Operation} operation SPARQL algebra operation.\n * And the variables that appear in the projection operation\n * will be added to a new values operation.\n * @param {Bindings} bindings A bindings object.\n * @param algebraFactory The algebra factory.\n * @param bindingsFactory The bindings factory.\n * @param options Options for materializations.\n * @param options.strictTargetVariables If target variable bindings (such as on SELECT or BIND) should not be allowed.\n * @param options.bindFilter If filter expressions should be materialized.\n * @param options.originalBindings The bindings object as it was at the top level call of materializeOperation.\n * @return Algebra.Operation A new operation materialized with the given bindings.\n */\nexport function materializeOperation(\n  operation: Algebra.Operation,\n  bindings: Bindings,\n  algebraFactory: AlgebraFactory,\n  bindingsFactory: BindingsFactory,\n  options: {\n    strictTargetVariables?: boolean;\n    bindFilter?: boolean;\n    originalBindings?: Bindings;\n  } = {},\n): Algebra.Operation {\n  options = {\n    strictTargetVariables: options.strictTargetVariables ?? false,\n    bindFilter: options.bindFilter ?? true,\n    originalBindings: options.originalBindings ?? bindings,\n  };\n\n  return algebraUtils.mapOperation(operation, {\n    [Algebra.Types.PATH]: {\n      preVisitor: () => ({ continue: false }),\n      transform: pathOp =>\n        // Materialize variables in a path expression.\n        // The predicate expression will be recursed.\n        Object.assign(algebraFactory.createPath(\n          materializeTerm(pathOp.subject, bindings),\n          pathOp.predicate,\n          materializeTerm(pathOp.object, bindings),\n          materializeTerm(pathOp.graph, bindings),\n        ), { metadata: pathOp.metadata }),\n    },\n    [Algebra.Types.PATTERN]: {\n      preVisitor: () => ({ continue: false }),\n      transform: patternOp =>\n        // Materialize variables in the quad pattern.\n        Object.assign(algebraFactory.createPattern(\n          materializeTerm(patternOp.subject, bindings),\n          materializeTerm(patternOp.predicate, bindings),\n          materializeTerm(patternOp.object, bindings),\n          materializeTerm(patternOp.graph, bindings),\n        ), { metadata: patternOp.metadata }),\n    },\n    [Algebra.Types.JOIN]: {\n      preVisitor: () => ({ continue: false }),\n      transform: op =>\n      // Materialize join operation, and ensure metadata is taken into account.\n      // Join entries with metadata should not be flattened.\n        Object.assign(algebraFactory.createJoin(op.input.map(input => materializeOperation(\n          input,\n          bindings,\n          algebraFactory,\n          bindingsFactory,\n          options,\n        )), op.input.every(input => !input.metadata)), { metadata: op.metadata }),\n    },\n    [Algebra.Types.EXTEND]: { transform: (extendOp) => {\n      // Materialize an extend operation.\n      // If strictTargetVariables is true, we throw if the extension target variable is attempted to be bound.\n      // Otherwise, we remove the extend operation.\n      if (bindings.has(extendOp.variable)) {\n        if (options.strictTargetVariables) {\n          throw new Error(`Tried to bind variable ${termToString(extendOp.variable)} in a BIND operator.`);\n        } else {\n          return materializeOperation(extendOp.input, bindings, algebraFactory, bindingsFactory, options);\n        }\n      }\n      return extendOp;\n    } },\n    [Algebra.Types.GROUP]: { transform: (groupOp) => {\n      // Materialize a group operation.\n      // If strictTargetVariables is true, we throw if the group target variable is attempted to be bound.\n      // Otherwise, we just filter out the bound variables.\n      if (options.strictTargetVariables) {\n        for (const variable of groupOp.variables) {\n          if (bindings.has(variable)) {\n            throw new Error(`Tried to bind variable ${termToString(variable)} in a GROUP BY operator.`);\n          }\n        }\n        return groupOp;\n      }\n      const variables = groupOp.variables.filter(variable => !bindings.has(variable));\n      return algebraFactory.createGroup(\n        groupOp.input,\n        variables,\n        groupOp.aggregates,\n      );\n    } },\n    [Algebra.Types.FILTER]: {\n      preVisitor: () => ({ continue: false }),\n      transform: (filterOp) => {\n        const originalBindings: Bindings = <Bindings> options.originalBindings;\n        if (filterOp.expression.subType !== 'operator' || originalBindings.size === 0) {\n          return filterOp;\n        }\n\n        // Make a values clause using all the variables from originalBindings.\n        const values: Algebra.Operation[] = createValuesFromBindings(algebraFactory, originalBindings);\n\n        // Recursively materialize the filter expression\n        const recursionResultExpression: Algebra.Expression = <Algebra.Expression> materializeOperation(\n          filterOp.expression,\n          bindings,\n          algebraFactory,\n          bindingsFactory,\n          options,\n        );\n\n        // Recursively materialize the filter input\n        let recursionResultInput: Algebra.Operation = materializeOperation(\n          filterOp.input,\n          bindings,\n          algebraFactory,\n          bindingsFactory,\n          options,\n        );\n\n        recursionResultInput = algebraFactory.createJoin([ ...values, recursionResultInput ]);\n\n        return algebraFactory.createFilter(recursionResultInput, recursionResultExpression);\n      },\n    },\n    [Algebra.Types.PROJECT]: {\n      preVisitor: () => ({ continue: false }),\n      transform: (projectOp) => {\n      // Materialize a project operation.\n\n        // Find projected variables which are present in the originalBindings.\n        // This will result in projected variables being handled via a values clause.\n        const values: Algebra.Operation[] =\n          createValuesFromBindings(algebraFactory, <Bindings> options.originalBindings, projectOp.variables);\n\n        let recursionResult: Algebra.Operation = materializeOperation(\n          projectOp.input,\n          bindings,\n          algebraFactory,\n          bindingsFactory,\n          options,\n        );\n\n        if (values.length > 0) {\n          recursionResult = algebraFactory.createJoin([ ...values, recursionResult ]);\n        }\n\n        return algebraFactory.createProject(recursionResult, projectOp.variables);\n      },\n    },\n    [Algebra.Types.VALUES]: {\n      preVisitor: () => ({ continue: !options.strictTargetVariables }),\n      transform: (valuesOp) => {\n        // Materialize a values operation.\n        // If strictTargetVariables is true, we throw if the values target variable is attempted to be bound.\n        // Otherwise, we just filter out the bound variables and their bindings.\n        if (options.strictTargetVariables) {\n          for (const variable of valuesOp.variables) {\n            if (bindings.has(variable)) {\n              throw new Error(`Tried to bind variable ${termToString(variable)} in a VALUES operator.`);\n            }\n          }\n          return valuesOp;\n        }\n        const variables = valuesOp.variables.filter(variable => !bindings.has(variable));\n        const valueBindings: Algebra.Values['bindings'] = <any> valuesOp.bindings.map((binding) => {\n          const newBinding = { ...binding };\n          let valid = true;\n          // eslint-disable-next-line unicorn/no-array-for-each\n          bindings.forEach((value: RDF.Term, key: RDF.Variable) => {\n            if (key.value in newBinding) {\n              if (!value.equals(newBinding[key.value])) {\n                // If the value of the binding is not equal, remove this binding completely from the VALUES clause\n                valid = false;\n              }\n              delete newBinding[key.value];\n            }\n          });\n          return valid ? newBinding : undefined;\n        }).filter(Boolean);\n        return algebraFactory.createValues(variables, valueBindings);\n      },\n    },\n    [Algebra.Types.EXPRESSION]: {\n      preVisitor: (expressionOp) => {\n        if (!options.bindFilter) {\n          return { continue: false };\n        }\n        if (expressionOp.subType === 'term') {\n          return { continue: false };\n        }\n        if (expressionOp.subType === 'operator' &&\n          (expressionOp.operator === 'bound' && expressionOp.args.length === 1 &&\n            expressionOp.args[0].subType === 'term' && [ ...bindings.keys() ]\n            .some(variable => (<Algebra.TermExpression>expressionOp.args[0]).term.equals(variable)))) {\n          return { continue: false };\n        }\n        return { continue: true };\n      },\n      transform: (expressionOp) => {\n        if (!options.bindFilter) {\n          return expressionOp;\n        }\n\n        if (expressionOp.subType === 'term') {\n          // Materialize a term expression\n          return algebraFactory.createTermExpression(materializeTerm(expressionOp.term, bindings));\n        }\n        if (expressionOp.subType === 'operator') {\n          if (expressionOp.operator === 'bound' && expressionOp.args.length === 1 &&\n        expressionOp.args[0].subType === 'term' && [ ...bindings.keys() ]\n            .some(variable => (<Algebra.TermExpression>expressionOp.args[0]).term.equals(variable))) {\n            return algebraFactory.createTermExpression(algebraFactory.dataFactory.literal(\n              'true',\n              algebraFactory.dataFactory.namedNode('http://www.w3.org/2001/XMLSchema#boolean'),\n            ));\n          }\n          return expressionOp;\n        }\n        if (expressionOp.subType === 'aggregate' &&\n      'variable' in expressionOp &&\n      bindings.has(expressionOp.variable)) {\n          // Materialize a bound aggregate operation.\n          // If strictTargetVariables is true, we throw if the expression target variable is attempted to be bound.\n          // Otherwise, we ignore this operation.\n          if (options.strictTargetVariables) {\n            throw new Error(`Tried to bind ${termToString(expressionOp.variable)} in a ${expressionOp.aggregator} aggregate.`);\n          } else {\n            return expressionOp;\n          }\n        }\n        return expressionOp;\n      },\n    },\n  });\n}\n\n/**\n * Make a values operation containing the values that are present in `bindings` for variables present in `variables`.\n * If no `variables` argument is given, this method returns a values operation\n * containing every binding from `bindings`.\n * @param {AlgebraFactory} factory The Factory used to create the values operation.\n * @param {Bindings} bindings A bindings object.\n * @param {Variable[]} variables A list of variables.\n * @returns Algebra.Values A new values operation the given bindings.\n */\nfunction createValuesFromBindings(\n  factory: AlgebraFactory,\n  bindings: Bindings,\n  variables?: Variable[],\n): Algebra.Values[] {\n  const values: Algebra.Values[] = [];\n\n  for (const [ variable, binding ] of bindings) {\n    if (!variables || variables.some(v => v.equals(variable))) {\n      const newBinding = { [variable.value]: <RDF.NamedNode | RDF.Literal> binding };\n\n      values.push(factory.createValues([ variable ], [ newBinding ]));\n    }\n  }\n\n  return values;\n}\n"]}