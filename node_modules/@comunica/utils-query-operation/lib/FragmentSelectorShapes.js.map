{"version":3,"file":"FragmentSelectorShapes.js","sourceRoot":"","sources":["FragmentSelectorShapes.ts"],"names":[],"mappings":"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","sourcesContent":["import { KeysRdfUpdateQuads } from '@comunica/context-entries';\nimport type { FragmentSelectorShape, IActionContext, IDataDestination, IQuerySourceWrapper } from '@comunica/types';\nimport { Algebra, algebraUtils, isKnownSubType } from '@comunica/utils-algebra';\nimport { getDataDestinationValue } from './Utils';\n\n/**\n * Check if the given shape accepts the given query operation.\n * @param shape A shape to test the query operation against.\n * @param operation A query operation to test.\n * @param options Additional options to consider.\n * @param options.joinBindings If additional bindings will be pushed down to the source for joining.\n * @param options.filterBindings If additional bindings will be pushed down to the source for filtering.\n */\nexport function doesShapeAcceptOperation(\n  shape: FragmentSelectorShape,\n  operation: Algebra.Operation,\n  options?: FragmentSelectorShapeTestFlags,\n): boolean {\n  return doesShapeAcceptOperationRecurseShape(shape, shape, operation, options);\n}\n\nfunction doesShapeAcceptOperationRecurseShape(\n  shapeTop: FragmentSelectorShape,\n  shapeActive: FragmentSelectorShape,\n  operation: Algebra.Operation,\n  options?: FragmentSelectorShapeTestFlags,\n): boolean {\n  // Recurse into the shape\n  if (shapeActive.type === 'conjunction') {\n    return shapeActive.children\n      .every(child => doesShapeAcceptOperationRecurseShape(shapeTop, child, operation, options));\n  }\n  if (shapeActive.type === 'disjunction') {\n    return shapeActive.children\n      .some(child => doesShapeAcceptOperationRecurseShape(shapeTop, child, operation, options));\n  }\n  if (shapeActive.type === 'negation') {\n    return !doesShapeAcceptOperationRecurseShape(shapeActive.child, shapeActive.child, operation, options);\n  }\n  if (shapeActive.type === 'arity') {\n    return doesShapeAcceptOperationRecurseShape(shapeTop, shapeActive.child, operation, options);\n  }\n\n  // Validate options\n  if ((options?.joinBindings && !shapeActive.joinBindings) ??\n    (options?.filterBindings && !shapeActive.filterBindings)) {\n    return false;\n  }\n\n  // Check if the shape's operation matches with the given operation\n  const shapeOperation = shapeActive.operation;\n  switch (shapeOperation.operationType) {\n    case 'type': {\n      if (shapeOperation.type === Algebra.Types.EXPRESSION && isExtensionFunction(operation) &&\n        !('extensionFunctions' in shapeOperation &&\n        shapeOperation.extensionFunctions?.includes(operation.name.value))) {\n        return false;\n      }\n      if (!doesShapeAcceptOperationRecurseOperationAndShape(shapeTop, shapeActive.children, operation, options) &&\n        !doesShapeAcceptOperationRecurseOperation(shapeTop, operation, options)) {\n        return false;\n      }\n      return shapeOperation.type === operation.type;\n    }\n    case 'pattern': {\n      if (!doesShapeAcceptOperationRecurseOperationAndShape(shapeTop, shapeActive.children, operation, options) &&\n        !doesShapeAcceptOperationRecurseOperation(shapeTop, operation, options)) {\n        return false;\n      }\n      return shapeOperation.pattern.type === operation.type;\n    }\n    case 'wildcard': {\n      // All possible operations are accepted by this shape.\n      // As exception, extension functions are not accepted through wildcards.\n      if (options?.wildcardAcceptAllExtensionFunctions) {\n        return true;\n      }\n      if (isExtensionFunction(operation)) {\n        return false;\n      }\n      // Also check for nested extension functions,\n      // and only accept the wildcard if all nested extension functions are supported by the query shape.\n      let hasUnsupportedExtensionFunction = false;\n      algebraUtils.visitOperation(operation, {\n        [Algebra.Types.EXPRESSION]: {\n          visitor: (subOp) => {\n            if (isExtensionFunction(subOp) && !doesShapeAcceptOperation(shapeTop, subOp, options)) {\n              hasUnsupportedExtensionFunction = true;\n              return false;\n            }\n            return true;\n          },\n        },\n      });\n      return !hasUnsupportedExtensionFunction;\n    }\n  }\n}\n\nfunction doesShapeAcceptOperationRecurseOperationAndShape(\n  shapeTop: FragmentSelectorShape,\n  shapeActiveChildren: FragmentSelectorShape[] | undefined,\n  operation: Algebra.Operation,\n  options?: FragmentSelectorShapeTestFlags,\n): boolean {\n  if (isExtensionFunction(operation) || isExtensionFunction((<any> operation).expression)) {\n    return false;\n  }\n  if (shapeActiveChildren) {\n    const operationCast = <Algebra.Operation & { input?: unknown; patterns?: any[] }> operation;\n    const operationInputs: Algebra.Operation[] = operationCast.input ?\n        (Array.isArray(operationCast.input) ? operationCast.input : [ operationCast.input ]) :\n      operationCast.patterns ?? [];\n    for (const [ i, shapeActiveChild ] of shapeActiveChildren.entries()) {\n      if (!operationInputs[i] ||\n        !doesShapeAcceptOperationRecurseShape(shapeTop, shapeActiveChild, operationInputs[i], options)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction doesShapeAcceptOperationRecurseOperation(\n  shapeTop: FragmentSelectorShape,\n  operation: Algebra.Operation,\n  options?: FragmentSelectorShapeTestFlags,\n): boolean {\n  // Recurse into the operation, and restart from the top-level shape\n  const operationCast = <Algebra.Operation & { input?: unknown; patterns?: any[]; expression?: any }> operation;\n  if (operationCast.input) {\n    const inputs: Algebra.Operation[] = Array\n      .isArray(operationCast.input) ?\n      operationCast.input :\n        [ operationCast.input ];\n    if (!inputs.every(input => doesShapeAcceptOperationRecurseShape(shapeTop, shapeTop, input, options))) {\n      return false;\n    }\n  }\n  if (operationCast.expression && isExtensionFunction(operationCast.expression) &&\n      !doesShapeAcceptOperationRecurseShape(shapeTop, shapeTop, operationCast.expression, options)) {\n    return false;\n  }\n  return !(operationCast.patterns && !operationCast.patterns\n    .every((input: Algebra.Pattern) => doesShapeAcceptOperationRecurseShape(shapeTop, shapeTop, input, options)));\n}\n\nfunction isStandardSparqlFunction(iri: string): boolean {\n  return /^https?:\\/\\/www\\.w3\\.org\\//u.test(iri);\n}\n\nfunction isExtensionFunction(operation: Algebra.Operation): operation is Algebra.NamedExpression {\n  return operation && operation.type === Algebra.Types.EXPRESSION &&\n    isKnownSubType(operation, Algebra.ExpressionTypes.NAMED) && !isStandardSparqlFunction(operation.name.value);\n}\n\nexport type FragmentSelectorShapeTestFlags = {\n  joinBindings?: boolean;\n  filterBindings?: boolean;\n  wildcardAcceptAllExtensionFunctions?: boolean;\n};\n\nexport async function passFullOperationToSource(\n  operation: Algebra.Operation,\n  sources: IQuerySourceWrapper[],\n  context: IActionContext,\n): Promise<boolean> {\n  if (sources.length === 1) {\n    const sourceWrapper = sources[0];\n    const destination: IDataDestination | undefined = context.get(KeysRdfUpdateQuads.destination);\n    if (!destination || sourceWrapper.source.referenceValue === getDataDestinationValue(destination)) {\n      try {\n        const shape = await sourceWrapper.source.getSelectorShape(context);\n        if (doesShapeAcceptOperation(shape, operation)) {\n          return true;\n        }\n      } catch {\n        // Fallback to the default case when the selector shape does not exist,\n        // which can occur for a non-existent destination.\n      }\n    }\n  }\n  return false;\n}\n"]}