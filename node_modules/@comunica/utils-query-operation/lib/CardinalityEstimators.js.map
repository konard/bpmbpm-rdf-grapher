{"version":3,"file":"CardinalityEstimators.js","sourceRoot":"","sources":["CardinalityEstimators.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IDataset, QueryResultCardinality } from '@comunica/types';\nimport { Algebra, AlgebraFactory, algebraUtils } from '@comunica/utils-algebra';\nimport type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\n\n// These are only used internally for estimates\nconst DF = new DataFactory<RDF.BaseQuad>();\nconst AF = new AlgebraFactory(DF);\n\n/**\n * Estimate the cardinality of the provided operation using the specified dataset metadata.\n * This is the primary function that should be called to perform cardinality estimation.\n */\nexport async function estimateCardinality(\n  operation: Algebra.Operation,\n  dataset: IDataset,\n): Promise<QueryResultCardinality> {\n  const estimate = await dataset.getCardinality(operation);\n\n  if (estimate) {\n    return estimate;\n  }\n\n  switch (operation.type) {\n    case Algebra.Types.ASK:\n      return { type: 'exact', value: 1, dataset: dataset.uri };\n    case Algebra.Types.LOAD:\n    case Algebra.Types.DELETE_INSERT:\n    case Algebra.Types.ADD:\n    case Algebra.Types.COMPOSITE_UPDATE:\n    case Algebra.Types.CLEAR:\n    case Algebra.Types.NOP:\n    case Algebra.Types.DROP:\n    case Algebra.Types.CREATE:\n    case Algebra.Types.MOVE:\n    case Algebra.Types.COPY:\n      return { type: 'exact', value: 0, dataset: dataset.uri };\n    case Algebra.Types.PROJECT:\n    case Algebra.Types.FILTER:\n    case Algebra.Types.ORDER_BY:\n    case Algebra.Types.GROUP:\n    case Algebra.Types.CONSTRUCT:\n    case Algebra.Types.DISTINCT:\n    case Algebra.Types.REDUCED:\n    case Algebra.Types.EXTEND:\n    case Algebra.Types.FROM:\n    case Algebra.Types.GRAPH:\n      return estimateCardinality((<Algebra.Graph> operation).input, dataset);\n    case Algebra.Types.ZERO_OR_ONE_PATH:\n    case Algebra.Types.ZERO_OR_MORE_PATH:\n    case Algebra.Types.ONE_OR_MORE_PATH:\n    case Algebra.Types.INV:\n      return estimateCardinality((<Algebra.Inv> operation).path, dataset);\n    case Algebra.Types.PATH:\n      return estimateCardinality((<Algebra.Path> operation).predicate, dataset);\n    case Algebra.Types.NPS:\n      return estimateNpsCardinality((<Algebra.Nps> operation), dataset);\n    case Algebra.Types.LINK:\n      return estimateCardinality(\n        AF.createPattern(DF.variable('s'), (<Algebra.Link> operation).iri, DF.variable('o')),\n        dataset,\n      );\n    case Algebra.Types.UNION:\n    case Algebra.Types.SEQ:\n    case Algebra.Types.ALT:\n      return estimateUnionCardinality((<Algebra.Alt> operation).input, dataset);\n    case Algebra.Types.BGP:\n      return estimateJoinCardinality((<Algebra.Bgp> operation).patterns, dataset);\n    case Algebra.Types.JOIN:\n    case Algebra.Types.LEFT_JOIN:\n      return estimateJoinCardinality((<Algebra.LeftJoin> operation).input, dataset);\n    case Algebra.Types.SLICE:\n      return estimateSliceCardinality((<Algebra.Slice> operation), dataset);\n    case Algebra.Types.MINUS:\n      return estimateMinusCardinality((<Algebra.Minus> operation), dataset);\n    case Algebra.Types.VALUES:\n      return { type: 'exact', value: (<Algebra.Values> operation).bindings.length, dataset: dataset.uri };\n    case Algebra.Types.SERVICE:\n    case Algebra.Types.DESCRIBE:\n    case Algebra.Types.EXPRESSION:\n    case Algebra.Types.PATTERN:\n      return { type: 'estimate', value: Number.POSITIVE_INFINITY, dataset: dataset.uri };\n  }\n  return { type: 'estimate', value: Number.POSITIVE_INFINITY, dataset: dataset.uri };\n}\n\n/**\n * Estimate the cardinality of a minus, by taking into account the input cardinalities.\n */\nexport async function estimateMinusCardinality(\n  minus: Algebra.Minus,\n  dataset: IDataset,\n): Promise<QueryResultCardinality> {\n  const estimateFirst = await estimateCardinality(minus.input[0], dataset);\n  const estimateSecond = await estimateCardinality(minus.input[1], dataset);\n  return {\n    type: 'estimate',\n    value: Math.max(estimateFirst.value - estimateSecond.value, 0),\n    dataset: dataset.uri,\n  };\n}\n\n/**\n * Estimate the cardinality of a slice operation, taking into account the input cardinality and the slice range.\n */\nexport async function estimateSliceCardinality(\n  slice: Algebra.Slice,\n  dataset: IDataset,\n): Promise<QueryResultCardinality> {\n  const estimate = await estimateCardinality(slice.input, dataset);\n  if (estimate.value > 0) {\n    estimate.value = Math.max(estimate.value - slice.start, 0);\n    if (slice.length !== undefined) {\n      estimate.value = Math.min(estimate.value, slice.length);\n    }\n  }\n  return estimate;\n}\n\n/**\n * Estimate the cardinality of a union, using a sum of the individual input cardinalities.\n */\nexport async function estimateUnionCardinality(\n  input: Algebra.Operation[],\n  dataset: IDataset,\n): Promise<QueryResultCardinality> {\n  const estimate: QueryResultCardinality = { type: 'exact', value: 0, dataset: dataset.uri };\n  for (const operation of input) {\n    const cardinality = await estimateCardinality(operation, dataset);\n    if (cardinality.type === 'estimate' && estimate.type === 'exact') {\n      estimate.type = cardinality.type;\n    }\n    estimate.value += cardinality.value;\n  }\n  return estimate;\n}\n\n/**\n * Estimate the cardinality of a join. This estimation is done by:\n *  1. Grouping operations together based on variables.\n *  2. Selecting the minimum op cardinality in each group as the cardinality of that group.\n *  3. Multiplying cardinalities of these (detached) groups.\n *\n * This should provide a good balance between selective groups of operations,\n * as well as cartesian joins between groups that do not overlap.\n */\nexport async function estimateJoinCardinality(\n  operations: Algebra.Operation[],\n  dataset: IDataset,\n): Promise<QueryResultCardinality> {\n  const operationGroups: { ops: Algebra.Operation[]; vars: Set<string> }[] = [];\n  for (const operation of operations) {\n    const vars = algebraUtils.inScopeVariables(operation).map(v => v.value);\n    const group = operationGroups.find(g => vars.some(v => g.vars.has(v)));\n    if (group) {\n      group.ops.push(operation);\n      for (const v of vars) {\n        group.vars.add(v);\n      }\n    } else {\n      operationGroups.push({ ops: [ operation ], vars: new Set(vars) });\n    }\n  }\n  const cardinality: QueryResultCardinality = {\n    type: 'estimate',\n    value: (await Promise.all(operationGroups\n      .map(async g => Math.min(...await Promise.all(\n        g.ops.map(async o => (await estimateCardinality(o, dataset)).value),\n      )))))\n      .reduce((acc, cur) => acc * cur, 1),\n    dataset: dataset.uri,\n  };\n  return cardinality;\n}\n\n/**\n * Estimate the cardinality of a negated property set, by subtracting the non-inversed\n * estimate from the total number of triples.\n */\nexport async function estimateNpsCardinality(\n  nps: Algebra.Nps,\n  dataset: IDataset,\n): Promise<QueryResultCardinality> {\n  const seq = AF.createSeq([ ...nps.iris ].reverse().map(iri => AF.createLink(iri)));\n  const seqCardinality = await estimateCardinality(seq, dataset);\n  const pattern = AF.createPattern(DF.variable('s'), DF.variable('p'), DF.variable('o'));\n  const patternCardinality = await estimateCardinality(pattern, dataset);\n  return {\n    type: 'estimate',\n    value: Math.max(0, patternCardinality.value - seqCardinality.value),\n    dataset: dataset.uri,\n  };\n}\n"]}