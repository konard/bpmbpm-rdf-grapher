{"version":3,"file":"ExpressionFunctionBnode.js","sourceRoot":"","sources":["ExpressionFunctionBnode.ts"],"names":[],"mappings":";;;AAAA,yEAAwE;AACxE,+DAAmF;AAEnF,qEAAuE;AACvE,qFAK8C;AAE9C;;;GAGG;AACH,MAAa,uBAAwB,SAAQ,6CAAsB;IACjE;;OAEG;IACK,MAAM,CAAU,SAAS,GAAG,IAAA,oCAAO,EAAC,2CAAc,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,CAAC;IAExG;;;OAGG;IACK,MAAM,CAAC,YAAY,GAAG,CAAC,CAAC;IAEhC;QACE,KAAK,CAAC;YACJ,KAAK,EAAE,MAAM,CAAC,iBAAiB;YAC/B,QAAQ,EAAE,2CAAc,CAAC,KAAK;YAC9B,KAAK,EAAE,KAAK,EAAC,OAAqB,EAA2B,EAAE;gBAC7D,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG,OAAO,CAAC;gBAC5C,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;oBAC/B,MAAM,QAAQ,CAAC,6BAA6B,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;oBAChE,SAAS,CAAC;gBAEZ,IAAI,QAA4B,CAAC;gBACjC,IAAI,KAAK,EAAE,CAAC;oBACV,MAAM,SAAS,GAAG,uBAAuB,CAAC,SAAS,CAAC,MAAM,CACxD,CAAE,KAAK,CAAE,EACT,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,yCAAuB,CAAC,iBAAiB,CAAC,EACnE,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,+BAAa,CAAC,sBAAsB,CAAC,CAC/D,CAAC;oBACF,IAAI,CAAC,SAAS,EAAE,CAAC;wBACf,MAAM,IAAI,iDAAoB,CAAC,IAAI,EAAE,2CAAc,CAAC,KAAK,CAAC,CAAC;oBAC7D,CAAC;oBACD,QAAQ,GAAG,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAE,KAAK,CAAE,CAAC,CAAC,GAAG,EAAE,CAAC;gBAClD,CAAC;gBAED,MAAM,KAAK,GAAG,IAAI,4CAAuB,CAAC,QAAQ,IAAI,SAAS,uBAAuB,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;gBACzG,OAAO,IAAI,sCAAS,CAAC,KAAK,CAAC,CAAC;YAC9B,CAAC;SACF,CAAC,CAAC;IACL,CAAC;IAEe,UAAU,CAAC,IAAkB;QAC3C,OAAO,IAAI,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC;IAChD,CAAC;;AA3CH,0DA4CC","sourcesContent":["import { ExpressionFunctionBase } from '@comunica/bus-function-factory';\nimport { KeysExpressionEvaluator, KeysInitQuery } from '@comunica/context-entries';\nimport type { Expression, IEvalContext, TermExpression } from '@comunica/types';\nimport { BlankNodeBindingsScoped } from '@comunica/utils-data-factory';\nimport {\n  BlankNode,\n  declare,\n  InvalidArgumentTypes,\n  SparqlOperator,\n} from '@comunica/utils-expression-evaluator';\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-bnode\n * id has to be distinct over all id's in dataset\n */\nexport class ExpressionFunctionBnode extends ExpressionFunctionBase {\n  /**\n   * This OverloadTree with the constant function will handle both type promotion and subtype-substitution\n   */\n  private static readonly bnodeTree = declare(SparqlOperator.BNODE).onString1(() => arg => arg).collect();\n\n  /**\n   * A counter that keeps track blank node generated through BNODE() SPARQL\n   * expressions.\n   */\n  private static bnodeCounter = 0;\n\n  public constructor() {\n    super({\n      arity: Number.POSITIVE_INFINITY,\n      operator: SparqlOperator.BNODE,\n      apply: async(context: IEvalContext): Promise<TermExpression> => {\n        const { args, mapping, exprEval } = context;\n        const input = args.length === 1 ?\n          await exprEval.evaluatorExpressionEvaluation(args[0], mapping) :\n          undefined;\n\n        let strInput: string | undefined;\n        if (input) {\n          const operation = ExpressionFunctionBnode.bnodeTree.search(\n            [ input ],\n            exprEval.context.getSafe(KeysExpressionEvaluator.superTypeProvider),\n            exprEval.context.getSafe(KeysInitQuery.functionArgumentsCache),\n          );\n          if (!operation) {\n            throw new InvalidArgumentTypes(args, SparqlOperator.BNODE);\n          }\n          strInput = operation(exprEval)([ input ]).str();\n        }\n\n        const bnode = new BlankNodeBindingsScoped(strInput ?? `BNODE_${ExpressionFunctionBnode.bnodeCounter++}`);\n        return new BlankNode(bnode);\n      },\n    });\n  }\n\n  public override checkArity(args: Expression[]): boolean {\n    return args.length === 0 || args.length === 1;\n  }\n}\n"]}