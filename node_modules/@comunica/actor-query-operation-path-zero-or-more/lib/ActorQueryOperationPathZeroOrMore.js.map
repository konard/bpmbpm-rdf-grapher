{"version":3,"file":"ActorQueryOperationPathZeroOrMore.js","sourceRoot":"","sources":["ActorQueryOperationPathZeroOrMore.ts"],"names":[],"mappings":"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","sourcesContent":["import { ActorAbstractPath } from '@comunica/actor-abstract-path';\nimport type { MediatorMergeBindingsContext } from '@comunica/bus-merge-bindings-context';\nimport type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type {\n  Bindings,\n  IQueryOperationResult,\n  IActionContext,\n  ComunicaDataFactory,\n  MetadataVariable,\n} from '@comunica/types';\nimport { Algebra, AlgebraFactory } from '@comunica/utils-algebra';\nimport { BindingsFactory } from '@comunica/utils-bindings-factory';\nimport { getSafeBindings } from '@comunica/utils-query-operation';\nimport type * as RDF from '@rdfjs/types';\nimport { MultiTransformIterator, TransformIterator, EmptyIterator, BufferedIterator } from 'asynciterator';\nimport { termToString } from 'rdf-string';\n\n/**\n * A comunica Path ZeroOrMore Query Operation Actor.\n */\nexport class ActorQueryOperationPathZeroOrMore extends ActorAbstractPath {\n  public readonly mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n\n  public constructor(args: IActorQueryOperationPathZeroOrMoreArgs) {\n    super(args, Algebra.Types.ZERO_OR_MORE_PATH);\n    this.mediatorMergeBindingsContext = args.mediatorMergeBindingsContext;\n  }\n\n  public async runOperation(operation: Algebra.Path, context: IActionContext): Promise<IQueryOperationResult> {\n    const dataFactory: ComunicaDataFactory = context.getSafe(KeysInitQuery.dataFactory);\n    const algebraFactory = new AlgebraFactory(dataFactory);\n    const bindingsFactory = await BindingsFactory.create(this.mediatorMergeBindingsContext, context, dataFactory);\n\n    const distinct = await this.isPathArbitraryLengthDistinct(algebraFactory, context, operation);\n    if (distinct.operation) {\n      return distinct.operation;\n    }\n\n    context = distinct.context;\n\n    const predicate = <Algebra.ZeroOrMorePath> operation.predicate;\n    const sources = this.getPathSources(predicate);\n\n    const sVar = operation.subject.termType === 'Variable';\n    const oVar = operation.object.termType === 'Variable';\n\n    if (operation.subject.termType === 'Variable' && operation.object.termType === 'Variable') {\n      // Query ?s ?p ?o, to get all possible namedNodes in de the db\n      const predVar = this.generateVariable(dataFactory, operation);\n      const single = this.assignPatternSources(algebraFactory, algebraFactory\n        .createPattern(operation.subject, predVar, operation.object, operation.graph), sources);\n      const results = getSafeBindings(\n        await this.mediatorQueryOperation.mediate({ context, operation: single }),\n      );\n      const subjectVar = operation.subject;\n      const objectVar = operation.object;\n\n      // Set with all namedNodes we have already started a predicate* search from\n      const entities: Set<string> = new Set();\n\n      const termHashes = {};\n\n      const bindingsStream: MultiTransformIterator<Bindings, Bindings> = new MultiTransformIterator(\n        results.bindingsStream,\n        {\n          multiTransform: (bindings: Bindings) => {\n            // Get the subject and object of the triples (?s ?p ?o) and extract graph if it was a variable\n            const subject: RDF.Term = bindings.get(subjectVar)!;\n            const object: RDF.Term = bindings.get(objectVar)!;\n            const graph: RDF.Term = operation.graph.termType === 'Variable' ?\n              bindings.get(operation.graph)! :\n              operation.graph;\n            // Make a hash of namedNode + graph to remember from where we already started a search\n            const subjectGraphHash = termToString(subject) + termToString(graph);\n            const objectGraphHash = termToString(object) + termToString(graph);\n            return new TransformIterator<Bindings>(\n              async() => {\n                // If no new namedNodes in this triple, return nothing\n                if (entities.has(subjectGraphHash) && entities.has(objectGraphHash)) {\n                  return new EmptyIterator();\n                }\n                // Set up an iterator to which getSubjectAndObjectBindingsPredicateStar will push solutions\n                const it = new BufferedIterator<Bindings>();\n                const counter = { count: 0 };\n                // If not started from this namedNode (subject in triple) in this graph, start a search\n                if (!entities.has(subjectGraphHash)) {\n                  entities.add(subjectGraphHash);\n                  await this.getSubjectAndObjectBindingsPredicateStar(\n                    subjectVar,\n                    objectVar,\n                    subject,\n                    subject,\n                    predicate.path,\n                    graph,\n                    context,\n                    termHashes,\n                    {},\n                    it,\n                    counter,\n                    algebraFactory,\n                    bindingsFactory,\n                  );\n                }\n                // If not started from this namedNode (object in triple) in this graph, start a search\n                if (!entities.has(objectGraphHash)) {\n                  entities.add(objectGraphHash);\n                  await this.getSubjectAndObjectBindingsPredicateStar(\n                    subjectVar,\n                    objectVar,\n                    object,\n                    object,\n                    predicate.path,\n                    graph,\n                    context,\n                    termHashes,\n                    {},\n                    it,\n                    counter,\n                    algebraFactory,\n                    bindingsFactory,\n                  );\n                }\n                return it.map<Bindings>((item) => {\n                  // If the graph was a variable, fill in it's binding (we got it from the ?s ?p ?o binding)\n                  if (operation.graph.termType === 'Variable') {\n                    item = item.set(operation.graph, graph);\n                  }\n                  return item;\n                });\n              },\n              { autoStart: false, maxBufferSize: 128 },\n            );\n          },\n          autoStart: false,\n        },\n      );\n      const variables: MetadataVariable[] = (operation.graph.termType === 'Variable' ?\n          [ subjectVar, operation.object, operation.graph ] :\n          [ subjectVar, operation.object ])\n        .map(variable => ({ variable, canBeUndef: false }));\n      return {\n        type: 'bindings',\n        bindingsStream,\n        metadata: async() => ({ ...await results.metadata(), variables }),\n      };\n    }\n    if (!sVar && !oVar) {\n      const variable = this.generateVariable(dataFactory);\n      const starEval = await this.getObjectsPredicateStarEval(\n        operation.subject,\n        predicate.path,\n        variable,\n        operation.graph,\n        context,\n        true,\n        algebraFactory,\n        bindingsFactory,\n      );\n      const bindingsStream = starEval.bindingsStream.map<Bindings>((item) => {\n        if (operation.object.equals(item.get(variable))) {\n          return operation.graph.termType === 'Variable' ?\n            bindingsFactory.bindings([[ operation.graph, item.get(operation.graph)! ]]) :\n            bindingsFactory.bindings();\n        }\n        return null;\n      });\n      return {\n        type: 'bindings',\n        bindingsStream,\n        metadata: async() => ({\n          ...await starEval.metadata(),\n          variables: (operation.graph.termType === 'Variable' ? [ operation.graph ] : [])\n            .map(variable => ({ variable, canBeUndef: false })),\n        }),\n      };\n    }\n    // If (sVar || oVar)\n    const subject = sVar ? operation.object : operation.subject;\n    const value: RDF.Variable = <RDF.Variable> (sVar ? operation.subject : operation.object);\n    const pred = sVar ? algebraFactory.createInv(predicate.path) : predicate.path;\n    const starEval = await this.getObjectsPredicateStarEval(\n      subject,\n      pred,\n      value,\n      operation.graph,\n      context,\n      true,\n      algebraFactory,\n      bindingsFactory,\n    );\n    const variables = (operation.graph.termType === 'Variable' ? [ value, operation.graph ] : [ value ])\n      .map(variable => ({ variable, canBeUndef: false }));\n    return {\n      type: 'bindings',\n      bindingsStream: starEval.bindingsStream,\n      metadata: async() => ({ ...await starEval.metadata(), variables }),\n    };\n  }\n}\n\nexport interface IActorQueryOperationPathZeroOrMoreArgs extends IActorQueryOperationTypedMediatedArgs {\n  /**\n   * A mediator for creating binding context merge handlers\n   */\n  mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n}\n"]}