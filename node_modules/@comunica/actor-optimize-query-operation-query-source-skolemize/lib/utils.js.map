{"version":3,"file":"utils.js","sourceRoot":"","sources":["utils.ts"],"names":[],"mappings":";;;AAsBA,kCAOC;AAUD,sCASC;AASD,sCAMC;AASD,8CAWC;AASD,kDAcC;AASD,0DAcC;AAWD,0CAqBC;AAED,sEAmBC;AASD,0CAUC;AASD,oDA8BC;AAxOD,2DAAgF;AAChF,qEAA+D;AAG/D,yCAA2C;AAE9B,QAAA,aAAa,GAAG,6BAA6B,CAAC;AAE3D;;;;;GAKG;AACH,SAAgB,WAAW,CAAC,SAA4C,EAAE,MAAoB;IAC5F,IAAI,QAAQ,GAAG,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;IACpD,IAAI,QAAQ,KAAK,SAAS,EAAE,CAAC;QAC3B,QAAQ,GAAG,GAAG,SAAS,CAAC,IAAI,EAAE,CAAC;QAC/B,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;IACjD,CAAC;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED;;;;;;;GAOG;AACH,SAAgB,aAAa,CAC3B,WAAgC,EAChC,IAAc,EACd,QAAgB;IAEhB,IAAI,IAAI,CAAC,QAAQ,KAAK,WAAW,EAAE,CAAC;QAClC,OAAO,IAAI,oCAAe,CAAC,MAAM,QAAQ,IAAI,IAAI,CAAC,KAAK,EAAE,EAAE,WAAW,CAAC,SAAS,CAAC,GAAG,qBAAa,GAAG,QAAQ,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;IACjI,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;;;;GAMG;AACH,SAAgB,aAAa,CAC3B,WAAgC,EAChC,IAAO,EACP,QAAgB;IAEhB,OAAO,IAAA,0BAAc,EAAC,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;AAClF,CAAC;AAED;;;;;;GAMG;AACH,SAAgB,iBAAiB,CAC/B,WAAgC,EAChC,QAAsB,EACtB,QAAgB;IAEhB,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;QAC3B,IAAI,IAAI,CAAC,QAAQ,KAAK,MAAM,EAAE,CAAC;YAC7B,OAAO,aAAa,CAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;QACpD,CAAC;QACD,OAAO,aAAa,CAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;IACpD,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;;;;GAMG;AACH,SAAgB,mBAAmB,CACjC,WAAgC,EAChC,QAAiC,EACjC,QAAgB;IAEhB,MAAM,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;IAC7E,SAAS,eAAe;QACtB,QAAQ,CAAC,WAAW,CAAC,UAAU,EAAE,CAAC,QAAuB,EAAE,EAAE;YAC3D,GAAG,CAAC,WAAW,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;YACtC,QAAQ,CAAC,KAAK,CAAC,qBAAqB,CAAC,eAAe,CAAC,CAAC;QACxD,CAAC,CAAC,CAAC;IACL,CAAC;IACD,eAAe,EAAE,CAAC;IAClB,OAAO,GAAG,CAAC;AACb,CAAC;AAED;;;;;;GAMG;AACH,SAAgB,uBAAuB,CACrC,WAAgC,EAChC,QAAwB,EACxB,QAAgB;IAEhB,MAAM,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,iBAAiB,CAAC,WAAW,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC,CAAC;IACzF,SAAS,eAAe;QACtB,QAAQ,CAAC,WAAW,CAAC,UAAU,EAAE,CAAC,QAA0B,EAAE,EAAE;YAC9D,GAAG,CAAC,WAAW,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;YACtC,QAAQ,CAAC,KAAK,CAAC,qBAAqB,CAAC,eAAe,CAAC,CAAC;QACxD,CAAC,CAAC,CAAC;IACL,CAAC;IACD,eAAe,EAAE,CAAC;IAClB,OAAO,GAAG,CAAC;AACb,CAAC;AAED;;;;;;;;GAQG;AACH,SAAgB,eAAe,CAC7B,WAAgC,EAChC,IAAc,EACd,QAAgB;IAEhB,IAAI,IAAI,CAAC,QAAQ,KAAK,WAAW,IAAI,YAAY,IAAI,IAAI,EAAE,CAAC;QAC1D,IAAI,GAAsB,IAAK,CAAC,UAAU,CAAC;IAC7C,CAAC;IACD,IAAI,IAAI,CAAC,QAAQ,KAAK,WAAW,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,qBAAa,CAAC,EAAE,CAAC;QAC1E,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,qBAAa,CAAC,MAAM,CAAC,CAAC;QACrE,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,qBAAa,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;QAC5E,2BAA2B;QAC3B,IAAI,YAAY,KAAK,QAAQ,EAAE,CAAC;YAC9B,kCAAkC;YAClC,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,cAAc,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YAC1E,OAAO,WAAW,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;QAC1C,CAAC;QACD,kCAAkC;QAClC,OAAO,IAAI,CAAC;IACd,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAgB,6BAA6B,CAC3C,WAAgC,EAChC,IAAc,EACd,QAAgB;IAEhB,IAAI,IAAI,CAAC,QAAQ,KAAK,MAAM,EAAE,CAAC;QAC7B,OAAO,IAAA,0BAAc,EAAC,IAAI,EAAE,CAAC,OAAO,EAAE,EAAE;YACtC,MAAM,YAAY,GAAG,eAAe,CAAC,WAAW,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;YACrE,IAAI,CAAC,YAAY,EAAE,CAAC;gBAClB,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;YACrE,CAAC;YACD,OAAO,YAAY,CAAC;QACtB,CAAC,CAAC,CAAC;IACL,CAAC;IACD,MAAM,GAAG,GAAG,eAAe,CAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;IACzD,IAAI,GAAG,KAAK,IAAI,EAAE,CAAC;QACjB,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;IACrE,CAAC;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAED;;;;;;GAMG;AACH,SAAgB,eAAe,CAC7B,WAAgC,EAChC,IAAO,EACP,QAAgB;IAEhB,OAAO,IAAA,0BAAc,EAAC,IAAI,EAAE,CAAC,IAAc,EAAY,EAAE;QACvD,MAAM,OAAO,GAAG,eAAe,CAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;QAC7D,6EAA6E;QAC7E,OAAO,OAAO,IAAI,IAAI,CAAC;IACzB,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;;;;GAMG;AACH,SAAgB,oBAAoB,CAClC,WAAgC,EAChC,SAAY,EACZ,QAAgB;IAEhB,MAAM,OAAO,GAAG,IAAI,8BAAc,EAAE,CAAC;IACrC,IAAI,CAAC;QACH,OAAW,4BAAY,CAAC,YAAY,CAAC,SAAS,EAAE;YAC9C,CAAC,uBAAO,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE;gBACvB,UAAU,EAAE,GAAG,EAAE,CAAC,CAAC,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC;gBACvC,SAAS,EAAE,EAAE,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,aAAa,CAClD,6BAA6B,CAAC,WAAW,EAAE,EAAE,CAAC,OAAO,EAAE,QAAQ,CAAC,EAChE,6BAA6B,CAAC,WAAW,EAAE,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,EAClE,6BAA6B,CAAC,WAAW,EAAE,EAAE,CAAC,MAAM,EAAE,QAAQ,CAAC,EAC/D,6BAA6B,CAAC,WAAW,EAAE,EAAE,CAAC,KAAK,EAAE,QAAQ,CAAC,CAC/D,EAAE,EAAE,QAAQ,EAAE,EAAE,CAAC,QAAQ,EAAE,CAAC;aAC9B;YACD,CAAC,uBAAO,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;gBACpB,UAAU,EAAE,GAAG,EAAE,CAAC,CAAC,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC;gBACvC,SAAS,EAAE,EAAE,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,CAC/C,6BAA6B,CAAC,WAAW,EAAE,EAAE,CAAC,OAAO,EAAE,QAAQ,CAAC,EAChE,EAAE,CAAC,SAAS,EACZ,6BAA6B,CAAC,WAAW,EAAE,EAAE,CAAC,MAAM,EAAE,QAAQ,CAAC,EAC/D,6BAA6B,CAAC,WAAW,EAAE,EAAE,CAAC,KAAK,EAAE,QAAQ,CAAC,CAC/D,EAAE,EAAE,QAAQ,EAAE,EAAE,CAAC,QAAQ,EAAE,CAAC;aAC9B;SACF,CAAC,CAAC;IACL,CAAC;IAAC,MAAM,CAAC;QACP,qEAAqE;IACvE,CAAC;AACH,CAAC","sourcesContent":["import type {\n  BindingsStream,\n  ComunicaDataFactory,\n  IQuerySource,\n  MetadataBindings,\n  MetadataQuads,\n  QuerySourceReference,\n} from '@comunica/types';\nimport { Algebra, AlgebraFactory, algebraUtils } from '@comunica/utils-algebra';\nimport { BlankNodeScoped } from '@comunica/utils-data-factory';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { mapTermsNested } from 'rdf-terms';\n\nexport const SKOLEM_PREFIX = 'urn:comunica_skolem:source_';\n\n/**\n * Get the unique, deterministic id for the given source.\n * @param sourceIds ID's of datasources, see KeysRdfResolveQuadPattern.sourceIds.\n * @param source A data source.\n * @return The id of the given source.\n */\nexport function getSourceId(sourceIds: Map<QuerySourceReference, string>, source: IQuerySource): string {\n  let sourceId = sourceIds.get(source.referenceValue);\n  if (sourceId === undefined) {\n    sourceId = `${sourceIds.size}`;\n    sourceIds.set(source.referenceValue, sourceId);\n  }\n  return sourceId;\n}\n\n/**\n * If the given term is a blank node, return a deterministic named node for it\n * based on the source id and the blank node value.\n * @param dataFactory The data factory.\n * @param term Any RDF term.\n * @param sourceId A source identifier.\n * @return If the given term was a blank node, this will return a skolemized named node, otherwise the original term.\n */\nexport function skolemizeTerm(\n  dataFactory: ComunicaDataFactory,\n  term: RDF.Term,\n  sourceId: string,\n): RDF.Term | BlankNodeScoped {\n  if (term.termType === 'BlankNode') {\n    return new BlankNodeScoped(`bc_${sourceId}_${term.value}`, dataFactory.namedNode(`${SKOLEM_PREFIX}${sourceId}:${term.value}`));\n  }\n  return term;\n}\n\n/**\n * Skolemize all terms in the given quad.\n * @param dataFactory The data factory.\n * @param quad An RDF quad.\n * @param sourceId A source identifier.\n * @return The skolemized quad.\n */\nexport function skolemizeQuad<Q extends RDF.BaseQuad = RDF.Quad>(\n  dataFactory: ComunicaDataFactory,\n  quad: Q,\n  sourceId: string,\n): Q {\n  return mapTermsNested(quad, term => skolemizeTerm(dataFactory, term, sourceId));\n}\n\n/**\n * Skolemize all terms in the given bindings.\n * @param dataFactory The data factory.\n * @param bindings An RDF bindings object.\n * @param sourceId A source identifier.\n * @return The skolemized bindings.\n */\nexport function skolemizeBindings(\n  dataFactory: ComunicaDataFactory,\n  bindings: RDF.Bindings,\n  sourceId: string,\n): RDF.Bindings {\n  return bindings.map((term) => {\n    if (term.termType === 'Quad') {\n      return skolemizeQuad(dataFactory, term, sourceId);\n    }\n    return skolemizeTerm(dataFactory, term, sourceId);\n  });\n}\n\n/**\n * Skolemize all terms in the given quad stream.\n * @param dataFactory The data factory.\n * @param iterator An RDF quad stream.\n * @param sourceId A source identifier.\n * @return The skolemized quad stream.\n */\nexport function skolemizeQuadStream(\n  dataFactory: ComunicaDataFactory,\n  iterator: AsyncIterator<RDF.Quad>,\n  sourceId: string,\n): AsyncIterator<RDF.Quad> {\n  const ret = iterator.map(quad => skolemizeQuad(dataFactory, quad, sourceId));\n  function inheritMetadata(): void {\n    iterator.getProperty('metadata', (metadata: MetadataQuads) => {\n      ret.setProperty('metadata', metadata);\n      metadata.state.addInvalidateListener(inheritMetadata);\n    });\n  }\n  inheritMetadata();\n  return ret;\n}\n\n/**\n * Skolemize all terms in the given bindings stream.\n * @param dataFactory The data factory.\n * @param iterator An RDF bindings stream.\n * @param sourceId A source identifier.\n * @return The skolemized bindings stream.\n */\nexport function skolemizeBindingsStream(\n  dataFactory: ComunicaDataFactory,\n  iterator: BindingsStream,\n  sourceId: string,\n): BindingsStream {\n  const ret = iterator.map(bindings => skolemizeBindings(dataFactory, bindings, sourceId));\n  function inheritMetadata(): void {\n    iterator.getProperty('metadata', (metadata: MetadataBindings) => {\n      ret.setProperty('metadata', metadata);\n      metadata.state.addInvalidateListener(inheritMetadata);\n    });\n  }\n  inheritMetadata();\n  return ret;\n}\n\n/**\n * If a given term was a skolemized named node for the given source id,\n * deskolemize it again to a blank node.\n * If the given term was a skolemized named node for another source, return false.\n * If the given term was not a skolemized named node, return the original term.\n * @param dataFactory The data factory.\n * @param term Any RDF term.\n * @param sourceId A source identifier.\n */\nexport function deskolemizeTerm(\n  dataFactory: ComunicaDataFactory,\n  term: RDF.Term,\n  sourceId: string,\n): RDF.Term | null {\n  if (term.termType === 'BlankNode' && 'skolemized' in term) {\n    term = (<BlankNodeScoped> term).skolemized;\n  }\n  if (term.termType === 'NamedNode' && term.value.startsWith(SKOLEM_PREFIX)) {\n    const colonSeparator = term.value.indexOf(':', SKOLEM_PREFIX.length);\n    const termSourceId = term.value.slice(SKOLEM_PREFIX.length, colonSeparator);\n    // We had a skolemized term\n    if (termSourceId === sourceId) {\n      // It came from the correct source\n      const termLabel = term.value.slice(colonSeparator + 1, term.value.length);\n      return dataFactory.blankNode(termLabel);\n    }\n    // It came from a different source\n    return null;\n  }\n  return term;\n}\n\nexport function deskolemizeTermNestedThrowing(\n  dataFactory: ComunicaDataFactory,\n  term: RDF.Term,\n  sourceId: string,\n): RDF.Term {\n  if (term.termType === 'Quad') {\n    return mapTermsNested(term, (subTerm) => {\n      const deskolemized = deskolemizeTerm(dataFactory, subTerm, sourceId);\n      if (!deskolemized) {\n        throw new Error(`Skolemized term is not in scope for this source`);\n      }\n      return deskolemized;\n    });\n  }\n  const ret = deskolemizeTerm(dataFactory, term, sourceId);\n  if (ret === null) {\n    throw new Error(`Skolemized term is not in scope for this source`);\n  }\n  return ret;\n}\n\n/**\n * Deskolemize all terms in the given quad.\n * @param dataFactory The data factory.\n * @param quad An RDF quad.\n * @param sourceId A source identifier.\n * @return The deskolemized quad.\n */\nexport function deskolemizeQuad<Q extends RDF.BaseQuad = RDF.Quad>(\n  dataFactory: ComunicaDataFactory,\n  quad: Q,\n  sourceId: string,\n): Q {\n  return mapTermsNested(quad, (term: RDF.Term): RDF.Term => {\n    const newTerm = deskolemizeTerm(dataFactory, term, sourceId);\n    // If the term was skolemized in a different source then don't deskolemize it\n    return newTerm ?? term;\n  });\n}\n\n/**\n * Deskolemize all terms in the given quad.\n * Will return undefined if there is at least one blank node not in scope for this sourceId.\n * @param dataFactory The data factory.\n * @param operation An algebra operation.\n * @param sourceId A source identifier.\n */\nexport function deskolemizeOperation<O extends Algebra.Operation>(\n  dataFactory: ComunicaDataFactory,\n  operation: O,\n  sourceId: string,\n): O | undefined {\n  const factory = new AlgebraFactory();\n  try {\n    return <O> algebraUtils.mapOperation(operation, {\n      [Algebra.Types.PATTERN]: {\n        preVisitor: () => ({ continue: false }),\n        transform: op => Object.assign(factory.createPattern(\n          deskolemizeTermNestedThrowing(dataFactory, op.subject, sourceId),\n          deskolemizeTermNestedThrowing(dataFactory, op.predicate, sourceId),\n          deskolemizeTermNestedThrowing(dataFactory, op.object, sourceId),\n          deskolemizeTermNestedThrowing(dataFactory, op.graph, sourceId),\n        ), { metadata: op.metadata }),\n      },\n      [Algebra.Types.PATH]: {\n        preVisitor: () => ({ continue: false }),\n        transform: op => Object.assign(factory.createPath(\n          deskolemizeTermNestedThrowing(dataFactory, op.subject, sourceId),\n          op.predicate,\n          deskolemizeTermNestedThrowing(dataFactory, op.object, sourceId),\n          deskolemizeTermNestedThrowing(dataFactory, op.graph, sourceId),\n        ), { metadata: op.metadata }),\n      },\n    });\n  } catch {\n    // Return undefined for skolemized terms not in scope for this source\n  }\n}\n"]}