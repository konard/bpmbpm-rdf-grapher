import type { MediatorHttp } from '@comunica/bus-http';
import type { MediatorMergeBindingsContext } from '@comunica/bus-merge-bindings-context';
import type { MediatorQuerySerialize } from '@comunica/bus-query-serialize';
import type { IActionQuerySourceIdentifyHypermedia, IActorQuerySourceIdentifyHypermediaOutput, IActorQuerySourceIdentifyHypermediaArgs, IActorQuerySourceIdentifyHypermediaTest } from '@comunica/bus-query-source-identify-hypermedia';
import { ActorQuerySourceIdentifyHypermedia } from '@comunica/bus-query-source-identify-hypermedia';
import type { TestResult } from '@comunica/core';
/**
 * A comunica SPARQL Query Source Identify Hypermedia Actor.
 */
export declare class ActorQuerySourceIdentifyHypermediaSparql extends ActorQuerySourceIdentifyHypermedia {
    readonly mediatorHttp: MediatorHttp;
    readonly mediatorMergeBindingsContext: MediatorMergeBindingsContext;
    readonly mediatorQuerySerialize: MediatorQuerySerialize;
    readonly checkUrlSuffix: boolean;
    readonly forceHttpGet: boolean;
    readonly cacheSize: number;
    readonly forceSourceType: boolean;
    readonly bindMethod: BindMethod;
    readonly countTimeout: number;
    readonly cardinalityCountQueries: boolean;
    readonly cardinalityEstimateConstruction: boolean;
    readonly forceGetIfUrlLengthBelow: number;
    constructor(args: IActorQuerySourceIdentifyHypermediaSparqlArgs);
    testMetadata(action: IActionQuerySourceIdentifyHypermedia): Promise<TestResult<IActorQuerySourceIdentifyHypermediaTest>>;
    run(action: IActionQuerySourceIdentifyHypermedia): Promise<IActorQuerySourceIdentifyHypermediaOutput>;
}
export interface IActorQuerySourceIdentifyHypermediaSparqlArgs extends IActorQuerySourceIdentifyHypermediaArgs {
    /**
     * The HTTP mediator
     */
    mediatorHttp: MediatorHttp;
    /**
     * A mediator for creating binding context merge handlers
     */
    mediatorMergeBindingsContext: MediatorMergeBindingsContext;
    /**
     * Mediator for serializing queries.
     */
    mediatorQuerySerialize: MediatorQuerySerialize;
    /**
     * If URLs ending with '/sparql' should also be considered SPARQL endpoints.
     * @default {true}
     */
    checkUrlSuffix: boolean;
    /**
     * If non-update queries should be sent via HTTP GET instead of POST
     * @default {false}
     */
    forceHttpGet: boolean;
    /**
     * The cache size for COUNT queries.
     * @range {integer}
     * @default {1024}
     */
    cacheSize: number;
    /**
     * If provided, forces the source type of a source.
     * @default {false}
     */
    forceSourceType?: boolean;
    /**
     * The query operation for communicating bindings.
     * @default {values}
     */
    bindMethod: BindMethod;
    /**
     * Timeout in ms of how long count queries are allowed to take.
     * If the timeout is reached, an infinity cardinality is returned.
     * @default {3000}
     */
    countTimeout: number;
    /**
     * If count queries should be sent to obtain the cardinality of (sub)queries.
     * If set to false, resulting cardinalities will always be considered infinity.
     * @default {true}
     */
    cardinalityCountQueries: boolean;
    /**
     * If estimates for queries should be constructed locally from sub-query cardinalities.
     * If set to false, count queries will used for cardinality estimation at all levels.
     * @default {false}
     */
    cardinalityEstimateConstruction: boolean;
    /**
     * Force an HTTP GET instead of default POST (when forceHttpGet is false)
     * when the url length (including encoded query) is below this number.
     * @default {600}
     */
    forceGetIfUrlLengthBelow: number;
}
export type BindMethod = 'values' | 'union' | 'filter';
