{"version":3,"file":"QuerySourceSparql.js","sourceRoot":"","sources":["QuerySourceSparql.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MediatorHttp } from '@comunica/bus-http';\nimport type { MediatorQuerySerialize } from '@comunica/bus-query-serialize';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport { Actor } from '@comunica/core';\nimport type {\n  Bindings,\n  BindingsStream,\n  ComunicaDataFactory,\n  FragmentSelectorShape,\n  IActionContext,\n  IDataset,\n  IQueryBindingsOptions,\n  IQuerySource,\n  MetadataBindings,\n  MetadataVariable,\n  QueryResultCardinality,\n} from '@comunica/types';\nimport type { AlgebraFactory } from '@comunica/utils-algebra';\nimport { Algebra, algebraUtils, isKnownOperation } from '@comunica/utils-algebra';\nimport type { BindingsFactory } from '@comunica/utils-bindings-factory';\nimport { MetadataValidationState } from '@comunica/utils-metadata';\nimport { estimateCardinality } from '@comunica/utils-query-operation';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { TransformIterator, wrap } from 'asynciterator';\nimport { SparqlEndpointFetcher } from 'fetch-sparql-endpoint';\nimport { LRUCache } from 'lru-cache';\nimport { uniqTerms } from 'rdf-terms';\nimport type { BindMethod } from './ActorQuerySourceIdentifyHypermediaSparql';\n\nexport class QuerySourceSparql implements IQuerySource {\n  public readonly referenceValue: string;\n  private url: string;\n  private readonly urlBackup: string;\n  private readonly context: IActionContext;\n  private readonly mediatorHttp: MediatorHttp;\n  private readonly mediatorQuerySerialize: MediatorQuerySerialize;\n  private readonly bindMethod: BindMethod;\n  private readonly countTimeout: number;\n  private readonly cardinalityCountQueries: boolean;\n  private readonly cardinalityEstimateConstruction: boolean;\n  private readonly defaultGraph?: string;\n  private readonly unionDefaultGraph: boolean;\n  private readonly propertyFeatures?: Set<string>;\n  private readonly datasets?: IDataset[];\n  public readonly extensionFunctions?: string[];\n  private readonly dataFactory: ComunicaDataFactory;\n  private readonly algebraFactory: AlgebraFactory;\n  private readonly bindingsFactory: BindingsFactory;\n\n  private readonly endpointFetcher: SparqlEndpointFetcher;\n  private readonly cache: LRUCache<string, QueryResultCardinality> | undefined;\n\n  private lastSourceContext: IActionContext | undefined;\n\n  public constructor(\n    url: string,\n    urlBackup: string,\n    context: IActionContext,\n    mediatorHttp: MediatorHttp,\n    mediatorQuerySerialize: MediatorQuerySerialize,\n    bindMethod: BindMethod,\n    dataFactory: ComunicaDataFactory,\n    algebraFactory: AlgebraFactory,\n    bindingsFactory: BindingsFactory,\n    forceHttpGet: boolean,\n    cacheSize: number,\n    countTimeout: number,\n    cardinalityCountQueries: boolean,\n    cardinalityEstimateConstruction: boolean,\n    forceGetIfUrlLengthBelow: number,\n    parseUnsupportedVersions: boolean,\n    metadata: Record<string, any>,\n  ) {\n    this.referenceValue = urlBackup;\n    this.url = url;\n    this.urlBackup = urlBackup;\n    this.context = context;\n    this.mediatorHttp = mediatorHttp;\n    this.mediatorQuerySerialize = mediatorQuerySerialize;\n    this.bindMethod = bindMethod;\n    this.dataFactory = dataFactory;\n    this.algebraFactory = algebraFactory;\n    this.bindingsFactory = bindingsFactory;\n    this.endpointFetcher = new SparqlEndpointFetcher({\n      method: forceHttpGet ? 'GET' : 'POST',\n      fetch: async(input: Request | string, init?: RequestInit) => {\n        const response = await this.mediatorHttp.mediate(\n          { input, init, context: this.lastSourceContext! },\n        );\n        // If we encounter a 404, try our backup URL.\n        // After retrying the request with the new URL, we replace the URL for future requests.\n        if (response.status === 404 && this.url !== this.urlBackup) {\n          Actor.getContextLogger(this.context)?.warn(`Encountered a 404 when requesting ${this.url} according to the service description of ${this.urlBackup}. This is a server configuration issue. Retrying the current and modifying future requests to ${this.urlBackup} instead.`);\n          input = (<string> input).replace(this.url, this.urlBackup);\n          this.url = this.urlBackup;\n          return await this.mediatorHttp.mediate(\n            { input, init, context: this.lastSourceContext! },\n          );\n        }\n        return response;\n      },\n      prefixVariableQuestionMark: true,\n      dataFactory,\n      forceGetIfUrlLengthBelow,\n      directPost: metadata.postAccepted && !metadata.postAccepted.includes('application/x-www-form-urlencoded'),\n      parseUnsupportedVersions,\n    });\n    this.cache = cacheSize > 0 ?\n      new LRUCache<string, QueryResultCardinality>({ max: cacheSize }) :\n      undefined;\n    this.countTimeout = countTimeout;\n    this.cardinalityCountQueries = cardinalityCountQueries;\n    this.cardinalityEstimateConstruction = cardinalityEstimateConstruction;\n    this.defaultGraph = metadata.defaultGraph;\n    this.unionDefaultGraph = metadata.unionDefaultGraph ?? false;\n    this.datasets = metadata.datasets;\n    this.extensionFunctions = metadata.extensionFunctions;\n    this.propertyFeatures = metadata.propertyFeatures ? new Set(metadata.propertyFeatures) : undefined;\n  }\n\n  public async getFilterFactor(): Promise<number> {\n    return 1;\n  }\n\n  public async getSelectorShape(): Promise<FragmentSelectorShape> {\n    const innerDisjunction: FragmentSelectorShape = {\n      type: 'disjunction',\n      children: [\n        {\n          type: 'operation',\n          operation: { operationType: 'wildcard' },\n          joinBindings: true,\n        },\n      ],\n    };\n    if (this.extensionFunctions) {\n      innerDisjunction.children.push({\n        type: 'operation',\n        operation: {\n          operationType: 'type',\n          type: Algebra.Types.EXPRESSION,\n          extensionFunctions: this.extensionFunctions,\n        },\n        joinBindings: true,\n      });\n    }\n    return {\n      type: 'conjunction',\n      children: [\n        innerDisjunction,\n        {\n          // DISTINCT CONSTRUCT is not allowed in SPARQL 1.1, so we explicitly disallowed it.\n          type: 'negation',\n          child: {\n            type: 'operation',\n            operation: { operationType: 'type', type: Algebra.Types.DISTINCT },\n            children: [\n              {\n                type: 'operation',\n                operation: { operationType: 'type', type: Algebra.Types.CONSTRUCT },\n                children: [\n                  {\n                    type: 'operation',\n                    operation: { operationType: 'wildcard' },\n                    joinBindings: true,\n                  },\n                ],\n              },\n            ],\n          },\n        },\n      ],\n    };\n  }\n\n  public queryBindings(\n    operationIn: Algebra.Operation,\n    context: IActionContext,\n    options?: IQueryBindingsOptions,\n  ): BindingsStream {\n    // If bindings are passed, modify the operations\n    let operationPromise: Promise<Algebra.Operation>;\n    if (options?.joinBindings) {\n      operationPromise = QuerySourceSparql.addBindingsToOperation(\n        this.algebraFactory,\n        this.bindMethod,\n        operationIn,\n        options.joinBindings,\n      );\n    } else {\n      operationPromise = Promise.resolve(operationIn);\n    }\n\n    const bindings: BindingsStream = new TransformIterator(async() => {\n      // Prepare queries\n      const operation = await operationPromise;\n      const variables: RDF.Variable[] = algebraUtils.inScopeVariables(operation);\n      const queryString = context.get<string>(KeysInitQuery.queryString);\n      const queryFormat: RDF.QueryFormat = context.getSafe(KeysInitQuery.queryFormat);\n      const selectQuery: string = !options?.joinBindings && queryString && queryFormat.language === 'sparql' ?\n        queryString :\n        await this.operationToSelectQuery(this.algebraFactory, operation, variables);\n      const undefVariables = QuerySourceSparql.getOperationUndefs(operation);\n\n      return this.queryBindingsRemote(this.url, selectQuery, variables, context, undefVariables);\n    }, { autoStart: false });\n    this.attachMetadata(bindings, context, operationPromise);\n\n    return bindings;\n  }\n\n  public queryQuads(operation: Algebra.Operation, context: IActionContext): AsyncIterator<RDF.Quad> {\n    const quads = wrap<any>((async() => {\n      this.lastSourceContext = this.context.merge(context);\n      const query: string = context.get(KeysInitQuery.queryString) ?? await this.operationToQuery(operation);\n      const rawStream = await this.endpointFetcher.fetchTriples(this.url, query);\n      return rawStream;\n    })(), { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY });\n    this.attachMetadata(quads, context, Promise.resolve((<Algebra.Operation & { input: any }>operation).input));\n    return quads;\n  }\n\n  public async queryBoolean(operation: Algebra.Ask, context: IActionContext): Promise<boolean> {\n    // Shortcut the ASK query to return true when supported propertyFeature predicates are used in it.\n    if (this.operationUsesPropertyFeatures(operation)) {\n      return true;\n    }\n    // Without propertyFeature overlap, perform the actual ASK query.\n    this.lastSourceContext = this.context.merge(context);\n    const query: string = context.get(KeysInitQuery.queryString) ?? await this.operationToQuery(operation);\n    const promise = this.endpointFetcher.fetchAsk(this.url, query);\n    return promise;\n  }\n\n  public async queryVoid(operation: Algebra.Operation, context: IActionContext): Promise<void> {\n    this.lastSourceContext = this.context.merge(context);\n    const query: string = context.get(KeysInitQuery.queryString) ?? await this.operationToQuery(operation);\n    const promise = this.endpointFetcher.fetchUpdate(this.url, query);\n    return promise;\n  }\n\n  protected attachMetadata(\n    target: AsyncIterator<any>,\n    context: IActionContext,\n    operationPromise: Promise<Algebra.Operation>,\n  ): void {\n    // Emit metadata containing the estimated count\n    let variablesCount: MetadataVariable[] = [];\n    // eslint-disable-next-line no-async-promise-executor,ts/no-misused-promises\n    new Promise<QueryResultCardinality>(async(resolve, reject) => {\n      try {\n        const operation = await operationPromise;\n        const variablesScoped = algebraUtils.inScopeVariables(operation);\n        const countQuery = await this.operationToNormalizedCountQuery(operation);\n\n        const undefVariables = QuerySourceSparql.getOperationUndefs(operation);\n        variablesCount = variablesScoped.map(variable => ({\n          variable,\n          canBeUndef: undefVariables.some(undefVariable => undefVariable.equals(variable)),\n        }));\n\n        const cachedCardinality = this.cache?.get(countQuery);\n        if (cachedCardinality) {\n          return resolve(cachedCardinality);\n        }\n\n        // Attempt to estimate locally prior to sending a COUNT request, as this should be much faster.\n        // The estimates may be off by varying amounts, so this is set behind a configuration flag.\n        if (this.cardinalityEstimateConstruction) {\n          const localEstimate = await this.estimateOperationCardinality(operation);\n          if (Number.isFinite(localEstimate.value)) {\n            this.cache?.set(countQuery, localEstimate);\n            return resolve(localEstimate);\n          }\n        }\n\n        // Don't send count queries if disabled.\n        if (!this.cardinalityCountQueries) {\n          return resolve({ type: 'estimate', value: Number.POSITIVE_INFINITY, dataset: this.url });\n        }\n\n        const timeoutHandler = setTimeout(() => resolve({\n          type: 'estimate',\n          value: Number.POSITIVE_INFINITY,\n          dataset: this.url,\n        }), this.countTimeout);\n        const varCount = this.dataFactory.variable('count');\n        const bindingsStream: BindingsStream = await this\n          .queryBindingsRemote(this.url, countQuery, [ varCount ], context, []);\n        bindingsStream\n          .on('data', (bindings: Bindings) => {\n            clearTimeout(timeoutHandler);\n            const count = bindings.get(varCount);\n            const cardinality: QueryResultCardinality = {\n              type: 'estimate',\n              value: Number.POSITIVE_INFINITY,\n              dataset: this.url,\n            };\n            if (count) {\n              const cardinalityValue: number = Number.parseInt(count.value, 10);\n              if (!Number.isNaN(cardinalityValue)) {\n                cardinality.type = 'exact';\n                cardinality.value = cardinalityValue;\n                this.cache?.set(countQuery, cardinality);\n              }\n            }\n            return resolve(cardinality);\n          })\n          .on('error', () => {\n            clearTimeout(timeoutHandler);\n            resolve({ type: 'estimate', value: Number.POSITIVE_INFINITY, dataset: this.url });\n          })\n          .on('end', () => {\n            clearTimeout(timeoutHandler);\n            resolve({ type: 'estimate', value: Number.POSITIVE_INFINITY, dataset: this.url });\n          });\n      } catch (error: unknown) {\n        reject(error);\n      }\n    })\n      .then(cardinality => target.setProperty('metadata', {\n        state: new MetadataValidationState(),\n        cardinality,\n        variables: variablesCount,\n      }))\n      .catch(() => target.setProperty('metadata', {\n        state: new MetadataValidationState(),\n        cardinality: { type: 'estimate', value: Number.POSITIVE_INFINITY, dataset: this.url },\n        variables: variablesCount,\n      }));\n  }\n\n  /**\n   * Convert an algebra operation into a query string, and if the operation is a simple triple pattern,\n   * then also replace any variables with s, p, and o to increase the chance of cache hits.\n   * @param {Algebra.Operation} operation The operation to convert into a query string.\n   * @returns {string} Query string for a COUNT query over the operation.\n   */\n  public async operationToNormalizedCountQuery(operation: Algebra.Operation): Promise<string> {\n    const normalizedOperation = isKnownOperation(operation, Algebra.Types.PATTERN) ?\n      this.algebraFactory.createPattern(\n        operation.subject.termType === 'Variable' ? this.dataFactory.variable('s') : operation.subject,\n        operation.predicate.termType === 'Variable' ? this.dataFactory.variable('p') : operation.predicate,\n        operation.object.termType === 'Variable' ? this.dataFactory.variable('o') : operation.object,\n      ) :\n      operation;\n    return await this.operationToCountQuery(\n      this.dataFactory,\n      this.algebraFactory,\n      normalizedOperation,\n    );\n  }\n\n  /**\n   * Performs local cardinality estimation for the specified SPARQL algebra operation, which should\n   * result in better estimation performance at the expense of accuracy.\n   * @param {Algebra.Operation} operation A query operation.\n   */\n  public async estimateOperationCardinality(operation: Algebra.Operation): Promise<QueryResultCardinality> {\n    if (this.operationUsesPropertyFeatures(operation)) {\n      return { type: 'estimate', value: 1, dataset: this.url };\n    }\n\n    const dataset: IDataset = {\n      getCardinality: async(operation: Algebra.Operation): Promise<QueryResultCardinality | undefined> => {\n        const queryString = await this.operationToNormalizedCountQuery(operation);\n\n        const cachedCardinality = this.cache?.get(queryString);\n        if (cachedCardinality) {\n          return cachedCardinality;\n        }\n\n        if (this.datasets) {\n          const cardinalities = await Promise.all(this.datasets\n            .filter(ds => this.unionDefaultGraph || (this.defaultGraph && ds.uri.endsWith(this.defaultGraph)))\n            .map(ds => estimateCardinality(operation, ds)));\n\n          const cardinality: QueryResultCardinality = {\n            type: cardinalities.some(card => card.type === 'estimate') ? 'estimate' : 'exact',\n            value: cardinalities.length > 0 ? cardinalities.reduce((acc, card) => acc + card.value, 0) : 0,\n            dataset: this.url,\n          };\n\n          return cardinality;\n        }\n      },\n      source: this.url,\n      uri: this.url,\n    };\n\n    return estimateCardinality(operation, dataset);\n  }\n\n  /**\n   * Checks whether the provided operation makes use of this endpoint's property features,\n   * if the endpoint has property features detected.\n   * @param {Algebra.Operation} operation The operation to check.\n   * @returns {boolean} Whether the operation makes use of property features.\n   */\n  public operationUsesPropertyFeatures(operation: Algebra.Operation): boolean {\n    let propertyFeaturesUsed = false;\n    if (this.propertyFeatures) {\n      algebraUtils.visitOperation(operation, {\n        [Algebra.Types.PATTERN]: {\n          visitor: (subOp) => {\n            if (subOp.predicate.termType === 'NamedNode' && this.propertyFeatures!.has(subOp.predicate.value)) {\n              propertyFeaturesUsed = true;\n            }\n            return false;\n          },\n        },\n        [Algebra.Types.LINK]: {\n          visitor: (subOp) => {\n            if (this.propertyFeatures!.has(subOp.iri.value)) {\n              propertyFeaturesUsed = true;\n            }\n            return false;\n          },\n        },\n        [Algebra.Types.NPS]: {\n          visitor: (subOp) => {\n            if (subOp.iris.some(iri => this.propertyFeatures!.has(iri.value))) {\n              propertyFeaturesUsed = true;\n            }\n            return false;\n          },\n        },\n      });\n    }\n    return propertyFeaturesUsed;\n  }\n\n  /**\n   * Create an operation that includes the bindings from the given bindings stream.\n   * @param algebraFactory The algebra factory.\n   * @param bindMethod A method for adding bindings to an operation.\n   * @param operation The operation to bind to.\n   * @param addBindings The bindings to add.\n   * @param addBindings.bindings The bindings stream.\n   * @param addBindings.metadata The bindings metadata.\n   */\n  public static async addBindingsToOperation(\n    algebraFactory: AlgebraFactory,\n    bindMethod: BindMethod,\n    operation: Algebra.Operation,\n    addBindings: { bindings: BindingsStream; metadata: MetadataBindings },\n  ): Promise<Algebra.Operation> {\n    const bindings = await addBindings.bindings.toArray();\n\n    switch (bindMethod) {\n      case 'values':\n        return algebraFactory.createJoin([\n          algebraFactory.createValues(\n            addBindings.metadata.variables.map(v => v.variable),\n            bindings.map(binding => Object.fromEntries([ ...binding ]\n              .map(([ key, value ]) => [ key.value, <RDF.Literal | RDF.NamedNode> value ]))),\n          ),\n          operation,\n        ], false);\n      case 'union': { throw new Error('Not implemented yet: \"union\" case'); }\n      case 'filter': { throw new Error('Not implemented yet: \"filter\" case'); }\n    }\n  }\n\n  /**\n   * Convert an operation to a select query for this pattern.\n   * @param algebraFactory The algebra factory.\n   * @param {Algebra.Operation} operation A query operation.\n   * @param {RDF.Variable[]} variables The variables in scope for the operation.\n   * @return {string} A select query string.\n   */\n  public operationToSelectQuery(\n    algebraFactory: AlgebraFactory,\n    operation: Algebra.Operation,\n    variables: RDF.Variable[],\n  ): Promise<string> {\n    return this.operationToQuery(algebraFactory.createProject(operation, variables));\n  }\n\n  /**\n   * Convert an operation to a count query for the number of matching triples for this pattern.\n   * @param dataFactory The data factory.\n   * @param algebraFactory The algebra factory.\n   * @param {Algebra.Operation} operation A query operation.\n   * @return {string} A count query string.\n   */\n  public operationToCountQuery(\n    dataFactory: ComunicaDataFactory,\n    algebraFactory: AlgebraFactory,\n    operation: Algebra.Operation,\n  ): Promise<string> {\n    return this.operationToQuery(algebraFactory.createProject(\n      algebraFactory.createExtend(\n        algebraFactory.createGroup(\n          operation,\n          [],\n          [ algebraFactory.createBoundAggregate(\n            dataFactory.variable('var0'),\n            'count',\n            algebraFactory.createWildcardExpression(),\n            false,\n          ) ],\n        ),\n        dataFactory.variable('count'),\n        algebraFactory.createTermExpression(dataFactory.variable('var0')),\n      ),\n      [ dataFactory.variable('count') ],\n    ));\n  }\n\n  /**\n   * Convert an operation to a query for this pattern.\n   * @param {Algebra.Operation} operation A query operation.\n   * @return {string} A query string.\n   */\n  public async operationToQuery(operation: Algebra.Operation): Promise<string> {\n    return (await this.mediatorQuerySerialize.mediate({\n      queryFormat: { language: 'sparql', version: '1.2' },\n      operation,\n      newlines: false,\n      indentWidth: 0,\n      context: this.context,\n    })).query;\n  }\n\n  /**\n   * Check if the given operation may produce undefined values.\n   * @param operation\n   */\n  public static getOperationUndefs(operation: Algebra.Operation): RDF.Variable[] {\n    const variables: RDF.Variable[] = [];\n    algebraUtils.visitOperation(operation, {\n      [Algebra.Types.LEFT_JOIN]: { preVisitor: (subOperation) => {\n        const left = algebraUtils.inScopeVariables(subOperation.input[0]);\n        const right = algebraUtils.inScopeVariables(subOperation.input[1]);\n        for (const varRight of right) {\n          if (!left.some(varLeft => varLeft.equals(varRight))) {\n            variables.push(varRight);\n          }\n        }\n        return { continue: false };\n      } },\n      [Algebra.Types.VALUES]: { preVisitor: (values) => {\n        for (const variable of values.variables) {\n          if (values.bindings.some(bindings => !(variable.value in bindings))) {\n            variables.push(variable);\n          }\n        }\n        return { continue: false };\n      } },\n      [Algebra.Types.UNION]: { preVisitor: (union) => {\n        // Determine variables in scope of the union branches that are not occurring in every branch\n        const scopedVariables = union.input.map(op => algebraUtils.inScopeVariables(op));\n        for (const variable of uniqTerms(scopedVariables.flat())) {\n          if (!scopedVariables.every(input => input.some(inputVar => inputVar.equals(variable)))) {\n            variables.push(variable);\n          }\n        }\n        return {};\n      } },\n    });\n    return uniqTerms(variables);\n  }\n\n  /**\n   * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.\n   * @param {string} endpoint A SPARQL endpoint URL.\n   * @param {string} query A SPARQL query string.\n   * @param {RDF.Variable[]} variables The expected variables.\n   * @param {IActionContext} context The source context.\n   * @param undefVariables Variables that may have undefs.\n   * @return {BindingsStream} A stream of bindings.\n   */\n  public async queryBindingsRemote(\n    endpoint: string,\n    query: string,\n    variables: RDF.Variable[],\n    context: IActionContext,\n    undefVariables: RDF.Variable[],\n  ): Promise<BindingsStream> {\n    // Index undef variables\n    const undefVariablesSet = new Set(undefVariables.map(v => v.value));\n\n    this.lastSourceContext = this.context.merge(context);\n    const rawStream = await this.endpointFetcher.fetchBindings(endpoint, query);\n\n    const wrapped = wrap<any>(rawStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY });\n    return wrapped.map<RDF.Bindings>((rawData: Record<string, RDF.Term>) => {\n      const bindings = variables.map((variable) => {\n        const value = rawData[`?${variable.value}`];\n        if (!undefVariablesSet.has(variable.value) && !value) {\n          Actor.getContextLogger(this.context)?.warn(`The endpoint ${endpoint} failed to provide a binding for ${variable.value}.`);\n        }\n        return <[RDF.Variable, RDF.Term]>[ variable, value ];\n      }).filter(([ _, v ]) => Boolean(v));\n      return this.bindingsFactory.bindings(bindings);\n    });\n  }\n\n  public toString(): string {\n    return `QuerySourceSparql(${this.url})`;\n  }\n}\n"]}