{"version":3,"file":"ICachePolicy.js","sourceRoot":"","sources":["ICachePolicy.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * A cache policy represents the policy under which certain data can be cached.\n * This is a generalization of the CachePolicy interface from the http-cache-semantics npm package.\n * @param <I> The type of input request this policy applies to.\n */\nexport interface ICachePolicy<I> {\n  /**\n   * Returns true if the response can be stored in a cache.\n   * If it's false then you MUST NOT store either the request or the response.\n   */\n  storable: () => boolean;\n\n  /**\n   * This is the most important method. Use this method to check whether a cached response is still fresh in the\n   * context of the new request.\n   *\n   * If it returns true, then the given request matches the original response this cache policy has been created with,\n   * and the response can be reused without contacting the server. Note that the old response can't be returned without\n   * being updated, see responseHeaders().\n   *\n   * If it returns false, then the response may not be matching at all (e.g. it's for a different URL or method),\n   * or may require to be refreshed first (see revalidationHeaders()).\n   *\n   * @param input The new input request.\n   */\n  satisfiesWithoutRevalidation: (input: I) => Promise<boolean>;\n\n  /**\n   * Returns updated, filtered set of response headers to return to clients receiving the cached response.\n   * This function is necessary, because proxies MUST always remove hop-by-hop headers (such as TE and Connection) and\n   * update response's Age to avoid doubling cache time.\n   * Example:\n   * `cachedResponse.headers = cachePolicy.responseHeaders(cachedResponse);`\n   */\n  responseHeaders: () => Headers;\n\n  /**\n   * Returns approximate time in milliseconds until the response becomes stale (i.e. not fresh).\n   *\n   * After that time (when `timeToLive() <= 0`) the response might not be usable without revalidation. However,\n   * there are exceptions, e.g. a client can explicitly allow stale responses, so always check with\n   * `satisfiesWithoutRevalidation()`.\n   */\n  timeToLive: () => number;\n\n  /**\n   * Returns updated, filtered set of request headers to send to the origin server to check if the cached\n   * response can be reused. These headers allow the origin server to return status 304 indicating the\n   * response is still fresh. All headers unrelated to caching are passed through as-is.\n   *\n   * Use this method when updating cache from the origin server.\n   *\n   * @example\n   * updateRequest.headers = cachePolicy.revalidationHeaders(updateRequest);\n   */\n  revalidationHeaders: (newInput: I) => Promise<Headers>;\n\n  /**\n   * Use this method to update the cache after receiving a new response from the origin server.\n   */\n  revalidatedPolicy: (\n    revalidationInput: I,\n    revalidationResponse: ICacheResponseHead,\n  ) => Promise<IRevalidationPolicy<I>>;\n}\n\nexport interface IRevalidationPolicy<I> {\n  /**\n   * A new `ICachePolicy` with HTTP headers updated from `revalidationResponse`. You can always replace\n   * the old cached `ICachePolicy` with the new one.\n   */\n  policy: ICachePolicy<I>;\n  /**\n   * Boolean indicating whether the response body has changed.\n   *\n   * - If `false`, then a valid 304 Not Modified response has been received, and you can reuse the old\n   * cached response body.\n   * - If `true`, you should use new response's body (if present), or make another request to the origin\n   * server without any conditional headers (i.e. don't use `revalidationHeaders()` this time) to get\n   * the new resource.\n   */\n  modified: boolean;\n  matches: boolean;\n}\n\nexport interface ICacheResponseHead {\n  /**\n   * The HTTP status code.\n   */\n  status: number;\n  /**\n   * The returned headers of the final URL.\n   */\n  headers?: Headers;\n}\n"]}