{"version":3,"file":"Algebra.js","sourceRoot":"","sources":["Algebra.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;AAKH,oFAA8E;AAArE,oHAAA,KAAK,OAAA;AAAE,8HAAA,eAAe,OAAA","sourcesContent":["/**\n * We redefine our algebra components to use interfaces instead of type unions.\n * Thereby opening up the algebra for unknown extensions\n */\n\nimport type { Algebra } from '@traqula/algebra-transformations-1-2';\nimport type { Patch } from '@traqula/core';\n\nexport { Types, ExpressionTypes } from '@traqula/algebra-transformations-1-2';\n\ntype withMeta = { metadata?: Record<string, unknown> };\n\n// Base types\nexport type BaseOperation = Algebra.BaseOperation & withMeta;\nexport type BaseExpression = Algebra.BaseExpression & withMeta;\nexport type Operation = BaseOperation;\nexport type Expression = BaseExpression;\n\n// https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n/**\n * Maps algebra operation (as union types) Algebra.baseOperations (as interface) as values,\n * staying as precises as possible, and also working on arrays.\n */\nexport type OpenSingle<T> = [T] extends [any[]] ? OpenSingle<T[number]>[] :\n    [T] extends [Algebra.Pattern] ? Algebra.Pattern & withMeta :\n        [T] extends [Algebra.Expression] ? Expression :\n            [T] extends [Algebra.Operation] ? Operation : T;\n\n/**\n * Reverse operation of OpenSingle\n */\nexport type CloseSingle<T> = T extends any[] ? CloseSingle<T[number]>[] :\n  T extends BoundAggregate ? Algebra.BoundAggregate :\n    T extends Algebra.BaseExpression ? Algebra.Expression :\n      T extends Algebra.BaseOperation ? Algebra.Operation : T;\n\n/**\n * Maps a single object or array containing values of type algebra operation (as union types)\n * the same type but having Algebra.baseOperations (as interface) as values.\n */\nexport type Opened<T extends object> = {[K in keyof T]: OpenSingle<T[K]> } & withMeta;\n/**\n * Reversed of Opened\n */\nexport type Closed<T extends object > = {[K in keyof T]: CloseSingle<T[K]> };\n\n// Redefinitions of types\nexport type KnownOperation = Ask | KnownExpression | Bgp | Construct | Describe | Distinct | Extend | From | Filter\n  | Graph | Group | Join | LeftJoin | Minus | Nop | OrderBy | Path | Pattern | Project | KnownPropertyPathSymbol\n  | Reduced | Service | Slice | Union | Values | KnownUpdate | CompositeUpdate;\nexport type KnownExpression = AggregateExpression | GroupConcatExpression | ExistenceExpression | NamedExpression |\n  OperatorExpression | TermExpression | WildcardExpression | BoundAggregate;\nexport type KnownPropertyPathSymbol = Alt | Inv | Link | Nps | OneOrMorePath | Seq | ZeroOrMorePath | ZeroOrOnePath;\nexport type KnownUpdate = DeleteInsert | Load | Clear | Create | Drop | Add | Move | Copy;\n\nexport type TypedOperation<T extends Algebra.Types> = Extract<KnownOperation, { type: T }>;\nexport type TypedExpression<T extends Algebra.ExpressionTypes> = Extract<KnownOperation, { subType: T }>;\n/**\n * Algebra operation taking a single operation as input.\n */\nexport type Single = Opened<Algebra.Single>;\n/**\n * Algebra operation taking multiple operations as input.\n */\nexport type Multi = Opened<Algebra.Multi>;\n/**\n * Algebra operation taking exactly two input operations.\n */\nexport type Double = Opened<Algebra.Double>;\nexport type AggregateExpression = Opened<Algebra.AggregateExpression>;\nexport type GroupConcatExpression = Opened<Algebra.GroupConcatExpression>;\nexport type ExistenceExpression = Opened<Algebra.ExistenceExpression>;\nexport type NamedExpression = Opened<Algebra.NamedExpression>;\nexport type OperatorExpression = Opened<Algebra.OperatorExpression>;\nexport type TermExpression = Opened<Algebra.TermExpression>;\nexport type WildcardExpression = Opened<Algebra.WildcardExpression>;\n/**\n * Algebra operation representing the [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths) alternative (`|`).\n * Property paths have a specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n */\nexport type Alt = Opened<Algebra.Alt>;\nexport type Ask = Opened<Algebra.Ask>;\nexport type Bgp = Opened<Algebra.Bgp>;\nexport type Construct = Opened<Algebra.Construct>;\nexport type Describe = Opened<Algebra.Describe>;\nexport type Distinct = Opened<Algebra.Distinct>;\nexport type Extend = Opened<Algebra.Extend>;\nexport type From = Opened<Algebra.From>;\nexport type Filter = Opened<Algebra.Filter>;\nexport type Graph = Opened<Algebra.Graph>;\nexport type BoundAggregate = Opened<Algebra.BoundAggregate>;\nexport type Group = Patch<Opened<Algebra.Group>, { aggregates: BoundAggregate[] }>;\n/**\n * Algebra operation representing the [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths) inverse (`^`).\n * Having a specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n * This operation, besides basic mode is the reason SPARQL can contain literals in the subject position.\n */\nexport type Inv = Opened<Algebra.Inv>;\nexport type Join = Opened<Algebra.Join>;\nexport type LeftJoin = Opened<Algebra.LeftJoin>;\n/**\n * Algebra operation representing the property of a [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths).\n * Property paths have a specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n * This operation, is just a way of saying to a Propery Path operation that nothing fancy is going on,\n * and it should just match this property.\n */\nexport type Link = Opened<Algebra.Link>;\nexport type Minus = Opened<Algebra.Minus>;\n/**\n * An empty operation.\n * For example used for the algebra representation of a query string that does not contain any operation.\n */\nexport type Nop = Opened<Algebra.Nop>;\n/**\n * Algebra operation representing the [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths) negated property set (`!`).\n * Property paths have a specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n */\nexport type Nps = Opened<Algebra.Nps>;\n/**\n * Algebra operation representing the [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths) one or more (`+`).\n * Property paths have a specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n */\nexport type OneOrMorePath = Opened<Algebra.OneOrMorePath>;\nexport type OrderBy = Opened<Algebra.OrderBy>;\nexport type Path = Opened<Algebra.Path>;\n/**\n * Simple BGP entry (triple)\n */\nexport type Pattern = Algebra.Pattern & withMeta;\nexport type Project = Opened<Algebra.Project>;\nexport type Reduced = Opened<Algebra.Reduced>;\n/**\n * Algebra operation representing the [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths) sequence (`/`).\n * Property paths have a specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n */\nexport type Seq = Opened<Algebra.Seq>;\nexport type Service = Opened<Algebra.Service>;\nexport type Slice = Opened<Algebra.Slice>;\nexport type Union = Opened<Algebra.Union>;\n/**\n * Algebra operation representing the [VALUES pattern](https://www.w3.org/TR/sparql11-query/#inline-data)\n * Has a list of variables that will be assigned.\n * The assignments are represented as a list of object containing bindings.\n * Each binging links the variable value to the appropriate Term for this binding.\n * Does not take any input.\n */\nexport type Values = Opened<Algebra.Values>;\n/**\n * Algebra operation representing the [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths) zero or more (`*`).\n * The having specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n */\nexport type ZeroOrMorePath = Opened<Algebra.ZeroOrMorePath>;\n/**\n * Algebra operation representing the [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths) zero or one (`?`).\n * The having specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n */\nexport type ZeroOrOnePath = Opened<Algebra.ZeroOrOnePath>;\nexport type CompositeUpdate = Opened<Algebra.CompositeUpdate>;\nexport type DeleteInsert = Opened<Algebra.DeleteInsert>;\nexport type UpdateGraph = Opened<Algebra.UpdateGraph>;\nexport type Load = Opened<Algebra.Load>;\nexport type Clear = Opened<Algebra.Clear>;\nexport type Create = Opened<Algebra.Create>;\nexport type Drop = Opened<Algebra.Drop>;\nexport type UpdateGraphShortcut = Opened<Algebra.UpdateGraphShortcut>;\nexport type Add = Opened<Algebra.Add>;\nexport type Move = Opened<Algebra.Move>;\nexport type Copy = Opened<Algebra.Copy>;\n"]}