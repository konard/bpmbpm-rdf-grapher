"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.inScopeVariables = exports.visitOperationSub = exports.visitOperation = exports.mapOperationSub = exports.mapOperationSubStrict = exports.mapOperation = exports.mapOperationStrict = exports.transformer = exports.objectify = exports.resolveIRI = void 0;
exports.isKnownOperation = isKnownOperation;
exports.isKnownSubType = isKnownSubType;
const algebra_transformations_1_2_1 = require("@traqula/algebra-transformations-1-2");
const core_1 = require("@traqula/core");
exports.resolveIRI = algebra_transformations_1_2_1.algebraUtils.resolveIRI;
exports.objectify = algebra_transformations_1_2_1.algebraUtils.objectify;
/**
 * Type guard that checks if an operation is of a certain type and subType known by Comunica.
 * In case the type and subtype matches one known by Comunica,
 * the type guard will conclude the operation contains all member Comunica expects from this operation-type and subtype.
 * @param val the operation that should be type checked
 * @param type the type we want to test against
 * @param subType the potential subtype we want to test against
 *     - when provided and not matching, we do not fall back to just checking the type.
 * @return a boolean indicating whether the type and subtype are equal to the expected type and subtype.
 * Only checking the subtype when a string is provided.
 */
function isKnownOperation(val, type, subType) {
    return val.type === type && (subType === undefined || val.subType === subType);
}
/**
 * Type guard that checks if an operation is of a certain subType known by Comunica.
 * In case the subtype matches one known by Comunica,
 * the type guard will conclude the operation contains all member Comunica expects from this operation-subtype
 * @param val the operation that should be type checked
 * @param subType the subType we want to test against
 * @return a boolean indicating whether the subType equals the expected subType
 */
function isKnownSubType(val, subType) {
    return val.subType === subType;
}
exports.transformer = new core_1.TransformerSubTyped({
    /**
     * Metadata often contains references to actors,
     * the transformer should not copy these actors, nor should it traverse the actors when visitingOperations.
     * (since there can be cycles involved).
     * It should however still make a shallowCopy from the metadata object, but not map over it.
     */
    shallowKeys: new Set(['metadata']),
    ignoreKeys: new Set(['metadata']),
}, {
    // Optimization that causes search tree pruning
    [algebra_transformations_1_2_1.Types.PATTERN]: { ignoreKeys: new Set(['subject', 'predicate', 'object', 'graph', 'metadata']) },
    [algebra_transformations_1_2_1.Types.EXPRESSION]: { ignoreKeys: new Set(['name', 'term', 'wildcard', 'variable', 'metadata']) },
    [algebra_transformations_1_2_1.Types.DESCRIBE]: { ignoreKeys: new Set(['terms', 'metadata']) },
    [algebra_transformations_1_2_1.Types.EXTEND]: { ignoreKeys: new Set(['variable', 'metadata']) },
    [algebra_transformations_1_2_1.Types.FROM]: { ignoreKeys: new Set(['default', 'named', 'metadata']) },
    [algebra_transformations_1_2_1.Types.GRAPH]: { ignoreKeys: new Set(['name', 'metadata']) },
    [algebra_transformations_1_2_1.Types.GROUP]: { ignoreKeys: new Set(['variables', 'metadata']) },
    [algebra_transformations_1_2_1.Types.LINK]: { ignoreKeys: new Set(['iri', 'metadata']) },
    [algebra_transformations_1_2_1.Types.NPS]: { ignoreKeys: new Set(['iris', 'metadata']) },
    [algebra_transformations_1_2_1.Types.PATH]: { ignoreKeys: new Set(['subject', 'object', 'graph', 'metadata']) },
    [algebra_transformations_1_2_1.Types.PROJECT]: { ignoreKeys: new Set(['variables', 'metadata']) },
    [algebra_transformations_1_2_1.Types.SERVICE]: { ignoreKeys: new Set(['name', 'metadata']) },
    [algebra_transformations_1_2_1.Types.VALUES]: { ignoreKeys: new Set(['variables', 'bindings', 'metadata']) },
    [algebra_transformations_1_2_1.Types.LOAD]: { ignoreKeys: new Set(['source', 'destination', 'metadata']) },
    [algebra_transformations_1_2_1.Types.CLEAR]: { ignoreKeys: new Set(['source', 'metadata']) },
    [algebra_transformations_1_2_1.Types.CREATE]: { ignoreKeys: new Set(['source', 'metadata']) },
    [algebra_transformations_1_2_1.Types.DROP]: { ignoreKeys: new Set(['source', 'metadata']) },
    [algebra_transformations_1_2_1.Types.ADD]: { ignoreKeys: new Set(['source', 'destination', 'metadata']) },
    [algebra_transformations_1_2_1.Types.MOVE]: { ignoreKeys: new Set(['source', 'destination', 'metadata']) },
    [algebra_transformations_1_2_1.Types.COPY]: { ignoreKeys: new Set(['source', 'destination', 'metadata']) },
});
/**
 * Transform a single operation, similar to {@link mapOperation}, but using stricter typings.
 * e.g. wrapping a distinct around the outermost project:
 * ```ts
 * mapOperationStrict<'unsafe', Operation>({
 *   type: Algebra.Types.SLICE,
 *   input: {
 *     type: Algebra.Types.PROJECT,
 *     input: {
 *       type: Algebra.Types.JOIN,
 *       input: [{ type: Algebra.Types.PROJECT }, { type: Algebra.Types.BGP }],
 *     },
 *   },
 * }, {
 *   [Algebra.Types.PROJECT]: {
 *     preVisitor: () => ({ continue: false }),
 *     transform: projection => algebraFactory.createDistinct(projection),
 *   },
 * });
 * const returns = {
 *   type: Algebra.Types.SLICE,
 *   input: {
 *     type: Algebra.Types.DISTINCT,
 *     input: {
 *       type: Algebra.Types.PROJECT,
 *       input: {
 *         type: Algebra.Types.JOIN,
 *         input: [{ type: Algebra.Types.PROJECT }, { type: Algebra.Types.BGP }],
 *       },
 *     },
 *   },
 * };
 * ```
 * @param startObject the object from which we will start the transformation,
 *   potentially visiting and transforming its descendants along the way.
 * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally
 *    containing preVisitor and transformer.
 *    The preVisitor allows you to provide {@link TransformContext} for the current object,
 *    altering how it will be transformed.
 *    The transformer allows you to manipulate the copy of the current object,
 *    and expects you to return the value that should take the current objects place.
 * @return the result of transforming the requested descendant operations (based on the preVisitor)
 * using a transformer that works its way back up from the descendant to the startObject.
 */
exports.mapOperationStrict = exports.transformer.transformNode.bind(exports.transformer);
/**
 * Transform a single operation.
 * e.g. wrapping a distinct around the outermost project:
 * ```ts
 * mapOperation({
 *   type: Algebra.Types.SLICE,
 *   input: {
 *     type: Algebra.Types.PROJECT,
 *     input: {
 *       type: Algebra.Types.JOIN,
 *       input: [{ type: Algebra.Types.PROJECT }, { type: Algebra.Types.BGP }],
 *     },
 *   },
 * }, {
 *   [Algebra.Types.PROJECT]: {
 *     preVisitor: () => ({ continue: false }),
 *     transform: projection => algebraFactory.createDistinct(projection),
 *   },
 * });
 * const returns = {
 *   type: Algebra.Types.SLICE,
 *   input: {
 *     type: Algebra.Types.DISTINCT,
 *     input: {
 *       type: Algebra.Types.PROJECT,
 *       input: {
 *         type: Algebra.Types.JOIN,
 *         input: [{ type: Algebra.Types.PROJECT }, { type: Algebra.Types.BGP }],
 *       },
 *     },
 *   },
 * };
 * ```
 * @param startObject the object from which we will start the transformation,
 *   potentially visiting and transforming its descendants along the way.
 * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally
 *    containing preVisitor and transformer.
 *    The preVisitor allows you to provide {@link TransformContext} for the current object,
 *    altering how it will be transformed.
 *    The transformer allows you to manipulate the copy of the current object,
 *    and expects you to return the value that should take the current objects place.
 * @return the result of transforming the requested descendant operations (based on the preVisitor)
 * using a transformer that works its way back up from the descendant to the startObject.
 */
exports.mapOperation = exports.mapOperationStrict;
/**
 * Transform a single operation, similar to {@link mapOperationSub}, but using stricter typings.
 * e.g. wrapping a distinct around the all project operations not contained in an aggregate expression
 * (invalid algebra anyway):
 * ```ts
 * mapOperationSubStrict<'unsafe', Operation>({
 *   type: Algebra.Types.SLICE,
 *   input: {
 *     type: Algebra.Types.PROJECT,
 *     input: {
 *       type: Algebra.Types.JOIN,
 *       input: [{
 *         type: Algebra.Types.EXPRESSION,
 *         subType: Algebra.ExpressionTypes.AGGREGATE,
 *         input: { type: Algebra.Types.PROJECT },
 *       }, { type: Algebra.Types.BGP }],
 *     },
 *   },
 * }, { [Algebra.Types.PROJECT]: {
 *   transform: projection => algebraFactory.createDistinct(projection),
 * }}, { [Algebra.Types.EXPRESSION]: { [Algebra.ExpressionTypes.AGGREGATE]: {
 *   preVisitor: () => ({ continue: false }),
 * }}});
 * const returns = {
 *   type: Algebra.Types.SLICE,
 *   input: {
 *     type: Algebra.Types.DISTINCT,
 *     input: {
 *       type: Algebra.Types.PROJECT,
 *       input: {
 *         type: Algebra.Types.JOIN,
 *         input: [{
 *           type: Algebra.Types.EXPRESSION,
 *           subType: Algebra.ExpressionTypes.AGGREGATE,
 *           input: { type: Algebra.Types.PROJECT },
 *         }, { type: Algebra.Types.BGP }],
 *       },
 *     },
 *   },
 * };
 * ```
 * @param startObject the object from which we will start the transformation,
 *   potentially visiting and transforming its descendants along the way.
 * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally
 *    containing preVisitor and transformer.
 *    The preVisitor allows you to provide {@link TransformContext} for the current object,
 *    altering how it will be transformed.
 *    The transformer allows you to manipulate the copy of the current object,
 *    and expects you to return the value that should take the current objects place.
 * @param nodeSpecificCallBacks Same as nodeCallBacks but using an additional level of indirection to
 *     indicate the subType.
 * @return the result of transforming the requested descendant operations (based on the preVisitor)
 * using a transformer that works its way back up from the descendant to the startObject.
 */
exports.mapOperationSubStrict = exports.transformer.transformNodeSpecific.bind(exports.transformer);
/**
 * Transform a single operation, similar to {@link mapOperation}, but also allowing you to target subTypes.
 * e.g. wrapping a distinct around the all project operations not contained in an aggregate expression
 * (invalid algebra anyway):
 * ```ts
 * mapOperationSub({
 *   type: Algebra.Types.SLICE,
 *   input: {
 *     type: Algebra.Types.PROJECT,
 *     input: {
 *       type: Algebra.Types.JOIN,
 *       input: [{
 *         type: Algebra.Types.EXPRESSION,
 *         subType: Algebra.ExpressionTypes.AGGREGATE,
 *         input: { type: Algebra.Types.PROJECT },
 *       }, { type: Algebra.Types.BGP }],
 *     },
 *   },
 * }, { [Algebra.Types.PROJECT]: {
 *   transform: projection => algebraFactory.createDistinct(projection),
 * }}, { [Algebra.Types.EXPRESSION]: { [Algebra.ExpressionTypes.AGGREGATE]: {
 *   preVisitor: () => ({ continue: false }),
 * }}});
 * const returns = {
 *   type: Algebra.Types.SLICE,
 *   input: {
 *     type: Algebra.Types.DISTINCT,
 *     input: {
 *       type: Algebra.Types.PROJECT,
 *       input: {
 *         type: Algebra.Types.JOIN,
 *         input: [{
 *           type: Algebra.Types.EXPRESSION,
 *           subType: Algebra.ExpressionTypes.AGGREGATE,
 *           input: { type: Algebra.Types.PROJECT },
 *         }, { type: Algebra.Types.BGP }],
 *       },
 *     },
 *   },
 * };
 * ```
 * @param startObject the object from which we will start the transformation,
 *   potentially visiting and transforming its descendants along the way.
 * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally
 *    containing preVisitor and transformer.
 *    The preVisitor allows you to provide {@link TransformContext} for the current object,
 *    altering how it will be transformed.
 *    The transformer allows you to manipulate the copy of the current object,
 *    and expects you to return the value that should take the current objects place.
 * @param nodeSpecificCallBacks Same as nodeCallBacks but using an additional level of indirection to
 *     indicate the subType.
 * @return the result of transforming the requested descendant operations (based on the preVisitor)
 * using a transformer that works its way back up from the descendant to the startObject.
 */
exports.mapOperationSub = exports.mapOperationSubStrict;
/**
 * Similar to {@link mapOperation}, but only visiting instead of copying and transforming explicitly.
 * e.g.:
 * ```ts
 * visitOperation({
 *   type: Algebra.Types.DISTINCT,
 *   input: {
 *     type: Algebra.Types.PROJECT,
 *     input: { type: Algebra.Types.DISTINCT },
 *   },
 * }, {
 *   [Algebra.Types.DISTINCT]: { visitor: () => console.log('1') },
 *   [Algebra.Types.PROJECT]: {
 *     preVisitor: () => ({ continue: false }),
 *     visitor: () => console.log('2'),
 *   },
 * });
 * ```
 * Will first call the preVisitor on the project and notice it should not iterate on its descendants.
 * It then visits the project, and the outermost distinct, printing '21'.
 * The pre-visitor visits starting from the root, going deeper, while the actual visitor goes in reverse.
 * @param startObject the object from which we will start visiting,
 *   potentially visiting its descendants along the way.
 * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally
 *    containing preVisitor and visitor.
 *    The preVisitor allows you to provide {@link VisitContext} for the current object,
 *    altering how it will be visited.
 *    The visitor allows you to visit the object from deepest to the outermost object.
 *    This is useful if you for example want to manipulate the objects you visit during your visits,
 *    similar to {@link mapOperation}.
 */
exports.visitOperation = exports.transformer.visitNode.bind(exports.transformer);
/**
 * Visits an object and it's descendants, similar to {@link visitOperation},
 * but also allowing you to target subTypes. e.g.:
 * e.g.:
 * ```ts
 * visitOperationSub({
 *   type: Algebra.Types.DISTINCT,
 *   input: {
 *     type: Algebra.Types.DISTINCT,
 *     subType: 'special',
 *   },
 * }, {
 *   [Algebra.Types.DISTINCT]: {
 *     visitor: () => console.log('1'),
 *     preVisitor: () => {
 *       console.log('2');
 *       return {};
 *     },
 *   },
 * }, {
 *   [Algebra.Types.DISTINCT]: { special: {
 *     visitor: () => console.log('3'),
 *   }},
 * });
 * ```
 * Will call the preVisitor on the outer distinct, then the visitor of the special distinct,
 * followed by the visiting the outer distinct, printing '231'.
 * The pre-visitor visits starting from the root, going deeper, while the actual visitor goes in reverse.
 * @param startObject the object from which we will start visiting,
 *   potentially visiting its descendants along the way.
 * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally
 *    containing preVisitor and visitor.
 *    The preVisitor allows you to provide {@link VisitContext} for the current object,
 *    altering how it will be visited.
 *    The visitor allows you to visit the object from deepest to the outermost object.
 *    This is useful if you for example want to manipulate the objects you visit during your visits,
 *    similar to {@link mapOperation}.
 * @param nodeSpecificCallBacks Same as nodeCallBacks but using an additional level of indirection to
 *     indicate the subType.
 */
exports.visitOperationSub = exports.transformer.visitNodeSpecific.bind(exports.transformer);
/**
 * Detects all in-scope variables.
 * In practice this means iterating through the entire algebra tree, finding all variables,
 * and stopping when a project function is found.
 * @param {Operation} op Input algebra tree.
 * @param visitor the visitor to be used to traverse the various nodes.
 *        Allows you to provide a visitor with different default preVisitor cotexts.
 * @returns {RDF.Variable[]} List of unique in-scope variables.
 */
const inScopeVariables = (op, visitor = exports.visitOperation) => algebra_transformations_1_2_1.algebraUtils.inScopeVariables(op, visitor);
exports.inScopeVariables = inScopeVariables;
//# sourceMappingURL=utils.js.map