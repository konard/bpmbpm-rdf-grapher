{"version":3,"file":"utils.js","sourceRoot":"","sources":["utils.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra as TraqulaAlgebra } from '@traqula/algebra-transformations-1-2';\nimport { algebraUtils, Types } from '@traqula/algebra-transformations-1-2';\n\n// eslint-disable-next-line unused-imports/no-unused-imports,unused-imports/no-unused-imports-ts\nimport type { TransformContext, VisitContext } from '@traqula/core';\nimport { TransformerSubTyped } from '@traqula/core';\nimport type { KnownOperation, Operation } from './Algebra';\n\nexport const resolveIRI = algebraUtils.resolveIRI;\nexport const objectify = algebraUtils.objectify;\n\n/**\n * Type guard that checks if an operation is of a certain type and subType known by Comunica.\n * In case the type and subtype matches one known by Comunica,\n * the type guard will conclude the operation contains all member Comunica expects from this operation-type and subtype.\n * @param val the operation that should be type checked\n * @param type the type we want to test against\n * @param subType the potential subtype we want to test against\n *     - when provided and not matching, we do not fall back to just checking the type.\n * @return a boolean indicating whether the type and subtype are equal to the expected type and subtype.\n * Only checking the subtype when a string is provided.\n */\nexport function isKnownOperation<\n  Type extends KnownOperation['type'],\n  SubType extends Extract<KnownOperation, { type: Type }>['subType'] | undefined = undefined,\n>(val: Operation, type: Type, subType?: SubType): val is\n  SubType extends undefined ? (\n    Extract<KnownOperation, { type: Type }> extends object ?\n      Extract<KnownOperation, { type: Type }> : { type: Type }\n  ) : Extract<KnownOperation, { type: Type; subType: SubType }> extends object ?\n    Extract<KnownOperation, { type: Type; subType: SubType }> : { type: Type; subType: SubType } {\n  return val.type === type && (subType === undefined || val.subType === subType);\n}\n\n/**\n * Type guard that checks if an operation is of a certain subType known by Comunica.\n * In case the subtype matches one known by Comunica,\n * the type guard will conclude the operation contains all member Comunica expects from this operation-subtype\n * @param val the operation that should be type checked\n * @param subType the subType we want to test against\n * @return a boolean indicating whether the subType equals the expected subType\n */\nexport function isKnownSubType<\n  SubType extends KnownOperation['subType'],\n  Obj extends Operation,\n>(val: Obj, subType: SubType):\n  val is Extract<KnownOperation, { type: Obj['type']; subType: SubType }> extends object ?\n    Obj & Extract<KnownOperation, { type: Obj['type']; subType: SubType }> : Obj & { subType: SubType } {\n  return val.subType === subType;\n}\n\n// ----------------------- manipulators --------------------\n\ntype _NeedRefForReusabilityWithoutExplicitTypeDefinition = TraqulaAlgebra.Operation;\nexport const transformer = new TransformerSubTyped<KnownOperation>({\n  /**\n   * Metadata often contains references to actors,\n   * the transformer should not copy these actors, nor should it traverse the actors when visitingOperations.\n   * (since there can be cycles involved).\n   * It should however still make a shallowCopy from the metadata object, but not map over it.\n   */\n  shallowKeys: new Set([ 'metadata' ]),\n  ignoreKeys: new Set([ 'metadata' ]),\n}, {\n  // Optimization that causes search tree pruning\n  [Types.PATTERN]: { ignoreKeys: new Set([ 'subject', 'predicate', 'object', 'graph', 'metadata' ]) },\n  [Types.EXPRESSION]: { ignoreKeys: new Set([ 'name', 'term', 'wildcard', 'variable', 'metadata' ]) },\n  [Types.DESCRIBE]: { ignoreKeys: new Set([ 'terms', 'metadata' ]) },\n  [Types.EXTEND]: { ignoreKeys: new Set([ 'variable', 'metadata' ]) },\n  [Types.FROM]: { ignoreKeys: new Set([ 'default', 'named', 'metadata' ]) },\n  [Types.GRAPH]: { ignoreKeys: new Set([ 'name', 'metadata' ]) },\n  [Types.GROUP]: { ignoreKeys: new Set([ 'variables', 'metadata' ]) },\n  [Types.LINK]: { ignoreKeys: new Set([ 'iri', 'metadata' ]) },\n  [Types.NPS]: { ignoreKeys: new Set([ 'iris', 'metadata' ]) },\n  [Types.PATH]: { ignoreKeys: new Set([ 'subject', 'object', 'graph', 'metadata' ]) },\n  [Types.PROJECT]: { ignoreKeys: new Set([ 'variables', 'metadata' ]) },\n  [Types.SERVICE]: { ignoreKeys: new Set([ 'name', 'metadata' ]) },\n  [Types.VALUES]: { ignoreKeys: new Set([ 'variables', 'bindings', 'metadata' ]) },\n  [Types.LOAD]: { ignoreKeys: new Set([ 'source', 'destination', 'metadata' ]) },\n  [Types.CLEAR]: { ignoreKeys: new Set([ 'source', 'metadata' ]) },\n  [Types.CREATE]: { ignoreKeys: new Set([ 'source', 'metadata' ]) },\n  [Types.DROP]: { ignoreKeys: new Set([ 'source', 'metadata' ]) },\n  [Types.ADD]: { ignoreKeys: new Set([ 'source', 'destination', 'metadata' ]) },\n  [Types.MOVE]: { ignoreKeys: new Set([ 'source', 'destination', 'metadata' ]) },\n  [Types.COPY]: { ignoreKeys: new Set([ 'source', 'destination', 'metadata' ]) },\n});\n\n/**\n * Transform a single operation, similar to {@link mapOperation}, but using stricter typings.\n * e.g. wrapping a distinct around the outermost project:\n * ```ts\n * mapOperationStrict<'unsafe', Operation>({\n *   type: Algebra.Types.SLICE,\n *   input: {\n *     type: Algebra.Types.PROJECT,\n *     input: {\n *       type: Algebra.Types.JOIN,\n *       input: [{ type: Algebra.Types.PROJECT }, { type: Algebra.Types.BGP }],\n *     },\n *   },\n * }, {\n *   [Algebra.Types.PROJECT]: {\n *     preVisitor: () => ({ continue: false }),\n *     transform: projection => algebraFactory.createDistinct(projection),\n *   },\n * });\n * const returns = {\n *   type: Algebra.Types.SLICE,\n *   input: {\n *     type: Algebra.Types.DISTINCT,\n *     input: {\n *       type: Algebra.Types.PROJECT,\n *       input: {\n *         type: Algebra.Types.JOIN,\n *         input: [{ type: Algebra.Types.PROJECT }, { type: Algebra.Types.BGP }],\n *       },\n *     },\n *   },\n * };\n * ```\n * @param startObject the object from which we will start the transformation,\n *   potentially visiting and transforming its descendants along the way.\n * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally\n *    containing preVisitor and transformer.\n *    The preVisitor allows you to provide {@link TransformContext} for the current object,\n *    altering how it will be transformed.\n *    The transformer allows you to manipulate the copy of the current object,\n *    and expects you to return the value that should take the current objects place.\n * @return the result of transforming the requested descendant operations (based on the preVisitor)\n * using a transformer that works its way back up from the descendant to the startObject.\n */\nexport const mapOperationStrict = transformer.transformNode.bind(transformer);\n\n/**\n * Transform a single operation.\n * e.g. wrapping a distinct around the outermost project:\n * ```ts\n * mapOperation({\n *   type: Algebra.Types.SLICE,\n *   input: {\n *     type: Algebra.Types.PROJECT,\n *     input: {\n *       type: Algebra.Types.JOIN,\n *       input: [{ type: Algebra.Types.PROJECT }, { type: Algebra.Types.BGP }],\n *     },\n *   },\n * }, {\n *   [Algebra.Types.PROJECT]: {\n *     preVisitor: () => ({ continue: false }),\n *     transform: projection => algebraFactory.createDistinct(projection),\n *   },\n * });\n * const returns = {\n *   type: Algebra.Types.SLICE,\n *   input: {\n *     type: Algebra.Types.DISTINCT,\n *     input: {\n *       type: Algebra.Types.PROJECT,\n *       input: {\n *         type: Algebra.Types.JOIN,\n *         input: [{ type: Algebra.Types.PROJECT }, { type: Algebra.Types.BGP }],\n *       },\n *     },\n *   },\n * };\n * ```\n * @param startObject the object from which we will start the transformation,\n *   potentially visiting and transforming its descendants along the way.\n * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally\n *    containing preVisitor and transformer.\n *    The preVisitor allows you to provide {@link TransformContext} for the current object,\n *    altering how it will be transformed.\n *    The transformer allows you to manipulate the copy of the current object,\n *    and expects you to return the value that should take the current objects place.\n * @return the result of transforming the requested descendant operations (based on the preVisitor)\n * using a transformer that works its way back up from the descendant to the startObject.\n */\nexport const mapOperation: (typeof mapOperationStrict<'unsafe', Operation>) = <any> mapOperationStrict;\n\n/**\n * Transform a single operation, similar to {@link mapOperationSub}, but using stricter typings.\n * e.g. wrapping a distinct around the all project operations not contained in an aggregate expression\n * (invalid algebra anyway):\n * ```ts\n * mapOperationSubStrict<'unsafe', Operation>({\n *   type: Algebra.Types.SLICE,\n *   input: {\n *     type: Algebra.Types.PROJECT,\n *     input: {\n *       type: Algebra.Types.JOIN,\n *       input: [{\n *         type: Algebra.Types.EXPRESSION,\n *         subType: Algebra.ExpressionTypes.AGGREGATE,\n *         input: { type: Algebra.Types.PROJECT },\n *       }, { type: Algebra.Types.BGP }],\n *     },\n *   },\n * }, { [Algebra.Types.PROJECT]: {\n *   transform: projection => algebraFactory.createDistinct(projection),\n * }}, { [Algebra.Types.EXPRESSION]: { [Algebra.ExpressionTypes.AGGREGATE]: {\n *   preVisitor: () => ({ continue: false }),\n * }}});\n * const returns = {\n *   type: Algebra.Types.SLICE,\n *   input: {\n *     type: Algebra.Types.DISTINCT,\n *     input: {\n *       type: Algebra.Types.PROJECT,\n *       input: {\n *         type: Algebra.Types.JOIN,\n *         input: [{\n *           type: Algebra.Types.EXPRESSION,\n *           subType: Algebra.ExpressionTypes.AGGREGATE,\n *           input: { type: Algebra.Types.PROJECT },\n *         }, { type: Algebra.Types.BGP }],\n *       },\n *     },\n *   },\n * };\n * ```\n * @param startObject the object from which we will start the transformation,\n *   potentially visiting and transforming its descendants along the way.\n * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally\n *    containing preVisitor and transformer.\n *    The preVisitor allows you to provide {@link TransformContext} for the current object,\n *    altering how it will be transformed.\n *    The transformer allows you to manipulate the copy of the current object,\n *    and expects you to return the value that should take the current objects place.\n * @param nodeSpecificCallBacks Same as nodeCallBacks but using an additional level of indirection to\n *     indicate the subType.\n * @return the result of transforming the requested descendant operations (based on the preVisitor)\n * using a transformer that works its way back up from the descendant to the startObject.\n */\nexport const mapOperationSubStrict = transformer.transformNodeSpecific.bind(transformer);\n\n/**\n * Transform a single operation, similar to {@link mapOperation}, but also allowing you to target subTypes.\n * e.g. wrapping a distinct around the all project operations not contained in an aggregate expression\n * (invalid algebra anyway):\n * ```ts\n * mapOperationSub({\n *   type: Algebra.Types.SLICE,\n *   input: {\n *     type: Algebra.Types.PROJECT,\n *     input: {\n *       type: Algebra.Types.JOIN,\n *       input: [{\n *         type: Algebra.Types.EXPRESSION,\n *         subType: Algebra.ExpressionTypes.AGGREGATE,\n *         input: { type: Algebra.Types.PROJECT },\n *       }, { type: Algebra.Types.BGP }],\n *     },\n *   },\n * }, { [Algebra.Types.PROJECT]: {\n *   transform: projection => algebraFactory.createDistinct(projection),\n * }}, { [Algebra.Types.EXPRESSION]: { [Algebra.ExpressionTypes.AGGREGATE]: {\n *   preVisitor: () => ({ continue: false }),\n * }}});\n * const returns = {\n *   type: Algebra.Types.SLICE,\n *   input: {\n *     type: Algebra.Types.DISTINCT,\n *     input: {\n *       type: Algebra.Types.PROJECT,\n *       input: {\n *         type: Algebra.Types.JOIN,\n *         input: [{\n *           type: Algebra.Types.EXPRESSION,\n *           subType: Algebra.ExpressionTypes.AGGREGATE,\n *           input: { type: Algebra.Types.PROJECT },\n *         }, { type: Algebra.Types.BGP }],\n *       },\n *     },\n *   },\n * };\n * ```\n * @param startObject the object from which we will start the transformation,\n *   potentially visiting and transforming its descendants along the way.\n * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally\n *    containing preVisitor and transformer.\n *    The preVisitor allows you to provide {@link TransformContext} for the current object,\n *    altering how it will be transformed.\n *    The transformer allows you to manipulate the copy of the current object,\n *    and expects you to return the value that should take the current objects place.\n * @param nodeSpecificCallBacks Same as nodeCallBacks but using an additional level of indirection to\n *     indicate the subType.\n * @return the result of transforming the requested descendant operations (based on the preVisitor)\n * using a transformer that works its way back up from the descendant to the startObject.\n */\nexport const mapOperationSub: (typeof mapOperationSubStrict<'unsafe', Operation>) = <any> mapOperationSubStrict;\n\n/**\n * Similar to {@link mapOperation}, but only visiting instead of copying and transforming explicitly.\n * e.g.:\n * ```ts\n * visitOperation({\n *   type: Algebra.Types.DISTINCT,\n *   input: {\n *     type: Algebra.Types.PROJECT,\n *     input: { type: Algebra.Types.DISTINCT },\n *   },\n * }, {\n *   [Algebra.Types.DISTINCT]: { visitor: () => console.log('1') },\n *   [Algebra.Types.PROJECT]: {\n *     preVisitor: () => ({ continue: false }),\n *     visitor: () => console.log('2'),\n *   },\n * });\n * ```\n * Will first call the preVisitor on the project and notice it should not iterate on its descendants.\n * It then visits the project, and the outermost distinct, printing '21'.\n * The pre-visitor visits starting from the root, going deeper, while the actual visitor goes in reverse.\n * @param startObject the object from which we will start visiting,\n *   potentially visiting its descendants along the way.\n * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally\n *    containing preVisitor and visitor.\n *    The preVisitor allows you to provide {@link VisitContext} for the current object,\n *    altering how it will be visited.\n *    The visitor allows you to visit the object from deepest to the outermost object.\n *    This is useful if you for example want to manipulate the objects you visit during your visits,\n *    similar to {@link mapOperation}.\n */\nexport const visitOperation = transformer.visitNode.bind(transformer);\n\n/**\n * Visits an object and it's descendants, similar to {@link visitOperation},\n * but also allowing you to target subTypes. e.g.:\n * e.g.:\n * ```ts\n * visitOperationSub({\n *   type: Algebra.Types.DISTINCT,\n *   input: {\n *     type: Algebra.Types.DISTINCT,\n *     subType: 'special',\n *   },\n * }, {\n *   [Algebra.Types.DISTINCT]: {\n *     visitor: () => console.log('1'),\n *     preVisitor: () => {\n *       console.log('2');\n *       return {};\n *     },\n *   },\n * }, {\n *   [Algebra.Types.DISTINCT]: { special: {\n *     visitor: () => console.log('3'),\n *   }},\n * });\n * ```\n * Will call the preVisitor on the outer distinct, then the visitor of the special distinct,\n * followed by the visiting the outer distinct, printing '231'.\n * The pre-visitor visits starting from the root, going deeper, while the actual visitor goes in reverse.\n * @param startObject the object from which we will start visiting,\n *   potentially visiting its descendants along the way.\n * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally\n *    containing preVisitor and visitor.\n *    The preVisitor allows you to provide {@link VisitContext} for the current object,\n *    altering how it will be visited.\n *    The visitor allows you to visit the object from deepest to the outermost object.\n *    This is useful if you for example want to manipulate the objects you visit during your visits,\n *    similar to {@link mapOperation}.\n * @param nodeSpecificCallBacks Same as nodeCallBacks but using an additional level of indirection to\n *     indicate the subType.\n */\nexport const visitOperationSub = transformer.visitNodeSpecific.bind(transformer);\n\n/**\n * Detects all in-scope variables.\n * In practice this means iterating through the entire algebra tree, finding all variables,\n * and stopping when a project function is found.\n * @param {Operation} op Input algebra tree.\n * @param visitor the visitor to be used to traverse the various nodes.\n *        Allows you to provide a visitor with different default preVisitor cotexts.\n * @returns {RDF.Variable[]} List of unique in-scope variables.\n */\nexport const inScopeVariables: typeof algebraUtils.inScopeVariables =\n  (op: Operation, visitor = <typeof algebraUtils.visitOperation>visitOperation): RDF.Variable[] =>\n    algebraUtils.inScopeVariables(op, visitor);\n"]}