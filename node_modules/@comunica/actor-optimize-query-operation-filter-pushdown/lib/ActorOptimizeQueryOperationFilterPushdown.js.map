{"version":3,"file":"ActorOptimizeQueryOperationFilterPushdown.js","sourceRoot":"","sources":["ActorOptimizeQueryOperationFilterPushdown.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  IActionOptimizeQueryOperation,\n  IActorOptimizeQueryOperationArgs,\n  IActorOptimizeQueryOperationOutput,\n} from '@comunica/bus-optimize-query-operation';\nimport { ActorOptimizeQueryOperation } from '@comunica/bus-optimize-query-operation';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { passTestVoid } from '@comunica/core';\nimport type { ComunicaDataFactory, FragmentSelectorShape, IActionContext, IQuerySourceWrapper } from '@comunica/types';\nimport {\n  AlgebraFactory,\n  Algebra,\n  algebraUtils,\n  isKnownOperation,\n  isKnownSubType,\n} from '@comunica/utils-algebra';\nimport { doesShapeAcceptOperation, getExpressionVariables, getOperationSource } from '@comunica/utils-query-operation';\nimport type * as RDF from '@rdfjs/types';\nimport { mapTermsNested } from 'rdf-terms';\n\n/**\n * A comunica Filter Pushdown Optimize Query Operation Actor.\n */\nexport class ActorOptimizeQueryOperationFilterPushdown extends ActorOptimizeQueryOperation {\n  private readonly aggressivePushdown: boolean;\n  private readonly maxIterations: number;\n  private readonly splitConjunctive: boolean;\n  private readonly mergeConjunctive: boolean;\n  private readonly pushIntoLeftJoins: boolean;\n  private readonly pushEqualityIntoPatterns: boolean;\n\n  public constructor(args: IActorOptimizeQueryOperationFilterPushdownArgs) {\n    super(args);\n    this.aggressivePushdown = args.aggressivePushdown;\n    this.maxIterations = args.maxIterations;\n    this.splitConjunctive = args.splitConjunctive;\n    this.mergeConjunctive = args.mergeConjunctive;\n    this.pushIntoLeftJoins = args.pushIntoLeftJoins;\n    this.pushEqualityIntoPatterns = args.pushEqualityIntoPatterns;\n  }\n\n  public async test(_action: IActionOptimizeQueryOperation): Promise<TestResult<IActorTest>> {\n    return passTestVoid();\n  }\n\n  public async run(action: IActionOptimizeQueryOperation): Promise<IActorOptimizeQueryOperationOutput> {\n    const dataFactory: ComunicaDataFactory = action.context.getSafe(KeysInitQuery.dataFactory);\n    const algebraFactory = new AlgebraFactory(dataFactory);\n    let operation: Algebra.Operation = action.operation;\n\n    // Split conjunctive filters into nested filters\n    if (this.splitConjunctive) {\n      operation = algebraUtils.mapOperation(operation, {\n        [Algebra.Types.FILTER]: { transform: (filterOp) => {\n          // Split conjunctive filters into separate filters\n          if (isKnownSubType(filterOp.expression, Algebra.ExpressionTypes.OPERATOR) &&\n            filterOp.expression.operator === '&&') {\n            this.logDebug(action.context, `Split conjunctive filter into ${filterOp.expression.args.length} nested filters`);\n            return filterOp.expression.args\n              .reduce((operation, expression) => algebraFactory.createFilter(operation, expression), filterOp.input);\n          }\n          return filterOp;\n        } },\n      });\n    }\n\n    // Collect selector shapes of all operations\n    const sources = this.getSources(operation);\n    // eslint-disable-next-line ts/no-unnecessary-type-assertion\n    const sourceShapes = new Map(<[IQuerySourceWrapper, FragmentSelectorShape][]> await Promise.all(sources\n      .map(async source => [\n        source,\n        await source.source.getSelectorShape(source.context ? action.context.merge(source.context) : action.context),\n      ])));\n\n    // Push down all filters\n    // We loop until no more filters can be pushed down.\n    let repeat = true;\n    let iterations = 0;\n    while (repeat && iterations < this.maxIterations) {\n      repeat = false;\n      operation = algebraUtils.mapOperation(operation, {\n        [Algebra.Types.FILTER]: { transform: (filterOp) => {\n          // Check if the filter must be pushed down\n          const extensionFunctions = action.context.get(KeysInitQuery.extensionFunctions);\n          const extensionFunctionsAlwaysPushdown = action.context.get(KeysInitQuery.extensionFunctionsAlwaysPushdown);\n          if (!this.shouldAttemptPushDown(\n            filterOp,\n            sources,\n            sourceShapes,\n            extensionFunctions,\n            extensionFunctionsAlwaysPushdown,\n          )) {\n            return filterOp;\n          }\n\n          // For all filter expressions in the operation,\n          // we attempt to push them down as deep as possible into the algebra.\n          const variables = getExpressionVariables(filterOp.expression);\n          const [ isModified, result ] = this\n            .filterPushdown(filterOp.expression, variables, filterOp.input, algebraFactory, action.context);\n          if (isModified) {\n            repeat = true;\n          }\n          return result;\n        } },\n      });\n      iterations++;\n    }\n\n    if (iterations > 1) {\n      this.logDebug(action.context, `Pushed down filters in ${iterations} iterations`);\n    }\n\n    // Merge nested filters into conjunctive filters\n    if (this.mergeConjunctive) {\n      operation = algebraUtils.mapOperation(operation, {\n        [Algebra.Types.FILTER]: { transform: (op) => {\n          if (op.input.type === Algebra.Types.FILTER) {\n            const { nestedExpressions, input } = this.getNestedFilterExpressions(op);\n            this.logDebug(action.context, `Merge ${nestedExpressions.length} nested filters into conjunctive filter`);\n            return algebraFactory.createFilter(\n              input,\n              nestedExpressions.slice(1).reduce((previous, current) =>\n                algebraFactory.createOperatorExpression('&&', [ previous, current ]), nestedExpressions[0]),\n            );\n          }\n          return op;\n        } },\n      });\n    }\n\n    return { operation, context: action.context };\n  }\n\n  /**\n   * Check if the given filter operation must be attempted to push down, based on the following criteria:\n   * - Always push down if aggressive mode is enabled\n   * - Push down if the filter is extremely selective\n   * - Don't push down extension functions comunica support, but a source does not\n   * - Push down if federated and at least one accepts the filter\n   * @param operation The filter operation\n   * @param sources The query sources in the operation\n   * @param sourceShapes A mapping of sources to selector shapes.\n   * @param extensionFunctions The extension functions comunica supports.\n   * @param extensionFunctionsAlwaysPushdown If extension functions must always be pushed down to sources that support\n   *                                         expressions, even if those sources to not explicitly declare support for\n   *                                         these extension functions.\n   */\n  public shouldAttemptPushDown(\n    operation: Algebra.Filter,\n    sources: IQuerySourceWrapper[],\n    sourceShapes: Map<IQuerySourceWrapper, FragmentSelectorShape>,\n    extensionFunctions?: Record<string, any>,\n    extensionFunctionsAlwaysPushdown?: boolean,\n  ): boolean {\n    // Always push down if aggressive mode is enabled\n    if (this.aggressivePushdown) {\n      return true;\n    }\n\n    // Push down if the filter is extremely selective\n    const expression = operation.expression;\n    if (isKnownSubType(expression, Algebra.ExpressionTypes.OPERATOR) && expression.operator === '=' &&\n      ((isKnownSubType(expression.args[0], Algebra.ExpressionTypes.TERM) &&\n          expression.args[0].term.termType !== 'Variable' &&\n          isKnownSubType(expression.args[1], Algebra.ExpressionTypes.TERM) &&\n          expression.args[1].term.termType === 'Variable') ||\n        (isKnownSubType(expression.args[0], Algebra.ExpressionTypes.TERM) &&\n          expression.args[0].term.termType === 'Variable' &&\n          isKnownSubType(expression.args[1], Algebra.ExpressionTypes.TERM) &&\n          expression.args[1].term.termType !== 'Variable'))) {\n      return true;\n    }\n\n    // Don't push down extension functions comunica support, but no source does\n    if (extensionFunctions && isKnownSubType(expression, Algebra.ExpressionTypes.NAMED) &&\n        expression.name.value in extensionFunctions &&\n        // Checks if there's not a single source that supports the extension function\n        !sources.some(source =>\n          doesShapeAcceptOperation(sourceShapes.get(source)!, expression))\n    ) {\n      return false;\n    }\n\n    // Push down if federated and at least one accepts the filter\n    if (sources.some(source => doesShapeAcceptOperation(sourceShapes.get(source)!, operation, {\n      wildcardAcceptAllExtensionFunctions: extensionFunctionsAlwaysPushdown,\n    }))) {\n      return true;\n    }\n\n    // Don't push down in all other cases\n    return false;\n  }\n\n  /**\n   * Collected all sources that are defined within the given operation of children recursively.\n   * @param operation An operation.\n   */\n  public getSources(operation: Algebra.Operation): IQuerySourceWrapper[] {\n    const sources = new Set<IQuerySourceWrapper>();\n    const sourceAdder = (subOperation: Algebra.Operation): boolean => {\n      const src = getOperationSource(subOperation);\n      if (src) {\n        sources.add(src);\n      }\n      return false;\n    };\n    algebraUtils.visitOperation(operation, {\n      [Algebra.Types.PATTERN]: { visitor: sourceAdder },\n      [Algebra.Types.SERVICE]: { visitor: sourceAdder },\n      [Algebra.Types.LINK]: { visitor: sourceAdder },\n      [Algebra.Types.NPS]: { visitor: sourceAdder },\n    });\n    return [ ...sources ];\n  }\n\n  protected getOverlappingOperations(\n    operation: Algebra.Union | Algebra.Join,\n    expressionVariables: RDF.Variable[],\n  ): {\n      fullyOverlapping: Algebra.Operation[];\n      partiallyOverlapping: Algebra.Operation[];\n      notOverlapping: Algebra.Operation[];\n    } {\n    const fullyOverlapping: Algebra.Operation[] = [];\n    const partiallyOverlapping: Algebra.Operation[] = [];\n    const notOverlapping: Algebra.Operation[] = [];\n    for (const input of operation.input) {\n      const inputVariables = algebraUtils.inScopeVariables(input);\n      if (this.variablesSubSetOf(expressionVariables, inputVariables)) {\n        fullyOverlapping.push(input);\n      } else if (this.variablesIntersect(expressionVariables, inputVariables)) {\n        partiallyOverlapping.push(input);\n      } else {\n        notOverlapping.push(input);\n      }\n    }\n\n    return {\n      fullyOverlapping,\n      partiallyOverlapping,\n      notOverlapping,\n    };\n  }\n\n  /**\n   * Recursively push down the given expression into the given operation if possible.\n   * Different operators have different semantics for choosing whether or not to push down,\n   * and how this pushdown is done.\n   * For every passed operator, it is checked whether or not the filter will have any effect on the operation.\n   * If not, the filter is voided.\n   * @param expression An expression to push down.\n   * @param expressionVariables The variables inside the given expression.\n   * @param operation The operation to push down into.\n   * @param factory An algebra factory.\n   * @param context The action context.\n   * @return A tuple indicating if the operation was modified and the modified operation.\n   */\n  public filterPushdown(\n    expression: Algebra.Expression,\n    expressionVariables: RDF.Variable[],\n    operation: Algebra.Operation,\n    factory: AlgebraFactory,\n    context: IActionContext,\n  ): [ boolean, Algebra.Operation ] {\n    // Void false expressions\n    if (this.isExpressionFalse(expression)) {\n      return [ true, factory.createUnion([]) ];\n    }\n\n    // Don't push down (NOT) EXISTS\n    if (isKnownOperation(expression, Algebra.Types.EXPRESSION, Algebra.ExpressionTypes.EXISTENCE)) {\n      return [ false, factory.createFilter(operation, expression) ];\n    }\n\n    if (isKnownOperation(operation, Algebra.Types.EXTEND)) {\n      // Pass if the variable is not part of the expression\n      if (!this.variablesIntersect([ operation.variable ], expressionVariables)) {\n        return [ true, factory.createExtend(\n          this.filterPushdown(expression, expressionVariables, operation.input, factory, context)[1],\n          operation.variable,\n          operation.expression,\n        ) ];\n      }\n      return [ false, factory.createFilter(operation, expression) ];\n    }\n    if (isKnownOperation(operation, Algebra.Types.FILTER)) {\n      // Always pass\n      const [ isModified, result ] = this\n        .filterPushdown(expression, expressionVariables, operation.input, factory, context);\n      return [ isModified, factory.createFilter(result, operation.expression) ];\n    }\n    if (isKnownOperation(operation, Algebra.Types.JOIN)) {\n      // Don't push down for empty join\n      if (operation.input.length === 0) {\n        return [ false, factory.createFilter(operation, expression) ];\n      }\n\n      // Determine overlapping operations\n      const {\n        fullyOverlapping,\n        partiallyOverlapping,\n        notOverlapping,\n      } = this.getOverlappingOperations(operation, expressionVariables);\n\n      const joins: Algebra.Operation[] = [];\n      let isModified = false;\n      if (fullyOverlapping.length > 0) {\n        isModified = true;\n        joins.push(factory.createJoin(fullyOverlapping\n          .map(input => this.filterPushdown(expression, expressionVariables, input, factory, context)[1])));\n      }\n      if (partiallyOverlapping.length > 0) {\n        joins.push(factory.createFilter(factory.createJoin(partiallyOverlapping, false), expression));\n      }\n      if (notOverlapping.length > 0) {\n        joins.push(...notOverlapping);\n      }\n\n      if (joins.length > 1) {\n        isModified = true;\n      }\n\n      if (isModified) {\n        this.logDebug(context, `Push down filter across join entries with ${fullyOverlapping.length} fully overlapping, ${partiallyOverlapping.length} partially overlapping, and ${notOverlapping.length} not overlapping`);\n      }\n\n      return [ isModified, joins.length === 1 ? joins[0] : factory.createJoin(joins) ];\n    }\n    if (isKnownOperation(operation, Algebra.Types.NOP)) {\n      return [ true, operation ];\n    }\n    if (isKnownOperation(operation, Algebra.Types.PROJECT)) {\n      // Push down if variables overlap\n      if (this.variablesIntersect(operation.variables, expressionVariables)) {\n        return [ true, factory.createProject(\n          this.filterPushdown(expression, expressionVariables, operation.input, factory, context)[1],\n          operation.variables,\n        ) ];\n      }\n      // Void expression otherwise\n      return [ true, operation ];\n    }\n    if (isKnownOperation(operation, Algebra.Types.UNION)) {\n      // Determine overlapping operations\n      const {\n        fullyOverlapping,\n        partiallyOverlapping,\n        notOverlapping,\n      } = this.getOverlappingOperations(operation, expressionVariables);\n\n      const unions: Algebra.Operation[] = [];\n      let isModified = false;\n      if (fullyOverlapping.length > 0) {\n        isModified = true;\n        unions.push(factory.createUnion(fullyOverlapping\n          .map(input => this.filterPushdown(expression, expressionVariables, input, factory, context)[1])));\n      }\n      if (partiallyOverlapping.length > 0) {\n        unions.push(factory.createFilter(factory.createUnion(partiallyOverlapping, false), expression));\n      }\n      if (notOverlapping.length > 0) {\n        unions.push(...notOverlapping);\n      }\n\n      if (unions.length > 1) {\n        isModified = true;\n      }\n\n      if (isModified) {\n        this.logDebug(context, `Push down filter across union entries with ${fullyOverlapping.length} fully overlapping, ${partiallyOverlapping.length} partially overlapping, and ${notOverlapping.length} not overlapping`);\n      }\n\n      return [ isModified, unions.length === 1 ? unions[0] : factory.createUnion(unions) ];\n    }\n    if (isKnownOperation(operation, Algebra.Types.VALUES)) {\n      // Only keep filter if it overlaps with the variables\n      if (this.variablesIntersect(operation.variables, expressionVariables)) {\n        return [ false, factory.createFilter(operation, expression) ];\n      }\n      return [ true, operation ];\n    }\n    if (isKnownOperation(operation, Algebra.Types.LEFT_JOIN)) {\n      if (this.pushIntoLeftJoins) {\n        const rightVariables = algebraUtils.inScopeVariables(operation.input[1]);\n        if (!this.variablesIntersect(expressionVariables, rightVariables)) {\n          // If filter *only* applies to left entry of optional, push it down into that.\n          this.logDebug(context, `Push down filter into left join`);\n          return [ true, factory.createLeftJoin(\n            this.filterPushdown(expression, expressionVariables, operation.input[0], factory, context)[1],\n            operation.input[1],\n            operation.expression,\n          ) ];\n        }\n      }\n\n      // Don't push down in all other cases\n      return [ false, factory.createFilter(operation, expression) ];\n    }\n    if (isKnownOperation(operation, Algebra.Types.PATTERN)) {\n      if (this.pushEqualityIntoPatterns) {\n        // Try to push simple FILTER(?s = <iri>) expressions into the pattern\n        const pushableResult = this.getEqualityExpressionPushableIntoPattern(expression);\n        if (pushableResult) {\n          let isModified = false;\n          const originalMetadata = operation.metadata;\n          operation = mapTermsNested(operation, (value) => {\n            if (value.equals(pushableResult.variable)) {\n              isModified = true;\n              return pushableResult.term;\n            }\n            return value;\n          });\n          operation.type = Algebra.Types.PATTERN;\n          operation.metadata = originalMetadata;\n          if (isModified) {\n            this.logDebug(context, `Push down filter into pattern for ?${pushableResult.variable.value}`);\n            return [ true, factory.createJoin([\n              operation,\n              factory.createValues(\n                [ pushableResult.variable ],\n                [{ [pushableResult.variable.value]: <RDF.NamedNode | RDF.Literal> pushableResult.term }],\n              ),\n            ]) ];\n          }\n        }\n      }\n\n      // Don't push down in all other cases\n      return [ false, factory.createFilter(operation, expression) ];\n    }\n    if (isKnownOperation(operation, Algebra.Types.PATH)) {\n      if (this.pushEqualityIntoPatterns) {\n        // Try to push simple FILTER(?s = <iri>) expressions into the path\n        const pushableResult = this.getEqualityExpressionPushableIntoPattern(expression);\n        if (pushableResult &&\n          (operation.subject.equals(pushableResult.variable) || operation.object.equals(pushableResult.variable))) {\n          this.logDebug(context, `Push down filter into path for ?${pushableResult.variable.value}`);\n          const originalMetadata = operation.metadata;\n          operation = factory.createPath(\n            operation.subject.equals(pushableResult.variable) ? pushableResult.term : operation.subject,\n            operation.predicate,\n            operation.object.equals(pushableResult.variable) ? pushableResult.term : operation.object,\n          );\n          operation.metadata = originalMetadata;\n          return [ true, factory.createJoin([\n            operation,\n            factory.createValues(\n              [ pushableResult.variable ],\n              [{ [pushableResult.variable.value]: <RDF.NamedNode | RDF.Literal> pushableResult.term }],\n            ),\n          ]) ];\n        }\n      }\n\n      // Don't push down in all other cases\n      return [ false, factory.createFilter(operation, expression) ];\n    }\n\n    // Operations that do not support pushing down\n    // Left-join and minus might be possible to support in the future.\n    return [ false, factory.createFilter(operation, expression) ];\n  }\n\n  /**\n   * Check if the given expression is a simple equals operation with one variable and one non-literal\n   * (or literal with canonical lexical form) term that can be pushed into a pattern.\n   * @param expression The current expression.\n   * @return The variable and term to fill into the pattern, or undefined.\n   */\n  public getEqualityExpressionPushableIntoPattern(\n    expression: Algebra.Expression,\n  ): { variable: RDF.Variable; term: RDF.Term } | undefined {\n    if (isKnownSubType(expression, Algebra.ExpressionTypes.OPERATOR) && expression.operator === '=') {\n      const arg0 = expression.args[0];\n      const arg1 = expression.args[1];\n      if (isKnownSubType(arg0, Algebra.ExpressionTypes.TERM) && arg0.term.termType !== 'Variable' &&\n        (arg0.term.termType !== 'Literal' || this.isLiteralWithCanonicalLexicalForm(arg0.term)) &&\n        isKnownSubType(arg1, Algebra.ExpressionTypes.TERM) &&\n        arg1.term.termType === 'Variable') {\n        return {\n          variable: arg1.term,\n          term: arg0.term,\n        };\n      }\n      if (isKnownSubType(arg0, Algebra.ExpressionTypes.TERM) && arg0.term.termType === 'Variable' &&\n        isKnownSubType(arg1, Algebra.ExpressionTypes.TERM) && arg1.term.termType !== 'Variable' &&\n        (arg1.term.termType !== 'Literal' || this.isLiteralWithCanonicalLexicalForm(arg1.term))) {\n        return {\n          variable: arg0.term,\n          term: arg1.term,\n        };\n      }\n    }\n  }\n\n  /**\n   * Check if the given term is a literal with datatype that where all values\n   * can only have one possible lexical representation.\n   * In other words, no variants of values exist that should be considered equal.\n   * For example: \"01\"^xsd:number and \"1\"^xsd:number will return false.\n   * @param term An RDF term.\n   * @protected\n   */\n  protected isLiteralWithCanonicalLexicalForm(term: RDF.Literal): boolean {\n    switch (term.datatype.value) {\n      case 'http://www.w3.org/2001/XMLSchema#string':\n      case 'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString':\n      case 'http://www.w3.org/2001/XMLSchema#normalizedString':\n      case 'http://www.w3.org/2001/XMLSchema#anyURI':\n      case 'http://www.w3.org/2001/XMLSchema#base64Binary':\n      case 'http://www.w3.org/2001/XMLSchema#language':\n      case 'http://www.w3.org/2001/XMLSchema#Name':\n      case 'http://www.w3.org/2001/XMLSchema#NCName':\n      case 'http://www.w3.org/2001/XMLSchema#NMTOKEN':\n      case 'http://www.w3.org/2001/XMLSchema#token':\n      case 'http://www.w3.org/2001/XMLSchema#hexBinary':\n        return true;\n    }\n    return false;\n  }\n\n  /**\n   * Check if there is an overlap between the two given lists of variables.\n   * @param varsA A list of variables.\n   * @param varsB A list of variables.\n   */\n  public variablesIntersect(varsA: RDF.Variable[], varsB: RDF.Variable[]): boolean {\n    return varsA.some(varA => varsB.some(varB => varA.equals(varB)));\n  }\n\n  /**\n   * Check if all variables from the first list are included in the second list.\n   * The second list may contain other variables as well.\n   * @param varsNeedles A list of variables to search for.\n   * @param varsHaystack A list of variables to search in.\n   */\n  public variablesSubSetOf(varsNeedles: RDF.Variable[], varsHaystack: RDF.Variable[]): boolean {\n    return varsNeedles.length <= varsHaystack.length &&\n      varsNeedles.every(varA => varsHaystack.some(varB => varA.equals(varB)));\n  }\n\n  /**\n   * Check if an expression is simply 'false'.\n   * @param expression An expression.\n   */\n  public isExpressionFalse(expression: Algebra.Expression): boolean {\n    const casted = <Extract<Algebra.KnownExpression, { term?: unknown }>> expression;\n    return (casted.term && casted.term.termType === 'Literal' && casted.term.value === 'false');\n  }\n\n  /**\n   * Get all directly nested filter expressions.\n   * As soon as a non-filter is found, it is returned as the input field.\n   * @param op A filter expression.\n   */\n  public getNestedFilterExpressions(\n    op: Algebra.Filter,\n  ): { nestedExpressions: Algebra.Expression[]; input: Algebra.Operation } {\n    if (isKnownOperation(op.input, Algebra.Types.FILTER)) {\n      const childData = this.getNestedFilterExpressions(op.input);\n      return { nestedExpressions: [ op.expression, ...childData.nestedExpressions ], input: childData.input };\n    }\n    return { nestedExpressions: [ op.expression ], input: op.input };\n  }\n}\n\nexport interface IActorOptimizeQueryOperationFilterPushdownArgs extends IActorOptimizeQueryOperationArgs {\n  /**\n   * If filters should be pushed down as deep as possible.\n   * If false, filters will only be pushed down if the source(s) accept them,\n   * or if the filter is very selective.\n   * @range {boolean}\n   * @default {false}\n   */\n  aggressivePushdown: boolean;\n  /**\n   * The maximum number of full iterations across the query can be done for attempting to push down filters.\n   * @default {10}\n   */\n  maxIterations: number;\n  /**\n   * If conjunctive filters should be split into nested filters before applying filter pushdown.\n   * This can enable pushing down deeper.\n   * @range {boolean}\n   * @default {true}\n   */\n  splitConjunctive: boolean;\n  /**\n   * If nested filters should be merged into conjunctive filters after applying filter pushdown.\n   * @range {boolean}\n   * @default {true}\n   */\n  mergeConjunctive: boolean;\n  /**\n   * If filters should be pushed into left-joins.\n   * @range {boolean}\n   * @default {true}\n   */\n  pushIntoLeftJoins: boolean;\n  /**\n   * If simple equality filters should be pushed into patterns and paths.\n   * This only applies to equality filters with terms that are not literals that have no canonical lexical form.\n   * @range {boolean}\n   * @default {true}\n   */\n  pushEqualityIntoPatterns: boolean;\n}\n"]}