"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorRdfJoinMultiSmallest = void 0;
const bus_rdf_join_1 = require("@comunica/bus-rdf-join");
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const utils_algebra_1 = require("@comunica/utils-algebra");
const utils_query_operation_1 = require("@comunica/utils-query-operation");
/**
 * A Multi Smallest RDF Join Actor.
 * It accepts 3 or more streams, joins the smallest two, and joins the result with the remaining streams.
 */
class ActorRdfJoinMultiSmallest extends bus_rdf_join_1.ActorRdfJoin {
    mediatorJoinEntriesSort;
    mediatorJoin;
    constructor(args) {
        super(args, {
            logicalType: 'inner',
            physicalName: 'multi-smallest',
            limitEntries: 3,
            limitEntriesMin: true,
            canHandleUndefs: true,
            isLeaf: false,
        });
        this.mediatorJoinEntriesSort = args.mediatorJoinEntriesSort;
        this.mediatorJoin = args.mediatorJoin;
    }
    /**
     * Finds join indexes of lowest cardinality result sets, with priority on result sets that have common variables
     * @param entries A sorted array of entries, sorted on cardinality
     */
    getJoinIndexes(entries) {
        // Iterate over all combinations of join indexes,
        // return the first combination that does not lead to a cartesian product
        for (let i = 0; i < entries.length; i++) {
            for (let j = i + 1; j < entries.length; j++) {
                if (this.hasCommonVariables(entries[i], entries[j])) {
                    return [i, j];
                }
            }
        }
        // If all result sets are disjoint we just want the sets with lowest cardinality
        return [0, 1];
    }
    hasCommonVariables(entry1, entry2) {
        const variableNames1 = entry1.metadata.variables.map(x => x.variable.value);
        const variableNames2 = new Set(entry2.metadata.variables.map(x => x.variable.value));
        return variableNames1.some(v => variableNames2.has(v));
    }
    /**
     * Order the given join entries using the join-entries-sort bus.
     * @param {IJoinEntryWithMetadata[]} entries An array of join entries.
     * @param context The action context.
     * @return {IJoinEntryWithMetadata[]} The sorted join entries.
     */
    async sortJoinEntries(entries, context) {
        return (await this.mediatorJoinEntriesSort.mediate({ entries, context })).entries;
    }
    async getOutput(action, sideData) {
        const dataFactory = action.context.getSafe(context_entries_1.KeysInitQuery.dataFactory);
        const algebraFactory = new utils_algebra_1.AlgebraFactory(dataFactory);
        // Determine the two smallest streams by sorting (e.g. via cardinality)
        const entries = sideData.sortedEntries;
        const entriesMetaData = await bus_rdf_join_1.ActorRdfJoin.getEntriesWithMetadatas(entries);
        const bestJoinIndexes = this.getJoinIndexes(entriesMetaData);
        const smallestEntry1 = entries[bestJoinIndexes[0]];
        const smallestEntry2 = entries[bestJoinIndexes[1]];
        entries.splice(bestJoinIndexes[1], 1);
        entries.splice(bestJoinIndexes[0], 1);
        // Join the two selected streams, and then join the result with the remaining streams
        const firstEntry = {
            output: (0, utils_query_operation_1.getSafeBindings)(await this.mediatorJoin
                .mediate({ type: action.type, entries: [smallestEntry1, smallestEntry2], context: action.context })),
            operation: algebraFactory
                .createJoin([smallestEntry1.operation, smallestEntry2.operation], false),
        };
        entries.push(firstEntry);
        return {
            result: await this.mediatorJoin.mediate({
                type: action.type,
                entries,
                context: action.context,
            }),
        };
    }
    async getJoinCoefficients(action, sideData) {
        let { metadatas } = sideData;
        metadatas = [...metadatas];
        // Determine the two smallest streams by sorting (e.g. via cardinality)
        const sortedEntries = await this.sortJoinEntries(action.entries
            .map((entry, i) => ({ ...entry, metadata: metadatas[i] })), action.context);
        metadatas = sortedEntries.map(entry => entry.metadata);
        const requestInitialTimes = bus_rdf_join_1.ActorRdfJoin.getRequestInitialTimes(metadatas);
        const requestItemTimes = bus_rdf_join_1.ActorRdfJoin.getRequestItemTimes(metadatas);
        return (0, core_1.passTestWithSideData)({
            iterations: metadatas.reduce((acc, metadata) => acc * metadata.cardinality.value, 1),
            persistedItems: 0,
            blockingItems: 0,
            requestTime: metadatas.reduce((sum, metadata, i) => sum + requestInitialTimes[i] +
                metadata.cardinality.value * requestItemTimes[i], 0),
        }, { ...sideData, sortedEntries });
    }
}
exports.ActorRdfJoinMultiSmallest = ActorRdfJoinMultiSmallest;
//# sourceMappingURL=ActorRdfJoinMultiSmallest.js.map