"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonLexicalLiteral = exports.YearMonthDurationLiteral = exports.DayTimeDurationLiteral = exports.DurationLiteral = exports.DateLiteral = exports.TimeLiteral = exports.DateTimeLiteral = exports.StringLiteral = exports.DirLangStringLiteral = exports.LangStringLiteral = exports.BooleanLiteral = exports.DoubleLiteral = exports.FloatLiteral = exports.DecimalLiteral = exports.IntegerLiteral = exports.NumericLiteral = exports.Literal = exports.DefaultGraph = exports.Quad = exports.BlankNode = exports.NamedNode = exports.Term = void 0;
exports.isLiteralTermExpression = isLiteralTermExpression;
exports.isNonLexicalLiteral = isNonLexicalLiteral;
const types_1 = require("@comunica/types");
const C = require("../util/Consts");
const Consts_1 = require("../util/Consts");
const Err = require("../util/Errors");
const Serialization_1 = require("../util/Serialization");
class Term {
    expressionType = types_1.ExpressionType.Term;
    str() {
        throw new Err.InvalidArgumentTypes([this], C.SparqlOperator.STR);
    }
    coerceEBV() {
        throw new Err.EBVCoercionError(this);
    }
}
exports.Term = Term;
// NamedNodes -----------------------------------------------------------------
class NamedNode extends Term {
    value;
    termType = 'namedNode';
    constructor(value) {
        super();
        this.value = value;
    }
    toRDF(dataFactory) {
        return dataFactory.namedNode(this.value);
    }
    str() {
        return this.value;
    }
}
exports.NamedNode = NamedNode;
// BlankNodes -----------------------------------------------------------------
class BlankNode extends Term {
    value;
    termType = 'blankNode';
    constructor(value) {
        super();
        this.value = value;
    }
    toRDF(dataFactory) {
        return typeof this.value === 'string' ? dataFactory.blankNode(this.value) : this.value;
    }
}
exports.BlankNode = BlankNode;
// Quads -----------------------------------------------------------------
class Quad extends Term {
    subject;
    predicate;
    object;
    graph;
    termType = 'quad';
    constructor(subject, predicate, object, graph) {
        super();
        this.subject = subject;
        this.predicate = predicate;
        this.object = object;
        this.graph = graph;
    }
    toRDF(dataFactory) {
        return dataFactory.quad(this.subject.toRDF(dataFactory), this.predicate.toRDF(dataFactory), this.object.toRDF(dataFactory), this.graph.toRDF(dataFactory));
    }
    str() {
        return `Quad: [${this.subject.str()}, ${this.predicate.str()}, ${this.object.str()}, ${this.graph.str()}]`;
    }
}
exports.Quad = Quad;
class DefaultGraph extends Term {
    termType = 'defaultGraph';
    constructor() {
        super();
    }
    toRDF(dataFactory) {
        return dataFactory.defaultGraph();
    }
    str() {
        return 'DefaultGraph';
    }
}
exports.DefaultGraph = DefaultGraph;
// Literals-- -----------------------------------------------------------------
function isLiteralTermExpression(expr) {
    if (expr.termType === 'literal') {
        return expr;
    }
    return undefined;
}
class Literal extends Term {
    typedValue;
    dataType;
    strValue;
    language;
    direction;
    termType = 'literal';
    /**
     * @param typedValue internal representation of this literal's value
     * @param dataType a string representing the datatype. Can be of type @see LiteralTypes or any URI
     * @param strValue the string value of this literal. In other words, the string representing the RDF.literal value.
     * @param language the language, mainly for language enabled strings like RDF_LANG_STRING
     * @param direction the base direction, mainly for directional language enabled strings like RDF_DIR_LANG_STRING
     */
    constructor(typedValue, dataType, strValue, language, direction) {
        super();
        this.typedValue = typedValue;
        this.dataType = dataType;
        this.strValue = strValue;
        this.language = language;
        this.direction = direction;
    }
    toRDF(dataFactory) {
        return dataFactory.literal(this.strValue ?? this.str(), this.direction && this.language ?
            { language: this.language, direction: this.direction } :
            this.language ?? dataFactory.namedNode(this.dataType));
    }
    str() {
        return this.strValue ?? this.typedValue.toString();
    }
}
exports.Literal = Literal;
class NumericLiteral extends Literal {
    typedValue;
    strValue;
    language;
    constructor(typedValue, dataType, strValue, language) {
        super(typedValue, dataType, strValue, language);
        this.typedValue = typedValue;
        this.strValue = strValue;
        this.language = language;
    }
    coerceEBV() {
        return Boolean(this.typedValue);
    }
    toRDF(dataFactory) {
        const term = super.toRDF(dataFactory);
        if (!Number.isFinite(this.typedValue)) {
            term.value = term.value.replace('Infinity', 'INF');
        }
        return term;
    }
    str() {
        return this.strValue ??
            this.specificFormatter(this.typedValue);
    }
}
exports.NumericLiteral = NumericLiteral;
class IntegerLiteral extends NumericLiteral {
    typedValue;
    strValue;
    language;
    constructor(typedValue, dataType, strValue, language) {
        super(typedValue, dataType ?? Consts_1.TypeURL.XSD_INTEGER, strValue, language);
        this.typedValue = typedValue;
        this.strValue = strValue;
        this.language = language;
    }
    specificFormatter(val) {
        return val.toFixed(0);
    }
}
exports.IntegerLiteral = IntegerLiteral;
class DecimalLiteral extends NumericLiteral {
    typedValue;
    strValue;
    language;
    constructor(typedValue, dataType, strValue, language) {
        super(typedValue, dataType ?? Consts_1.TypeURL.XSD_DECIMAL, strValue, language);
        this.typedValue = typedValue;
        this.strValue = strValue;
        this.language = language;
    }
    specificFormatter(val) {
        return val.toString();
    }
}
exports.DecimalLiteral = DecimalLiteral;
class FloatLiteral extends NumericLiteral {
    typedValue;
    strValue;
    language;
    constructor(typedValue, dataType, strValue, language) {
        super(typedValue, dataType ?? Consts_1.TypeURL.XSD_FLOAT, strValue, language);
        this.typedValue = typedValue;
        this.strValue = strValue;
        this.language = language;
    }
    specificFormatter(val) {
        return val.toString();
    }
}
exports.FloatLiteral = FloatLiteral;
class DoubleLiteral extends NumericLiteral {
    typedValue;
    strValue;
    language;
    constructor(typedValue, dataType, strValue, language) {
        super(typedValue, dataType ?? Consts_1.TypeURL.XSD_DOUBLE, strValue, language);
        this.typedValue = typedValue;
        this.strValue = strValue;
        this.language = language;
    }
    specificFormatter(val) {
        if (!Number.isFinite(val)) {
            if (val > 0) {
                return 'INF';
            }
            if (val < 0) {
                return '-INF';
            }
            return 'NaN';
        }
        const jsExponential = val.toExponential();
        const [jsMantisse, jsExponent] = jsExponential.split('e');
        // Leading + must be removed for integer
        // https://www.w3.org/TR/xmlschema-2/#integer
        const exponent = jsExponent.replace(/\+/u, '');
        // SPARQL test suite prefers trailing zero's
        const mantisse = jsMantisse.includes('.') ?
            jsMantisse :
            `${jsMantisse}.0`;
        return `${mantisse}E${exponent}`;
    }
}
exports.DoubleLiteral = DoubleLiteral;
class BooleanLiteral extends Literal {
    typedValue;
    strValue;
    constructor(typedValue, strValue, dataType) {
        super(typedValue, dataType ?? Consts_1.TypeURL.XSD_BOOLEAN, strValue);
        this.typedValue = typedValue;
        this.strValue = strValue;
    }
    coerceEBV() {
        return this.typedValue;
    }
}
exports.BooleanLiteral = BooleanLiteral;
class LangStringLiteral extends Literal {
    typedValue;
    language;
    constructor(typedValue, language, dataType) {
        super(typedValue, dataType ?? Consts_1.TypeURL.RDF_LANG_STRING, typedValue, language);
        this.typedValue = typedValue;
        this.language = language;
    }
    coerceEBV() {
        // Throws in [SPARQL 1.2](https://www.w3.org/TR/sparql12-query/#ebv), and [1.1](https://www.w3.org/TR/sparql11-query/#ebv)
        return super.coerceEBV();
    }
}
exports.LangStringLiteral = LangStringLiteral;
class DirLangStringLiteral extends Literal {
    typedValue;
    language;
    direction;
    constructor(typedValue, language, direction, dataType) {
        super(typedValue, dataType ?? Consts_1.TypeURL.RDF_DIR_LANG_STRING, typedValue, language, direction);
        this.typedValue = typedValue;
        this.language = language;
        this.direction = direction;
    }
}
exports.DirLangStringLiteral = DirLangStringLiteral;
// https://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal
// https://www.w3.org/TR/sparql11-query/#defn_SimpleLiteral
// https://www.w3.org/TR/sparql11-query/#func-strings
// This does not include language tagged literals
class StringLiteral extends Literal {
    typedValue;
    /**
     * @param typedValue
     * @param dataType Should be type that implements XSD_STRING
     */
    constructor(typedValue, dataType) {
        super(typedValue, dataType ?? Consts_1.TypeURL.XSD_STRING, typedValue);
        this.typedValue = typedValue;
    }
    coerceEBV() {
        return this.str().length > 0;
    }
}
exports.StringLiteral = StringLiteral;
class DateTimeLiteral extends Literal {
    typedValue;
    strValue;
    constructor(typedValue, strValue, dataType) {
        super(typedValue, dataType ?? Consts_1.TypeURL.XSD_DATE_TIME, strValue);
        this.typedValue = typedValue;
        this.strValue = strValue;
    }
    str() {
        return (0, Serialization_1.serializeDateTime)(this.typedValue);
    }
}
exports.DateTimeLiteral = DateTimeLiteral;
class TimeLiteral extends Literal {
    typedValue;
    strValue;
    constructor(typedValue, strValue, dataType) {
        super(typedValue, dataType ?? Consts_1.TypeURL.XSD_TIME, strValue);
        this.typedValue = typedValue;
        this.strValue = strValue;
    }
    str() {
        return (0, Serialization_1.serializeTime)(this.typedValue);
    }
}
exports.TimeLiteral = TimeLiteral;
class DateLiteral extends Literal {
    typedValue;
    strValue;
    constructor(typedValue, strValue, dataType) {
        super(typedValue, dataType ?? Consts_1.TypeURL.XSD_DATE, strValue);
        this.typedValue = typedValue;
        this.strValue = strValue;
    }
    str() {
        return (0, Serialization_1.serializeDate)(this.typedValue);
    }
}
exports.DateLiteral = DateLiteral;
class DurationLiteral extends Literal {
    typedValue;
    strValue;
    constructor(typedValue, strValue, dataType) {
        super(typedValue, dataType ?? Consts_1.TypeURL.XSD_DURATION, strValue);
        this.typedValue = typedValue;
        this.strValue = strValue;
    }
    str() {
        return (0, Serialization_1.serializeDuration)(this.typedValue);
    }
}
exports.DurationLiteral = DurationLiteral;
class DayTimeDurationLiteral extends DurationLiteral {
    typedValue;
    strValue;
    constructor(typedValue, strValue, dataType) {
        super(typedValue, strValue, dataType ?? Consts_1.TypeURL.XSD_DAY_TIME_DURATION);
        this.typedValue = typedValue;
        this.strValue = strValue;
    }
}
exports.DayTimeDurationLiteral = DayTimeDurationLiteral;
class YearMonthDurationLiteral extends Literal {
    typedValue;
    strValue;
    constructor(typedValue, strValue, dataType) {
        super(typedValue, dataType ?? Consts_1.TypeURL.XSD_YEAR_MONTH_DURATION, strValue);
        this.typedValue = typedValue;
        this.strValue = strValue;
    }
    str() {
        return (0, Serialization_1.serializeDuration)(this.typedValue, 'P0M');
    }
}
exports.YearMonthDurationLiteral = YearMonthDurationLiteral;
/**
 * This class is used when a literal is parsed, and it's value is
 * an invalid lexical form for it's datatype. The spec defines value with
 * invalid lexical form are still valid terms, and as such we can not error
 * immediately. This class makes sure that the typedValue will remain undefined,
 * and the category 'nonlexical'. This way, only when operators apply to the
 * 'nonlexical' category, they will keep working, otherwise they will throw a
 * type error.
 * This seems to match the spec, except maybe for functions that accept
 * non-lexical values for their datatype.
 *
 * See:
 *  - https://www.w3.org/TR/xquery/#dt-type-error
 *  - https://www.w3.org/TR/rdf-concepts/#section-Literal-Value
 *  - https://www.w3.org/TR/xquery/#dt-ebv
 *  - ... some other more precise thing i can't find...
 */
class NonLexicalLiteral extends Literal {
    openWorldType;
    constructor(typedValue, dataType, openWorldType, strValue, language) {
        super({ toString: () => 'undefined' }, dataType, strValue, language);
        this.openWorldType = openWorldType;
    }
    coerceEBV() {
        // Always throws in [SPARQL 1.2](https://www.w3.org/TR/sparql12-query/#ebv),
        // and sometimes throws in [1.1](https://www.w3.org/TR/sparql11-query/#ebv)
        return super.coerceEBV();
    }
    toRDF(dataFactory) {
        return dataFactory.literal(this.str(), this.language ?? dataFactory.namedNode(this.dataType));
    }
    str() {
        return this.strValue ?? '';
    }
}
exports.NonLexicalLiteral = NonLexicalLiteral;
function isNonLexicalLiteral(lit) {
    if (lit instanceof NonLexicalLiteral) {
        return lit;
    }
    return undefined;
}
//# sourceMappingURL=Term.js.map