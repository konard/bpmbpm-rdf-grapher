{"version":3,"file":"Term.js","sourceRoot":"","sources":["Term.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ComunicaDataFactory,\n  IDateRepresentation,\n  IDateTimeRepresentation,\n  IDurationRepresentation,\n  ISuperTypeProvider,\n  ITimeRepresentation,\n  IYearMonthDurationRepresentation,\n  TermExpression,\n  TermType,\n} from '@comunica/types';\nimport { ExpressionType } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport * as C from '../util/Consts';\nimport { TypeURL } from '../util/Consts';\nimport * as Err from '../util/Errors';\nimport { serializeDate, serializeDateTime, serializeDuration, serializeTime } from '../util/Serialization';\n\nexport abstract class Term implements TermExpression {\n  public expressionType: ExpressionType.Term = ExpressionType.Term;\n  public abstract termType: TermType;\n\n  public abstract toRDF(dataFactory: ComunicaDataFactory): RDF.Term;\n\n  public str(): string {\n    throw new Err.InvalidArgumentTypes([ this ], C.SparqlOperator.STR);\n  }\n\n  public coerceEBV(): boolean {\n    throw new Err.EBVCoercionError(this);\n  }\n}\n\n// NamedNodes -----------------------------------------------------------------\nexport class NamedNode extends Term {\n  public termType: TermType = 'namedNode';\n  public constructor(public value: string) {\n    super();\n  }\n\n  public toRDF(dataFactory: ComunicaDataFactory): RDF.Term {\n    return dataFactory.namedNode(this.value);\n  }\n\n  public override str(): string {\n    return this.value;\n  }\n}\n\n// BlankNodes -----------------------------------------------------------------\n\nexport class BlankNode extends Term {\n  public value: RDF.BlankNode | string;\n  public termType: TermType = 'blankNode';\n\n  public constructor(value: RDF.BlankNode | string) {\n    super();\n    this.value = value;\n  }\n\n  public toRDF(dataFactory: ComunicaDataFactory): RDF.Term {\n    return typeof this.value === 'string' ? dataFactory.blankNode(this.value) : this.value;\n  }\n}\n\n// Quads -----------------------------------------------------------------\nexport class Quad extends Term {\n  public termType: TermType = 'quad';\n\n  public constructor(\n    public readonly subject: Term,\n    public readonly predicate: Term,\n    public readonly object: Term,\n    public readonly graph: Term,\n  ) {\n    super();\n  }\n\n  public toRDF(dataFactory: ComunicaDataFactory): RDF.BaseQuad {\n    return dataFactory.quad(\n      <RDF.Quad_Subject> this.subject.toRDF(dataFactory),\n      <RDF.Quad_Predicate> this.predicate.toRDF(dataFactory),\n      <RDF.Quad_Object> this.object.toRDF(dataFactory),\n      <RDF.Quad_Graph> this.graph.toRDF(dataFactory),\n    );\n  }\n\n  public override str(): string {\n    return `Quad: [${this.subject.str()}, ${this.predicate.str()}, ${this.object.str()}, ${this.graph.str()}]`;\n  }\n}\n\nexport class DefaultGraph extends Term {\n  public termType: TermType = 'defaultGraph';\n\n  public constructor() {\n    super();\n  }\n\n  public toRDF(dataFactory: ComunicaDataFactory): RDF.DefaultGraph {\n    return dataFactory.defaultGraph();\n  }\n\n  public override str(): string {\n    return 'DefaultGraph';\n  }\n}\n\n// Literals-- -----------------------------------------------------------------\nexport function isLiteralTermExpression(expr: TermExpression): Literal<any> | undefined {\n  if (expr.termType === 'literal') {\n    return <Literal<any>> expr;\n  }\n  return undefined;\n}\n\nexport interface ISerializable {\n  toString: () => string;\n}\n\nexport class Literal<T extends ISerializable> extends Term {\n  public termType = <const> 'literal';\n  /**\n   * @param typedValue internal representation of this literal's value\n   * @param dataType a string representing the datatype. Can be of type @see LiteralTypes or any URI\n   * @param strValue the string value of this literal. In other words, the string representing the RDF.literal value.\n   * @param language the language, mainly for language enabled strings like RDF_LANG_STRING\n   * @param direction the base direction, mainly for directional language enabled strings like RDF_DIR_LANG_STRING\n   */\n  public constructor(\n    public typedValue: T,\n    public dataType: string,\n    public strValue?: string,\n    public language?: string,\n    public direction?: 'ltr' | 'rtl',\n  ) {\n    super();\n  }\n\n  public toRDF(dataFactory: ComunicaDataFactory): RDF.Literal {\n    return dataFactory.literal(\n      this.strValue ?? this.str(),\n      this.direction && this.language ?\n          { language: this.language, direction: this.direction } :\n        this.language ?? dataFactory.namedNode(this.dataType),\n    );\n  }\n\n  public override str(): string {\n    return this.strValue ?? this.typedValue.toString();\n  }\n}\n\nexport abstract class NumericLiteral extends Literal<number> {\n  protected constructor(\n    public override typedValue: number,\n    dataType: string,\n    public override strValue?: string,\n    public override language?: string,\n  ) {\n    super(typedValue, dataType, strValue, language);\n  }\n\n  protected abstract specificFormatter(val: number): string;\n\n  public override coerceEBV(): boolean {\n    return Boolean(this.typedValue);\n  }\n\n  public override toRDF(dataFactory: ComunicaDataFactory): RDF.Literal {\n    const term = super.toRDF(dataFactory);\n    if (!Number.isFinite(this.typedValue)) {\n      term.value = term.value.replace('Infinity', 'INF');\n    }\n    return term;\n  }\n\n  public override str(): string {\n    return this.strValue ??\n      this.specificFormatter(this.typedValue);\n  }\n}\n\nexport class IntegerLiteral extends NumericLiteral {\n  public constructor(\n    public override typedValue: number,\n    dataType?: string,\n    public override strValue?: string,\n    public override language?: string,\n  ) {\n    super(typedValue, dataType ?? TypeURL.XSD_INTEGER, strValue, language);\n  }\n\n  protected specificFormatter(val: number): string {\n    return val.toFixed(0);\n  }\n}\n\nexport class DecimalLiteral extends NumericLiteral {\n  public constructor(\n    public override typedValue: number,\n    dataType?: string,\n    public override strValue?: string,\n    public override language?: string,\n  ) {\n    super(typedValue, dataType ?? TypeURL.XSD_DECIMAL, strValue, language);\n  }\n\n  protected specificFormatter(val: number): string {\n    return val.toString();\n  }\n}\n\nexport class FloatLiteral extends NumericLiteral {\n  public constructor(\n    public override typedValue: number,\n    dataType?: string,\n    public override strValue?: string,\n    public override language?: string,\n  ) {\n    super(typedValue, dataType ?? TypeURL.XSD_FLOAT, strValue, language);\n  }\n\n  protected specificFormatter(val: number): string {\n    return val.toString();\n  }\n}\n\nexport class DoubleLiteral extends NumericLiteral {\n  public constructor(\n    public override typedValue: number,\n    dataType?: string,\n    public override strValue?: string,\n    public override language?: string,\n  ) {\n    super(typedValue, dataType ?? TypeURL.XSD_DOUBLE, strValue, language);\n  }\n\n  protected specificFormatter(val: number): string {\n    if (!Number.isFinite(val)) {\n      if (val > 0) {\n        return 'INF';\n      }\n      if (val < 0) {\n        return '-INF';\n      }\n      return 'NaN';\n    }\n\n    const jsExponential = val.toExponential();\n    const [ jsMantisse, jsExponent ] = jsExponential.split('e');\n\n    // Leading + must be removed for integer\n    // https://www.w3.org/TR/xmlschema-2/#integer\n    const exponent = jsExponent.replace(/\\+/u, '');\n\n    // SPARQL test suite prefers trailing zero's\n    const mantisse = jsMantisse.includes('.') ?\n      jsMantisse :\n      `${jsMantisse}.0`;\n\n    return `${mantisse}E${exponent}`;\n  }\n}\n\nexport class BooleanLiteral extends Literal<boolean> {\n  public constructor(public override typedValue: boolean, public override strValue?: string, dataType?: string) {\n    super(typedValue, dataType ?? TypeURL.XSD_BOOLEAN, strValue);\n  }\n\n  public override coerceEBV(): boolean {\n    return this.typedValue;\n  }\n}\n\nexport class LangStringLiteral extends Literal<string> {\n  public constructor(public override typedValue: string, public override language: string, dataType?: string) {\n    super(typedValue, dataType ?? TypeURL.RDF_LANG_STRING, typedValue, language);\n  }\n\n  public override coerceEBV(): boolean {\n    // Throws in [SPARQL 1.2](https://www.w3.org/TR/sparql12-query/#ebv), and [1.1](https://www.w3.org/TR/sparql11-query/#ebv)\n    return super.coerceEBV();\n  }\n}\n\nexport class DirLangStringLiteral extends Literal<string> {\n  public constructor(\n    public override typedValue: string,\n    public override language: string,\n    public override direction: 'ltr' | 'rtl',\n    dataType?: string,\n  ) {\n    super(typedValue, dataType ?? TypeURL.RDF_DIR_LANG_STRING, typedValue, language, direction);\n  }\n}\n\n// https://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal\n// https://www.w3.org/TR/sparql11-query/#defn_SimpleLiteral\n// https://www.w3.org/TR/sparql11-query/#func-strings\n// This does not include language tagged literals\nexport class StringLiteral extends Literal<string> {\n  /**\n   * @param typedValue\n   * @param dataType Should be type that implements XSD_STRING\n   */\n  public constructor(public override typedValue: string, dataType?: string) {\n    super(typedValue, dataType ?? TypeURL.XSD_STRING, typedValue);\n  }\n\n  public override coerceEBV(): boolean {\n    return this.str().length > 0;\n  }\n}\n\nexport class DateTimeLiteral extends Literal<IDateTimeRepresentation> {\n  public constructor(\n    public override typedValue: IDateTimeRepresentation,\n    public override strValue?: string,\n    dataType?: string,\n  ) {\n    super(typedValue, dataType ?? TypeURL.XSD_DATE_TIME, strValue);\n  }\n\n  public override str(): string {\n    return serializeDateTime(this.typedValue);\n  }\n}\n\nexport class TimeLiteral extends Literal<ITimeRepresentation> {\n  public constructor(\n    public override typedValue: ITimeRepresentation,\n    public override strValue?: string,\n    dataType?: string,\n  ) {\n    super(typedValue, dataType ?? TypeURL.XSD_TIME, strValue);\n  }\n\n  public override str(): string {\n    return serializeTime(this.typedValue);\n  }\n}\n\nexport class DateLiteral extends Literal<IDateRepresentation> {\n  public constructor(\n    public override typedValue: IDateRepresentation,\n    public override strValue?: string,\n    dataType?: string,\n  ) {\n    super(typedValue, dataType ?? TypeURL.XSD_DATE, strValue);\n  }\n\n  public override str(): string {\n    return serializeDate(this.typedValue);\n  }\n}\n\nexport class DurationLiteral extends Literal<Partial<IDurationRepresentation>> {\n  public constructor(\n    public override typedValue: Partial<IDurationRepresentation>,\n    public override strValue?: string,\n    dataType?: string,\n  ) {\n    super(typedValue, dataType ?? TypeURL.XSD_DURATION, strValue);\n  }\n\n  public override str(): string {\n    return serializeDuration(this.typedValue);\n  }\n}\n\nexport class DayTimeDurationLiteral extends DurationLiteral {\n  public constructor(\n    public override typedValue: Partial<IDurationRepresentation>,\n    public override strValue?: string,\n    dataType?: string,\n  ) {\n    super(typedValue, strValue, dataType ?? TypeURL.XSD_DAY_TIME_DURATION);\n  }\n}\n\nexport class YearMonthDurationLiteral extends Literal<Partial<IYearMonthDurationRepresentation>> {\n  public constructor(\n    public override typedValue: Partial<IYearMonthDurationRepresentation>,\n    public override strValue?: string,\n    dataType?: string,\n  ) {\n    super(typedValue, dataType ?? TypeURL.XSD_YEAR_MONTH_DURATION, strValue);\n  }\n\n  public override str(): string {\n    return serializeDuration(this.typedValue, 'P0M');\n  }\n}\n\n/**\n * This class is used when a literal is parsed, and it's value is\n * an invalid lexical form for it's datatype. The spec defines value with\n * invalid lexical form are still valid terms, and as such we can not error\n * immediately. This class makes sure that the typedValue will remain undefined,\n * and the category 'nonlexical'. This way, only when operators apply to the\n * 'nonlexical' category, they will keep working, otherwise they will throw a\n * type error.\n * This seems to match the spec, except maybe for functions that accept\n * non-lexical values for their datatype.\n *\n * See:\n *  - https://www.w3.org/TR/xquery/#dt-type-error\n *  - https://www.w3.org/TR/rdf-concepts/#section-Literal-Value\n *  - https://www.w3.org/TR/xquery/#dt-ebv\n *  - ... some other more precise thing i can't find...\n */\nexport class NonLexicalLiteral extends Literal<{ toString: () => 'undefined' }> {\n  public constructor(\n    typedValue: undefined,\n    dataType: string,\n    private readonly openWorldType: ISuperTypeProvider,\n    strValue?: string,\n    language?: string,\n  ) {\n    super({ toString: () => 'undefined' }, dataType, strValue, language);\n  }\n\n  public override coerceEBV(): boolean {\n    // Always throws in [SPARQL 1.2](https://www.w3.org/TR/sparql12-query/#ebv),\n    // and sometimes throws in [1.1](https://www.w3.org/TR/sparql11-query/#ebv)\n    return super.coerceEBV();\n  }\n\n  public override toRDF(dataFactory: ComunicaDataFactory): RDF.Literal {\n    return dataFactory.literal(\n      this.str(),\n      this.language ?? dataFactory.namedNode(this.dataType),\n    );\n  }\n\n  public override str(): string {\n    return this.strValue ?? '';\n  }\n}\n\nexport function isNonLexicalLiteral(lit: Literal<any>): NonLexicalLiteral | undefined {\n  if (lit instanceof NonLexicalLiteral) {\n    return lit;\n  }\n  return undefined;\n}\n"]}