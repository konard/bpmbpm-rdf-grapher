{"version":3,"file":"Errors.js","sourceRoot":"","sources":["Errors.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Expression } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type * as E from '../expressions';\nimport type * as C from './Consts';\n\n/**\n * This class of error will be thrown when an expression errors.\n * Various reasons this could happen are:\n *   - invalid types for the given operator\n *   - unbound variables\n *   - invalid lexical forms\n *   - ...\n *\n * The distinction is made so that one can catch this specific type\n * and handle it accordingly to the SPARQL spec (relevant for e.g. FILTER, EXTEND),\n * while others (programming errors) can be re-thrown.\n *\n * @see isExpressionError\n */\nexport class ExpressionError extends Error {}\n\n/**\n * Checks whether a given error is an {@link ExpressionError}.\n * Also useful for mocking in tests for covering all branches.\n *\n * @see ExpressionError\n */\nexport function isExpressionError(error: Error): boolean {\n  return error instanceof ExpressionError;\n}\n\n/**\n * A literal has an invalid lexical form for the datatype it is accompanied by.\n * This error is only thrown when the term is as function argument that requires\n * a valid lexical form.\n */\nexport class InvalidLexicalForm extends ExpressionError {\n  public constructor(public arg: RDF.Term) {\n    super(`Invalid lexical form '${pp(arg)}'`);\n  }\n}\n\n/**\n * A variable in the expression was not bound.\n */\nexport class UnboundVariableError extends ExpressionError {\n  public constructor(public variable: string, public bindings: RDF.Bindings) {\n    super(`Unbound variable '${pp(variable)}'`);\n  }\n}\n\n/**\n * An invalid term was being coerced to an Effective Boolean Value.\n *\n * See the {@link https://www.w3.org/TR/sparql11-query/#ebv | SPARQL docs}\n * on EBVs.\n */\nexport class EBVCoercionError extends ExpressionError {\n  public constructor(public arg: E.Term) {\n    super(`Cannot coerce term to EBV '${pp(arg)}'`);\n  }\n}\n\n/**\n * An equality test was done on literals with unsupported datatypes.\n *\n * See {@link https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal | term equality spec}.\n */\nexport class RDFEqualTypeError extends ExpressionError {\n  public constructor(public args: Expression[]) {\n    super('Equality test for literals with unsupported datatypes');\n  }\n}\n\n/**\n * All the expressions in a COALESCE call threw errors.\n */\nexport class CoalesceError extends ExpressionError {\n  public constructor(public errors: Error[]) {\n    super('All COALESCE arguments threw errors');\n  }\n}\n\n/**\n * No arguments to an IN call where equal, and at least one threw an error.\n */\nexport class InError extends ExpressionError {\n  public constructor(public errors: (Error | false)[]) {\n    super(\n      `Some argument to IN errorred and none where equal. ${\n\n        errors.map(err => `(${err.toString()}) `).join('and ')}`,\n    );\n  }\n}\n\n/**\n * Literals were passed to an operator that doesn't support their datatypes.\n */\nexport class InvalidArgumentTypes extends ExpressionError {\n  public constructor(public args: Expression[], public op: C.GeneralOperator) {\n    super(`Argument types not valid for operator: '${pp(op)}' with '${pp(args)}`);\n  }\n}\n\n/**\n * An invalid typecast happened.\n */\nexport class CastError<T> extends ExpressionError {\n  public constructor(public arg: T, cast: C.TypeURL) {\n    super(`Invalid cast: '${pp(arg)}' to '${pp(cast)}'`);\n  }\n}\n\nexport class InvalidTimezoneCall extends ExpressionError {\n  public constructor(public dateString: string) {\n    super(`TIMEZONE call on ${dateString} which has no timezone`);\n  }\n}\n\nexport class IncompatibleLanguageOperation extends ExpressionError {\n  public constructor(public arg1: E.LangStringLiteral, public arg2: E.LangStringLiteral) {\n    super(`Operation on incompatible language literals '${pp(arg1)}' and '${pp(arg2)}'`);\n  }\n}\n\nexport class IncompatibleDirectionalLanguageOperation extends ExpressionError {\n  public constructor(public arg1: E.DirLangStringLiteral, public arg2: E.DirLangStringLiteral) {\n    super(`Operation on incompatible directional language literals '${pp(arg1)}' and '${pp(arg2)}'`);\n  }\n}\n\nexport class EmptyAggregateError extends ExpressionError {\n  public constructor() {\n    super('Empty aggregate expression');\n  }\n}\n\nexport class ParseError extends ExpressionError {\n  public constructor(str: string, type: string) {\n    super(`Failed to parse \"${str}\" as ${type}.`);\n  }\n}\n\n// Non Expression Errors ------------------------------------------------------\n\n/**\n * An error that arises when we detect a 'should-be-impossible' state.\n * Given that this error is thrown, it clearly wasn't impossible, and some\n * mistake has been made.\n */\nexport class UnexpectedError<T> extends Error {\n  public constructor(message: string, public payload?: T) {\n    super(`Programmer Error '${message}'`);\n  }\n}\n\nexport class InvalidArity extends Error {\n  public constructor(public args: Expression[], public op: C.GeneralOperator) {\n    super(`The number of args does not match the arity of the operator '${pp(op)}'.`);\n  }\n}\n\nexport class InvalidExpression<T> extends Error {\n  public constructor(expr: T) {\n    super(`Invalid SPARQL Expression '${pp(expr)}'`);\n  }\n}\n\nexport class ExtensionFunctionError extends Error {\n  public constructor(name: string, functionError: unknown) {\n    if (functionError instanceof Error) {\n      super(`Error thrown in ${name}: ${functionError.message}${functionError.stack ? `\\n${functionError.stack}` : ''}`);\n    } else {\n      super(`Error thrown in ${name}`);\n    }\n  }\n}\n\nexport class NoAggregator extends Error {\n  public constructor(name?: string) {\n    super(`Aggregate expression ${pp(name)} found, but no aggregate hook provided.`);\n  }\n}\n\nfunction pp<T>(object: T): string {\n  return JSON.stringify(object);\n}\n"]}