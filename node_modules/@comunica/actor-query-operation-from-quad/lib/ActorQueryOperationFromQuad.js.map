{"version":3,"file":"ActorQueryOperationFromQuad.js","sourceRoot":"","sources":["ActorQueryOperationFromQuad.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport { ActorQueryOperationTypedMediated } from '@comunica/bus-query-operation';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { passTestVoid } from '@comunica/core';\nimport type { ComunicaDataFactory, IActionContext, IQueryOperationResult } from '@comunica/types';\nimport { Algebra, AlgebraFactory, isKnownOperation } from '@comunica/utils-algebra';\nimport type * as RDF from '@rdfjs/types';\n\n/**\n * A comunica From Query Operation Actor.\n */\nexport class ActorQueryOperationFromQuad extends ActorQueryOperationTypedMediated<Algebra.From> {\n  private static readonly ALGEBRA_TYPES: string[] = Object.keys(Algebra.Types).map(key => (<any> Algebra.Types)[key]);\n\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, Algebra.Types.FROM);\n  }\n\n  /**\n   * Create a deep copy of the given operation.\n   * @param {Operation} operation An operation.\n   * @param {(subOperation: Operation) => Operation} recursiveCb A callback for recursive operation calls.\n   * @return {Operation} The copied operation.\n   */\n  public static copyOperation(\n    operation: Algebra.Operation,\n    recursiveCb: (subOperation: Algebra.Operation) => Algebra.Operation,\n  ): Algebra.Operation {\n    const copiedOperation: Algebra.Operation = <any> {};\n    for (const [ key, value ] of Object.entries(operation)) {\n      const castedKey = <keyof typeof operation> key;\n      if (Array.isArray(value) && key !== 'template') {\n        // We exclude the 'template' entry, as we don't want to modify the template value of construct operations\n        if (key === 'variables') {\n          copiedOperation[castedKey] = <any> value;\n        } else {\n          copiedOperation[castedKey] = <any> value.map(recursiveCb);\n        }\n      } else if (ActorQueryOperationFromQuad.ALGEBRA_TYPES.includes(value.type)) {\n        copiedOperation[castedKey] = <any> recursiveCb(value);\n      } else {\n        copiedOperation[castedKey] = value;\n      }\n    }\n    return copiedOperation;\n  }\n\n  /**\n   * Recursively transform the given operation to use the given graphs as default graph\n   * This will (possibly) create a new operation and not modify the given operation.\n   * @package\n   * @param algebraFactory The algebra factory.\n   * @param {Operation} operation An operation.\n   * @param {RDF.Term[]} defaultGraphs Graph terms.\n   * @return {Operation} A new operation.\n   */\n  public static applyOperationDefaultGraph(\n    algebraFactory: AlgebraFactory,\n    operation: Algebra.Operation,\n    defaultGraphs: RDF.Term[],\n  ): Algebra.Operation {\n    // If the operation is a BGP or Path, change the graph.\n    if ((isKnownOperation(operation, Algebra.Types.BGP) && operation.patterns.length > 0) ||\n      isKnownOperation(operation, Algebra.Types.PATH) || isKnownOperation(operation, Algebra.Types.PATTERN)) {\n      if (isKnownOperation(operation, Algebra.Types.BGP)) {\n        return ActorQueryOperationFromQuad\n          .joinOperations(algebraFactory, operation.patterns.map((pattern) => {\n            if (pattern.graph.termType !== 'DefaultGraph') {\n              return algebraFactory.createBgp([ pattern ]);\n            }\n            const bgps = defaultGraphs.map((graph: RDF.Term) =>\n              algebraFactory.createBgp([ Object.assign(\n                algebraFactory\n                  .createPattern(pattern.subject, pattern.predicate, pattern.object, graph),\n                { metadata: pattern.metadata },\n              ) ]));\n            return ActorQueryOperationFromQuad.unionOperations(algebraFactory, bgps);\n          }));\n      }\n      if (operation.graph.termType !== 'DefaultGraph') {\n        return operation;\n      }\n      const paths = defaultGraphs.map(\n        (graph: RDF.Term) => {\n          if (isKnownOperation(operation, Algebra.Types.PATH)) {\n            return algebraFactory\n              .createPath(operation.subject, operation.predicate, operation.object, graph);\n          }\n          return Object.assign(algebraFactory\n            .createPattern(\n              operation.subject,\n              operation.predicate,\n              operation.object,\n              graph,\n            ), { metadata: operation.metadata });\n        },\n      );\n      return ActorQueryOperationFromQuad.unionOperations(algebraFactory, paths);\n    }\n\n    return ActorQueryOperationFromQuad.copyOperation(\n      operation,\n      subOperation => this.applyOperationDefaultGraph(algebraFactory, subOperation, defaultGraphs),\n    );\n  }\n\n  /**\n   * Recursively transform the given operation to use the given graphs as named graph\n   * This will (possibly) create a new operation and not modify the given operation.\n   * @package\n   * @param algebraFactory The algebra factory.\n   * @param {Operation} operation An operation.\n   * @param {RDF.Term[]} namedGraphs Graph terms.\n   * @param {RDF.Term[]} defaultGraphs Default graph terms.\n   * @return {Operation} A new operation.\n   */\n  public static applyOperationNamedGraph(\n    algebraFactory: AlgebraFactory,\n    operation: Algebra.Operation,\n    namedGraphs: RDF.NamedNode[],\n    defaultGraphs: RDF.Term[],\n  ): Algebra.Operation {\n    // If the operation is a BGP or Path, change the graph.\n    if ((isKnownOperation(operation, Algebra.Types.BGP) && operation.patterns.length > 0) ||\n      isKnownOperation(operation, Algebra.Types.PATH) || isKnownOperation(operation, Algebra.Types.PATTERN)) {\n      const patternGraph: RDF.Term = operation.type === 'bgp' ? operation.patterns[0].graph : operation.graph;\n      if (patternGraph.termType === 'DefaultGraph') {\n        // SPARQL spec (8.2) describes that when FROM NAMED's are used without a FROM, the default graph must be empty.\n        // The FROMs are transformed before this step to a named node, so this will not apply to this case anymore.\n        return algebraFactory.createBgp([]);\n      }\n      if (patternGraph.termType === 'Variable') {\n        if (namedGraphs.length === 1) {\n          const graph: RDF.NamedNode = namedGraphs[0];\n          // If the pattern graph is a variable, replace the graph and bind the variable using VALUES\n          const bindings: Record<string, RDF.Literal | RDF.NamedNode> = {};\n          bindings[patternGraph.value] = graph;\n          const values: Algebra.Values = algebraFactory\n            .createValues([ patternGraph ], [ bindings ]);\n\n          let pattern: Algebra.Operation;\n          if (operation.type === 'bgp') {\n            pattern = algebraFactory\n              .createBgp(operation.patterns.map((pat: Algebra.Pattern) => algebraFactory\n                .createPattern(pat.subject, pat.predicate, pat.object, graph)));\n          } else if (operation.type === 'path') {\n            pattern = algebraFactory\n              .createPath(operation.subject, operation.predicate, operation.object, graph);\n          } else {\n            pattern = algebraFactory\n              .createPattern(operation.subject, operation.predicate, operation.object, graph);\n          }\n\n          return algebraFactory.createJoin([ values, pattern ]);\n        }\n        // If the pattern graph is a variable, take the union of the pattern applied to each available named graph\n        return ActorQueryOperationFromQuad.unionOperations(algebraFactory, namedGraphs.map(\n          (graph: RDF.NamedNode) => ActorQueryOperationFromQuad.applyOperationNamedGraph(\n            algebraFactory,\n            operation,\n            [ graph ],\n            defaultGraphs,\n          ),\n        ));\n      }\n      // The pattern's graph is defined (including the default graphs)\n      const isNamedGraphAvailable: boolean = [ ...namedGraphs, ...defaultGraphs ].some(\n        (namedGraph: RDF.Term) => namedGraph.equals(patternGraph),\n      );\n      if (isNamedGraphAvailable) {\n        // Return the pattern as-is if the pattern's graph was selected in a FROM NAMED\n        return operation;\n      }\n      // No-op if the pattern's graph was not selected in a FROM NAMED.\n      return algebraFactory.createBgp([]);\n    }\n\n    return ActorQueryOperationFromQuad.copyOperation(\n      operation,\n      (subOperation: Algebra.Operation) => this\n        .applyOperationNamedGraph(algebraFactory, subOperation, namedGraphs, defaultGraphs),\n    );\n  }\n\n  /**\n   * Transform the given array of operations into a join operation.\n   * @package\n   * @param algebraFactory The algebra factory.\n   * @param {Operation[]} operations An array of operations, must contain at least one operation.\n   * @return {Join} A join operation.\n   */\n  public static joinOperations(algebraFactory: AlgebraFactory, operations: Algebra.Operation[]): Algebra.Operation {\n    if (operations.length === 1) {\n      return operations[0];\n    }\n    if (operations.length > 1) {\n      return algebraFactory.createJoin(operations);\n    }\n    throw new Error('A join can only be applied on at least one operation');\n  }\n\n  /**\n   * Transform the given array of operations into a union operation.\n   * @package\n   * @param algebraFactory The algebra factory.\n   * @param {Operation[]} operations An array of operations, must contain at least one operation.\n   * @return {Union} A union operation.\n   */\n  public static unionOperations(algebraFactory: AlgebraFactory, operations: Algebra.Operation[]): Algebra.Operation {\n    if (operations.length === 1) {\n      return operations[0];\n    }\n    if (operations.length > 1) {\n      return algebraFactory.createUnion(operations);\n    }\n    throw new Error('A union can only be applied on at least one operation');\n  }\n\n  /**\n   * Transform an operation based on the default and named graphs in the pattern.\n   *\n   * FROM sets the default graph.\n   * If multiple are available, take the union of the operation for all of them at quad-pattern level.\n   *\n   * FROM NAMED indicates which named graphs are available.\n   * This will rewrite the query so that only triples from the given named graphs can be selected.\n   *\n   * @package\n   * @param algebraFactory The algebra factory.\n   * @param {From} pattern A from operation.\n   * @return {Operation} The transformed operation.\n   */\n  public static createOperation(algebraFactory: AlgebraFactory, pattern: Algebra.From): Algebra.Operation {\n    let operation: Algebra.Operation = pattern.input;\n    if (pattern.default.length > 0) {\n      operation = ActorQueryOperationFromQuad.applyOperationDefaultGraph(algebraFactory, operation, pattern.default);\n    }\n    if (pattern.named.length > 0 || pattern.default.length > 0) {\n      operation = ActorQueryOperationFromQuad\n        .applyOperationNamedGraph(algebraFactory, operation, pattern.named, pattern.default);\n    }\n    return operation;\n  }\n\n  public async testOperation(_operation: Algebra.From, _context: IActionContext): Promise<TestResult<IActorTest>> {\n    return passTestVoid();\n  }\n\n  public async runOperation(\n    operationOriginal: Algebra.From,\n    context: IActionContext,\n  ): Promise<IQueryOperationResult> {\n    const dataFactory: ComunicaDataFactory = context.getSafe(KeysInitQuery.dataFactory);\n    const algebraFactory = new AlgebraFactory(dataFactory);\n\n    const operation: Algebra.Operation = ActorQueryOperationFromQuad.createOperation(algebraFactory, operationOriginal);\n    return this.mediatorQueryOperation.mediate({ operation, context });\n  }\n}\n"]}