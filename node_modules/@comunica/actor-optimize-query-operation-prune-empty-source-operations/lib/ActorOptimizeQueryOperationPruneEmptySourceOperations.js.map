{"version":3,"file":"ActorOptimizeQueryOperationPruneEmptySourceOperations.js","sourceRoot":"","sources":["ActorOptimizeQueryOperationPruneEmptySourceOperations.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  IActionOptimizeQueryOperation,\n  IActorOptimizeQueryOperationOutput,\n  IActorOptimizeQueryOperationArgs,\n} from '@comunica/bus-optimize-query-operation';\nimport { ActorOptimizeQueryOperation } from '@comunica/bus-optimize-query-operation';\nimport { KeysInitQuery, KeysQuerySourceIdentify } from '@comunica/context-entries';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { failTest, passTestVoid } from '@comunica/core';\nimport type {\n  ComunicaDataFactory,\n  IActionContext,\n  IQuerySourceWrapper,\n  MetadataBindings,\n  QueryResultCardinality,\n} from '@comunica/types';\nimport { Algebra, AlgebraFactory, algebraUtils, isKnownOperation } from '@comunica/utils-algebra';\nimport { doesShapeAcceptOperation, getOperationSource } from '@comunica/utils-query-operation';\n\n/**\n * A comunica Prune Empty Source Operations Optimize Query Operation Actor.\n */\nexport class ActorOptimizeQueryOperationPruneEmptySourceOperations extends ActorOptimizeQueryOperation {\n  private readonly useAskIfSupported: boolean;\n\n  public constructor(args: IActorOptimizeQueryOperationPruneEmptySourceOperationsArgs) {\n    super(args);\n    this.useAskIfSupported = args.useAskIfSupported;\n  }\n\n  public async test(action: IActionOptimizeQueryOperation): Promise<TestResult<IActorTest>> {\n    if (getOperationSource(action.operation)) {\n      return failTest(`Actor ${this.name} does not work with top-level operation sources.`);\n    }\n    return passTestVoid();\n  }\n\n  public async run(action: IActionOptimizeQueryOperation): Promise<IActorOptimizeQueryOperationOutput> {\n    const dataFactory: ComunicaDataFactory = action.context.getSafe(KeysInitQuery.dataFactory);\n    const algebraFactory = new AlgebraFactory(dataFactory);\n\n    let operation = action.operation;\n\n    // Collect all operations with source types\n    // Only consider unions of patterns or alts of links, since these are created during exhaustive source assignment.\n    const collectedOperations: (Algebra.Pattern | Algebra.Link)[] = [];\n    algebraUtils.visitOperation(operation, {\n      [Algebra.Types.UNION]: { preVisitor: (subOperation) => {\n        this.collectMultiOperationInputs(subOperation.input, collectedOperations, Algebra.Types.PATTERN);\n        return {};\n      } },\n      [Algebra.Types.ALT]: { preVisitor: (subOperation) => {\n        this.collectMultiOperationInputs(subOperation.input, collectedOperations, Algebra.Types.LINK);\n        return { continue: false };\n      } },\n      [Algebra.Types.SERVICE]: { preVisitor: () => ({ continue: false }) },\n    });\n\n    // Determine in an async manner whether or not these sources return non-empty results\n    const emptyOperations: Set<Algebra.Operation> = new Set();\n    await Promise.all(collectedOperations.map(async(collectedOperation) => {\n      const checkOperation = collectedOperation.type === Algebra.Types.LINK ?\n        algebraFactory.createPattern(dataFactory.variable('s'), collectedOperation.iri, dataFactory.variable('?o')) :\n        collectedOperation;\n      if (!await this.hasSourceResults(\n        algebraFactory,\n        getOperationSource(collectedOperation)!,\n        checkOperation,\n        action.context,\n      )) {\n        emptyOperations.add(collectedOperation);\n      }\n    }));\n\n    // Only perform next mapping if we have at least one empty operation\n    if (emptyOperations.size > 0) {\n      this.logDebug(action.context, `Pruning ${emptyOperations.size} source-specific operations`);\n      // Rewrite operations by removing the empty children\n      operation = algebraUtils.mapOperation(operation, {\n        [Algebra.Types.UNION]: { transform: (subOperation, origOp) =>\n          this.mapMultiOperation(subOperation, origOp, emptyOperations, children =>\n            algebraFactory.createUnion(children)) },\n        [Algebra.Types.ALT]: { transform: (subOperation, origOp) =>\n          this.mapMultiOperation(subOperation, origOp, emptyOperations, children =>\n            algebraFactory.createAlt(children)) },\n\n        // Remove operations that have become empty now due to missing variables\n        [Algebra.Types.PROJECT]: {\n          transform: (subOperation) => {\n            // Remove projections that have become empty now due to missing variables\n            if (ActorOptimizeQueryOperationPruneEmptySourceOperations.hasEmptyOperation(subOperation)) {\n              return algebraFactory.createUnion([]);\n            }\n            return subOperation;\n          },\n        },\n        [Algebra.Types.LEFT_JOIN]: { transform: (subOperation) => {\n          // Remove left joins with empty right operation\n          if (ActorOptimizeQueryOperationPruneEmptySourceOperations.hasEmptyOperation(subOperation.input[1])) {\n            return subOperation.input[0];\n          }\n          return subOperation;\n        } },\n      });\n    }\n\n    return { operation, context: action.context };\n  }\n\n  protected static hasEmptyOperation(operation: Algebra.Operation): boolean {\n    // If union (or alt) is empty, consider it empty (`Array.every` on an empty array always returns true)\n    // But if we find a union with multiple children,\n    // *all* of the children must be empty before the full operation is considered empty.\n    let emptyOperation = false;\n    algebraUtils.visitOperation(operation, {\n      [Algebra.Types.UNION]: { preVisitor: (unionOp) => {\n        if (unionOp.input.every(subSubOperation => ActorOptimizeQueryOperationPruneEmptySourceOperations\n          .hasEmptyOperation(subSubOperation))) {\n          emptyOperation = true;\n          return { shortcut: true };\n        }\n        return { continue: false };\n      } },\n      [Algebra.Types.LEFT_JOIN]: { preVisitor: (leftJoinOp) => {\n        // Only recurse into left part of left-join\n        if (ActorOptimizeQueryOperationPruneEmptySourceOperations.hasEmptyOperation(leftJoinOp.input[0])) {\n          emptyOperation = true;\n          return { shortcut: true };\n        }\n        return { continue: false };\n      } },\n      [Algebra.Types.ALT]: { preVisitor: (altOp) => {\n        if (altOp.input.length === 0) {\n          emptyOperation = true;\n          return { shortcut: true };\n        }\n        return { continue: false };\n      } },\n    });\n    return emptyOperation;\n  }\n\n  protected collectMultiOperationInputs(\n    inputs: Algebra.Operation[],\n    collectedOperations: (Algebra.Pattern | Algebra.Link)[],\n    inputType: (Algebra.Pattern | Algebra.Link)['type'],\n  ): void {\n    for (const input of inputs) {\n      if (getOperationSource(input) && isKnownOperation(input, inputType)) {\n        collectedOperations.push(input);\n      }\n    }\n  }\n\n  protected mapMultiOperation<O extends Algebra.Union | Algebra.Alt>(\n    operationCopy: O,\n    origOp: O,\n    emptyOperations: Set<Algebra.Operation>,\n    multiOperationFactory: (input: O['input']) => Algebra.Operation,\n  ): Algebra.Operation {\n    // Determine which operations return non-empty results\n    const nonEmptyInputs: Algebra.Operation[] = [];\n    for (const [ idx, input ] of operationCopy.input.entries()) {\n      if (!emptyOperations.has(origOp.input[idx])) {\n        nonEmptyInputs.push(input);\n      }\n    }\n\n    // Remove empty operations\n    if (nonEmptyInputs.length === operationCopy.input.length) {\n      return operationCopy;\n    }\n    if (nonEmptyInputs.length === 0) {\n      return multiOperationFactory([]);\n    }\n    if (nonEmptyInputs.length === 1) {\n      return nonEmptyInputs[0];\n    }\n    return multiOperationFactory(nonEmptyInputs);\n  }\n\n  /**\n   * Check if the given query operation will produce at least one result in the given source.\n   * @param algebraFactory The algebra factory.\n   * @param source A query source.\n   * @param input A query operation.\n   * @param context The query context.\n   */\n  public async hasSourceResults(\n    algebraFactory: AlgebraFactory,\n    source: IQuerySourceWrapper,\n    input: Algebra.Operation,\n    context: IActionContext,\n  ): Promise<boolean> {\n    const mergedContext = source.context ? context.merge(source.context) : context;\n    const wildcardAcceptAllExtensionFunctions = mergedContext.get(KeysInitQuery.extensionFunctionsAlwaysPushdown);\n\n    // Traversal contexts should never be considered empty at optimization time.\n    if (mergedContext.get(KeysQuerySourceIdentify.traverse)) {\n      return true;\n    }\n\n    // Prefer ASK over COUNT when instructed to, and the source allows it\n    if (this.useAskIfSupported) {\n      const askOperation = algebraFactory.createAsk(input);\n      const askSupported = doesShapeAcceptOperation(\n        await source.source.getSelectorShape(context),\n        askOperation,\n        { wildcardAcceptAllExtensionFunctions },\n      );\n      if (askSupported) {\n        return source.source.queryBoolean(askOperation, mergedContext);\n      }\n    }\n\n    // Fall back to sending the full operation, and extracting the cardinality from metadata\n    const bindingsStream = source.source.queryBindings(input, mergedContext);\n    const cardinality = await new Promise<QueryResultCardinality>((resolve, reject) => {\n      bindingsStream.on('error', reject);\n      bindingsStream.getProperty('metadata', (metadata: MetadataBindings) => {\n        bindingsStream.destroy();\n        resolve(metadata.cardinality);\n      });\n    });\n\n    // If the cardinality is an estimate, such as from a VoID description,\n    // verify it using ASK if the source supports it.\n    // Since the VoID estimators in Comunica cannot produce false negatives, only positive assignments must be verified.\n    if (cardinality.type === 'estimate' && cardinality.value > 0) {\n      const askOperation = algebraFactory.createAsk(input);\n      const askSupported = doesShapeAcceptOperation(\n        await source.source.getSelectorShape(context),\n        askOperation,\n        { wildcardAcceptAllExtensionFunctions },\n      );\n      if (askSupported) {\n        return source.source.queryBoolean(askOperation, mergedContext);\n      }\n    }\n\n    return cardinality.value > 0;\n  }\n}\n\nexport interface IActorOptimizeQueryOperationPruneEmptySourceOperationsArgs extends IActorOptimizeQueryOperationArgs {\n  /**\n   * If true, ASK queries will be sent to the source instead of COUNT queries to check emptiness for patterns.\n   * This will only be done for sources that accept ASK queries.\n   * @default {false}\n   */\n  useAskIfSupported: boolean;\n}\n"]}