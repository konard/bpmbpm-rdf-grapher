"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorOptimizeQueryOperationPruneEmptySourceOperations = void 0;
const bus_optimize_query_operation_1 = require("@comunica/bus-optimize-query-operation");
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const utils_algebra_1 = require("@comunica/utils-algebra");
const utils_query_operation_1 = require("@comunica/utils-query-operation");
/**
 * A comunica Prune Empty Source Operations Optimize Query Operation Actor.
 */
class ActorOptimizeQueryOperationPruneEmptySourceOperations extends bus_optimize_query_operation_1.ActorOptimizeQueryOperation {
    useAskIfSupported;
    constructor(args) {
        super(args);
        this.useAskIfSupported = args.useAskIfSupported;
    }
    async test(action) {
        if ((0, utils_query_operation_1.getOperationSource)(action.operation)) {
            return (0, core_1.failTest)(`Actor ${this.name} does not work with top-level operation sources.`);
        }
        return (0, core_1.passTestVoid)();
    }
    async run(action) {
        const dataFactory = action.context.getSafe(context_entries_1.KeysInitQuery.dataFactory);
        const algebraFactory = new utils_algebra_1.AlgebraFactory(dataFactory);
        let operation = action.operation;
        // Collect all operations with source types
        // Only consider unions of patterns or alts of links, since these are created during exhaustive source assignment.
        const collectedOperations = [];
        utils_algebra_1.algebraUtils.visitOperation(operation, {
            [utils_algebra_1.Algebra.Types.UNION]: { preVisitor: (subOperation) => {
                    this.collectMultiOperationInputs(subOperation.input, collectedOperations, utils_algebra_1.Algebra.Types.PATTERN);
                    return {};
                } },
            [utils_algebra_1.Algebra.Types.ALT]: { preVisitor: (subOperation) => {
                    this.collectMultiOperationInputs(subOperation.input, collectedOperations, utils_algebra_1.Algebra.Types.LINK);
                    return { continue: false };
                } },
            [utils_algebra_1.Algebra.Types.SERVICE]: { preVisitor: () => ({ continue: false }) },
        });
        // Determine in an async manner whether or not these sources return non-empty results
        const emptyOperations = new Set();
        await Promise.all(collectedOperations.map(async (collectedOperation) => {
            const checkOperation = collectedOperation.type === utils_algebra_1.Algebra.Types.LINK ?
                algebraFactory.createPattern(dataFactory.variable('s'), collectedOperation.iri, dataFactory.variable('?o')) :
                collectedOperation;
            if (!await this.hasSourceResults(algebraFactory, (0, utils_query_operation_1.getOperationSource)(collectedOperation), checkOperation, action.context)) {
                emptyOperations.add(collectedOperation);
            }
        }));
        // Only perform next mapping if we have at least one empty operation
        if (emptyOperations.size > 0) {
            this.logDebug(action.context, `Pruning ${emptyOperations.size} source-specific operations`);
            // Rewrite operations by removing the empty children
            operation = utils_algebra_1.algebraUtils.mapOperation(operation, {
                [utils_algebra_1.Algebra.Types.UNION]: { transform: (subOperation, origOp) => this.mapMultiOperation(subOperation, origOp, emptyOperations, children => algebraFactory.createUnion(children)) },
                [utils_algebra_1.Algebra.Types.ALT]: { transform: (subOperation, origOp) => this.mapMultiOperation(subOperation, origOp, emptyOperations, children => algebraFactory.createAlt(children)) },
                // Remove operations that have become empty now due to missing variables
                [utils_algebra_1.Algebra.Types.PROJECT]: {
                    transform: (subOperation) => {
                        // Remove projections that have become empty now due to missing variables
                        if (ActorOptimizeQueryOperationPruneEmptySourceOperations.hasEmptyOperation(subOperation)) {
                            return algebraFactory.createUnion([]);
                        }
                        return subOperation;
                    },
                },
                [utils_algebra_1.Algebra.Types.LEFT_JOIN]: { transform: (subOperation) => {
                        // Remove left joins with empty right operation
                        if (ActorOptimizeQueryOperationPruneEmptySourceOperations.hasEmptyOperation(subOperation.input[1])) {
                            return subOperation.input[0];
                        }
                        return subOperation;
                    } },
            });
        }
        return { operation, context: action.context };
    }
    static hasEmptyOperation(operation) {
        // If union (or alt) is empty, consider it empty (`Array.every` on an empty array always returns true)
        // But if we find a union with multiple children,
        // *all* of the children must be empty before the full operation is considered empty.
        let emptyOperation = false;
        utils_algebra_1.algebraUtils.visitOperation(operation, {
            [utils_algebra_1.Algebra.Types.UNION]: { preVisitor: (unionOp) => {
                    if (unionOp.input.every(subSubOperation => ActorOptimizeQueryOperationPruneEmptySourceOperations
                        .hasEmptyOperation(subSubOperation))) {
                        emptyOperation = true;
                        return { shortcut: true };
                    }
                    return { continue: false };
                } },
            [utils_algebra_1.Algebra.Types.LEFT_JOIN]: { preVisitor: (leftJoinOp) => {
                    // Only recurse into left part of left-join
                    if (ActorOptimizeQueryOperationPruneEmptySourceOperations.hasEmptyOperation(leftJoinOp.input[0])) {
                        emptyOperation = true;
                        return { shortcut: true };
                    }
                    return { continue: false };
                } },
            [utils_algebra_1.Algebra.Types.ALT]: { preVisitor: (altOp) => {
                    if (altOp.input.length === 0) {
                        emptyOperation = true;
                        return { shortcut: true };
                    }
                    return { continue: false };
                } },
        });
        return emptyOperation;
    }
    collectMultiOperationInputs(inputs, collectedOperations, inputType) {
        for (const input of inputs) {
            if ((0, utils_query_operation_1.getOperationSource)(input) && (0, utils_algebra_1.isKnownOperation)(input, inputType)) {
                collectedOperations.push(input);
            }
        }
    }
    mapMultiOperation(operationCopy, origOp, emptyOperations, multiOperationFactory) {
        // Determine which operations return non-empty results
        const nonEmptyInputs = [];
        for (const [idx, input] of operationCopy.input.entries()) {
            if (!emptyOperations.has(origOp.input[idx])) {
                nonEmptyInputs.push(input);
            }
        }
        // Remove empty operations
        if (nonEmptyInputs.length === operationCopy.input.length) {
            return operationCopy;
        }
        if (nonEmptyInputs.length === 0) {
            return multiOperationFactory([]);
        }
        if (nonEmptyInputs.length === 1) {
            return nonEmptyInputs[0];
        }
        return multiOperationFactory(nonEmptyInputs);
    }
    /**
     * Check if the given query operation will produce at least one result in the given source.
     * @param algebraFactory The algebra factory.
     * @param source A query source.
     * @param input A query operation.
     * @param context The query context.
     */
    async hasSourceResults(algebraFactory, source, input, context) {
        const mergedContext = source.context ? context.merge(source.context) : context;
        const wildcardAcceptAllExtensionFunctions = mergedContext.get(context_entries_1.KeysInitQuery.extensionFunctionsAlwaysPushdown);
        // Traversal contexts should never be considered empty at optimization time.
        if (mergedContext.get(context_entries_1.KeysQuerySourceIdentify.traverse)) {
            return true;
        }
        // Prefer ASK over COUNT when instructed to, and the source allows it
        if (this.useAskIfSupported) {
            const askOperation = algebraFactory.createAsk(input);
            const askSupported = (0, utils_query_operation_1.doesShapeAcceptOperation)(await source.source.getSelectorShape(context), askOperation, { wildcardAcceptAllExtensionFunctions });
            if (askSupported) {
                return source.source.queryBoolean(askOperation, mergedContext);
            }
        }
        // Fall back to sending the full operation, and extracting the cardinality from metadata
        const bindingsStream = source.source.queryBindings(input, mergedContext);
        const cardinality = await new Promise((resolve, reject) => {
            bindingsStream.on('error', reject);
            bindingsStream.getProperty('metadata', (metadata) => {
                bindingsStream.destroy();
                resolve(metadata.cardinality);
            });
        });
        // If the cardinality is an estimate, such as from a VoID description,
        // verify it using ASK if the source supports it.
        // Since the VoID estimators in Comunica cannot produce false negatives, only positive assignments must be verified.
        if (cardinality.type === 'estimate' && cardinality.value > 0) {
            const askOperation = algebraFactory.createAsk(input);
            const askSupported = (0, utils_query_operation_1.doesShapeAcceptOperation)(await source.source.getSelectorShape(context), askOperation, { wildcardAcceptAllExtensionFunctions });
            if (askSupported) {
                return source.source.queryBoolean(askOperation, mergedContext);
            }
        }
        return cardinality.value > 0;
    }
}
exports.ActorOptimizeQueryOperationPruneEmptySourceOperations = ActorOptimizeQueryOperationPruneEmptySourceOperations;
//# sourceMappingURL=ActorOptimizeQueryOperationPruneEmptySourceOperations.js.map