{"version":3,"file":"ActorOptimizeQueryOperationAssignSourcesExhaustive.js","sourceRoot":"","sources":["ActorOptimizeQueryOperationAssignSourcesExhaustive.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  IActionOptimizeQueryOperation,\n  IActorOptimizeQueryOperationOutput,\n  IActorOptimizeQueryOperationArgs,\n} from '@comunica/bus-optimize-query-operation';\nimport { ActorOptimizeQueryOperation } from '@comunica/bus-optimize-query-operation';\nimport { KeysInitQuery, KeysQueryOperation } from '@comunica/context-entries';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { ActionContext, passTestVoid } from '@comunica/core';\nimport type { ComunicaDataFactory, IQuerySourceWrapper } from '@comunica/types';\nimport { Algebra, AlgebraFactory, algebraUtils } from '@comunica/utils-algebra';\nimport {\n  assignOperationSource,\n  passFullOperationToSource,\n} from '@comunica/utils-query-operation';\n\n/**\n * A comunica Assign Sources Exhaustive Optimize Query Operation Actor.\n */\nexport class ActorOptimizeQueryOperationAssignSourcesExhaustive extends ActorOptimizeQueryOperation {\n  public constructor(args: IActorOptimizeQueryOperationArgs) {\n    super(args);\n  }\n\n  public async test(_action: IActionOptimizeQueryOperation): Promise<TestResult<IActorTest>> {\n    return passTestVoid();\n  }\n\n  public async run(action: IActionOptimizeQueryOperation): Promise<IActorOptimizeQueryOperationOutput> {\n    const dataFactory: ComunicaDataFactory = action.context.getSafe(KeysInitQuery.dataFactory);\n    const algebraFactory = new AlgebraFactory(dataFactory);\n\n    const sources = action.context.get(KeysQueryOperation.querySources) ?? [];\n    const serviceSources = action.context.get(KeysQueryOperation.serviceSources) ?? {};\n    if (sources.length === 0 && Object.keys(serviceSources).length === 0) {\n      return { operation: action.operation, context: action.context };\n    }\n    if (await passFullOperationToSource(action.operation, sources, action.context)) {\n      return {\n        operation: assignOperationSource(action.operation, sources[0]),\n        context: action.context,\n      };\n    }\n    return {\n      operation: this.assignExhaustive(algebraFactory, action.operation, sources, serviceSources),\n      // We only keep queryString in the context if we only have a single source that accepts the full operation.\n      // In that case, the queryString can be sent to the source as-is.\n      context: action.context\n        .delete(KeysInitQuery.queryString),\n    };\n  }\n\n  /**\n   * Assign the given sources to the leaves in the given query operation.\n   * Leaves will be wrapped in a union operation and duplicated for every source.\n   * The input operation will not be modified.\n   * @param factory The algebra factory.\n   * @param operation The input operation.\n   * @param sources The sources to assign.\n   * @param serviceSources Mapping of SERVICE names to sources.\n   */\n  public assignExhaustive(\n    factory: AlgebraFactory,\n    operation: Algebra.Operation,\n    sources: IQuerySourceWrapper[],\n    serviceSources: Record<string, IQuerySourceWrapper>,\n  ): Algebra.Operation {\n    return algebraUtils.mapOperation(operation, {\n      [Algebra.Types.PATTERN]: {\n        preVisitor: () => ({ continue: false }),\n        transform: (patternOp) => {\n          if (sources.length === 1) {\n            return assignOperationSource(patternOp, sources[0]);\n          }\n          return factory.createUnion(sources\n            .map(source => assignOperationSource(patternOp, source)));\n        },\n      },\n      [Algebra.Types.SERVICE]: {\n        preVisitor: () => ({ continue: false }),\n        transform: (serviceOp) => {\n          if (serviceOp.name.termType === 'NamedNode') {\n            let source = serviceSources[serviceOp.name.value];\n            if (source) {\n              if (serviceOp.silent) {\n                source = {\n                  ...source,\n                  context: (source.context ?? new ActionContext()).set(KeysInitQuery.lenient, true),\n                };\n              }\n              return this.assignExhaustive(\n                factory,\n                serviceOp.input,\n                [ source ],\n                // Pass empty serviceSources to ensure nested SERVICE clauses are not transformed.\n                {},\n              );\n            }\n          }\n          return serviceOp;\n        },\n      },\n      [Algebra.Types.CONSTRUCT]: {\n        preVisitor: () => ({ continue: false }),\n        transform: constructOp => factory.createConstruct(\n          this.assignExhaustive(factory, constructOp.input, sources, serviceSources),\n          constructOp.template,\n        ),\n      },\n      [Algebra.Types.LINK]: {\n        preVisitor: () => ({ continue: false }),\n        transform: (linkOp) => {\n          if (sources.length === 1) {\n            return assignOperationSource(linkOp, sources[0]);\n          }\n          return factory.createAlt(sources\n            .map(source => assignOperationSource(linkOp, source)));\n        },\n      },\n      [Algebra.Types.NPS]: {\n        preVisitor: () => ({ continue: false }),\n        transform: (npsOp) => {\n          if (sources.length === 1) {\n            return assignOperationSource(npsOp, sources[0]);\n          }\n          return factory.createAlt(sources\n            .map(source => assignOperationSource(npsOp, source)));\n        },\n      },\n      [Algebra.Types.DELETE_INSERT]: {\n        preVisitor: () => ({ continue: false }),\n        transform: delInsOp => factory.createDeleteInsert(\n          delInsOp.delete,\n          delInsOp.insert,\n          delInsOp.where ? this.assignExhaustive(factory, delInsOp.where, sources, serviceSources) : undefined,\n        ),\n      },\n    });\n  }\n}\n"]}