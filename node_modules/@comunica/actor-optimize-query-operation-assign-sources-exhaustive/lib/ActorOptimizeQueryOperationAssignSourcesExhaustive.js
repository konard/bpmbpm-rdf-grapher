"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorOptimizeQueryOperationAssignSourcesExhaustive = void 0;
const bus_optimize_query_operation_1 = require("@comunica/bus-optimize-query-operation");
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const utils_algebra_1 = require("@comunica/utils-algebra");
const utils_query_operation_1 = require("@comunica/utils-query-operation");
/**
 * A comunica Assign Sources Exhaustive Optimize Query Operation Actor.
 */
class ActorOptimizeQueryOperationAssignSourcesExhaustive extends bus_optimize_query_operation_1.ActorOptimizeQueryOperation {
    constructor(args) {
        super(args);
    }
    async test(_action) {
        return (0, core_1.passTestVoid)();
    }
    async run(action) {
        const dataFactory = action.context.getSafe(context_entries_1.KeysInitQuery.dataFactory);
        const algebraFactory = new utils_algebra_1.AlgebraFactory(dataFactory);
        const sources = action.context.get(context_entries_1.KeysQueryOperation.querySources) ?? [];
        const serviceSources = action.context.get(context_entries_1.KeysQueryOperation.serviceSources) ?? {};
        if (sources.length === 0 && Object.keys(serviceSources).length === 0) {
            return { operation: action.operation, context: action.context };
        }
        if (await (0, utils_query_operation_1.passFullOperationToSource)(action.operation, sources, action.context)) {
            return {
                operation: (0, utils_query_operation_1.assignOperationSource)(action.operation, sources[0]),
                context: action.context,
            };
        }
        return {
            operation: this.assignExhaustive(algebraFactory, action.operation, sources, serviceSources),
            // We only keep queryString in the context if we only have a single source that accepts the full operation.
            // In that case, the queryString can be sent to the source as-is.
            context: action.context
                .delete(context_entries_1.KeysInitQuery.queryString),
        };
    }
    /**
     * Assign the given sources to the leaves in the given query operation.
     * Leaves will be wrapped in a union operation and duplicated for every source.
     * The input operation will not be modified.
     * @param factory The algebra factory.
     * @param operation The input operation.
     * @param sources The sources to assign.
     * @param serviceSources Mapping of SERVICE names to sources.
     */
    assignExhaustive(factory, operation, sources, serviceSources) {
        return utils_algebra_1.algebraUtils.mapOperation(operation, {
            [utils_algebra_1.Algebra.Types.PATTERN]: {
                preVisitor: () => ({ continue: false }),
                transform: (patternOp) => {
                    if (sources.length === 1) {
                        return (0, utils_query_operation_1.assignOperationSource)(patternOp, sources[0]);
                    }
                    return factory.createUnion(sources
                        .map(source => (0, utils_query_operation_1.assignOperationSource)(patternOp, source)));
                },
            },
            [utils_algebra_1.Algebra.Types.SERVICE]: {
                preVisitor: () => ({ continue: false }),
                transform: (serviceOp) => {
                    if (serviceOp.name.termType === 'NamedNode') {
                        let source = serviceSources[serviceOp.name.value];
                        if (source) {
                            if (serviceOp.silent) {
                                source = {
                                    ...source,
                                    context: (source.context ?? new core_1.ActionContext()).set(context_entries_1.KeysInitQuery.lenient, true),
                                };
                            }
                            return this.assignExhaustive(factory, serviceOp.input, [source], 
                            // Pass empty serviceSources to ensure nested SERVICE clauses are not transformed.
                            {});
                        }
                    }
                    return serviceOp;
                },
            },
            [utils_algebra_1.Algebra.Types.CONSTRUCT]: {
                preVisitor: () => ({ continue: false }),
                transform: constructOp => factory.createConstruct(this.assignExhaustive(factory, constructOp.input, sources, serviceSources), constructOp.template),
            },
            [utils_algebra_1.Algebra.Types.LINK]: {
                preVisitor: () => ({ continue: false }),
                transform: (linkOp) => {
                    if (sources.length === 1) {
                        return (0, utils_query_operation_1.assignOperationSource)(linkOp, sources[0]);
                    }
                    return factory.createAlt(sources
                        .map(source => (0, utils_query_operation_1.assignOperationSource)(linkOp, source)));
                },
            },
            [utils_algebra_1.Algebra.Types.NPS]: {
                preVisitor: () => ({ continue: false }),
                transform: (npsOp) => {
                    if (sources.length === 1) {
                        return (0, utils_query_operation_1.assignOperationSource)(npsOp, sources[0]);
                    }
                    return factory.createAlt(sources
                        .map(source => (0, utils_query_operation_1.assignOperationSource)(npsOp, source)));
                },
            },
            [utils_algebra_1.Algebra.Types.DELETE_INSERT]: {
                preVisitor: () => ({ continue: false }),
                transform: delInsOp => factory.createDeleteInsert(delInsOp.delete, delInsOp.insert, delInsOp.where ? this.assignExhaustive(factory, delInsOp.where, sources, serviceSources) : undefined),
            },
        });
    }
}
exports.ActorOptimizeQueryOperationAssignSourcesExhaustive = ActorOptimizeQueryOperationAssignSourcesExhaustive;
//# sourceMappingURL=ActorOptimizeQueryOperationAssignSourcesExhaustive.js.map