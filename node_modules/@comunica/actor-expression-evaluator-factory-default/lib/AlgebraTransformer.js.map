{"version":3,"file":"AlgebraTransformer.js","sourceRoot":"","sources":["AlgebraTransformer.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MediatorFunctionFactory } from '@comunica/bus-function-factory';\nimport { KeysExpressionEvaluator } from '@comunica/context-entries';\nimport type { Expression, IActionContext, OperatorExpression } from '@comunica/types';\nimport { Algebra, AlgebraFactory, isKnownSubType } from '@comunica/utils-algebra';\nimport * as ExprEval from '@comunica/utils-expression-evaluator';\n\nexport class AlgebraTransformer extends ExprEval.TermTransformer {\n  private readonly AF = new AlgebraFactory();\n  public constructor(\n    private readonly context: IActionContext,\n    private readonly mediatorFunctionFactory: MediatorFunctionFactory,\n  ) {\n    super(context.getSafe(KeysExpressionEvaluator.superTypeProvider));\n  }\n\n  public async transformAlgebra(expr: Algebra.Expression): Promise<Expression> {\n    if (isKnownSubType(expr, Algebra.ExpressionTypes.TERM)) {\n      // A triple term is actually not a term since it itself can contain\n      // variables thereby having the properties of an operator, we therefore map it to the triple operator here.\n      // Not that this is needed because the EE has a shortcut for terms and sees them as distinct from operators.\n      if (expr.term.termType === 'Quad') {\n        return await this.transformOperator(this.AF.createOperatorExpression('triple', [\n          this.AF.createTermExpression(expr.term.subject),\n          this.AF.createTermExpression(expr.term.predicate),\n          this.AF.createTermExpression(expr.term.object),\n        ]));\n      }\n      return this.transformTerm(expr);\n    }\n    if (isKnownSubType(expr, Algebra.ExpressionTypes.OPERATOR)) {\n      return await this.transformOperator(expr);\n    }\n    if (isKnownSubType(expr, Algebra.ExpressionTypes.NAMED)) {\n      return await this.transformNamed(expr);\n    }\n    if (isKnownSubType(expr, Algebra.ExpressionTypes.EXISTENCE)) {\n      return AlgebraTransformer.transformExistence(expr);\n    }\n    if (isKnownSubType(expr, Algebra.ExpressionTypes.AGGREGATE)) {\n      return AlgebraTransformer.transformAggregate(expr);\n    }\n    if (isKnownSubType(expr, Algebra.ExpressionTypes.WILDCARD)) {\n      return AlgebraTransformer.transformWildcard(expr);\n    }\n    throw new Error(`Expression of type ${expr.subType} cannot be converted into internal representation of expression.`);\n  }\n\n  private static transformWildcard(_term: Algebra.WildcardExpression): Expression {\n    return new ExprEval.NamedNode('*');\n  }\n\n  private async getOperator(operator: string, expr: Algebra.OperatorExpression | Algebra.NamedExpression):\n  Promise<OperatorExpression> {\n    const operatorFunc = await this.mediatorFunctionFactory.mediate({\n      functionName: operator,\n      arguments: expr.args,\n      context: this.context,\n    });\n    const operatorArgs = await Promise.all(expr.args.map(arg => this.transformAlgebra(arg)));\n    if (!operatorFunc.checkArity(operatorArgs)) {\n      throw new ExprEval.InvalidArity(operatorArgs, operator);\n    }\n    return new ExprEval.Operator(operator, operatorArgs, operatorFunc.apply);\n  }\n\n  private async transformOperator(expr: Algebra.OperatorExpression): Promise<OperatorExpression> {\n    return this.getOperator(expr.operator.toLowerCase(), expr);\n  }\n\n  private async transformNamed(expr: Algebra.NamedExpression): Promise<OperatorExpression> {\n    return this.getOperator(expr.name.value, expr);\n  }\n\n  public static transformAggregate(expr: Algebra.AggregateExpression): ExprEval.Aggregate {\n    const name = expr.aggregator;\n    return new ExprEval.Aggregate(name, expr);\n  }\n\n  public static transformExistence(expr: Algebra.ExistenceExpression): ExprEval.Existence {\n    return new ExprEval.Existence(expr);\n  }\n}\n"]}