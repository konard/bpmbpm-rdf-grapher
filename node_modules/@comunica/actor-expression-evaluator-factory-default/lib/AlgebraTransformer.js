"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgebraTransformer = void 0;
const context_entries_1 = require("@comunica/context-entries");
const utils_algebra_1 = require("@comunica/utils-algebra");
const ExprEval = require("@comunica/utils-expression-evaluator");
class AlgebraTransformer extends ExprEval.TermTransformer {
    context;
    mediatorFunctionFactory;
    AF = new utils_algebra_1.AlgebraFactory();
    constructor(context, mediatorFunctionFactory) {
        super(context.getSafe(context_entries_1.KeysExpressionEvaluator.superTypeProvider));
        this.context = context;
        this.mediatorFunctionFactory = mediatorFunctionFactory;
    }
    async transformAlgebra(expr) {
        if ((0, utils_algebra_1.isKnownSubType)(expr, utils_algebra_1.Algebra.ExpressionTypes.TERM)) {
            // A triple term is actually not a term since it itself can contain
            // variables thereby having the properties of an operator, we therefore map it to the triple operator here.
            // Not that this is needed because the EE has a shortcut for terms and sees them as distinct from operators.
            if (expr.term.termType === 'Quad') {
                return await this.transformOperator(this.AF.createOperatorExpression('triple', [
                    this.AF.createTermExpression(expr.term.subject),
                    this.AF.createTermExpression(expr.term.predicate),
                    this.AF.createTermExpression(expr.term.object),
                ]));
            }
            return this.transformTerm(expr);
        }
        if ((0, utils_algebra_1.isKnownSubType)(expr, utils_algebra_1.Algebra.ExpressionTypes.OPERATOR)) {
            return await this.transformOperator(expr);
        }
        if ((0, utils_algebra_1.isKnownSubType)(expr, utils_algebra_1.Algebra.ExpressionTypes.NAMED)) {
            return await this.transformNamed(expr);
        }
        if ((0, utils_algebra_1.isKnownSubType)(expr, utils_algebra_1.Algebra.ExpressionTypes.EXISTENCE)) {
            return AlgebraTransformer.transformExistence(expr);
        }
        if ((0, utils_algebra_1.isKnownSubType)(expr, utils_algebra_1.Algebra.ExpressionTypes.AGGREGATE)) {
            return AlgebraTransformer.transformAggregate(expr);
        }
        if ((0, utils_algebra_1.isKnownSubType)(expr, utils_algebra_1.Algebra.ExpressionTypes.WILDCARD)) {
            return AlgebraTransformer.transformWildcard(expr);
        }
        throw new Error(`Expression of type ${expr.subType} cannot be converted into internal representation of expression.`);
    }
    static transformWildcard(_term) {
        return new ExprEval.NamedNode('*');
    }
    async getOperator(operator, expr) {
        const operatorFunc = await this.mediatorFunctionFactory.mediate({
            functionName: operator,
            arguments: expr.args,
            context: this.context,
        });
        const operatorArgs = await Promise.all(expr.args.map(arg => this.transformAlgebra(arg)));
        if (!operatorFunc.checkArity(operatorArgs)) {
            throw new ExprEval.InvalidArity(operatorArgs, operator);
        }
        return new ExprEval.Operator(operator, operatorArgs, operatorFunc.apply);
    }
    async transformOperator(expr) {
        return this.getOperator(expr.operator.toLowerCase(), expr);
    }
    async transformNamed(expr) {
        return this.getOperator(expr.name.value, expr);
    }
    static transformAggregate(expr) {
        const name = expr.aggregator;
        return new ExprEval.Aggregate(name, expr);
    }
    static transformExistence(expr) {
        return new ExprEval.Existence(expr);
    }
}
exports.AlgebraTransformer = AlgebraTransformer;
//# sourceMappingURL=AlgebraTransformer.js.map