"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQueryProcessExplainQuery = void 0;
const bus_query_process_1 = require("@comunica/bus-query-process");
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const utils_algebra_1 = require("@comunica/utils-algebra");
const utils_query_operation_1 = require("@comunica/utils-query-operation");
/**
 * A comunica Explain Query Query Process Actor.
 */
class ActorQueryProcessExplainQuery extends bus_query_process_1.ActorQueryProcess {
    queryProcessor;
    mediatorQuerySerialize;
    constructor(args) {
        super(args);
        this.queryProcessor = args.queryProcessor;
        this.mediatorQuerySerialize = args.mediatorQuerySerialize;
    }
    async test(action) {
        if ((action.context.get(context_entries_1.KeysInitQuery.explain) ??
            action.context.get(new core_1.ActionContextKey('explain'))) !== 'query') {
            return (0, core_1.failTest)(`${this.name} can only explain in 'query' mode.`);
        }
        return (0, core_1.passTestVoid)();
    }
    async run(action) {
        // Parse and optimize the query
        let { operation, context } = await this.queryProcessor.parse(action.query, action.context);
        ({ operation, context } = await this.queryProcessor.optimize(operation, context));
        // Convert source annotations to SERVICE clauses
        const AF = new utils_algebra_1.AlgebraFactory();
        operation = ActorQueryProcessExplainQuery.sourceAnnotationToServices(AF, context.getSafe(context_entries_1.KeysInitQuery.dataFactory), operation);
        // Serialize the operation to a SPARQL query
        let data;
        if (operation.type === utils_algebra_1.Algebra.Types.UNION) {
            // This can happen if it was determined during optimization that the query has zero results.
            data = 'SELECT * WHERE { FILTER(false) }';
        }
        else {
            data = (await this.mediatorQuerySerialize.mediate({
                queryFormat: { language: 'sparql', version: '1.1' },
                operation,
                newlines: true,
                indentWidth: 2,
                context,
            })).query;
        }
        return {
            result: {
                explain: true,
                type: 'query',
                data,
            },
        };
    }
    static sourceAnnotationToServices(algebraFactory, dataFactory, operation) {
        // TODO: The casts below should not be necessary.
        return utils_algebra_1.transformer.transformObject(operation, (subOperationUntyped) => {
            const subOperation = subOperationUntyped;
            const source = (0, utils_query_operation_1.getOperationSource)(subOperation);
            if (source) {
                return algebraFactory.createService(subOperation, typeof source.source.referenceValue === 'string' ?
                    dataFactory.namedNode(source.source.referenceValue) :
                    dataFactory.namedNode(`comunica:${source.source.referenceValue.constructor.name}`), source.context?.get(context_entries_1.KeysInitQuery.lenient));
            }
            return subOperation;
        });
    }
}
exports.ActorQueryProcessExplainQuery = ActorQueryProcessExplainQuery;
//# sourceMappingURL=ActorQueryProcessExplainQuery.js.map