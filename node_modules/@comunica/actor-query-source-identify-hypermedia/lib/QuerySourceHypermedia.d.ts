import type { MediatorQuerySourceDereferenceLink } from '@comunica/bus-query-source-dereference-link';
import type { MediatorRdfMetadataAccumulate } from '@comunica/bus-rdf-metadata-accumulate';
import type { MediatorRdfResolveHypermediaLinks } from '@comunica/bus-rdf-resolve-hypermedia-links';
import type { MediatorRdfResolveHypermediaLinksQueue } from '@comunica/bus-rdf-resolve-hypermedia-links-queue';
import type { BindingsStream, ComunicaDataFactory, FragmentSelectorShape, IActionContext, IQueryBindingsOptions, IQuerySource, ILink } from '@comunica/types';
import type { Algebra } from '@comunica/utils-algebra';
import type { BindingsFactory } from '@comunica/utils-bindings-factory';
import type * as RDF from '@rdfjs/types';
import type { AsyncIterator } from 'asynciterator';
import { LRUCache } from 'lru-cache';
import type { ISourceState } from './LinkedRdfSourcesAsyncRdfIterator';
export declare class QuerySourceHypermedia implements IQuerySource {
    readonly referenceValue: string;
    readonly firstLink: ILink;
    readonly mediators: IMediatorArgs;
    readonly dataFactory: ComunicaDataFactory;
    readonly bindingsFactory: BindingsFactory;
    /**
     * A cache for source URLs to source states.
     */
    sourcesState: LRUCache<string, Promise<ISourceState>>;
    private readonly cacheSize;
    private readonly maxIterators;
    constructor(cacheSize: number, firstUrl: ILink, maxIterators: number, mediators: IMediatorArgs, dataFactory: ComunicaDataFactory, bindingsFactory: BindingsFactory);
    getSelectorShape(context: IActionContext): Promise<FragmentSelectorShape>;
    getFilterFactor(context: IActionContext): Promise<number>;
    queryBindings(operation: Algebra.Operation, context: IActionContext, options?: IQueryBindingsOptions): BindingsStream;
    queryQuads(operation: Algebra.Operation, context: IActionContext): AsyncIterator<RDF.Quad>;
    queryBoolean(operation: Algebra.Ask, context: IActionContext): Promise<boolean>;
    queryVoid(operation: Algebra.Operation, context: IActionContext): Promise<void>;
    /**
     * Resolve a source for the given URL.
     * @param link A source link.
     * @param handledDatasets A hash of dataset identifiers that have already been handled.
     * @param context The action context.
     */
    getSource(link: ILink, handledDatasets: Record<string, boolean>, context: IActionContext): Promise<ISourceState>;
    /**
     * Resolve a source for the given URL.
     * This will first try to retrieve the source from cache.
     * @param link A source ILink.
     * @param handledDatasets A hash of dataset identifiers that have already been handled.
     * @param context The action context.
     */
    getSourceCached(link: ILink, handledDatasets: Record<string, boolean>, context: IActionContext): Promise<ISourceState>;
    toString(): string;
}
export interface IMediatorArgs {
    mediatorMetadataAccumulate: MediatorRdfMetadataAccumulate;
    mediatorQuerySourceDereferenceLink: MediatorQuerySourceDereferenceLink;
    mediatorRdfResolveHypermediaLinks: MediatorRdfResolveHypermediaLinks;
    mediatorRdfResolveHypermediaLinksQueue: MediatorRdfResolveHypermediaLinksQueue;
}
