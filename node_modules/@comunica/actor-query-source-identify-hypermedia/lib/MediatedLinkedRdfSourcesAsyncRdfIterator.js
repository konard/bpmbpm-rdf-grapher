"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediatedLinkedRdfSourcesAsyncRdfIterator = void 0;
const context_entries_1 = require("@comunica/context-entries");
const LinkedRdfSourcesAsyncRdfIterator_1 = require("./LinkedRdfSourcesAsyncRdfIterator");
/**
 * A quad iterator that can iterate over consecutive RDF sources
 * that are determined using the rdf-resolve-hypermedia-links bus.
 *
 * @see LinkedRdfSourcesAsyncRdfIterator
 */
class MediatedLinkedRdfSourcesAsyncRdfIterator extends LinkedRdfSourcesAsyncRdfIterator_1.LinkedRdfSourcesAsyncRdfIterator {
    mediatorMetadataAccumulate;
    mediatorRdfResolveHypermediaLinks;
    mediatorRdfResolveHypermediaLinksQueue;
    handledUrls;
    linkQueue;
    constructor(operation, queryBindingsOptions, context, firstLink, maxIterators, sourceStateGetter, mediatorMetadataAccumulate, mediatorRdfResolveHypermediaLinks, mediatorRdfResolveHypermediaLinksQueue) {
        super(operation, queryBindingsOptions, context, firstLink, maxIterators, sourceStateGetter);
        this.mediatorMetadataAccumulate = mediatorMetadataAccumulate;
        this.mediatorRdfResolveHypermediaLinks = mediatorRdfResolveHypermediaLinks;
        this.mediatorRdfResolveHypermediaLinksQueue = mediatorRdfResolveHypermediaLinksQueue;
        this.handledUrls = { [firstLink.url]: true };
    }
    isCloseable(linkQueue, requireQueueEmpty) {
        return (requireQueueEmpty ? linkQueue.isEmpty() : linkQueue.isEmpty()) && !this.areIteratorsRunning();
    }
    getLinkQueue() {
        if (!this.linkQueue) {
            this.linkQueue = this.mediatorRdfResolveHypermediaLinksQueue
                .mediate({ context: this.context })
                .then(result => result.linkQueue);
        }
        return this.linkQueue;
    }
    async getSourceLinks(metadata, startSource) {
        try {
            const { links } = await this.mediatorRdfResolveHypermediaLinks.mediate({ context: this.context, metadata });
            // Update discovery event statistic if available
            const traversalTracker = this.context.get(context_entries_1.KeysStatistics.discoveredLinks);
            if (traversalTracker) {
                for (const link of links) {
                    traversalTracker.updateStatistic({ url: link.url, metadata: { ...link.metadata } }, startSource.link);
                }
            }
            // Filter URLs to avoid cyclic next-page loops
            return links.filter((link) => {
                if (this.handledUrls[link.url]) {
                    return false;
                }
                this.handledUrls[link.url] = true;
                return true;
            });
        }
        catch {
            // No next URLs may be available, for example when we've reached the end of a Hydra next-page sequence.
            return [];
        }
    }
    async accumulateMetadata(accumulatedMetadata, appendingMetadata) {
        return (await this.mediatorMetadataAccumulate.mediate({
            mode: 'append',
            accumulatedMetadata,
            appendingMetadata,
            context: this.context,
        })).metadata;
    }
}
exports.MediatedLinkedRdfSourcesAsyncRdfIterator = MediatedLinkedRdfSourcesAsyncRdfIterator;
//# sourceMappingURL=MediatedLinkedRdfSourcesAsyncRdfIterator.js.map