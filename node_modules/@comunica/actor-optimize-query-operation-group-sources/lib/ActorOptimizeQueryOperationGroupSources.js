"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorOptimizeQueryOperationGroupSources = void 0;
const bus_optimize_query_operation_1 = require("@comunica/bus-optimize-query-operation");
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const utils_algebra_1 = require("@comunica/utils-algebra");
const utils_query_operation_1 = require("@comunica/utils-query-operation");
/**
 * A comunica Group Sources Optimize Query Operation Actor.
 */
class ActorOptimizeQueryOperationGroupSources extends bus_optimize_query_operation_1.ActorOptimizeQueryOperation {
    constructor(args) {
        super(args);
    }
    async test(action) {
        if ((0, utils_query_operation_1.getOperationSource)(action.operation)) {
            return (0, core_1.failTest)(`Actor ${this.name} does not work with top-level operation sources.`);
        }
        return (0, core_1.passTestVoid)();
    }
    async run(action) {
        return { operation: await this.groupOperation(action.operation, action.context), context: action.context };
    }
    /**
     * Group operations belonging to the same source together, only if that source accepts the grouped operations.
     * This grouping will be done recursively for the whole operation tree.
     * Operations annotated with sources are considered leaves in the tree.
     * @param operation An operation to group.
     * @param context The action context.
     */
    async groupOperation(operation, context) {
        const dataFactory = context.getSafe(context_entries_1.KeysInitQuery.dataFactory);
        const algebraFactory = new utils_algebra_1.AlgebraFactory(dataFactory);
        // Return operation as-is if the operation already has a single source, or if the operation has no children.
        if ((0, utils_query_operation_1.getOperationSource)(operation) ?? !('input' in operation)) {
            return operation;
        }
        // If operation has a single input, move source annotation upwards if the source can handle it.
        if (!Array.isArray(operation.input)) {
            const groupedInput = await this.groupOperation(operation.input, context);
            if (groupedInput.metadata?.scopedSource) {
                const source = (0, utils_query_operation_1.getOperationSource)(groupedInput);
                operation = await this.moveSourceAnnotationUpwardsIfPossible(operation, [groupedInput], source, context);
            }
            return { ...operation, input: groupedInput };
        }
        // If operation has multiple inputs, cluster source annotations.
        const inputs = await Promise.all(operation.input
            .map(subInput => this.groupOperation(subInput, context)));
        const clusters = this.clusterOperationsWithEqualSources(inputs);
        // If we just have a single cluster, move the source annotation upwards
        if (clusters.length === 1) {
            const newInputs = clusters[0];
            const source = (0, utils_query_operation_1.getOperationSource)(clusters[0][0]);
            return {
                ...await this.moveSourceAnnotationUpwardsIfPossible(operation, newInputs, source, context),
                input: newInputs,
            };
        }
        // If the number of clusters is equal to the number of original inputs, do nothing.
        if (clusters.length === inputs.length) {
            const result = { ...operation, input: inputs };
            return result;
        }
        // If we have multiple clusters, created nested multi-operations
        let multiFactoryMethod;
        if ((0, utils_algebra_1.isKnownOperation)(operation, utils_algebra_1.Algebra.Types.JOIN)) {
            multiFactoryMethod = algebraFactory.createJoin.bind(algebraFactory);
        }
        else if ((0, utils_algebra_1.isKnownOperation)(operation, utils_algebra_1.Algebra.Types.UNION)) {
            multiFactoryMethod = algebraFactory.createUnion.bind(algebraFactory);
        }
        else if ((0, utils_algebra_1.isKnownOperation)(operation, utils_algebra_1.Algebra.Types.ALT)) {
            multiFactoryMethod = algebraFactory.createAlt.bind(algebraFactory);
        }
        else if ((0, utils_algebra_1.isKnownOperation)(operation, utils_algebra_1.Algebra.Types.SEQ)) {
            multiFactoryMethod = algebraFactory.createSeq.bind(algebraFactory);
        }
        else {
            // While LeftJoin and Minus are also multi-operations,
            // these can never occur because they only have 2 inputs,
            // so these cases will always be captured by one of the 2 if-cases above
            // (clusters.length === 1 or clusters.length === input.length)
            // In all other cases, error
            throw new Error(`Unsupported operation '${operation.type}' detected while grouping sources`);
        }
        return await this.groupOperationMulti(clusters, multiFactoryMethod, context);
    }
    async groupOperationMulti(clusters, factoryMethod, context) {
        let flatten = true;
        const nestedMerges = await Promise.all(clusters.map(async (cluster) => {
            const source = (0, utils_query_operation_1.getOperationSource)(cluster[0]);
            const merged = await this
                .moveSourceAnnotationUpwardsIfPossible(factoryMethod(cluster, true), cluster, source, context);
            if ((0, utils_query_operation_1.getOperationSource)(merged)) {
                flatten = false;
            }
            return merged;
        }));
        return factoryMethod(nestedMerges, flatten);
    }
    /**
     * Cluster the given operations by equal source annotations.
     * @param operationsIn An array of operations to cluster.
     */
    clusterOperationsWithEqualSources(operationsIn) {
        // Operations can have a source, or no source at all
        const sourceOperations = new Map();
        const sourcelessOperations = [];
        // Cluster by source
        for (const operation of operationsIn) {
            const source = (0, utils_query_operation_1.getOperationSource)(operation);
            if (source) {
                if (!sourceOperations.has(source)) {
                    sourceOperations.set(source, []);
                }
                sourceOperations.get(source).push(operation);
            }
            else {
                sourcelessOperations.push(operation);
            }
        }
        // Return clusters
        const clusters = [];
        if (sourcelessOperations.length > 0) {
            clusters.push(sourcelessOperations);
        }
        for (const [source, operations] of sourceOperations.entries()) {
            clusters.push(operations
                .map(operation => (0, utils_query_operation_1.assignOperationSource)(operation, source)));
        }
        return clusters;
    }
    /**
     * If the given source accepts the grouped operation, annotate the grouped operation with the source,
     * and remove the source annotation from the seperate input operations.
     * Otherwise, return the grouped operation unchanged.
     * @param operation A grouped operation consisting of all given input operations.
     * @param inputs An array of operations that share the same source annotation.
     * @param source The common source.
     * @param context The action context.
     */
    async moveSourceAnnotationUpwardsIfPossible(operation, inputs, source, context) {
        if (source && this.isPossibleToMoveSourceAnnotationUpwards(operation, await source.source.getSelectorShape(context), context)) {
            this.logDebug(context, `Hoist ${inputs.length} source-specific operations into a single ${operation.type} operation for ${source.source.toString()}`);
            operation = (0, utils_query_operation_1.assignOperationSource)(operation, source);
            for (const input of inputs) {
                (0, utils_query_operation_1.removeOperationSource)(input);
            }
        }
        return operation;
    }
    /**
     * Checks if it's possible to move the source annotation upwards using the following rules:
     * - If the shape doesn't accept the operation, then it's not possible.
     * - If it does and the operation does not contain extension functions or
     *   comunica doesn't support them, then it's possible.
     * - If comunica does support them, then it's possible only if the shape accepts the extension function expressions.
     * @param operation A grouped operation consisting of all given input operations.
     * @param shape The common source's shape.
     * @param context The action context.
     */
    isPossibleToMoveSourceAnnotationUpwards(operation, shape, context) {
        const wildcardAcceptAllExtensionFunctions = context.get(context_entries_1.KeysInitQuery.extensionFunctionsAlwaysPushdown);
        if ((0, utils_query_operation_1.doesShapeAcceptOperation)(shape, operation, { wildcardAcceptAllExtensionFunctions })) {
            const extensionFunctions = context.get(context_entries_1.KeysInitQuery.extensionFunctions);
            const expression = operation.expression;
            return !extensionFunctions ||
                !(expression && (0, utils_algebra_1.isKnownSubType)(expression, utils_algebra_1.Algebra.ExpressionTypes.NAMED)) ||
                !(expression?.name.value in extensionFunctions) ||
                (0, utils_query_operation_1.doesShapeAcceptOperation)(shape, expression, { wildcardAcceptAllExtensionFunctions });
        }
        return false;
    }
}
exports.ActorOptimizeQueryOperationGroupSources = ActorOptimizeQueryOperationGroupSources;
//# sourceMappingURL=ActorOptimizeQueryOperationGroupSources.js.map