{"version":3,"file":"ActorOptimizeQueryOperationGroupSources.js","sourceRoot":"","sources":["ActorOptimizeQueryOperationGroupSources.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  IActionOptimizeQueryOperation,\n  IActorOptimizeQueryOperationOutput,\n  IActorOptimizeQueryOperationArgs,\n} from '@comunica/bus-optimize-query-operation';\nimport { ActorOptimizeQueryOperation } from '@comunica/bus-optimize-query-operation';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { failTest, passTestVoid } from '@comunica/core';\nimport type { ComunicaDataFactory, FragmentSelectorShape, IActionContext, IQuerySourceWrapper } from '@comunica/types';\nimport { Algebra, AlgebraFactory, isKnownOperation, isKnownSubType } from '@comunica/utils-algebra';\nimport {\n  assignOperationSource,\n  doesShapeAcceptOperation,\n  getOperationSource,\n  removeOperationSource,\n} from '@comunica/utils-query-operation';\n\n/**\n * A comunica Group Sources Optimize Query Operation Actor.\n */\nexport class ActorOptimizeQueryOperationGroupSources extends ActorOptimizeQueryOperation {\n  public constructor(args: IActorOptimizeQueryOperationArgs) {\n    super(args);\n  }\n\n  public async test(action: IActionOptimizeQueryOperation): Promise<TestResult<IActorTest>> {\n    if (getOperationSource(action.operation)) {\n      return failTest(`Actor ${this.name} does not work with top-level operation sources.`);\n    }\n    return passTestVoid();\n  }\n\n  public async run(action: IActionOptimizeQueryOperation): Promise<IActorOptimizeQueryOperationOutput> {\n    return { operation: await this.groupOperation(action.operation, action.context), context: action.context };\n  }\n\n  /**\n   * Group operations belonging to the same source together, only if that source accepts the grouped operations.\n   * This grouping will be done recursively for the whole operation tree.\n   * Operations annotated with sources are considered leaves in the tree.\n   * @param operation An operation to group.\n   * @param context The action context.\n   */\n  public async groupOperation(operation: Algebra.Operation, context: IActionContext): Promise<Algebra.Operation> {\n    const dataFactory: ComunicaDataFactory = context.getSafe(KeysInitQuery.dataFactory);\n    const algebraFactory = new AlgebraFactory(dataFactory);\n\n    // Return operation as-is if the operation already has a single source, or if the operation has no children.\n    if (getOperationSource(operation) ?? !('input' in operation)) {\n      return operation;\n    }\n\n    // If operation has a single input, move source annotation upwards if the source can handle it.\n    if (!Array.isArray(operation.input)) {\n      const groupedInput = await this.groupOperation(<Algebra.Operation> operation.input, context);\n      if (groupedInput.metadata?.scopedSource) {\n        const source: IQuerySourceWrapper = <IQuerySourceWrapper> getOperationSource(groupedInput);\n        operation = await this.moveSourceAnnotationUpwardsIfPossible(operation, [ groupedInput ], source, context);\n      }\n      return <Algebra.Operation> { ...operation, input: groupedInput };\n    }\n\n    // If operation has multiple inputs, cluster source annotations.\n    const inputs: Algebra.Operation[] = await Promise.all(operation.input\n      .map(subInput => this.groupOperation(subInput, context)));\n    const clusters = this.clusterOperationsWithEqualSources(inputs);\n\n    // If we just have a single cluster, move the source annotation upwards\n    if (clusters.length === 1) {\n      const newInputs = clusters[0];\n      const source = getOperationSource(clusters[0][0])!;\n      return <Algebra.Operation> {\n        ...await this.moveSourceAnnotationUpwardsIfPossible(operation, newInputs, source, context),\n        input: newInputs,\n      };\n    }\n\n    // If the number of clusters is equal to the number of original inputs, do nothing.\n    if (clusters.length === inputs.length) {\n      const result: Algebra.Multi = { ...operation, input: inputs };\n      return result;\n    }\n\n    // If we have multiple clusters, created nested multi-operations\n    let multiFactoryMethod: (children: Algebra.Operation[], flatten: boolean) => Algebra.Operation;\n    if (isKnownOperation(operation, Algebra.Types.JOIN)) {\n      multiFactoryMethod = algebraFactory.createJoin.bind(algebraFactory);\n    } else if (isKnownOperation(operation, Algebra.Types.UNION)) {\n      multiFactoryMethod = algebraFactory.createUnion.bind(algebraFactory);\n    } else if (isKnownOperation(operation, Algebra.Types.ALT)) {\n      multiFactoryMethod = <any> algebraFactory.createAlt.bind(algebraFactory);\n    } else if (isKnownOperation(operation, Algebra.Types.SEQ)) {\n      multiFactoryMethod = <any> algebraFactory.createSeq.bind(algebraFactory);\n    } else {\n      // While LeftJoin and Minus are also multi-operations,\n      // these can never occur because they only have 2 inputs,\n      // so these cases will always be captured by one of the 2 if-cases above\n      // (clusters.length === 1 or clusters.length === input.length)\n\n      // In all other cases, error\n      throw new Error(`Unsupported operation '${operation.type}' detected while grouping sources`);\n    }\n    return await this.groupOperationMulti(clusters, multiFactoryMethod, context);\n  }\n\n  protected async groupOperationMulti(\n    clusters: Algebra.Operation[][],\n    factoryMethod: (children: Algebra.Operation[], flatten: boolean) => Algebra.Operation,\n    context: IActionContext,\n  ): Promise<Algebra.Operation> {\n    let flatten = true;\n    const nestedMerges = await Promise.all(clusters.map(async(cluster) => {\n      const source = getOperationSource(cluster[0])!;\n      const merged = await this\n        .moveSourceAnnotationUpwardsIfPossible(factoryMethod(cluster, true), cluster, source, context);\n      if (getOperationSource(merged)) {\n        flatten = false;\n      }\n      return merged;\n    }));\n    return factoryMethod(nestedMerges, flatten);\n  }\n\n  /**\n   * Cluster the given operations by equal source annotations.\n   * @param operationsIn An array of operations to cluster.\n   */\n  public clusterOperationsWithEqualSources(operationsIn: Algebra.Operation[]): Algebra.Operation[][] {\n    // Operations can have a source, or no source at all\n    const sourceOperations: Map<IQuerySourceWrapper, Algebra.Operation[]> = new Map();\n    const sourcelessOperations: Algebra.Operation[] = [];\n\n    // Cluster by source\n    for (const operation of operationsIn) {\n      const source = getOperationSource(operation);\n      if (source) {\n        if (!sourceOperations.has(source)) {\n          sourceOperations.set(source, []);\n        }\n        sourceOperations.get(source)!.push(operation);\n      } else {\n        sourcelessOperations.push(operation);\n      }\n    }\n\n    // Return clusters\n    const clusters: Algebra.Operation[][] = [];\n    if (sourcelessOperations.length > 0) {\n      clusters.push(sourcelessOperations);\n    }\n    for (const [ source, operations ] of sourceOperations.entries()) {\n      clusters.push(operations\n        .map(operation => assignOperationSource(operation, source)));\n    }\n    return clusters;\n  }\n\n  /**\n   * If the given source accepts the grouped operation, annotate the grouped operation with the source,\n   * and remove the source annotation from the seperate input operations.\n   * Otherwise, return the grouped operation unchanged.\n   * @param operation A grouped operation consisting of all given input operations.\n   * @param inputs An array of operations that share the same source annotation.\n   * @param source The common source.\n   * @param context The action context.\n   */\n  public async moveSourceAnnotationUpwardsIfPossible<O extends Algebra.Operation>(\n    operation: O,\n    inputs: Algebra.Operation[],\n    source: IQuerySourceWrapper | undefined,\n    context: IActionContext,\n  ): Promise<O> {\n    if (source && this.isPossibleToMoveSourceAnnotationUpwards(\n      operation,\n      await source.source.getSelectorShape(context),\n      context,\n    )) {\n      this.logDebug(context, `Hoist ${inputs.length} source-specific operations into a single ${operation.type} operation for ${source.source.toString()}`);\n      operation = assignOperationSource(operation, source);\n      for (const input of inputs) {\n        removeOperationSource(input);\n      }\n    }\n    return operation;\n  }\n\n  /**\n   * Checks if it's possible to move the source annotation upwards using the following rules:\n   * - If the shape doesn't accept the operation, then it's not possible.\n   * - If it does and the operation does not contain extension functions or\n   *   comunica doesn't support them, then it's possible.\n   * - If comunica does support them, then it's possible only if the shape accepts the extension function expressions.\n   * @param operation A grouped operation consisting of all given input operations.\n   * @param shape The common source's shape.\n   * @param context The action context.\n   */\n  public isPossibleToMoveSourceAnnotationUpwards<O extends Algebra.Operation>(\n    operation: O,\n    shape: FragmentSelectorShape,\n    context: IActionContext,\n  ): boolean {\n    const wildcardAcceptAllExtensionFunctions = context.get(KeysInitQuery.extensionFunctionsAlwaysPushdown);\n    if (doesShapeAcceptOperation(shape, operation, { wildcardAcceptAllExtensionFunctions })) {\n      const extensionFunctions = context.get(KeysInitQuery.extensionFunctions);\n      const expression: Algebra.Expression | undefined = (<any> operation).expression;\n      return !extensionFunctions ||\n        !(expression && isKnownSubType(expression, Algebra.ExpressionTypes.NAMED)) ||\n        !(expression?.name.value in extensionFunctions) ||\n        doesShapeAcceptOperation(shape, expression, { wildcardAcceptAllExtensionFunctions });\n    }\n    return false;\n  }\n}\n"]}