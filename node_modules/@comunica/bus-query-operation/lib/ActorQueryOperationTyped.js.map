{"version":3,"file":"ActorQueryOperationTyped.js","sourceRoot":"","sources":["ActorQueryOperationTyped.ts"],"names":[],"mappings":";;;AAAA,+DAA8E;AAE9E,yCAA0C;AAQ1C,6DAA2D;AAG3D,+DAA4D;AAE5D;;GAEG;AACH,MAAsB,wBAGpB,SAAQ,yCAAuB;IACf,aAAa,CAAS;IAEtC,YAAsB,IAAkC,EAAE,aAAqB;QAC7E,KAAK,CAAC,IAAI,CAAC,CAAC;QACZ,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;QACnC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;YACxB,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAC;QACxE,CAAC;IACH,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,MAA6B;QAC7C,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC;YACtB,OAAO,IAAA,eAAQ,EAAC,0DAA0D,CAAC,CAAC;QAC9E,CAAC;QACD,IAAI,MAAM,CAAC,SAAS,CAAC,IAAI,KAAK,IAAI,CAAC,aAAa,EAAE,CAAC;YACjD,OAAO,IAAA,eAAQ,EAAC,SAAS,IAAI,CAAC,IAAI,kBAAkB,IAAI,CAAC,aAAa,wBAClE,MAAM,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC;QAC/B,CAAC;QACD,MAAM,SAAS,GAAU,MAAM,CAAC,SAAS,CAAC;QAC1C,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;IACvD,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAA6B,EAAE,QAAY;QAC1D,uBAAuB;QACvB,MAAM,uBAAuB,GAAyC,MAAM,CAAC,OAAO;aACjF,GAAG,CAAC,+BAAa,CAAC,uBAAuB,CAAC,CAAC;QAC9C,IAAI,uBAAuB,EAAE,CAAC;YAC5B,uBAAuB,CAAC,YAAY,CAClC,MAAM,CAAC,SAAS,CAAC,IAAI,EACrB,SAAS,EACT,MAAM,CAAC,SAAS,EAChB,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,+BAAa,CAAC,qBAAqB,CAAC,EACvD,IAAI,CAAC,IAAI,EACT,EAAE,CACH,CAAC;YACF,MAAM,CAAC,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,+BAAa,CAAC,qBAAqB,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC;QAC7F,CAAC;QAED,MAAM,SAAS,GAAU,MAAM,CAAC,SAAS,CAAC;QAC1C,MAAM,UAAU,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,oCAAkB,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;QAC/E,MAAM,MAAM,GAA0B,MAAM,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;QAC/F,IAAI,UAAU,IAAI,MAAM,EAAE,CAAC;YACzB,MAAM,CAAC,QAAQ,GACb,IAAA,gCAAe,EAA8E,MAAM,CAAC,QAAQ,CAAC,CAAC;QAClH,CAAC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;CAMF;AAxDD,4DAwDC","sourcesContent":["import { KeysInitQuery, KeysQueryOperation } from '@comunica/context-entries';\nimport type { IActorTest, TestResult } from '@comunica/core';\nimport { failTest } from '@comunica/core';\nimport type {\n  IQueryOperationResult,\n  IPhysicalQueryPlanLogger,\n  IActionContext,\n  IMetadata,\n} from '@comunica/types';\nimport type { Algebra } from '@comunica/utils-algebra';\nimport { cachifyMetadata } from '@comunica/utils-metadata';\nimport type * as RDF from '@rdfjs/types';\nimport type { IActionQueryOperation, IActorQueryOperationArgs } from './ActorQueryOperation';\nimport { ActorQueryOperation } from './ActorQueryOperation';\n\n/**\n * A base implementation for query operation actors for a specific operation type.\n */\nexport abstract class ActorQueryOperationTyped<\n  O extends Algebra.Operation,\nTS = undefined,\n> extends ActorQueryOperation<TS> {\n  public readonly operationName: string;\n\n  protected constructor(args: IActorQueryOperationArgs<TS>, operationName: string) {\n    super(args);\n    this.operationName = operationName;\n    if (!this.operationName) {\n      throw new Error('A valid \"operationName\" argument must be provided.');\n    }\n  }\n\n  public async test(action: IActionQueryOperation): Promise<TestResult<IActorTest, TS>> {\n    if (!action.operation) {\n      return failTest('Missing field \\'operation\\' in a query operation action.');\n    }\n    if (action.operation.type !== this.operationName) {\n      return failTest(`Actor ${this.name} only supports ${this.operationName} operations, but got ${\n          action.operation.type}`);\n    }\n    const operation: O = <O> action.operation;\n    return this.testOperation(operation, action.context);\n  }\n\n  public async run(action: IActionQueryOperation, sideData: TS): Promise<IQueryOperationResult> {\n    // Log to physical plan\n    const physicalQueryPlanLogger: IPhysicalQueryPlanLogger | undefined = action.context\n      .get(KeysInitQuery.physicalQueryPlanLogger);\n    if (physicalQueryPlanLogger) {\n      physicalQueryPlanLogger.logOperation(\n        action.operation.type,\n        undefined,\n        action.operation,\n        action.context.get(KeysInitQuery.physicalQueryPlanNode),\n        this.name,\n        {},\n      );\n      action.context = action.context.set(KeysInitQuery.physicalQueryPlanNode, action.operation);\n    }\n\n    const operation: O = <O> action.operation;\n    const subContext = action.context.set(KeysQueryOperation.operation, operation);\n    const output: IQueryOperationResult = await this.runOperation(operation, subContext, sideData);\n    if ('metadata' in output) {\n      output.metadata = <any>\n        cachifyMetadata<IMetadata<RDF.QuadTermName | RDF.Variable>, RDF.QuadTermName | RDF.Variable>(output.metadata);\n    }\n    return output;\n  }\n\n  protected abstract testOperation(operation: O, context: IActionContext): Promise<TestResult<IActorTest, TS>>;\n\n  protected abstract runOperation(operation: O, context: IActionContext, sideData: TS):\n  Promise<IQueryOperationResult>;\n}\n"]}