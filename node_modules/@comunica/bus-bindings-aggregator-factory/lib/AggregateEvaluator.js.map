{"version":3,"file":"AggregateEvaluator.js","sourceRoot":"","sources":["AggregateEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["import { KeysExpressionEvaluator } from '@comunica/context-entries';\nimport type { IExpressionEvaluator, ISuperTypeProvider } from '@comunica/types';\nimport * as Eval from '@comunica/utils-expression-evaluator';\nimport type * as RDF from '@rdfjs/types';\nimport * as RdfString from 'rdf-string';\n\n/**\n * This is the base class for all aggregators.\n * NOTE: The wildcard count aggregator significantly differs from the others and overloads parts of this class.\n */\nexport abstract class AggregateEvaluator {\n  private errorOccurred = false;\n\n  protected readonly variableValues: Set<string>;\n\n  protected readonly superTypeProvider: ISuperTypeProvider;\n  protected readonly termTransformer: Eval.TermTransformer;\n\n  protected constructor(\n    protected readonly evaluator: IExpressionEvaluator,\n    protected readonly distinct: boolean,\n    private readonly throwError = false,\n  ) {\n    this.errorOccurred = false;\n    this.superTypeProvider = evaluator.context.getSafe(KeysExpressionEvaluator.superTypeProvider);\n    this.termTransformer = new Eval.TermTransformer(this.superTypeProvider);\n\n    this.variableValues = new Set();\n  }\n\n  protected abstract putTerm(term: RDF.Term): void;\n  protected abstract termResult(): RDF.Term | undefined;\n\n  public emptyValueTerm(): RDF.Term | undefined {\n    return undefined;\n  }\n\n  /**\n   * The spec says to throw an error when a set function is called on an empty\n   * set (unless explicitly mentioned otherwise like COUNT).\n   * However, aggregate error handling says to not bind the result in case of an\n   * error. So to simplify logic in the caller, we return undefined by default.\n   */\n  public emptyValue(): RDF.Term | undefined {\n    const val = this.emptyValueTerm();\n    if (val === undefined && this.throwError) {\n      throw new Eval.EmptyAggregateError();\n    }\n    return val;\n  }\n\n  /**\n   * Base implementation of putBindings, that evaluates to a term and then calls putTerm.\n   * The WildcardCountAggregator will completely discard this implementation.\n   * @param bindings\n   */\n  public async putBindings(bindings: RDF.Bindings): Promise<void> {\n    if (this.errorOccurred) {\n      return;\n    }\n    try {\n      const term = await this.evaluator.evaluate(bindings);\n      if (!term || this.errorOccurred) {\n        return;\n      }\n\n      // Handle DISTINCT before putting the term\n      if (!this.distinct || !this.variableValues.has(RdfString.termToString(term))) {\n        this.putTerm(term);\n        if (this.distinct) {\n          this.variableValues.add(RdfString.termToString(term));\n        }\n      }\n    } catch (error: unknown) {\n      this.safeThrow(error);\n    }\n  }\n\n  public async result(): Promise<RDF.Term | undefined> {\n    if (this.errorOccurred) {\n      return undefined;\n    }\n    return this.termResult();\n  }\n\n  private safeThrow(err: unknown): void {\n    if (this.throwError) {\n      throw err;\n    } else {\n      this.errorOccurred = true;\n    }\n  }\n\n  protected termToNumericOrError(term: RDF.Term): Eval.NumericLiteral {\n    if (term.termType !== 'Literal') {\n      throw new Error(`Term with value ${term.value} has type ${term.termType} and is not a numeric literal`);\n    } else if (\n      !Eval.isSubTypeOf(term.datatype.value, Eval.TypeAlias.SPARQL_NUMERIC, this.superTypeProvider)) {\n      throw new Error(`Term datatype ${term.datatype.value} with value ${term.value} has type ${term.termType} and is not a numeric literal`);\n    }\n    return <Eval.NumericLiteral> this.termTransformer.transformLiteral(term);\n  }\n}\n"]}