"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.funcExpr1 = funcExpr1;
exports.funcExpr2 = funcExpr2;
exports.funcExpr3 = funcExpr3;
exports.funcVar1 = funcVar1;
exports.funcExprOrNil1 = funcExprOrNil1;
exports.funcNil1 = funcNil1;
exports.funcExprList1 = funcExprList1;
exports.funcExpr2or3 = funcExpr2or3;
exports.funcExpr3or4 = funcExpr3or4;
exports.funcGroupGraphPattern = funcGroupGraphPattern;
exports.baseAggregateFunc = baseAggregateFunc;
const core_1 = require("@traqula/core");
const index_js_1 = require("./grammar/index.js");
const l = __importStar(require("./lexer/index.js"));
function funcExpr1(func) {
    return {
        name: (0, core_1.unCapitalize)(func.name),
        impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
            const operator = CONSUME(func);
            CONSUME(l.symbols.LParen);
            const arg = SUBRULE(index_js_1.expression);
            const close = CONSUME(l.symbols.RParen);
            return ACTION(() => C.astFactory.expressionOperation(operator.image, [arg], C.astFactory.sourceLocation(operator, close)));
        },
    };
}
function funcExpr2(func) {
    return {
        name: (0, core_1.unCapitalize)(func.name),
        impl: ({ ACTION, CONSUME, SUBRULE1, SUBRULE2 }) => (C) => {
            const operator = CONSUME(func);
            CONSUME(l.symbols.LParen);
            const arg1 = SUBRULE1(index_js_1.expression);
            CONSUME(l.symbols.comma);
            const arg2 = SUBRULE2(index_js_1.expression);
            const close = CONSUME(l.symbols.RParen);
            return ACTION(() => C.astFactory.expressionOperation(operator.image, [arg1, arg2], C.astFactory.sourceLocation(operator, close)));
        },
    };
}
function funcExpr3(func) {
    return {
        name: (0, core_1.unCapitalize)(func.name),
        impl: ({ ACTION, CONSUME, CONSUME1, CONSUME2, SUBRULE1, SUBRULE2, SUBRULE3 }) => (C) => {
            const operator = CONSUME(func);
            CONSUME(l.symbols.LParen);
            const arg1 = SUBRULE1(index_js_1.expression);
            CONSUME1(l.symbols.comma);
            const arg2 = SUBRULE2(index_js_1.expression);
            CONSUME2(l.symbols.comma);
            const arg3 = SUBRULE3(index_js_1.expression);
            const close = CONSUME(l.symbols.RParen);
            return ACTION(() => C.astFactory.expressionOperation(operator.image, [arg1, arg2, arg3], C.astFactory.sourceLocation(operator, close)));
        },
    };
}
function funcVar1(func) {
    return {
        name: (0, core_1.unCapitalize)(func.name),
        impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
            const operator = CONSUME(func);
            CONSUME(l.symbols.LParen);
            const arg = SUBRULE(index_js_1.var_);
            const close = CONSUME(l.symbols.RParen);
            return ACTION(() => C.astFactory.expressionOperation(operator.image, [arg], C.astFactory.sourceLocation(operator, close)));
        },
    };
}
function funcExprOrNil1(func) {
    return {
        name: (0, core_1.unCapitalize)(func.name),
        impl: ({ ACTION, CONSUME, OR, SUBRULE }) => (C) => {
            const operator = CONSUME(func);
            return OR([
                { ALT: () => {
                        CONSUME(l.symbols.LParen);
                        const arg = SUBRULE(index_js_1.expression);
                        const close = CONSUME(l.symbols.RParen);
                        return ACTION(() => C.astFactory.expressionOperation(operator.image, [arg], C.astFactory.sourceLocation(operator, close)));
                    } },
                { ALT: () => {
                        const nil = CONSUME(l.terminals.nil);
                        return ACTION(() => C.astFactory.expressionOperation(operator.image, [], C.astFactory.sourceLocation(operator, nil)));
                    } },
            ]);
        },
    };
}
function funcNil1(func) {
    return {
        name: (0, core_1.unCapitalize)(func.name),
        impl: ({ ACTION, CONSUME }) => (C) => {
            const operator = CONSUME(func);
            const nil = CONSUME(l.terminals.nil);
            return ACTION(() => C.astFactory.expressionOperation(operator.image, [], C.astFactory.sourceLocation(operator, nil)));
        },
    };
}
function funcExprList1(func) {
    return {
        name: (0, core_1.unCapitalize)(func.name),
        impl: ({ ACTION, CONSUME, SUBRULE }) => (C) => {
            const operator = CONSUME(func);
            const args = SUBRULE(index_js_1.expressionList);
            return ACTION(() => C.astFactory.expressionOperation(operator.image, args.val, C.astFactory.sourceLocation(operator, args)));
        },
    };
}
function funcExpr2or3(func) {
    return {
        name: (0, core_1.unCapitalize)(func.name),
        impl: ({ ACTION, CONSUME, SUBRULE1, SUBRULE2, SUBRULE3, CONSUME1, OPTION, CONSUME2 }) => (C) => {
            const operator = CONSUME(func);
            CONSUME(l.symbols.LParen);
            const arg1 = SUBRULE1(index_js_1.expression);
            CONSUME1(l.symbols.comma);
            const arg2 = SUBRULE2(index_js_1.expression);
            const arg3 = OPTION(() => {
                CONSUME2(l.symbols.comma);
                return SUBRULE3(index_js_1.expression);
            });
            const close = CONSUME(l.symbols.RParen);
            return ACTION(() => C.astFactory.expressionOperation(operator.image, arg3 ? [arg1, arg2, arg3] : [arg1, arg2], C.astFactory.sourceLocation(operator, close)));
        },
    };
}
function funcExpr3or4(func) {
    return {
        name: (0, core_1.unCapitalize)(func.name),
        impl: ({ ACTION, CONSUME, SUBRULE1, SUBRULE2, SUBRULE3, SUBRULE4, CONSUME1, OPTION, CONSUME2, CONSUME3, }) => (C) => {
            const operator = CONSUME(func);
            CONSUME(l.symbols.LParen);
            const arg1 = SUBRULE1(index_js_1.expression);
            CONSUME1(l.symbols.comma);
            const arg2 = SUBRULE2(index_js_1.expression);
            CONSUME2(l.symbols.comma);
            const arg3 = SUBRULE3(index_js_1.expression);
            const arg4 = OPTION(() => {
                CONSUME3(l.symbols.comma);
                return SUBRULE4(index_js_1.expression);
            });
            const close = CONSUME(l.symbols.RParen);
            return ACTION(() => C.astFactory.expressionOperation(operator.image, arg4 ? [arg1, arg2, arg3, arg4] : [arg1, arg2, arg3], C.astFactory.sourceLocation(operator, close)));
        },
    };
}
function funcGroupGraphPattern(func) {
    return {
        name: (0, core_1.unCapitalize)(func.name),
        impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
            const operator = CONSUME(func);
            const group = SUBRULE(index_js_1.groupGraphPattern);
            return ACTION(() => C.astFactory.expressionPatternOperation(operator.image, group, C.astFactory.sourceLocation(operator, group)));
        },
    };
}
function baseAggregateFunc(func) {
    return {
        name: (0, core_1.unCapitalize)(func.name),
        impl: ({ ACTION, CONSUME, SUBRULE, OPTION }) => (C) => {
            const operator = CONSUME(func);
            CONSUME(l.symbols.LParen);
            const distinct = OPTION(() => CONSUME(l.distinct));
            const expr1 = SUBRULE(index_js_1.expression);
            const close = CONSUME(l.symbols.RParen);
            return ACTION(() => C.astFactory.aggregate(operator.image, distinct !== undefined, expr1, undefined, C.astFactory.sourceLocation(operator, close)));
        },
    };
}
//# sourceMappingURL=expressionHelpers.js.map