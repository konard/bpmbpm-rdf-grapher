"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TermFactoryMixin = TermFactoryMixin;
const nodeType = 'term';
// eslint-disable-next-line ts/explicit-function-return-type
function TermFactoryMixin(Base) {
    return class TermFactory extends Base {
        __blankNodeCounter = 0;
        resetBlankNodeCounter() {
            this.__blankNodeCounter = 0;
        }
        isTerm(x) {
            return this.isOfType(x, 'term');
        }
        termBlank(label, loc) {
            const base = {
                type: 'term',
                subType: 'blankNode',
                loc,
            };
            if (label === undefined) {
                return { ...base, label: `g_${this.__blankNodeCounter++}` };
            }
            return { ...base, label: `e_${label}` };
        }
        isTermBlank(obj) {
            return this.isOfSubType(obj, nodeType, 'blankNode');
        }
        termLiteral(loc, value, langOrIri) {
            return {
                type: nodeType,
                subType: 'literal',
                value,
                langOrIri,
                loc,
            };
        }
        isTermLiteral(obj) {
            return this.isOfSubType(obj, nodeType, 'literal');
        }
        isTermLiteralLangStr(obj) {
            return this.isTermLiteral(obj) && typeof obj.langOrIri === 'string';
        }
        isTermLiteralStr(obj) {
            return this.isTermLiteral(obj) && typeof obj.langOrIri === 'undefined';
        }
        isTermLiteralTyped(obj) {
            const casted = obj;
            return this.isTermLiteral(obj) && typeof casted.langOrIri === 'object' &&
                casted.langOrIri !== null && this.isTermNamed(casted.langOrIri);
        }
        termVariable(value, loc) {
            return {
                type: nodeType,
                subType: 'variable',
                value,
                loc,
            };
        }
        isTermVariable(obj) {
            return this.isOfSubType(obj, nodeType, 'variable');
        }
        termNamed(loc, value, prefix) {
            const base = {
                type: nodeType,
                subType: 'namedNode',
                value,
                loc,
            };
            if (prefix === undefined) {
                return base;
            }
            return { ...base, prefix };
        }
        isTermNamed(obj) {
            return this.isOfSubType(obj, nodeType, 'namedNode');
        }
        isTermNamedPrefixed(obj) {
            const casted = obj;
            return this.isTermNamed(obj) && typeof casted.prefix === 'string';
        }
    };
}
//# sourceMappingURL=TermFactory.js.map