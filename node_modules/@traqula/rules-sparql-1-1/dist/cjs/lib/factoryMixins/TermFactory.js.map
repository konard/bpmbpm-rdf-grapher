{"version":3,"file":"TermFactory.js","sourceRoot":"","sources":["../../../../lib/factoryMixins/TermFactory.ts"],"names":[],"mappings":"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","sourcesContent":["import type { AstCoreFactory, SourceLocation, Typed, SubTyped } from '@traqula/core';\nimport type {\n  TermBlank,\n  TermIri,\n  TermIriFull,\n  TermIriPrefixed,\n  TermLiteral,\n  TermLiteralLangStr,\n  TermLiteralStr,\n  TermLiteralTyped,\n  TermVariable,\n} from '../Sparql11types.js';\nimport type { Constructor } from './mixins.js';\n\ntype NodeType = 'term';\nconst nodeType: NodeType = 'term';\n\n// eslint-disable-next-line ts/explicit-function-return-type\nexport function TermFactoryMixin<TBase extends Constructor<AstCoreFactory>>(Base: TBase) {\n  return class TermFactory extends Base {\n    public __blankNodeCounter = 0;\n\n    public resetBlankNodeCounter(): void {\n      this.__blankNodeCounter = 0;\n    }\n\n    public isTerm(x: object): x is Typed<'term'> {\n      return this.isOfType(x, 'term');\n    }\n\n    public termBlank(label: undefined | string, loc: SourceLocation): TermBlank {\n      const base = <const>{\n        type: 'term',\n        subType: 'blankNode',\n        loc,\n      };\n      if (label === undefined) {\n        return { ...base, label: `g_${this.__blankNodeCounter++}` };\n      }\n      return { ...base, label: `e_${label}` };\n    }\n\n    public isTermBlank(obj: object): obj is SubTyped<NodeType, 'blankNode'> {\n      return this.isOfSubType(obj, nodeType, 'blankNode');\n    }\n\n    /**\n     * String, no lang, no type\n     */\n    public termLiteral(loc: SourceLocation, value: string, lang?: undefined): TermLiteralStr;\n    /**\n     * String with a language tag\n     */\n    public termLiteral(loc: SourceLocation, value: string, lang: string): TermLiteralLangStr;\n    /**\n     * Lexical form with a type\n     */\n    public termLiteral(loc: SourceLocation, value: string, iri: TermIri): TermLiteralTyped;\n    public termLiteral(loc: SourceLocation, value: string, langOrIri?: string | TermIri): TermLiteral;\n    public termLiteral(loc: SourceLocation, value: string, langOrIri?: string | TermIri): TermLiteral {\n      return {\n        type: nodeType,\n        subType: 'literal',\n        value,\n        langOrIri,\n        loc,\n      };\n    }\n\n    public isTermLiteral(obj: object): obj is SubTyped<NodeType, 'literal'> {\n      return this.isOfSubType(obj, nodeType, 'literal');\n    }\n\n    public isTermLiteralLangStr(obj: object): obj is SubTyped<NodeType, 'literal'> & { langOrIri: string } {\n      return this.isTermLiteral(obj) && typeof (<{ langOrIri?: unknown }>obj).langOrIri === 'string';\n    }\n\n    public isTermLiteralStr(obj: object): obj is SubTyped<NodeType, 'literal'> & { langOrIri: undefined } {\n      return this.isTermLiteral(obj) && typeof (<{ langOrIri?: unknown }>obj).langOrIri === 'undefined';\n    }\n\n    public isTermLiteralTyped(obj: object):\n      obj is SubTyped<NodeType, 'literal'> & { langOrIri: SubTyped<NodeType, 'namedNode'> } {\n      const casted = <{ langOrIri?: unknown }>obj;\n      return this.isTermLiteral(obj) && typeof casted.langOrIri === 'object' &&\n        casted.langOrIri !== null && this.isTermNamed(casted.langOrIri);\n    }\n\n    public termVariable(value: string, loc: SourceLocation): TermVariable {\n      return {\n        type: nodeType,\n        subType: 'variable',\n        value,\n        loc,\n      };\n    }\n\n    public isTermVariable(obj: object): obj is SubTyped<NodeType, 'variable'> {\n      return this.isOfSubType(obj, nodeType, 'variable');\n    }\n\n    /**\n     * A namednode with fully defined with a uri.\n     */\n    public termNamed(loc: SourceLocation, value: string, prefix?: undefined): TermIriFull;\n    /**\n     * A namednode defined using a prefix\n     */\n    public termNamed(loc: SourceLocation, value: string, prefix: string): TermIriPrefixed;\n    public termNamed(loc: SourceLocation, value: string, prefix?: string): TermIriFull | TermIriPrefixed {\n      const base = <const>{\n        type: nodeType,\n        subType: 'namedNode',\n        value,\n        loc,\n      };\n      if (prefix === undefined) {\n        return base;\n      }\n      return { ...base, prefix };\n    }\n\n    public isTermNamed(obj: object): obj is SubTyped<NodeType, 'namedNode'> {\n      return this.isOfSubType(obj, nodeType, 'namedNode');\n    }\n\n    public isTermNamedPrefixed(obj: object): obj is SubTyped<NodeType, 'namedNode'> & { prefix: string } {\n      const casted = <{ prefix?: unknown }>obj;\n      return this.isTermNamed(obj) && typeof casted.prefix === 'string';\n    }\n  };\n}\n"]}