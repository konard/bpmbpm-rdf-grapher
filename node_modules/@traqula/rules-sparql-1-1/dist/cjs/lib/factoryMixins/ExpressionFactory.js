"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpressionFactoryMixin = ExpressionFactoryMixin;
const nodeType = 'expression';
// eslint-disable-next-line ts/explicit-function-return-type
function ExpressionFactoryMixin(Base) {
    return class ExpressionFactory extends Base {
        isExpressionPure(obj) {
            return this.isOfType(obj, nodeType);
        }
        formatOperator(operator) {
            return operator.toLowerCase().replaceAll(' ', '');
        }
        expressionOperation(operator, args, loc) {
            return {
                type: nodeType,
                subType: 'operation',
                operator: this.formatOperator(operator),
                args,
                loc,
            };
        }
        isExpressionOperator(obj) {
            return this.isOfSubType(obj, nodeType, 'operation');
        }
        expressionFunctionCall(functionOp, args, distinct, loc) {
            return {
                type: 'expression',
                subType: 'functionCall',
                function: functionOp,
                args,
                distinct,
                loc,
            };
        }
        isExpressionFunctionCall(obj) {
            return this.isOfSubType(obj, nodeType, 'functionCall');
        }
        expressionPatternOperation(operator, args, loc) {
            return {
                type: nodeType,
                subType: 'patternOperation',
                operator: this.formatOperator(operator),
                args,
                loc,
            };
        }
        isExpressionPatternOperation(obj) {
            return this.isOfSubType(obj, nodeType, 'patternOperation');
        }
        aggregate(aggregation, distinct, arg, separator, loc) {
            const base = {
                type: 'expression',
                subType: 'aggregate',
                aggregation: this.formatOperator(aggregation),
                distinct,
                loc,
            };
            if (this.isOfType(arg, 'wildcard')) {
                return { ...base, expression: [arg] };
            }
            if (separator === undefined) {
                return { ...base, expression: [arg] };
            }
            return { ...base, expression: [arg], separator };
        }
        isExpressionAggregate(obj) {
            return this.isOfSubType(obj, nodeType, 'aggregate');
        }
        isExpressionAggregateSeparator(obj) {
            return this.isOfSubType(obj, nodeType, 'aggregate') &&
                typeof obj.separator === 'string';
        }
        isExpressionAggregateOnWildcard(obj) {
            const casted = obj;
            return this.isOfSubType(obj, nodeType, 'aggregate') && Array.isArray(casted.expression) &&
                casted.expression.length === 1 && this.isOfType(casted.expression[0], 'wildcard');
        }
        isExpressionAggregateDefault(obj) {
            const casted = obj;
            return this.isOfSubType(obj, nodeType, 'operation') && Array.isArray(casted.expression) &&
                casted.expression.length === 1 && !this.isOfType(casted.expression[0], 'wildcard');
        }
    };
}
//# sourceMappingURL=ExpressionFactory.js.map