{"version":3,"file":"ExpressionFactory.js","sourceRoot":"","sources":["../../../../lib/factoryMixins/ExpressionFactory.ts"],"names":[],"mappings":";;AAoBA,wDA6IC;AAhJD,MAAM,QAAQ,GAAa,YAAY,CAAC;AAExC,4DAA4D;AAC5D,SAAgB,sBAAsB,CAA4C,IAAW;IAC3F,OAAO,MAAM,iBAAkB,SAAQ,IAAI;QAClC,gBAAgB,CAAC,GAAW;YACjC,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;QACtC,CAAC;QAEM,cAAc,CAAC,QAAgB;YACpC,OAAO,QAAQ,CAAC,WAAW,EAAE,CAAC,UAAU,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;QACpD,CAAC;QAEM,mBAAmB,CACxB,QAAgB,EAChB,IAAU,EACV,GAAmB;YAEnB,OAAO;gBACL,IAAI,EAAE,QAAQ;gBACd,OAAO,EAAE,WAAW;gBACpB,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC;gBACvC,IAAI;gBACJ,GAAG;aACJ,CAAC;QACJ,CAAC;QAEM,oBAAoB,CAAC,GAAW;YACrC,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,QAAQ,EAAE,WAAW,CAAC,CAAC;QACtD,CAAC;QAEM,sBAAsB,CAC3B,UAAmB,EACnB,IAAU,EACV,QAAiB,EACjB,GAAmB;YAEnB,OAAO;gBACL,IAAI,EAAE,YAAY;gBAClB,OAAO,EAAE,cAAc;gBACvB,QAAQ,EAAE,UAAU;gBACpB,IAAI;gBACJ,QAAQ;gBACR,GAAG;aACJ,CAAC;QACJ,CAAC;QAEM,wBAAwB,CAAC,GAAW;YACzC,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,QAAQ,EAAE,cAAc,CAAC,CAAC;QACzD,CAAC;QAEM,0BAA0B,CAC/B,QAAgB,EAChB,IAAkB,EAClB,GAAmB;YAEnB,OAAO;gBACL,IAAI,EAAE,QAAQ;gBACd,OAAO,EAAE,kBAAkB;gBAC3B,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC;gBACvC,IAAI;gBACJ,GAAG;aACJ,CAAC;QACJ,CAAC;QAEM,4BAA4B,CAAC,GAAW;YAC7C,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,QAAQ,EAAE,kBAAkB,CAAC,CAAC;QAC7D,CAAC;QA8BM,SAAS,CACd,WAAmB,EACnB,QAAiB,EACjB,GAA0B,EAC1B,SAA6B,EAC7B,GAAmB;YAEnB,MAAM,IAAI,GAAW;gBACnB,IAAI,EAAE,YAAY;gBAClB,OAAO,EAAE,WAAW;gBACpB,WAAW,EAAE,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC;gBAC7C,QAAQ;gBACR,GAAG;aACJ,CAAC;YACF,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,UAAU,CAAC,EAAE,CAAC;gBACnC,OAAO,EAAE,GAAG,IAAI,EAAE,UAAU,EAAE,CAAE,GAAG,CAAE,EAAyC,CAAC;YACjF,CAAC;YACD,IAAI,SAAS,KAAK,SAAS,EAAE,CAAC;gBAC5B,OAAO,EAAE,GAAG,IAAI,EAAE,UAAU,EAAE,CAAE,GAAG,CAAE,EAAsC,CAAC;YAC9E,CAAC;YACD,OAAO,EAAE,GAAG,IAAI,EAAE,UAAU,EAAE,CAAE,GAAG,CAAE,EAAE,SAAS,EAAyC,CAAC;QAC5F,CAAC;QAEM,qBAAqB,CAAC,GAAW;YACtC,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,QAAQ,EAAE,WAAW,CAAC,CAAC;QACtD,CAAC;QAEM,8BAA8B,CAAC,GAAW;YAC/C,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,QAAQ,EAAE,WAAW,CAAC;gBACjD,OAAkC,GAAI,CAAC,SAAS,KAAK,QAAQ,CAAC;QAClE,CAAC;QAEM,+BAA+B,CAAC,GAAW;YAEhD,MAAM,MAAM,GAA8B,GAAG,CAAC;YAC9C,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,QAAQ,EAAE,WAAW,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC;gBACrF,MAAM,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;QACtF,CAAC;QAEM,4BAA4B,CAAC,GAAW;YAE7C,MAAM,MAAM,GAA8B,GAAG,CAAC;YAE9C,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,QAAQ,EAAE,WAAW,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC;gBACrF,MAAM,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;QACvF,CAAC;KACF,CAAC;AACJ,CAAC","sourcesContent":["import type { AstCoreFactory, SourceLocation, Typed, SubTyped } from '@traqula/core';\nimport type {\n  Expression,\n  ExpressionAggregate,\n  ExpressionAggregateDefault,\n  ExpressionAggregateOnWildcard,\n  ExpressionAggregateSeparator,\n  ExpressionFunctionCall,\n  ExpressionOperation,\n  ExpressionPatternOperation,\n  PatternGroup,\n  TermIri,\n  Wildcard,\n} from '../Sparql11types.js';\nimport type { Constructor } from './mixins.js';\n\ntype NodeType = 'expression';\nconst nodeType: NodeType = 'expression';\n\n// eslint-disable-next-line ts/explicit-function-return-type\nexport function ExpressionFactoryMixin<TBase extends Constructor<AstCoreFactory>>(Base: TBase) {\n  return class ExpressionFactory extends Base {\n    public isExpressionPure(obj: object): obj is Typed<NodeType> {\n      return this.isOfType(obj, nodeType);\n    }\n\n    public formatOperator(operator: string): string {\n      return operator.toLowerCase().replaceAll(' ', '');\n    }\n\n    public expressionOperation<Args extends Expression[]>(\n      operator: string,\n      args: Args,\n      loc: SourceLocation,\n    ): ExpressionOperation & { args: Args } {\n      return {\n        type: nodeType,\n        subType: 'operation',\n        operator: this.formatOperator(operator),\n        args,\n        loc,\n      };\n    }\n\n    public isExpressionOperator(obj: object): obj is SubTyped<NodeType, 'operation'> {\n      return this.isOfSubType(obj, nodeType, 'operation');\n    }\n\n    public expressionFunctionCall<Args extends Expression[]>(\n      functionOp: TermIri,\n      args: Args,\n      distinct: boolean,\n      loc: SourceLocation,\n    ): ExpressionFunctionCall & { args: Args } {\n      return {\n        type: 'expression',\n        subType: 'functionCall',\n        function: functionOp,\n        args,\n        distinct,\n        loc,\n      };\n    }\n\n    public isExpressionFunctionCall(obj: object): obj is SubTyped<NodeType, 'functionCall'> {\n      return this.isOfSubType(obj, nodeType, 'functionCall');\n    }\n\n    public expressionPatternOperation(\n      operator: string,\n      args: PatternGroup,\n      loc: SourceLocation,\n    ): ExpressionPatternOperation {\n      return {\n        type: nodeType,\n        subType: 'patternOperation',\n        operator: this.formatOperator(operator),\n        args,\n        loc,\n      };\n    }\n\n    public isExpressionPatternOperation(obj: object): obj is SubTyped<NodeType, 'patternOperation'> {\n      return this.isOfSubType(obj, nodeType, 'patternOperation');\n    }\n\n    public aggregate(\n      aggregation: string,\n      distinct: boolean,\n      arg: Expression,\n      separator: undefined,\n      loc: SourceLocation\n    ): ExpressionAggregateDefault;\n    public aggregate(\n      aggregation: string,\n      distinct: boolean,\n      arg: Wildcard,\n      separator: undefined,\n      loc: SourceLocation\n    ): ExpressionAggregateOnWildcard;\n    public aggregate(\n      aggregation: string,\n      distinct: boolean,\n      arg: Expression,\n      separator: string,\n      loc: SourceLocation\n    ): ExpressionAggregateSeparator;\n    public aggregate(\n      aggregation: string,\n      distinct: boolean,\n      arg: Expression | Wildcard,\n      separator: string | undefined,\n      loc: SourceLocation,\n    ): ExpressionAggregate;\n    public aggregate(\n      aggregation: string,\n      distinct: boolean,\n      arg: Expression | Wildcard,\n      separator: string | undefined,\n      loc: SourceLocation,\n    ): ExpressionAggregate {\n      const base = <const> {\n        type: 'expression',\n        subType: 'aggregate',\n        aggregation: this.formatOperator(aggregation),\n        distinct,\n        loc,\n      };\n      if (this.isOfType(arg, 'wildcard')) {\n        return { ...base, expression: [ arg ]} satisfies ExpressionAggregateOnWildcard;\n      }\n      if (separator === undefined) {\n        return { ...base, expression: [ arg ]} satisfies ExpressionAggregateDefault;\n      }\n      return { ...base, expression: [ arg ], separator } satisfies ExpressionAggregateSeparator;\n    }\n\n    public isExpressionAggregate(obj: object): obj is SubTyped<NodeType, 'aggregate'> {\n      return this.isOfSubType(obj, nodeType, 'aggregate');\n    }\n\n    public isExpressionAggregateSeparator(obj: object): obj is SubTyped<NodeType, 'aggregate'> & { separator: string } {\n      return this.isOfSubType(obj, nodeType, 'aggregate') &&\n        typeof (<{ separator?: unknown }> obj).separator === 'string';\n    }\n\n    public isExpressionAggregateOnWildcard(obj: object):\n      obj is SubTyped<NodeType, 'aggregate'> & { expression: [Typed<'wildcard'>]} {\n      const casted = <{ expression?: unknown }> obj;\n      return this.isOfSubType(obj, nodeType, 'aggregate') && Array.isArray(casted.expression) &&\n        casted.expression.length === 1 && this.isOfType(casted.expression[0], 'wildcard');\n    }\n\n    public isExpressionAggregateDefault(obj: object):\n      obj is SubTyped<NodeType, 'aggregate'> & { expression: [Expression]} {\n      const casted = <{ expression?: unknown }> obj;\n\n      return this.isOfSubType(obj, nodeType, 'operation') && Array.isArray(casted.expression) &&\n        casted.expression.length === 1 && !this.isOfType(casted.expression[0], 'wildcard');\n    }\n  };\n}\n"]}