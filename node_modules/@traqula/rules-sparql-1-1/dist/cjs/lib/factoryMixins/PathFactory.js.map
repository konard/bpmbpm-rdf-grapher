{"version":3,"file":"PathFactory.js","sourceRoot":"","sources":["../../../../lib/factoryMixins/PathFactory.ts"],"names":[],"mappings":"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","sourcesContent":["import type { AstCoreFactory, SourceLocation, Typed, SubTyped } from '@traqula/core';\nimport type {\n  Path,\n  PathAlternativeLimited,\n  PathModified,\n  PathNegated,\n  PathNegatedElt,\n  PropertyPathChain,\n  TermIri,\n} from '../Sparql11types.js';\nimport type { Constructor } from './mixins.js';\n\ntype NodeType = 'path';\nconst nodeType: NodeType = 'path';\n\ntype RawNegatedElt = SubTyped<NodeType, '^'> & { items: [SubTyped<'term', 'namedNode'>]};\n\n// eslint-disable-next-line ts/explicit-function-return-type\nexport function PathFactoryMixin<TBase extends Constructor<AstCoreFactory>>(Base: TBase) {\n  return class PathFactory extends Base {\n    public isPathPure(obj: object): obj is Typed<NodeType> {\n      return this.isOfType(obj, nodeType);\n    }\n\n    public path(\n      subType: '|',\n      items: (TermIri | PathNegatedElt)[],\n      loc: SourceLocation\n    ): PathAlternativeLimited;\n    public path(\n      subType: '!',\n      items: [TermIri | PathNegatedElt | PathAlternativeLimited],\n      loc: SourceLocation\n    ): PathNegated;\n    public path(subType: '^', items: [TermIri], loc: SourceLocation): PathNegatedElt;\n    public path(subType: PathModified['subType'], item: [Path], loc: SourceLocation): PathModified;\n    public path(subType: '|' | '/', items: Path[], loc: SourceLocation):\n    PropertyPathChain;\n    public path(\n      subType: (PropertyPathChain | PathModified | PathNegated)['subType'],\n      items: Path[],\n      loc: SourceLocation,\n    ): Path {\n      const base = <const>{\n        type: nodeType,\n        loc,\n        items,\n      };\n      if (subType === '|' || subType === '/') {\n        return {\n          ...base,\n          subType,\n        } satisfies PropertyPathChain;\n      }\n      if ((subType === '?' || subType === '*' || subType === '+' || subType === '^') && items.length === 1) {\n        return {\n          ...base,\n          subType,\n          items: <[Path]>items,\n        } satisfies PathModified;\n      }\n      if (subType === '^' && items.length === 1 && !this.isPathPure(items[0])) {\n        return {\n          ...base,\n          subType,\n          items: <[TermIri]>items,\n        } satisfies PathNegatedElt;\n      }\n      if (subType === '!' && items.length === 1 && (\n        this.isPathAlternativeLimited(items[0]) || !this.isPathPure(items[0]) || this.isPathNegatedElt(items[0]))) {\n        return {\n          ...base,\n          subType,\n          items: <[TermIri | PathNegatedElt | PathAlternativeLimited]>items,\n        } satisfies PathNegated;\n      }\n      throw new Error('Invalid path type');\n    }\n\n    public isPathOfType<T extends U[], U extends string>(obj: object, subTypes: T): obj is SubTyped<NodeType, U> {\n      return this.isOfType(obj, nodeType) && subTypes.includes(<any>(<{ subType?: unknown }>obj).subType);\n    }\n\n    public isPathChain(obj: object): obj is SubTyped<NodeType, '|' | '/'> {\n      return this.isOfSubType(obj, nodeType, '/') || this.isOfSubType(obj, nodeType, '|');\n    }\n\n    public isPathModified(obj: object): obj is SubTyped<NodeType, '?' | '*' | '+' | '^'> {\n      return this.isOfSubType(obj, nodeType, '?') || this.isOfSubType(obj, nodeType, '*') ||\n        this.isOfSubType(obj, nodeType, '+') || this.isOfSubType(obj, nodeType, '^');\n    }\n\n    public isPathNegatedElt(obj: object): obj is RawNegatedElt {\n      const casted: { items?: unknown } = obj;\n      return this.isOfSubType(obj, nodeType, '^') && Array.isArray(casted.items) && casted.items.length === 1 &&\n        typeof casted.items[0] === 'object' && (casted.items[0] ?? false) && !this.isPathPure(casted.items[0]);\n    }\n\n    public isPathNegated(obj: object): obj is SubTyped<NodeType, '!'> {\n      return this.isOfSubType(obj, nodeType, '!');\n    }\n\n    public isPathAlternativeLimited(obj: object):\n      obj is SubTyped<NodeType, '|'> & { items: (SubTyped<'term', 'namedNode'> | RawNegatedElt)[] } {\n      const casted: { items?: unknown } = obj;\n      return this.isOfSubType(obj, nodeType, '|') && Array.isArray(casted.items) &&\n        casted.items.every(item => !this.isPathPure(item) || this.isPathNegatedElt(item));\n    }\n  };\n}\n"]}