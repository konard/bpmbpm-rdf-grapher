"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.verbA = exports.blankNode = exports.canCreateBlankNodes = exports.prefixedName = exports.iriFull = exports.iri = exports.string = exports.booleanLiteral = exports.numericLiteralNegative = exports.numericLiteralPositive = exports.numericLiteralUnsigned = exports.numericLiteral = exports.rdfLiteral = void 0;
exports.stringEscapedLexical = stringEscapedLexical;
const l = __importStar(require("../lexer/index.js"));
const utils_js_1 = require("../utils.js");
function stringEscapedLexical(str) {
    const lexical = str.replaceAll(/["\\\t\n\r\b\f]/gu, (char) => {
        switch (char) {
            case '\t':
                return '\\t';
            case '\n':
                return '\\n';
            case '\r':
                return '\\r';
            case '\b':
                return '\\b';
            case '\f':
                return '\\f';
            case '"':
                return '\\"';
            case '\\':
                return '\\\\';
            default:
                return char;
        }
    });
    return `"${lexical}"`;
}
/**
 * [[120]](https://www.w3.org/TR/sparql11-query/#rRDFLiteral)
 */
exports.rdfLiteral = {
    name: 'rdfLiteral',
    impl: ({ ACTION, SUBRULE1, CONSUME, OPTION, OR }) => (C) => {
        const value = SUBRULE1(exports.string);
        return OPTION(() => OR([
            { ALT: () => {
                    const lang = CONSUME(l.terminals.langTag);
                    return ACTION(() => C.astFactory.termLiteral(C.astFactory.sourceLocation(value, lang), value.value, lang.image.slice(1).toLowerCase()));
                } },
            { ALT: () => {
                    CONSUME(l.symbols.hathat);
                    const iriVal = SUBRULE1(exports.iri);
                    return ACTION(() => C.astFactory.termLiteral(C.astFactory.sourceLocation(value, iriVal), value.value, iriVal));
                } },
        ])) ?? value;
    },
    gImpl: ({ SUBRULE, PRINT, PRINT_WORD }) => (ast, { astFactory }) => {
        if (!ast.langOrIri || typeof ast.langOrIri === 'string') {
            // String or langdir string - no sub loc.
            astFactory.printFilter(ast, () => {
                PRINT_WORD('');
                PRINT(stringEscapedLexical(ast.value));
            });
            if (typeof ast.langOrIri === 'string') {
                astFactory.printFilter(ast, () => PRINT('@', ast.langOrIri));
            }
        }
        else if (astFactory.isSourceLocationNoMaterialize(ast.langOrIri.loc)) {
            // You have a typed literal. -- If type is not materialized, print raw
            astFactory.printFilter(ast, () => {
                PRINT_WORD(ast.value);
            });
        }
        else {
            astFactory.printFilter(ast, () => {
                PRINT_WORD('');
                PRINT(stringEscapedLexical(ast.value), '^^');
            });
            SUBRULE(exports.iri, ast.langOrIri);
        }
    },
};
/**
 * Parses a numeric literal.
 * [[130]](https://www.w3.org/TR/sparql11-query/#rNumericLiteral)
 */
exports.numericLiteral = {
    name: 'numericLiteral',
    impl: ({ SUBRULE, OR }) => () => OR([
        { ALT: () => SUBRULE(exports.numericLiteralUnsigned) },
        { ALT: () => SUBRULE(exports.numericLiteralPositive) },
        { ALT: () => SUBRULE(exports.numericLiteralNegative) },
    ]),
};
/**
 * Parses an unsigned numeric literal.
 * [[131]](https://www.w3.org/TR/sparql11-query/#rNumericLiteralUnsigned)
 */
exports.numericLiteralUnsigned = {
    name: 'numericLiteralUnsigned',
    impl: ({ ACTION, CONSUME, OR }) => (C) => {
        const parsed = OR([
            { ALT: () => [CONSUME(l.terminals.integer), utils_js_1.CommonIRIs.INTEGER] },
            { ALT: () => [CONSUME(l.terminals.decimal), utils_js_1.CommonIRIs.DECIMAL] },
            { ALT: () => [CONSUME(l.terminals.double), utils_js_1.CommonIRIs.DOUBLE] },
        ]);
        return ACTION(() => C.astFactory.termLiteral(C.astFactory.sourceLocation(parsed[0]), parsed[0].image, C.astFactory.termNamed(C.astFactory.sourceLocation(), parsed[1])));
    },
};
/**
 * Parses a positive numeric literal.
 * [[132]](https://www.w3.org/TR/sparql11-query/#rNumericLiteralPositive)
 */
exports.numericLiteralPositive = {
    name: 'numericLiteralPositive',
    impl: ({ ACTION, CONSUME, OR }) => (C) => {
        const parsed = OR([
            { ALT: () => [CONSUME(l.terminals.integerPositive), utils_js_1.CommonIRIs.INTEGER] },
            { ALT: () => [CONSUME(l.terminals.decimalPositive), utils_js_1.CommonIRIs.DECIMAL] },
            { ALT: () => [CONSUME(l.terminals.doublePositive), utils_js_1.CommonIRIs.DOUBLE] },
        ]);
        return ACTION(() => C.astFactory.termLiteral(C.astFactory.sourceLocation(parsed[0]), parsed[0].image, C.astFactory.termNamed(C.astFactory.sourceLocation(), parsed[1])));
    },
};
/**
 * Parses a negative numeric literal.
 * [[133]](https://www.w3.org/TR/sparql11-query/#rNumericLiteralNegative)
 */
exports.numericLiteralNegative = {
    name: 'numericLiteralNegative',
    impl: ({ ACTION, CONSUME, OR }) => (C) => {
        const parsed = OR([
            { ALT: () => [CONSUME(l.terminals.integerNegative), utils_js_1.CommonIRIs.INTEGER] },
            { ALT: () => [CONSUME(l.terminals.decimalNegative), utils_js_1.CommonIRIs.DECIMAL] },
            { ALT: () => [CONSUME(l.terminals.doubleNegative), utils_js_1.CommonIRIs.DOUBLE] },
        ]);
        return ACTION(() => C.astFactory.termLiteral(C.astFactory.sourceLocation(parsed[0]), parsed[0].image, C.astFactory.termNamed(C.astFactory.sourceLocation(), parsed[1])));
    },
};
/**
 * Parses a boolean literal.
 * [[134]](https://www.w3.org/TR/sparql11-query/#rBooleanLiteral)
 */
exports.booleanLiteral = {
    name: 'booleanLiteral',
    impl: ({ ACTION, CONSUME, OR }) => (C) => {
        const token = OR([
            { ALT: () => CONSUME(l.true_) },
            { ALT: () => CONSUME(l.false_) },
        ]);
        return ACTION(() => C.astFactory.termLiteral(C.astFactory.sourceLocation(token), token.image.toLowerCase(), C.astFactory.termNamed(C.astFactory.sourceLocation(), utils_js_1.CommonIRIs.BOOLEAN)));
    },
};
/**
 * Parses a string literal.
 * [[135]](https://www.w3.org/TR/sparql11-query/#rString)
 */
exports.string = {
    name: 'string',
    impl: ({ ACTION, CONSUME, OR }) => (C) => {
        const x = OR([
            { ALT: () => {
                    const token = CONSUME(l.terminals.stringLiteral1);
                    return [token, token.image.slice(1, -1)];
                } },
            { ALT: () => {
                    const token = CONSUME(l.terminals.stringLiteral2);
                    return [token, token.image.slice(1, -1)];
                } },
            { ALT: () => {
                    const token = CONSUME(l.terminals.stringLiteralLong1);
                    return [token, token.image.slice(3, -3)];
                } },
            { ALT: () => {
                    const token = CONSUME(l.terminals.stringLiteralLong2);
                    return [token, token.image.slice(3, -3)];
                } },
        ]);
        // Handle string escapes (19.7). (19.2 is handled at input level.)
        return ACTION(() => {
            const F = C.astFactory;
            const value = x[1].replaceAll(/\\([tnrbf"'\\])/gu, (_, char) => {
                switch (char) {
                    case 't':
                        return '\t';
                    case 'n':
                        return '\n';
                    case 'r':
                        return '\r';
                    case 'b':
                        return '\b';
                    case 'f':
                        return '\f';
                    default:
                        return char;
                }
            });
            return F.termLiteral(F.sourceLocation(x[0]), value);
        });
    },
};
/**
 * Parses a named node, either as an IRI or as a prefixed name.
 * [[136]](https://www.w3.org/TR/sparql11-query/#riri)
 */
exports.iri = {
    name: 'iri',
    impl: ({ SUBRULE, OR }) => () => OR([
        { ALT: () => SUBRULE(exports.iriFull) },
        { ALT: () => SUBRULE(exports.prefixedName) },
    ]),
    gImpl: ({ SUBRULE }) => (ast, { astFactory: F }) => F.isTermNamedPrefixed(ast) ? SUBRULE(exports.prefixedName, ast) : SUBRULE(exports.iriFull, ast),
};
exports.iriFull = {
    name: 'iriFull',
    impl: ({ ACTION, CONSUME }) => (C) => {
        const iriToken = CONSUME(l.terminals.iriRef);
        return ACTION(() => C.astFactory.termNamed(C.astFactory.sourceLocation(iriToken), iriToken.image.slice(1, -1)));
    },
    gImpl: ({ PRINT }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => PRINT('<', ast.value, '>'));
    },
};
/**
 * Parses a named node with a prefix. Looks up the prefix in the context and returns the full IRI.
 * [[137]](https://www.w3.org/TR/sparql11-query/#rPrefixedName)
 */
exports.prefixedName = {
    name: 'prefixedName',
    impl: ({ ACTION, CONSUME, OR }) => (C) => {
        function verifyPrefix(prefix) {
            if (!C.skipValidation && C.prefixes[prefix] === undefined) {
                throw new Error(`Unknown prefix: ${prefix}`);
            }
        }
        return OR([{ ALT: () => {
                    const longName = CONSUME(l.terminals.pNameLn);
                    return ACTION(() => {
                        const [prefix, localName] = longName.image.split(':');
                        verifyPrefix(prefix);
                        return C.astFactory.termNamed(C.astFactory.sourceLocation(longName), localName, prefix);
                    });
                },
            }, { ALT: () => {
                    const shortName = CONSUME(l.terminals.pNameNs);
                    return ACTION(() => {
                        const prefix = shortName.image.slice(0, -1);
                        verifyPrefix(prefix);
                        return C.astFactory.termNamed(C.astFactory.sourceLocation(shortName), '', prefix);
                    });
                },
            }]);
    },
    gImpl: ({ PRINT }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => PRINT(ast.prefix, ':', ast.value));
    },
};
exports.canCreateBlankNodes = Symbol('canCreateBlankNodes');
/**
 * Parses blank note and throws an error if 'canCreateBlankNodes' is not in the current parserMode.
 * [[138]](https://www.w3.org/TR/sparql11-query/#rBlankNode)
 */
exports.blankNode = {
    name: 'blankNode',
    impl: ({ ACTION, CONSUME, OR }) => (C) => {
        const result = OR([
            { ALT: () => {
                    const labelToken = CONSUME(l.terminals.blankNodeLabel);
                    return ACTION(() => C.astFactory.termBlank(labelToken.image.slice(2), C.astFactory.sourceLocation(labelToken)));
                } },
            { ALT: () => {
                    const anonToken = CONSUME(l.terminals.anon);
                    return ACTION(() => C.astFactory.termBlank(undefined, C.astFactory.sourceLocation(anonToken)));
                } },
        ]);
        ACTION(() => {
            if (!C.parseMode.has('canCreateBlankNodes')) {
                throw new Error('Blank nodes are not allowed in this context');
            }
        });
        return result;
    },
    gImpl: ({ PRINT }) => (ast, { astFactory }) => {
        astFactory.printFilter(ast, () => PRINT('_:', ast.label.replace(/^e_/u, '')));
    },
};
exports.verbA = {
    name: 'VerbA',
    impl: ({ ACTION, CONSUME }) => (C) => {
        const token = CONSUME(l.a);
        return ACTION(() => C.astFactory.termNamed(C.astFactory.sourceLocation(token), utils_js_1.CommonIRIs.TYPE, undefined));
    },
};
//# sourceMappingURL=literals.js.map