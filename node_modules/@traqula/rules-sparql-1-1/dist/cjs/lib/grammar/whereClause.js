"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.functionCall = exports.constraint = exports.filter = exports.groupOrUnionGraphPattern = exports.minusGraphPattern = exports.dataBlockValue = exports.inlineDataFull = exports.inlineDataOneVar = exports.dataBlock = exports.inlineData = exports.bind = exports.serviceGraphPattern = exports.graphGraphPattern = exports.optionalGraphPattern = exports.graphPatternNotTriples = exports.groupGraphPatternSub = exports.generatePattern = exports.groupGraphPattern = exports.whereClause = void 0;
const core_1 = require("@traqula/core");
const l = __importStar(require("../lexer/index.js"));
const validators_js_1 = require("../validation/validators.js");
const builtIn_js_1 = require("./builtIn.js");
const expression_js_1 = require("./expression.js");
const general_js_1 = require("./general.js");
const literals_js_1 = require("./literals.js");
const queryUnit_js_1 = require("./queryUnit.js");
const tripleBlock_js_1 = require("./tripleBlock.js");
/**
 * [[17]](https://www.w3.org/TR/sparql11-query/#rWhereClause)
 */
exports.whereClause = {
    name: 'whereClause',
    impl: ({ ACTION, SUBRULE, CONSUME, OPTION }) => (C) => {
        const where = OPTION(() => CONSUME(l.where));
        const group = SUBRULE(exports.groupGraphPattern);
        return ACTION(() => C.astFactory.wrap(group, C.astFactory.sourceLocation(where, group)));
    },
    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => PRINT_WORD('WHERE'));
        SUBRULE(exports.groupGraphPattern, ast.val);
    },
};
/**
 * [[53]](https://www.w3.org/TR/sparql11-query/#rGroupGraphPattern)
 */
exports.groupGraphPattern = {
    name: 'groupGraphPattern',
    impl: ({ ACTION, SUBRULE, CONSUME, OR }) => (C) => {
        const open = CONSUME(l.symbols.LCurly);
        const patterns = OR([
            { ALT: () => [SUBRULE(queryUnit_js_1.subSelect)] },
            { ALT: () => SUBRULE(exports.groupGraphPatternSub) },
        ]);
        const close = CONSUME(l.symbols.RCurly);
        return ACTION(() => C.astFactory.patternGroup(patterns, C.astFactory.sourceLocation(open, close)));
    },
    gImpl: ({ SUBRULE, PRINT_WORD, NEW_LINE, PRINT_ON_OWN_LINE }) => (ast, C) => {
        const { astFactory: F, indentInc } = C;
        F.printFilter(ast, () => {
            C[core_1.traqulaIndentation] += indentInc;
            PRINT_WORD('{');
            NEW_LINE();
        });
        for (const pattern of ast.patterns) {
            SUBRULE(exports.generatePattern, pattern);
        }
        F.printFilter(ast, () => {
            C[core_1.traqulaIndentation] -= indentInc;
            PRINT_ON_OWN_LINE('}');
        });
    },
};
exports.generatePattern = {
    name: 'generatePattern',
    gImpl: ({ SUBRULE }) => (ast, { astFactory: F }) => {
        if (ast.type === 'query') {
            SUBRULE(queryUnit_js_1.query, F.querySelect({
                context: [],
                datasets: F.datasetClauses([], F.sourceLocation()),
                where: ast.where,
                variables: ast.variables,
                solutionModifiers: ast.solutionModifiers,
                values: ast.values,
                distinct: ast.distinct,
                reduced: ast.reduced,
            }, ast.loc));
        }
        else if (ast.subType === 'group') {
            SUBRULE(exports.groupGraphPattern, ast);
        }
        else if (ast.subType === 'bgp') {
            SUBRULE(tripleBlock_js_1.triplesBlock, ast);
        }
        else {
            SUBRULE(exports.graphPatternNotTriples, ast);
        }
    },
};
/**
 * [[54]](https://www.w3.org/TR/sparql11-query/#rGroupGraphPatternSub)
 */
exports.groupGraphPatternSub = {
    name: 'groupGraphPatternSub',
    impl: ({ ACTION, SUBRULE, CONSUME, MANY, SUBRULE1, SUBRULE2, OPTION1, OPTION2, OPTION3 }) => (C) => {
        const patterns = [];
        const bgpPattern = OPTION1(() => SUBRULE1(tripleBlock_js_1.triplesBlock));
        if (bgpPattern) {
            patterns.push(bgpPattern);
        }
        MANY(() => {
            const notTriples = SUBRULE(exports.graphPatternNotTriples);
            patterns.push(notTriples);
            OPTION2(() => CONSUME(l.symbols.dot));
            const moreTriples = OPTION3(() => SUBRULE2(tripleBlock_js_1.triplesBlock));
            if (moreTriples) {
                patterns.push(moreTriples);
            }
        });
        ACTION(() => !C.skipValidation && (0, validators_js_1.checkNote13)(patterns));
        return patterns;
    },
};
/**
 * [[56]](https://www.w3.org/TR/sparql11-query/#rGraphPatternNotTriples)
 */
exports.graphPatternNotTriples = {
    name: 'graphPatternNotTriples',
    impl: ({ SUBRULE, OR }) => () => OR([
        { ALT: () => SUBRULE(exports.groupOrUnionGraphPattern) },
        { ALT: () => SUBRULE(exports.optionalGraphPattern) },
        { ALT: () => SUBRULE(exports.minusGraphPattern) },
        { ALT: () => SUBRULE(exports.graphGraphPattern) },
        { ALT: () => SUBRULE(exports.serviceGraphPattern) },
        { ALT: () => SUBRULE(exports.filter) },
        { ALT: () => SUBRULE(exports.bind) },
        { ALT: () => SUBRULE(exports.inlineData) },
    ]),
    gImpl: ({ SUBRULE }) => (ast) => {
        switch (ast.subType) {
            case 'group':
            case 'union':
                SUBRULE(exports.groupOrUnionGraphPattern, ast);
                break;
            case 'optional':
                SUBRULE(exports.optionalGraphPattern, ast);
                break;
            case 'minus':
                SUBRULE(exports.minusGraphPattern, ast);
                break;
            case 'graph':
                SUBRULE(exports.graphGraphPattern, ast);
                break;
            case 'service':
                SUBRULE(exports.serviceGraphPattern, ast);
                break;
            case 'filter':
                SUBRULE(exports.filter, ast);
                break;
            case 'bind':
                SUBRULE(exports.bind, ast);
                break;
            case 'values':
                SUBRULE(exports.inlineData, ast);
                break;
        }
    },
};
/**
 * [[57]](https://www.w3.org/TR/sparql11-query/#rOptionalGraphPattern)
 */
exports.optionalGraphPattern = {
    name: 'optionalGraphPattern',
    impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
        const optional = CONSUME(l.optional);
        const group = SUBRULE(exports.groupGraphPattern);
        return ACTION(() => C.astFactory.patternOptional(group.patterns, C.astFactory.sourceLocation(optional, group)));
    },
    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => PRINT_WORD('OPTIONAL'));
        SUBRULE(exports.groupGraphPattern, F.patternGroup(ast.patterns, ast.loc));
    },
};
/**
 * [[58]](https://www.w3.org/TR/sparql11-query/#rGraphGraphPattern)
 */
exports.graphGraphPattern = {
    name: 'graphGraphPattern',
    impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
        const graph = CONSUME(l.graph.graph);
        const name = SUBRULE(general_js_1.varOrIri);
        const group = SUBRULE(exports.groupGraphPattern);
        return ACTION(() => C.astFactory.patternGraph(name, group.patterns, C.astFactory.sourceLocation(graph, group)));
    },
    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => PRINT_WORD('GRAPH'));
        SUBRULE(general_js_1.varOrTerm, ast.name);
        SUBRULE(exports.groupGraphPattern, F.patternGroup(ast.patterns, ast.loc));
    },
};
/**
 * [[59]](https://www.w3.org/TR/sparql11-query/#rServiceGraphPattern)
 */
exports.serviceGraphPattern = {
    name: 'serviceGraphPattern',
    impl: ({ ACTION, SUBRULE1, CONSUME, OPTION }) => (C) => {
        const service = CONSUME(l.service);
        const silent = OPTION(() => {
            CONSUME(l.silent);
            return true;
        }) ?? false;
        const name = SUBRULE1(general_js_1.varOrIri);
        const group = SUBRULE1(exports.groupGraphPattern);
        return ACTION(() => C.astFactory.patternService(name, group.patterns, silent, C.astFactory.sourceLocation(service, group)));
    },
    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => {
            PRINT_WORD('SERVICE');
            if (ast.silent) {
                PRINT_WORD('SILENT');
            }
        });
        SUBRULE(general_js_1.varOrTerm, ast.name);
        SUBRULE(exports.groupGraphPattern, F.patternGroup(ast.patterns, ast.loc));
    },
};
/**
 * [[60]](https://www.w3.org/TR/sparql11-query/#rBind)
 */
exports.bind = {
    name: 'bind',
    impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
        const bind = CONSUME(l.bind);
        CONSUME(l.symbols.LParen);
        const expressionVal = SUBRULE(expression_js_1.expression);
        CONSUME(l.as);
        const variable = SUBRULE(general_js_1.var_);
        const close = CONSUME(l.symbols.RParen);
        return ACTION(() => C.astFactory.patternBind(expressionVal, variable, C.astFactory.sourceLocation(bind, close)));
    },
    gImpl: ({ SUBRULE, PRINT_WORD, NEW_LINE }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => PRINT_WORD('BIND', '('));
        SUBRULE(expression_js_1.expression, ast.expression);
        F.printFilter(ast, () => PRINT_WORD('AS'));
        SUBRULE(general_js_1.var_, ast.variable);
        F.printFilter(ast, () => {
            PRINT_WORD(')');
            NEW_LINE();
        });
    },
};
/**
 * [[61]](https://www.w3.org/TR/sparql11-query/#rInlineData)
 */
exports.inlineData = {
    name: 'inlineData',
    impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
        const values = CONSUME(l.values);
        const datablock = SUBRULE(exports.dataBlock);
        return ACTION(() => {
            datablock.loc = C.astFactory.sourceLocation(values, datablock);
            return datablock;
        });
    },
    gImpl: ({ SUBRULE, PRINT_WORD, PRINT_ON_EMPTY, NEW_LINE, PRINT_ON_OWN_LINE }) => (ast, C) => {
        const { astFactory: F, indentInc } = C;
        const variables = ast.variables;
        const singleVar = variables.length === 1;
        F.printFilter(ast, () => {
            PRINT_ON_EMPTY('VALUES', singleVar ? '' : '( ');
        });
        for (const variable of variables) {
            F.printFilter(ast, () => PRINT_WORD(''));
            SUBRULE(general_js_1.varOrTerm, variable);
            F.printFilter(ast, () => PRINT_WORD(''));
        }
        F.printFilter(ast, () => {
            C[core_1.traqulaIndentation] += indentInc;
            PRINT_WORD(singleVar ? '' : ')', '{');
            NEW_LINE();
        });
        for (const mapping of ast.values) {
            F.printFilter(ast, () => !singleVar && PRINT_WORD('('));
            for (const variable of variables) {
                const var_ = variable.value;
                if (mapping[var_] === undefined) {
                    F.printFilter(ast, () => PRINT_WORD('UNDEF'));
                }
                else {
                    SUBRULE(tripleBlock_js_1.graphNodePath, mapping[var_]);
                }
            }
            F.printFilter(ast, () => {
                PRINT_WORD(singleVar ? '' : ')');
                NEW_LINE();
            });
        }
        F.printFilter(ast, () => {
            C[core_1.traqulaIndentation] -= indentInc;
            PRINT_ON_OWN_LINE('}');
        });
    },
};
/**
 * [[62]](https://www.w3.org/TR/sparql11-query/#rDataBlock)
 */
exports.dataBlock = {
    name: 'dataBlock',
    impl: ({ SUBRULE, OR }) => () => OR([
        { ALT: () => SUBRULE(exports.inlineDataOneVar) },
        { ALT: () => SUBRULE(exports.inlineDataFull) },
    ]),
};
/**
 * [[63]](https://www.w3.org/TR/sparql11-query/#rInlineDataOneVar)
 */
exports.inlineDataOneVar = {
    name: 'inlineDataOneVar',
    impl: ({ ACTION, SUBRULE, CONSUME, MANY }) => (C) => {
        const res = [];
        const varVal = SUBRULE(general_js_1.var_);
        CONSUME(l.symbols.LCurly);
        MANY(() => {
            const value = SUBRULE(exports.dataBlockValue);
            ACTION(() => {
                res.push({ [varVal.value]: value });
            });
        });
        const close = CONSUME(l.symbols.RCurly);
        return ACTION(() => C.astFactory.patternValues([varVal], res, C.astFactory.sourceLocation(varVal, close)));
    },
};
/**
 * [[64]](https://www.w3.org/TR/sparql11-query/#rInlineDataFull)
 */
exports.inlineDataFull = {
    name: 'inlineDataFull',
    impl: ({ ACTION, OR, MANY1, MANY2, MANY3, MANY4, SUBRULE, CONSUME1, CONSUME2, }) => (C) => {
        const res = [];
        const vars = [];
        return OR([
            { ALT: () => {
                    // Grammar rule 64 together with note 11 learns us that a nil should be followed by a nil in DataBlock.
                    const nil = CONSUME1(l.terminals.nil);
                    CONSUME1(l.symbols.LCurly);
                    MANY1(() => {
                        CONSUME2(l.terminals.nil);
                        res.push({});
                    });
                    const close = CONSUME1(l.symbols.RCurly);
                    return ACTION(() => C.astFactory.patternValues(vars, res, C.astFactory.sourceLocation(nil, close)));
                } },
            { ALT: () => {
                    const open = CONSUME1(l.symbols.LParen);
                    MANY2(() => {
                        vars.push(SUBRULE(general_js_1.var_));
                    });
                    CONSUME1(l.symbols.RParen);
                    CONSUME2(l.symbols.LCurly);
                    MANY3(() => {
                        let parsedValues = 0;
                        const currentRow = {};
                        CONSUME2(l.symbols.LParen);
                        MANY4(() => {
                            ACTION(() => {
                                if (!C.skipValidation && parsedValues >= vars.length) {
                                    throw new Error('Number of dataBlockValues does not match number of variables. Too much values.');
                                }
                            });
                            const value = SUBRULE(exports.dataBlockValue);
                            ACTION(() => {
                                currentRow[vars[parsedValues].value] = value;
                                parsedValues++;
                            });
                        });
                        CONSUME2(l.symbols.RParen);
                        ACTION(() => {
                            res.push(currentRow);
                            if (!C.skipValidation && vars.length !== parsedValues) {
                                throw new Error('Number of dataBlockValues does not match number of variables. Too few values.');
                            }
                        });
                    });
                    const close = CONSUME2(l.symbols.RCurly);
                    return ACTION(() => C.astFactory.patternValues(vars, res, C.astFactory.sourceLocation(open, close)));
                } },
        ]);
    },
};
/**
 * [[65]](https://www.w3.org/TR/sparql11-query/#rDataBlockValue)
 */
exports.dataBlockValue = {
    name: 'dataBlockValue',
    impl: ({ SUBRULE, CONSUME, OR }) => () => OR([
        { ALT: () => SUBRULE(literals_js_1.iri) },
        { ALT: () => SUBRULE(literals_js_1.rdfLiteral) },
        { ALT: () => SUBRULE(literals_js_1.numericLiteral) },
        { ALT: () => SUBRULE(literals_js_1.booleanLiteral) },
        { ALT: () => {
                CONSUME(l.undef);
                // eslint-disable-next-line unicorn/no-useless-undefined
                return undefined;
            } },
    ]),
};
/**
 * [[66]](https://www.w3.org/TR/sparql11-query/#rMinusGraphPattern)
 */
exports.minusGraphPattern = {
    name: 'minusGraphPattern',
    impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
        const minus = CONSUME(l.minus);
        const group = SUBRULE(exports.groupGraphPattern);
        return ACTION(() => C.astFactory.patternMinus(group.patterns, C.astFactory.sourceLocation(minus, group)));
    },
    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => PRINT_WORD('MINUS'));
        SUBRULE(exports.groupGraphPattern, F.patternGroup(ast.patterns, ast.loc));
    },
};
/**
 * [[67]](https://www.w3.org/TR/sparql11-query/#rGroupOrUnionGraphPattern)
 */
exports.groupOrUnionGraphPattern = {
    name: 'groupOrUnionGraphPattern',
    impl: ({ ACTION, MANY, SUBRULE1, SUBRULE2, CONSUME }) => (C) => {
        const groups = [];
        const group = SUBRULE1(exports.groupGraphPattern);
        groups.push(group);
        MANY(() => {
            CONSUME(l.union);
            const group = SUBRULE2(exports.groupGraphPattern);
            groups.push(group);
        });
        return ACTION(() => groups.length === 1 ?
            groups[0] :
            C.astFactory.patternUnion(groups, C.astFactory.sourceLocation(group, groups.at(-1))));
    },
    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
        if (F.isPatternUnion(ast)) {
            const [head, ...tail] = ast.patterns;
            SUBRULE(exports.groupGraphPattern, head);
            for (const pattern of tail) {
                F.printFilter(ast, () => PRINT_WORD('UNION'));
                SUBRULE(exports.groupGraphPattern, pattern);
            }
        }
        else {
            SUBRULE(exports.groupGraphPattern, ast);
        }
    },
};
/**
 * [[68]](https://www.w3.org/TR/sparql11-query/#rFilter)
 */
exports.filter = {
    name: 'filter',
    impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
        const filterToken = CONSUME(l.filter);
        const expression = SUBRULE(exports.constraint);
        return ACTION(() => C.astFactory.patternFilter(expression, C.astFactory.sourceLocation(filterToken, expression)));
    },
    gImpl: ({ SUBRULE, PRINT_WORD, NEW_LINE }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => PRINT_WORD('FILTER ('));
        SUBRULE(expression_js_1.expression, ast.expression);
        F.printFilter(ast, () => {
            PRINT_WORD(')');
            NEW_LINE();
        });
    },
};
/**
 * [[69]](https://www.w3.org/TR/sparql11-query/#rConstraint)
 */
exports.constraint = {
    name: 'constraint',
    impl: ({ SUBRULE, OR }) => () => OR([
        { ALT: () => SUBRULE(expression_js_1.brackettedExpression) },
        { ALT: () => SUBRULE(builtIn_js_1.builtInCall) },
        { ALT: () => SUBRULE(exports.functionCall) },
    ]),
};
/**
 * [[70]](https://www.w3.org/TR/sparql11-query/#rFunctionCall)
 */
exports.functionCall = {
    name: 'functionCall',
    impl: ({ ACTION, SUBRULE }) => (C) => {
        const func = SUBRULE(literals_js_1.iri);
        const args = SUBRULE(expression_js_1.argList);
        return ACTION(() => C.astFactory.expressionFunctionCall(func, args.val.args, args.val.distinct, C.astFactory.sourceLocation(func, args)));
    },
};
//# sourceMappingURL=whereClause.js.map