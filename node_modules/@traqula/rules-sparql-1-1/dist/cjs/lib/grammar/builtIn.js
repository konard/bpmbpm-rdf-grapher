"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.builtInCall = exports.builtInIsnumeric = exports.builtInIsliteral = exports.builtInIsblank = exports.builtInIsuri = exports.builtInIsiri = exports.builtInSameterm = exports.builtInStrdt = exports.builtInStrlang = exports.builtInIf = exports.builtInCoalesce = exports.builtInSha512 = exports.builtInSha384 = exports.builtInSha256 = exports.builtInSha1 = exports.builtInMd5 = exports.builtInStruuid = exports.builtInUuid = exports.builtInNow = exports.builtInTz = exports.builtInTimezone = exports.builtInSeconds = exports.builtInMinutes = exports.builtInHours = exports.builtInDay = exports.builtInMonth = exports.builtInYear = exports.builtInStrafter = exports.builtInStrbefore = exports.builtInStrends = exports.builtInStrstarts = exports.builtInContains = exports.builtInEncode_for_uri = exports.builtInLcase = exports.builtInUcase = exports.builtInStrlen = exports.builtInConcat = exports.builtInRound = exports.builtInFloor = exports.builtInCeil = exports.builtInAbs = exports.builtInRand = exports.builtInBnodeSparqlJs = exports.builtInUri = exports.builtInIri = exports.builtInBound = exports.builtInDatatype = exports.builtInLangmatches = exports.builtInLang = exports.builtInStr = void 0;
exports.aggregate = exports.aggregateGroup_concat = exports.aggregateSample = exports.aggregateAvg = exports.aggregateMax = exports.aggregateMin = exports.aggregateSum = exports.aggregateCount = exports.notExistsFunc = exports.existsFunc = exports.strReplaceExpression = exports.substringExpression = exports.regexExpression = void 0;
exports.builtInCallList = builtInCallList;
const core_1 = require("@traqula/core");
const expressionHelpers_js_1 = require("../expressionHelpers.js");
const l = __importStar(require("../lexer/index.js"));
const expression_js_1 = require("./expression.js");
const literals_js_1 = require("./literals.js");
exports.builtInStr = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.str);
exports.builtInLang = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.lang);
exports.builtInLangmatches = (0, expressionHelpers_js_1.funcExpr2)(l.builtIn.langmatches);
exports.builtInDatatype = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.datatype);
exports.builtInBound = (0, expressionHelpers_js_1.funcVar1)(l.builtIn.bound);
exports.builtInIri = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.iri);
exports.builtInUri = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.uri);
exports.builtInBnodeSparqlJs = (0, expressionHelpers_js_1.funcExprOrNil1)(l.builtIn.bnode);
exports.builtInRand = (0, expressionHelpers_js_1.funcNil1)(l.builtIn.rand);
exports.builtInAbs = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.abs);
exports.builtInCeil = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.ceil);
exports.builtInFloor = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.floor);
exports.builtInRound = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.round);
exports.builtInConcat = (0, expressionHelpers_js_1.funcExprList1)(l.builtIn.concat);
exports.builtInStrlen = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.strlen);
exports.builtInUcase = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.ucase);
exports.builtInLcase = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.lcase);
exports.builtInEncode_for_uri = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.encode_for_uri);
exports.builtInContains = (0, expressionHelpers_js_1.funcExpr2)(l.builtIn.contains);
exports.builtInStrstarts = (0, expressionHelpers_js_1.funcExpr2)(l.builtIn.strstarts);
exports.builtInStrends = (0, expressionHelpers_js_1.funcExpr2)(l.builtIn.strends);
exports.builtInStrbefore = (0, expressionHelpers_js_1.funcExpr2)(l.builtIn.strbefore);
exports.builtInStrafter = (0, expressionHelpers_js_1.funcExpr2)(l.builtIn.strafter);
exports.builtInYear = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.year);
exports.builtInMonth = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.month);
exports.builtInDay = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.day);
exports.builtInHours = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.hours);
exports.builtInMinutes = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.minutes);
exports.builtInSeconds = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.seconds);
exports.builtInTimezone = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.timezone);
exports.builtInTz = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.tz);
exports.builtInNow = (0, expressionHelpers_js_1.funcNil1)(l.builtIn.now);
exports.builtInUuid = (0, expressionHelpers_js_1.funcNil1)(l.builtIn.uuid);
exports.builtInStruuid = (0, expressionHelpers_js_1.funcNil1)(l.builtIn.struuid);
exports.builtInMd5 = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.md5);
exports.builtInSha1 = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.sha1);
exports.builtInSha256 = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.sha256);
exports.builtInSha384 = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.sha384);
exports.builtInSha512 = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.sha512);
exports.builtInCoalesce = (0, expressionHelpers_js_1.funcExprList1)(l.builtIn.coalesce);
exports.builtInIf = (0, expressionHelpers_js_1.funcExpr3)(l.builtIn.if_);
exports.builtInStrlang = (0, expressionHelpers_js_1.funcExpr2)(l.builtIn.strlang);
exports.builtInStrdt = (0, expressionHelpers_js_1.funcExpr2)(l.builtIn.strdt);
exports.builtInSameterm = (0, expressionHelpers_js_1.funcExpr2)(l.builtIn.sameterm);
exports.builtInIsiri = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.isiri);
exports.builtInIsuri = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.isuri);
exports.builtInIsblank = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.isblank);
exports.builtInIsliteral = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.isliteral);
exports.builtInIsnumeric = (0, expressionHelpers_js_1.funcExpr1)(l.builtIn.isnumeric);
function builtInCallList(SUBRULE) {
    return [
        { ALT: () => SUBRULE(exports.aggregate) },
        { ALT: () => SUBRULE(exports.builtInStr) },
        { ALT: () => SUBRULE(exports.builtInLang) },
        { ALT: () => SUBRULE(exports.builtInLangmatches) },
        { ALT: () => SUBRULE(exports.builtInDatatype) },
        { ALT: () => SUBRULE(exports.builtInBound) },
        { ALT: () => SUBRULE(exports.builtInIri) },
        { ALT: () => SUBRULE(exports.builtInUri) },
        { ALT: () => SUBRULE(exports.builtInBnodeSparqlJs) },
        { ALT: () => SUBRULE(exports.builtInRand) },
        { ALT: () => SUBRULE(exports.builtInAbs) },
        { ALT: () => SUBRULE(exports.builtInCeil) },
        { ALT: () => SUBRULE(exports.builtInFloor) },
        { ALT: () => SUBRULE(exports.builtInRound) },
        { ALT: () => SUBRULE(exports.builtInConcat) },
        { ALT: () => SUBRULE(exports.substringExpression) },
        { ALT: () => SUBRULE(exports.builtInStrlen) },
        { ALT: () => SUBRULE(exports.strReplaceExpression) },
        { ALT: () => SUBRULE(exports.builtInUcase) },
        { ALT: () => SUBRULE(exports.builtInLcase) },
        { ALT: () => SUBRULE(exports.builtInEncode_for_uri) },
        { ALT: () => SUBRULE(exports.builtInContains) },
        { ALT: () => SUBRULE(exports.builtInStrstarts) },
        { ALT: () => SUBRULE(exports.builtInStrends) },
        { ALT: () => SUBRULE(exports.builtInStrbefore) },
        { ALT: () => SUBRULE(exports.builtInStrafter) },
        { ALT: () => SUBRULE(exports.builtInYear) },
        { ALT: () => SUBRULE(exports.builtInMonth) },
        { ALT: () => SUBRULE(exports.builtInDay) },
        { ALT: () => SUBRULE(exports.builtInHours) },
        { ALT: () => SUBRULE(exports.builtInMinutes) },
        { ALT: () => SUBRULE(exports.builtInSeconds) },
        { ALT: () => SUBRULE(exports.builtInTimezone) },
        { ALT: () => SUBRULE(exports.builtInTz) },
        { ALT: () => SUBRULE(exports.builtInNow) },
        { ALT: () => SUBRULE(exports.builtInUuid) },
        { ALT: () => SUBRULE(exports.builtInStruuid) },
        { ALT: () => SUBRULE(exports.builtInMd5) },
        { ALT: () => SUBRULE(exports.builtInSha1) },
        { ALT: () => SUBRULE(exports.builtInSha256) },
        { ALT: () => SUBRULE(exports.builtInSha384) },
        { ALT: () => SUBRULE(exports.builtInSha512) },
        { ALT: () => SUBRULE(exports.builtInCoalesce) },
        { ALT: () => SUBRULE(exports.builtInIf) },
        { ALT: () => SUBRULE(exports.builtInStrlang) },
        { ALT: () => SUBRULE(exports.builtInStrdt) },
        { ALT: () => SUBRULE(exports.builtInSameterm) },
        { ALT: () => SUBRULE(exports.builtInIsiri) },
        { ALT: () => SUBRULE(exports.builtInIsuri) },
        { ALT: () => SUBRULE(exports.builtInIsblank) },
        { ALT: () => SUBRULE(exports.builtInIsliteral) },
        { ALT: () => SUBRULE(exports.builtInIsnumeric) },
        { ALT: () => SUBRULE(exports.regexExpression) },
        { ALT: () => SUBRULE(exports.existsFunc) },
        { ALT: () => SUBRULE(exports.notExistsFunc) },
    ];
}
/**
 * [[121]](https://www.w3.org/TR/sparql11-query/#rBuiltInCall)
 */
exports.builtInCall = {
    name: 'builtInCall',
    impl: ({ OR, SUBRULE, cache }) => () => {
        const cached = cache.get(exports.builtInCall);
        if (cached) {
            return OR(cached);
        }
        const builtIns = builtInCallList(SUBRULE);
        cache.set(exports.builtInCall, builtIns);
        return OR(builtIns);
    },
};
/**
 * [[122]](https://www.w3.org/TR/sparql11-query/#rBuiltInCall)
 */
exports.regexExpression = (0, expressionHelpers_js_1.funcExpr2or3)(l.builtIn.regex);
/**
 * [[123]](https://www.w3.org/TR/sparql11-query/#rBuiltInCall)
 */
exports.substringExpression = (0, expressionHelpers_js_1.funcExpr2or3)(l.builtIn.substr);
/**
 * [[124]](https://www.w3.org/TR/sparql11-query/#rBuiltInCall)
 */
exports.strReplaceExpression = (0, expressionHelpers_js_1.funcExpr3or4)(l.builtIn.replace);
/**
 * [[125]](https://www.w3.org/TR/sparql11-query/#rBuiltInCall)
 */
exports.existsFunc = (0, expressionHelpers_js_1.funcGroupGraphPattern)(l.builtIn.exists);
/**
 * [[126]](https://www.w3.org/TR/sparql11-query/#rBuiltInCall)
 */
exports.notExistsFunc = (0, expressionHelpers_js_1.funcGroupGraphPattern)(l.builtIn.notexists);
exports.aggregateCount = {
    name: (0, core_1.unCapitalize)(l.builtIn.count.name),
    impl: ({ ACTION, CONSUME, SUBRULE, OR, OPTION }) => (C) => {
        const operatorToken = CONSUME(l.builtIn.count);
        CONSUME(l.symbols.LParen);
        const distinctToken = OPTION(() => CONSUME(l.distinct));
        const expressionVal = OR([
            { ALT: () => {
                    const starToken = CONSUME(l.symbols.star);
                    return ACTION(() => C.astFactory.wildcard(C.astFactory.sourceLocation(starToken)));
                } },
            { ALT: () => SUBRULE(expression_js_1.expression) },
        ]);
        const closeToken = CONSUME(l.symbols.RParen);
        return ACTION(() => {
            const F = C.astFactory;
            if (C.astFactory.isWildcard(expressionVal)) {
                return F.aggregate(operatorToken.image, Boolean(distinctToken), expressionVal, undefined, C.astFactory.sourceLocation(operatorToken, closeToken));
            }
            return F.aggregate(operatorToken.image, Boolean(distinctToken), expressionVal, undefined, C.astFactory.sourceLocation(operatorToken, closeToken));
        });
    },
};
exports.aggregateSum = (0, expressionHelpers_js_1.baseAggregateFunc)(l.builtIn.sum);
exports.aggregateMin = (0, expressionHelpers_js_1.baseAggregateFunc)(l.builtIn.min);
exports.aggregateMax = (0, expressionHelpers_js_1.baseAggregateFunc)(l.builtIn.max);
exports.aggregateAvg = (0, expressionHelpers_js_1.baseAggregateFunc)(l.builtIn.avg);
exports.aggregateSample = (0, expressionHelpers_js_1.baseAggregateFunc)(l.builtIn.sample);
exports.aggregateGroup_concat = {
    name: (0, core_1.unCapitalize)(l.builtIn.groupConcat.name),
    impl: ({ ACTION, CONSUME, OPTION1, SUBRULE, OPTION2 }) => (C) => {
        const operatorToken = CONSUME(l.builtIn.groupConcat);
        CONSUME(l.symbols.LParen);
        const distinctToken = OPTION1(() => CONSUME(l.distinct));
        const expr = SUBRULE(expression_js_1.expression);
        const sep = OPTION2(() => {
            CONSUME(l.symbols.semi);
            CONSUME(l.separator);
            CONSUME(l.symbols.equal);
            return SUBRULE(literals_js_1.string);
        });
        const closeToken = CONSUME(l.symbols.RParen);
        return ACTION(() => {
            const F = C.astFactory;
            return F.aggregate(operatorToken.image, Boolean(distinctToken), expr, sep?.value ?? ' ', F.sourceLocation(operatorToken, closeToken));
        });
    },
};
/**
 * [[127]](https://www.w3.org/TR/sparql11-query/#rBuiltInCall)
 */
exports.aggregate = {
    name: 'aggregate',
    impl: ({ ACTION, SUBRULE, OR }) => (C) => {
        // https://www.w3.org/2013/sparql-errata#errata-query-5 - Or note 15 in SPARQL1.2 spec
        //  An aggregate function is not allowed within an aggregate function.
        const wasInAggregate = ACTION(() => C.parseMode.has('inAggregate'));
        ACTION(() => C.parseMode.add('inAggregate'));
        const result = OR([
            { ALT: () => SUBRULE(exports.aggregateCount) },
            { ALT: () => SUBRULE(exports.aggregateSum) },
            { ALT: () => SUBRULE(exports.aggregateMin) },
            { ALT: () => SUBRULE(exports.aggregateMax) },
            { ALT: () => SUBRULE(exports.aggregateAvg) },
            { ALT: () => SUBRULE(exports.aggregateSample) },
            { ALT: () => SUBRULE(exports.aggregateGroup_concat) },
        ]);
        ACTION(() => !wasInAggregate && C.parseMode.delete('inAggregate'));
        ACTION(() => {
            if (!C.parseMode.has('canParseAggregate')) {
                throw new Error('Aggregates are only allowed in SELECT, HAVING, and ORDER BY clauses.');
            }
            if (C.parseMode.has('inAggregate')) {
                throw new Error('An aggregate function is not allowed within an aggregate function.');
            }
        });
        return result;
    },
    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => {
            PRINT_WORD(ast.aggregation.toUpperCase(), '(');
            if (ast.distinct) {
                PRINT_WORD('DISTINCT');
            }
        });
        const arg = ast.expression[0];
        if (F.isWildcard(arg)) {
            F.printFilter(ast, () => PRINT_WORD('*'));
        }
        else {
            SUBRULE(expression_js_1.expression, arg);
        }
        if (F.isExpressionAggregateSeparator(ast)) {
            F.printFilter(ast, () => PRINT_WORD(';', 'SEPARATOR', '=', (0, literals_js_1.stringEscapedLexical)(ast.separator)));
        }
        F.printFilter(ast, () => PRINT_WORD(')'));
    },
};
//# sourceMappingURL=builtIn.js.map