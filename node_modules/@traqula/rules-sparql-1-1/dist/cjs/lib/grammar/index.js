"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryOrUpdate = void 0;
const index_js_1 = require("../lexer/index.js");
const validators_js_1 = require("../validation/validators.js");
const general_js_1 = require("./general.js");
const queryUnit_js_1 = require("./queryUnit.js");
const updateUnit_js_1 = require("./updateUnit.js");
__exportStar(require("./queryUnit.js"), exports);
__exportStar(require("./updateUnit.js"), exports);
__exportStar(require("./builtIn.js"), exports);
__exportStar(require("./dataSetClause.js"), exports);
__exportStar(require("./expression.js"), exports);
__exportStar(require("../expressionHelpers.js"), exports);
__exportStar(require("./general.js"), exports);
__exportStar(require("./literals.js"), exports);
__exportStar(require("./propertyPaths.js"), exports);
__exportStar(require("./solutionModifier.js"), exports);
__exportStar(require("./tripleBlock.js"), exports);
__exportStar(require("./whereClause.js"), exports);
/**
 * Query or update, optimized for the Query case.
 * One could implement a new rule that does not use BACKTRACK.
 */
exports.queryOrUpdate = {
    name: 'queryOrUpdate',
    impl: ({ ACTION, SUBRULE, OR1, OR2, MANY, OPTION1, CONSUME, SUBRULE2 }) => (C) => {
        const prologueValues = SUBRULE(general_js_1.prologue);
        return OR1([
            { ALT: () => {
                    const subType = OR2([
                        { ALT: () => SUBRULE(queryUnit_js_1.selectQuery) },
                        { ALT: () => SUBRULE(queryUnit_js_1.constructQuery) },
                        { ALT: () => SUBRULE(queryUnit_js_1.describeQuery) },
                        { ALT: () => SUBRULE(queryUnit_js_1.askQuery) },
                    ]);
                    const values = SUBRULE(queryUnit_js_1.valuesClause);
                    return ACTION(() => ({
                        context: prologueValues,
                        ...subType,
                        type: 'query',
                        ...(values && { values }),
                        loc: C.astFactory.sourceLocation(prologueValues.at(0), subType, values),
                    }));
                } },
            { ALT: () => {
                    const updates = [];
                    updates.push({ context: prologueValues });
                    let parsedSemi = true;
                    MANY({
                        GATE: () => parsedSemi,
                        DEF: () => {
                            parsedSemi = false;
                            updates.at(-1).operation = SUBRULE(updateUnit_js_1.update1);
                            OPTION1(() => {
                                CONSUME(index_js_1.symbols.semi);
                                parsedSemi = true;
                                const innerPrologue = SUBRULE2(general_js_1.prologue);
                                updates.push({ context: innerPrologue });
                            });
                        },
                    });
                    return ACTION(() => {
                        const update = {
                            type: 'update',
                            updates,
                            loc: C.astFactory.sourceLocation(...updates.flatMap(x => [...x.context, x.operation])),
                        };
                        if (!C.skipValidation) {
                            (0, validators_js_1.updateNoReuseBlankNodeLabels)(update);
                        }
                        return update;
                    });
                } },
        ]);
    },
    gImpl: ({ SUBRULE }) => (ast, { astFactory: F }) => {
        if (F.isQuery(ast)) {
            SUBRULE(queryUnit_js_1.query, ast);
        }
        else {
            SUBRULE(updateUnit_js_1.update, ast);
        }
    },
};
//# sourceMappingURL=index.js.map