"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.quadsNotTriples = exports.quads = exports.graphRefAll = exports.graphRef = exports.graphOrDefault = exports.insertClause = exports.deleteClause = exports.modify = exports.deleteWhere = exports.deleteData = exports.insertData = exports.quadData = exports.quadPattern = exports.copy = exports.move = exports.add = exports.create = exports.drop = exports.clear = exports.load = exports.update1 = exports.update = exports.updateUnit = void 0;
const core_1 = require("@traqula/core");
const l = __importStar(require("../lexer/index.js"));
const validators_js_1 = require("../validation/validators.js");
const dataSetClause_js_1 = require("./dataSetClause.js");
const general_js_1 = require("./general.js");
const literals_js_1 = require("./literals.js");
const tripleBlock_js_1 = require("./tripleBlock.js");
const whereClause_js_1 = require("./whereClause.js");
/**
 * [[3]](https://www.w3.org/TR/sparql11-query/#rUpdateUnit)
 */
exports.updateUnit = {
    name: 'updateUnit',
    impl: ({ SUBRULE }) => () => SUBRULE(exports.update),
};
/**
 * [[29]](https://www.w3.org/TR/sparql11-query/#rUpdate)
 */
exports.update = {
    name: 'update',
    impl: ({ ACTION, SUBRULE, SUBRULE1, SUBRULE2, CONSUME, OPTION1, MANY }) => (C) => {
        // Override prologueValues on new reads of prologue and sink them into updates later
        const updates = [];
        const prologueValues = SUBRULE1(general_js_1.prologue);
        updates.push({ context: prologueValues });
        let parsedSemi = true;
        MANY({
            GATE: () => parsedSemi,
            DEF: () => {
                parsedSemi = false;
                updates.at(-1).operation = SUBRULE(exports.update1);
                OPTION1(() => {
                    CONSUME(l.symbols.semi);
                    parsedSemi = true;
                    const innerPrologue = SUBRULE2(general_js_1.prologue);
                    updates.push({ context: innerPrologue });
                });
            },
        });
        return ACTION(() => {
            const update = {
                type: 'update',
                updates,
                loc: C.astFactory.sourceLocation(...updates.flatMap(x => [...x.context, x.operation])),
            };
            if (!C.skipValidation) {
                (0, validators_js_1.updateNoReuseBlankNodeLabels)(update);
            }
            return update;
        });
    },
    gImpl: ({ SUBRULE, PRINT, NEW_LINE }) => (ast, { astFactory: F }) => {
        const [head, ...tail] = ast.updates;
        if (head) {
            SUBRULE(general_js_1.prologue, head.context);
            if (head.operation) {
                SUBRULE(exports.update1, head.operation);
            }
        }
        for (const update of tail) {
            F.printFilter(ast, () => {
                PRINT(';');
                NEW_LINE();
            });
            SUBRULE(general_js_1.prologue, update.context);
            if (update.operation) {
                SUBRULE(exports.update1, update.operation);
            }
        }
    },
};
/**
 * [[30]](https://www.w3.org/TR/sparql11-query/#rUpdate1)
 */
exports.update1 = {
    name: 'update1',
    impl: ({ SUBRULE, OR }) => () => OR([
        { ALT: () => SUBRULE(exports.load) },
        { ALT: () => SUBRULE(exports.clear) },
        { ALT: () => SUBRULE(exports.drop) },
        { ALT: () => SUBRULE(exports.add) },
        { ALT: () => SUBRULE(exports.move) },
        { ALT: () => SUBRULE(exports.copy) },
        { ALT: () => SUBRULE(exports.create) },
        { ALT: () => SUBRULE(exports.insertData) },
        { ALT: () => SUBRULE(exports.deleteData) },
        { ALT: () => SUBRULE(exports.deleteWhere) },
        { ALT: () => SUBRULE(exports.modify) },
    ]),
    gImpl: ({ SUBRULE }) => (ast) => {
        switch (ast.subType) {
            case ('load'):
                SUBRULE(exports.load, ast);
                break;
            case ('clear'):
                SUBRULE(exports.clear, ast);
                break;
            case ('drop'):
                SUBRULE(exports.drop, ast);
                break;
            case ('add'):
                SUBRULE(exports.add, ast);
                break;
            case ('move'):
                SUBRULE(exports.move, ast);
                break;
            case ('copy'):
                SUBRULE(exports.copy, ast);
                break;
            case ('create'):
                SUBRULE(exports.create, ast);
                break;
            case ('insertdata'):
                SUBRULE(exports.insertData, ast);
                break;
            case ('deletedata'):
                SUBRULE(exports.deleteData, ast);
                break;
            case ('deletewhere'):
                SUBRULE(exports.deleteWhere, ast);
                break;
            case ('modify'):
                SUBRULE(exports.modify, ast);
                break;
        }
    },
};
/**
 * [[31]](https://www.w3.org/TR/sparql11-query/#rLoad)
 */
exports.load = {
    name: 'load',
    impl: ({ ACTION, SUBRULE1, CONSUME, OPTION1, OPTION2 }) => (C) => {
        const loadToken = CONSUME(l.load);
        const silent = OPTION1(() => CONSUME(l.silent));
        const source = SUBRULE1(literals_js_1.iri);
        const destination = OPTION2(() => {
            CONSUME(l.loadInto);
            return SUBRULE1(exports.graphRef);
        });
        return ACTION(() => C.astFactory.updateOperationLoad(C.astFactory.sourceLocation(loadToken, source, destination), source, Boolean(silent), destination));
    },
    gImpl: ({ SUBRULE, PRINT_WORD, PRINT_ON_EMPTY }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => {
            PRINT_ON_EMPTY('LOAD ');
            if (ast.silent) {
                PRINT_WORD('SILENT');
            }
        });
        SUBRULE(literals_js_1.iri, ast.source);
        if (ast.destination) {
            F.printFilter(ast, () => PRINT_WORD('INTO'));
            SUBRULE(exports.graphRefAll, ast.destination);
        }
    },
};
function clearOrDrop(operation) {
    return {
        name: (0, core_1.unCapitalize)(operation.name),
        impl: ({ ACTION, SUBRULE1, CONSUME, OPTION }) => (C) => {
            const opToken = CONSUME(operation);
            const silent = OPTION(() => CONSUME(l.silent));
            const destination = SUBRULE1(exports.graphRefAll);
            return ACTION(() => C.astFactory.updateOperationClearDrop((0, core_1.unCapitalize)(operation.name), Boolean(silent), destination, C.astFactory.sourceLocation(opToken, destination)));
        },
        gImpl: ({ SUBRULE, PRINT_WORD, PRINT_ON_EMPTY }) => (ast, { astFactory: F }) => {
            F.printFilter(ast, () => {
                PRINT_ON_EMPTY(operation.name.toUpperCase(), ' ');
                if (ast.silent) {
                    PRINT_WORD('SILENT');
                }
            });
            SUBRULE(exports.graphRefAll, ast.destination);
        },
    };
}
/**
 * [[32]](https://www.w3.org/TR/sparql11-query/#rClear)
 */
exports.clear = clearOrDrop(l.clear);
/**
 * [[33]](https://www.w3.org/TR/sparql11-query/#rDrop)
 */
exports.drop = clearOrDrop(l.drop);
/**
 * [[34]](https://www.w3.org/TR/sparql11-query/#rCreate)
 */
exports.create = {
    name: 'create',
    impl: ({ ACTION, SUBRULE1, CONSUME, OPTION }) => (C) => {
        const createToken = CONSUME(l.create);
        const silent = OPTION(() => CONSUME(l.silent));
        const destination = SUBRULE1(exports.graphRef);
        return ACTION(() => C.astFactory.updateOperationCreate(destination, Boolean(silent), C.astFactory.sourceLocation(createToken, destination)));
    },
    gImpl: ({ SUBRULE, PRINT_WORD, PRINT_ON_EMPTY }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => {
            PRINT_ON_EMPTY('CREATE ');
            if (ast.silent) {
                PRINT_WORD('SILENT');
            }
        });
        SUBRULE(exports.graphRefAll, ast.destination);
    },
};
function copyMoveAddOperation(operation) {
    return {
        name: (0, core_1.unCapitalize)(operation.name),
        impl: ({ ACTION, CONSUME, SUBRULE1, SUBRULE2, OPTION }) => (C) => {
            const op = CONSUME(operation);
            const silent = OPTION(() => CONSUME(l.silent));
            const source = SUBRULE1(exports.graphOrDefault);
            CONSUME(l.to);
            const destination = SUBRULE2(exports.graphOrDefault);
            return ACTION(() => C.astFactory.updateOperationAddMoveCopy((0, core_1.unCapitalize)(operation.name), source, destination, Boolean(silent), C.astFactory.sourceLocation(op, destination)));
        },
        gImpl: ({ SUBRULE, PRINT_WORD, PRINT_ON_EMPTY }) => (ast, { astFactory: F }) => {
            F.printFilter(ast, () => {
                PRINT_ON_EMPTY(operation.name.toUpperCase(), ' ');
                if (ast.silent) {
                    PRINT_WORD('SILENT');
                }
            });
            SUBRULE(exports.graphRefAll, ast.source);
            F.printFilter(ast, () => PRINT_WORD('TO'));
            SUBRULE(exports.graphRefAll, ast.destination);
        },
    };
}
/**
 * [[35]](https://www.w3.org/TR/sparql11-query/#rAdd)
 */
exports.add = copyMoveAddOperation(l.add);
/**
 * [[36]](https://www.w3.org/TR/sparql11-query/#rMove)
 */
exports.move = copyMoveAddOperation(l.move);
/**
 * [[37]](https://www.w3.org/TR/sparql11-query/#rCopy)
 */
exports.copy = copyMoveAddOperation(l.copy);
/**
 * [[48]](https://www.w3.org/TR/sparql11-query/#rQuadPattern)
 */
exports.quadPattern = {
    name: 'quadPattern',
    impl: ({ ACTION, SUBRULE1, CONSUME }) => (C) => {
        const open = CONSUME(l.symbols.LCurly);
        const val = SUBRULE1(exports.quads);
        const close = CONSUME(l.symbols.RCurly);
        return ACTION(() => C.astFactory.wrap(val.val, C.astFactory.sourceLocation(open, close)));
    },
};
/**
 * [[49]](https://www.w3.org/TR/sparql11-query/#rQuadData)
 */
exports.quadData = {
    name: 'quadData',
    impl: ({ ACTION, SUBRULE1, CONSUME }) => (C) => {
        const open = CONSUME(l.symbols.LCurly);
        const couldParseVars = ACTION(() => C.parseMode.delete('canParseVars'));
        const val = SUBRULE1(exports.quads);
        ACTION(() => couldParseVars && C.parseMode.add('canParseVars'));
        const close = CONSUME(l.symbols.RCurly);
        return ACTION(() => C.astFactory.wrap(val.val, C.astFactory.sourceLocation(open, close)));
    },
};
function insertDeleteDelWhere(name, subType, cons1, dataRule) {
    return {
        name,
        impl: ({ ACTION, SUBRULE1, CONSUME }) => (C) => {
            const insDelToken = CONSUME(cons1);
            let couldCreateBlankNodes = true;
            if (name !== 'insertData') {
                couldCreateBlankNodes = ACTION(() => C.parseMode.delete('canCreateBlankNodes'));
            }
            const data = SUBRULE1(dataRule);
            if (name !== 'insertData') {
                ACTION(() => couldCreateBlankNodes && C.parseMode.add('canCreateBlankNodes'));
            }
            return ACTION(() => C.astFactory.updateOperationInsDelDataWhere(subType, data.val, C.astFactory.sourceLocation(insDelToken, data)));
        },
        gImpl: ({ SUBRULE, PRINT_WORD, PRINT_ON_EMPTY, PRINT_ON_OWN_LINE, NEW_LINE }) => (ast, C) => {
            const { astFactory: F, indentInc } = C;
            F.printFilter(ast, () => {
                if (subType === 'insertdata') {
                    PRINT_ON_EMPTY('INSERT DATA ');
                }
                else if (subType === 'deletedata') {
                    PRINT_ON_EMPTY('DELETE DATA ');
                }
                else if (subType === 'deletewhere') {
                    PRINT_ON_EMPTY('DELETE WHERE ');
                }
                C[core_1.traqulaIndentation] += indentInc;
                PRINT_WORD('{');
                NEW_LINE();
            });
            SUBRULE(exports.quads, F.wrap(ast.data, ast.loc));
            F.printFilter(ast, () => {
                C[core_1.traqulaIndentation] -= indentInc;
                PRINT_ON_OWN_LINE('}');
            });
        },
    };
}
/**
 * [[38]](https://www.w3.org/TR/sparql11-query/#rInsertData)
 */
exports.insertData = insertDeleteDelWhere('insertData', 'insertdata', l.insertDataClause, exports.quadData);
/**
 * [[39]](https://www.w3.org/TR/sparql11-query/#rDeleteData)
 */
exports.deleteData = insertDeleteDelWhere('deleteData', 'deletedata', l.deleteDataClause, exports.quadData);
/**
 * [[40]](https://www.w3.org/TR/sparql11-query/#rDeleteWhere)
 */
exports.deleteWhere = insertDeleteDelWhere('deleteWhere', 'deletewhere', l.deleteWhereClause, exports.quadPattern);
/**
 * [[41]](https://www.w3.org/TR/sparql11-query/#rModify)
 */
exports.modify = {
    name: 'modify',
    impl: ({ ACTION, CONSUME, SUBRULE1, SUBRULE2, OPTION1, OPTION2, OR }) => (C) => {
        const graph = OPTION1(() => {
            const withToken = CONSUME(l.modifyWith);
            const graph = SUBRULE1(literals_js_1.iri);
            return { withToken, graph };
        });
        const { insert, del } = OR([
            { ALT: () => {
                    const del = SUBRULE1(exports.deleteClause);
                    const insert = OPTION2(() => SUBRULE1(exports.insertClause));
                    return { del, insert };
                } },
            { ALT: () => {
                    const insert = SUBRULE2(exports.insertClause);
                    return { insert, del: undefined };
                } },
        ]);
        const using = SUBRULE1(dataSetClause_js_1.usingClauseStar);
        CONSUME(l.where);
        const where = SUBRULE1(whereClause_js_1.groupGraphPattern);
        return ACTION(() => C.astFactory.updateOperationModify(C.astFactory.sourceLocation(graph?.withToken, del, insert, where), insert?.val ?? [], del?.val ?? [], where, using, graph?.graph));
    },
    gImpl: ({ SUBRULE, PRINT_WORDS, PRINT_ON_EMPTY, NEW_LINE }) => (ast, C) => {
        const { astFactory: F, indentInc } = C;
        if (ast.graph) {
            F.printFilter(ast, () => PRINT_WORDS('WITH'));
            SUBRULE(literals_js_1.iri, ast.graph);
        }
        if (ast.delete.length > 0) {
            F.printFilter(ast, () => {
                C[core_1.traqulaIndentation] += indentInc;
                PRINT_WORDS('DELETE', '{');
                NEW_LINE();
            });
            SUBRULE(exports.quads, F.wrap(ast.delete, ast.loc));
            F.printFilter(ast, () => {
                C[core_1.traqulaIndentation] -= indentInc;
                PRINT_ON_EMPTY('}');
                NEW_LINE();
            });
        }
        if (ast.insert.length > 0) {
            F.printFilter(ast, () => {
                C[core_1.traqulaIndentation] += indentInc;
                PRINT_WORDS('INSERT', '{');
                NEW_LINE();
            });
            SUBRULE(exports.quads, F.wrap(ast.insert, ast.loc));
            F.printFilter(ast, () => {
                C[core_1.traqulaIndentation] -= indentInc;
                PRINT_ON_EMPTY('} ');
                NEW_LINE();
            });
        }
        SUBRULE(dataSetClause_js_1.usingClauseStar, ast.from);
        F.printFilter(ast, () => PRINT_WORDS('WHERE'));
        SUBRULE(whereClause_js_1.groupGraphPattern, ast.where);
    },
};
/**
 * [[42]](https://www.w3.org/TR/sparql11-query/#rDeleteClause)
 */
exports.deleteClause = {
    name: 'deleteClause',
    impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
        const delToken = CONSUME(l.deleteClause);
        const couldCreateBlankNodes = ACTION(() => C.parseMode.delete('canCreateBlankNodes'));
        const del = SUBRULE(exports.quadPattern);
        ACTION(() => couldCreateBlankNodes && C.parseMode.add('canCreateBlankNodes'));
        return ACTION(() => C.astFactory.wrap(del.val, C.astFactory.sourceLocation(delToken, del)));
    },
};
/**
 * [[43]](https://www.w3.org/TR/sparql11-query/#rInsertClause)
 */
exports.insertClause = {
    name: 'insertClause',
    impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
        const insertToken = CONSUME(l.insertClause);
        const insert = SUBRULE(exports.quadPattern);
        return ACTION(() => C.astFactory.wrap(insert.val, C.astFactory.sourceLocation(insertToken, insert)));
    },
};
/**
 * [[45]](https://www.w3.org/TR/sparql11-query/#rGraphOrDefault)
 */
exports.graphOrDefault = {
    name: 'graphOrDefault',
    impl: ({ ACTION, SUBRULE1, CONSUME, OPTION, OR }) => C => OR([
        { ALT: () => {
                const def = CONSUME(l.graph.default_);
                return ACTION(() => C.astFactory.graphRefDefault(C.astFactory.sourceLocation(def)));
            } },
        { ALT: () => {
                const graph = OPTION(() => CONSUME(l.graph.graph));
                const name = SUBRULE1(literals_js_1.iri);
                return ACTION(() => C.astFactory.graphRefSpecific(name, C.astFactory.sourceLocation(graph, name)));
            } },
    ]),
};
/**
 * [[46]](https://www.w3.org/TR/sparql11-query/#rGraphRef)
 */
exports.graphRef = {
    name: 'graphRef',
    impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
        const graph = CONSUME(l.graph.graph);
        const val = SUBRULE(literals_js_1.iri);
        return ACTION(() => C.astFactory.graphRefSpecific(val, C.astFactory.sourceLocation(graph, val)));
    },
    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => PRINT_WORD('GRAPH'));
        SUBRULE(literals_js_1.iri, ast.graph);
    },
};
/**
 * [[47]](https://www.w3.org/TR/sparql11-query/#rGraphRefAll)
 */
exports.graphRefAll = {
    name: 'graphRefAll',
    impl: ({ ACTION, SUBRULE, CONSUME, OR }) => C => OR([
        { ALT: () => SUBRULE(exports.graphRef) },
        { ALT: () => {
                const def = CONSUME(l.graph.default_);
                return ACTION(() => C.astFactory.graphRefDefault(C.astFactory.sourceLocation(def)));
            } },
        { ALT: () => {
                const named = CONSUME(l.graph.named);
                return ACTION(() => C.astFactory.graphRefNamed(C.astFactory.sourceLocation(named)));
            } },
        { ALT: () => {
                const graphAll = CONSUME(l.graph.graphAll);
                return ACTION(() => C.astFactory.graphRefAll(C.astFactory.sourceLocation(graphAll)));
            } },
    ]),
    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
        if (F.isGraphRefSpecific(ast)) {
            SUBRULE(exports.graphRef, ast);
        }
        else if (F.isGraphRefDefault(ast)) {
            F.printFilter(ast, () => PRINT_WORD('DEFAULT'));
        }
        else if (F.isGraphRefNamed(ast)) {
            F.printFilter(ast, () => PRINT_WORD('NAMED'));
        }
        else if (F.isGraphRefAll(ast)) {
            F.printFilter(ast, () => PRINT_WORD('ALL'));
        }
    },
};
/**
 * [[50]](https://www.w3.org/TR/sparql11-query/#rQuads)
 */
exports.quads = {
    name: 'quads',
    impl: ({ ACTION, SUBRULE, CONSUME, MANY, SUBRULE1, SUBRULE2, OPTION1, OPTION2, OPTION3 }) => (C) => {
        const quads = [];
        let last;
        OPTION1(() => {
            const triples = SUBRULE1(tripleBlock_js_1.triplesTemplate);
            last = triples;
            ACTION(() => quads.push(triples));
        });
        MANY(() => {
            const notTriples = SUBRULE(exports.quadsNotTriples);
            last = notTriples;
            quads.push(notTriples);
            OPTION2(() => {
                const dotToken = CONSUME(l.symbols.dot);
                last = dotToken;
                return dotToken;
            });
            OPTION3(() => {
                const triples = SUBRULE2(tripleBlock_js_1.triplesTemplate);
                last = triples;
                ACTION(() => quads.push(triples));
            });
        });
        return ACTION(() => C.astFactory.wrap(quads, C.astFactory.sourceLocation(quads.at(0), last)));
    },
    gImpl: ({ SUBRULE }) => (ast, { astFactory: F }) => {
        for (const quad of ast.val) {
            if (F.isPattern(quad)) {
                SUBRULE(tripleBlock_js_1.triplesBlock, quad);
            }
            else {
                SUBRULE(exports.quadsNotTriples, quad);
            }
        }
    },
};
/**
 * [[51]](https://www.w3.org/TR/sparql11-query/#rQuadsNotTriples)
 */
exports.quadsNotTriples = {
    name: 'quadsNotTriples',
    impl: ({ ACTION, SUBRULE1, CONSUME, OPTION }) => (C) => {
        const graph = CONSUME(l.graph.graph);
        const name = SUBRULE1(general_js_1.varOrIri);
        CONSUME(l.symbols.LCurly);
        const triples = OPTION(() => SUBRULE1(tripleBlock_js_1.triplesTemplate));
        const close = CONSUME(l.symbols.RCurly);
        return ACTION(() => C.astFactory.graphQuads(name, triples ?? C.astFactory.patternBgp([], C.astFactory.sourceLocation()), C.astFactory.sourceLocation(graph, close)));
    },
    gImpl: ({ SUBRULE, PRINT_WORD, NEW_LINE, PRINT_ON_OWN_LINE }) => (ast, C) => {
        const { astFactory: F, indentInc } = C;
        F.printFilter(ast, () => PRINT_WORD('GRAPH'));
        SUBRULE(general_js_1.varOrTerm, ast.graph);
        F.printFilter(ast, () => {
            C[core_1.traqulaIndentation] += indentInc;
            PRINT_WORD('{');
            NEW_LINE();
        });
        SUBRULE(tripleBlock_js_1.triplesBlock, ast.triples);
        F.printFilter(ast, () => {
            C[core_1.traqulaIndentation] -= indentInc;
            PRINT_ON_OWN_LINE('}');
        });
    },
};
//# sourceMappingURL=updateUnit.js.map