{"version":3,"file":"propertyPaths.js","sourceRoot":"","sources":["../../../../lib/grammar/propertyPaths.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IToken, TokenType } from '@traqula/chevrotain';\nimport type { RuleDefReturn } from '@traqula/core';\nimport * as l from '../lexer/index.js';\nimport type { SparqlGeneratorRule, SparqlGrammarRule } from '../sparql11HelperTypes.js';\nimport type { TermIri, PathNegatedElt, Path, PathModified, PathNegated } from '../Sparql11types.js';\nimport { iri, verbA } from './literals.js';\n\n/**\n * [[88]](https://www.w3.org/TR/sparql11-query/#rPath)\n */\nexport const path: SparqlGrammarRule<'path', Path> = <const> {\n  name: 'path',\n  impl: ({ SUBRULE }) => () => SUBRULE(pathAlternative),\n};\n\nexport const pathGenerator: SparqlGeneratorRule<'path', Path, [boolean | undefined]> = {\n  name: 'path',\n  gImpl: ({ PRINT, SUBRULE }) => (ast, { astFactory: F }, braces = true) => {\n    if (F.isTerm(ast) && F.isTermNamed(ast)) {\n      SUBRULE(iri, ast);\n    } else {\n      F.printFilter(ast, () => braces && PRINT('('));\n      switch (ast.subType) {\n        case '|':\n        case '/': {\n          const [ head, ...tail ] = ast.items;\n          SUBRULE(pathGenerator, head, braces);\n          for (const val of tail) {\n            F.printFilter(ast, () => PRINT(ast.subType));\n            SUBRULE(pathGenerator, val, braces);\n          }\n          break;\n        }\n        case '^':\n          F.printFilter(ast, () => PRINT('^'));\n          SUBRULE(pathGenerator, ast.items[0], braces);\n          break;\n        case '?':\n        case '*':\n        case '+':\n          SUBRULE(pathGenerator, ast.items[0], braces);\n          F.printFilter(ast, () => PRINT(ast.subType));\n          break;\n        case '!':\n          F.printFilter(ast, () => PRINT('!'));\n          F.printFilter(ast, () => PRINT('('));\n          SUBRULE(pathGenerator, ast.items[0], false);\n          F.printFilter(ast, () => PRINT(')'));\n          break;\n      }\n      F.printFilter(ast, () => braces && PRINT(')'));\n    }\n  },\n};\n\nexport function pathChainHelper<T extends string>(\n  name: T,\n  SEP: TokenType,\n  subType: '|' | '/',\n  subRule: SparqlGrammarRule<string, Path>,\n): SparqlGrammarRule<T, Path | TermIri> {\n  return {\n    name,\n    impl: ({ ACTION, CONSUME, SUBRULE1, SUBRULE2, MANY }) => (C) => {\n      const head = SUBRULE1(subRule);\n      let tailEnd: Path = head;\n      const tail: Path[] = [];\n\n      MANY(() => {\n        CONSUME(SEP);\n        tailEnd = SUBRULE2(subRule);\n        tail.push(tailEnd);\n      });\n\n      return ACTION(() => tail.length === 0 ?\n        head :\n        C.astFactory.path(subType, [ head, ...tail ], C.astFactory.sourceLocation(head, tailEnd)));\n    },\n  };\n}\n\n/**\n * [[92]](https://www.w3.org/TR/sparql11-query/#rPathEltOrInverse)\n */\nexport const pathEltOrInverse: SparqlGrammarRule<'pathEltOrInverse', PathModified | Path> = <const> {\n  name: 'pathEltOrInverse',\n  impl: ({ ACTION, CONSUME, SUBRULE1, SUBRULE2, OR }) => C => OR<Path | TermIri>([\n    { ALT: () => SUBRULE1(pathElt) },\n    { ALT: () => {\n      const hat = CONSUME(l.symbols.hat);\n      const item = SUBRULE2(pathElt);\n      return ACTION(() => C.astFactory.path('^', [ item ], C.astFactory.sourceLocation(hat, item)));\n    } },\n  ]),\n};\n\n/**\n * [[90]](https://www.w3.org/TR/sparql11-query/#rPathSequence)\n */\nexport const pathSequence = pathChainHelper('pathSequence', l.symbols.slash, '/', pathEltOrInverse);\n\n/**\n * [[89]](https://www.w3.org/TR/sparql11-query/#rPathAlternative)\n */\nexport const pathAlternative = pathChainHelper('pathAlternative', l.symbols.pipe, '|', pathSequence);\n\n/**\n * [[91]](https://www.w3.org/TR/sparql11-query/#rPathElt)\n */\nexport const pathElt: SparqlGrammarRule<'pathElt', PathModified | Path> = <const> {\n  name: 'pathElt',\n  impl: ({ ACTION, SUBRULE, OPTION }) => (C) => {\n    const item = SUBRULE(pathPrimary);\n    const modification = OPTION(() => SUBRULE(pathMod));\n    return ACTION(() => modification === undefined ?\n      item :\n      C.astFactory.path(modification.image, [ item ], C.astFactory.sourceLocation(item, modification)));\n  },\n};\n\n/**\n * [[93]](https://www.w3.org/TR/sparql11-query/#rPathMod)\n */\nexport const pathMod: SparqlGrammarRule<'pathMod', IToken & { image: '*' | '+' | '?' }> = <const> {\n  name: 'pathMod',\n  impl: ({ CONSUME, OR }) => () => OR<RuleDefReturn<typeof pathMod>>([\n    { ALT: () => <RuleDefReturn<typeof pathMod>> CONSUME(l.symbols.question) },\n    { ALT: () => <RuleDefReturn<typeof pathMod>> CONSUME(l.symbols.star) },\n    { ALT: () => <RuleDefReturn<typeof pathMod>> CONSUME(l.symbols.opPlus) },\n  ]),\n};\n\n/**\n * [[94]](https://www.w3.org/TR/sparql11-query/#rPathPrimary)\n */\nexport const pathPrimary: SparqlGrammarRule<'pathPrimary', Path> = <const> {\n  name: 'pathPrimary',\n  impl: ({ SUBRULE, CONSUME, OR }) => () => OR<Path>([\n    { ALT: () => SUBRULE(iri) },\n    { ALT: () => SUBRULE(verbA) },\n    { ALT: () => SUBRULE(pathNegatedPropertySet) },\n    { ALT: () => {\n      CONSUME(l.symbols.LParen);\n      const resRecursive = SUBRULE(path);\n      CONSUME(l.symbols.RParen);\n      return resRecursive;\n    } },\n  ]),\n};\n\n/**\n * [[95]](https://www.w3.org/TR/sparql11-query/#rPathNegatedPropertySet)\n */\nexport const pathNegatedPropertySet: SparqlGrammarRule<'pathNegatedPropertySet', PathNegated> = <const> {\n  name: 'pathNegatedPropertySet',\n  impl: ({ ACTION, CONSUME, SUBRULE1, SUBRULE2, SUBRULE3, OR, MANY }) => (C) => {\n    const exclamation = CONSUME(l.symbols.exclamation);\n    return OR<PathNegated>([\n      { ALT: () => {\n        const noAlternative = SUBRULE1(pathOneInPropertySet);\n        return ACTION(() =>\n          C.astFactory.path('!', [ noAlternative ], C.astFactory.sourceLocation(exclamation, noAlternative)));\n      } },\n      { ALT: () => {\n        const open = CONSUME(l.symbols.LParen);\n\n        const head = SUBRULE2(pathOneInPropertySet);\n        const tail: (TermIri | PathNegatedElt)[] = [];\n        MANY(() => {\n          CONSUME(l.symbols.pipe);\n          const item = SUBRULE3(pathOneInPropertySet);\n          tail.push(item);\n        });\n\n        const close = CONSUME(l.symbols.RParen);\n\n        return ACTION(() => {\n          const F = C.astFactory;\n          if (tail.length === 0) {\n            return F.path('!', [ head ], F.sourceLocation(exclamation, close));\n          }\n          return F.path(\n            '!',\n            [ F.path('|', [ head, ...tail ], F.sourceLocation(open, close)) ],\n            F.sourceLocation(exclamation, close),\n          );\n        });\n      } },\n    ]);\n  },\n};\n\n/**\n * [[96]](https://www.w3.org/TR/sparql11-query/#rPathOneInPropertySet)\n */\nexport const pathOneInPropertySet: SparqlGrammarRule<'pathOneInPropertySet', TermIri | PathNegatedElt> = <const> {\n  name: 'pathOneInPropertySet',\n  impl: ({ ACTION, CONSUME, SUBRULE1, SUBRULE2, OR1, OR2 }) => C =>\n    OR1<TermIri | PathNegatedElt>([\n      { ALT: () => SUBRULE1(iri) },\n      { ALT: () => SUBRULE1(verbA) },\n      { ALT: () => {\n        const hat = CONSUME(l.symbols.hat);\n        const item = OR2<TermIri>([\n          { ALT: () => SUBRULE2(iri) },\n          { ALT: () => SUBRULE2(verbA) },\n        ]);\n        return ACTION(() =>\n          C.astFactory.path('^', [ item ], C.astFactory.sourceLocation(hat, item)));\n      } },\n    ]),\n};\n"]}