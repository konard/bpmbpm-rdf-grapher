"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.constructTriples = exports.constructTemplate = exports.valuesClause = exports.askQuery = exports.describeQuery = exports.constructQuery = exports.selectClause = exports.subSelect = exports.selectQuery = exports.query = exports.queryUnit = void 0;
const core_1 = require("@traqula/core");
const l = __importStar(require("../lexer/index.js"));
const validators_js_1 = require("../validation/validators.js");
const dataSetClause_js_1 = require("./dataSetClause.js");
const expression_js_1 = require("./expression.js");
const general_js_1 = require("./general.js");
const solutionModifier_js_1 = require("./solutionModifier.js");
const tripleBlock_js_1 = require("./tripleBlock.js");
const whereClause_js_1 = require("./whereClause.js");
/**
 * [[1]](https://www.w3.org/TR/sparql11-query/#rQueryUnit)
 */
exports.queryUnit = {
    name: 'queryUnit',
    impl: ({ SUBRULE }) => () => SUBRULE(exports.query),
};
/**
 * [[2]](https://www.w3.org/TR/sparql11-query/#rQuery)
 */
exports.query = {
    name: 'query',
    impl: ({ ACTION, SUBRULE, OR }) => (C) => {
        const prologueValues = SUBRULE(general_js_1.prologue);
        const subType = OR([
            { ALT: () => SUBRULE(exports.selectQuery) },
            { ALT: () => SUBRULE(exports.constructQuery) },
            { ALT: () => SUBRULE(exports.describeQuery) },
            { ALT: () => SUBRULE(exports.askQuery) },
        ]);
        const values = SUBRULE(exports.valuesClause);
        return ACTION(() => ({
            context: prologueValues,
            ...subType,
            type: 'query',
            ...(values && { values }),
            loc: C.astFactory.sourceLocation(prologueValues.at(0), subType, values),
        }));
    },
    gImpl: ({ SUBRULE }) => (ast, { astFactory: F }) => {
        SUBRULE(general_js_1.prologue, ast.context);
        if (F.isQuerySelect(ast)) {
            SUBRULE(exports.selectQuery, ast);
        }
        else if (F.isQueryConstruct(ast)) {
            SUBRULE(exports.constructQuery, ast);
        }
        else if (F.isQueryDescribe(ast)) {
            SUBRULE(exports.describeQuery, ast);
        }
        else if (F.isQueryAsk(ast)) {
            SUBRULE(exports.askQuery, ast);
        }
        if (ast.values) {
            SUBRULE(whereClause_js_1.inlineData, ast.values);
        }
    },
};
/**
 * [[7]](https://www.w3.org/TR/sparql11-query/#rSelectQuery)
 */
exports.selectQuery = {
    name: 'selectQuery',
    impl: ({ ACTION, SUBRULE }) => (C) => {
        const selectVal = SUBRULE(exports.selectClause);
        const from = SUBRULE(dataSetClause_js_1.datasetClauseStar);
        const where = SUBRULE(whereClause_js_1.whereClause);
        const modifiers = SUBRULE(solutionModifier_js_1.solutionModifier);
        return ACTION(() => {
            const ret = {
                subType: 'select',
                where: where.val,
                solutionModifiers: modifiers,
                datasets: from,
                ...selectVal.val,
                loc: C.astFactory.sourceLocation(selectVal, where, modifiers.group, modifiers.having, modifiers.order, modifiers.limitOffset),
            };
            if (!C.skipValidation) {
                (0, validators_js_1.queryProjectionIsGood)(ret);
            }
            return ret;
        });
    },
    gImpl: ({ SUBRULE }) => (ast, { astFactory: F }) => {
        SUBRULE(exports.selectClause, F.wrap({
            variables: ast.variables,
            distinct: ast.distinct,
            reduced: ast.reduced,
        }, F.sourceLocation(...ast.variables)));
        SUBRULE(dataSetClause_js_1.datasetClauseStar, ast.datasets);
        SUBRULE(whereClause_js_1.whereClause, F.wrap(ast.where, ast.where.loc));
        SUBRULE(solutionModifier_js_1.solutionModifier, ast.solutionModifiers);
    },
};
/**
 * [[8]](https://www.w3.org/TR/sparql11-query/#rSubSelect)
 */
exports.subSelect = {
    name: 'subSelect',
    impl: ({ ACTION, SUBRULE }) => (C) => {
        const selectVal = SUBRULE(exports.selectClause);
        const where = SUBRULE(whereClause_js_1.whereClause);
        const modifiers = SUBRULE(solutionModifier_js_1.solutionModifier);
        const values = SUBRULE(exports.valuesClause);
        return ACTION(() => C.astFactory.querySelect({
            where: where.val,
            datasets: C.astFactory.datasetClauses([], C.astFactory.sourceLocation()),
            context: [],
            solutionModifiers: modifiers,
            ...selectVal.val,
            ...(values && { values }),
        }, C.astFactory.sourceLocation(selectVal, where, modifiers.group, modifiers.having, modifiers.order, modifiers.limitOffset, values)));
    },
};
/**
 * [[9]](https://www.w3.org/TR/sparql11-query/#rSelectClause)
 */
exports.selectClause = {
    name: 'selectClause',
    impl: ({ ACTION, AT_LEAST_ONE, SUBRULE1, SUBRULE2, CONSUME, OPTION, OR1, OR2, OR3, }) => (C) => {
        const select = CONSUME(l.select);
        const couldParseAgg = ACTION(() => C.parseMode.has('canParseAggregate') || !C.parseMode.add('canParseAggregate'));
        const distinctAndReduced = OPTION(() => OR1([
            { ALT: () => {
                    CONSUME(l.distinct);
                    return [true, false];
                } },
            { ALT: () => {
                    CONSUME(l.reduced);
                    return [false, true];
                } },
        ])) ?? [false, false];
        const distRed = ACTION(() => {
            const [distinct, reduced] = distinctAndReduced;
            return {
                ...(distinct && { distinct }),
                ...(reduced && { reduced }),
            };
        });
        let last;
        const val = OR2([
            { ALT: () => {
                    const star = CONSUME(l.symbols.star);
                    return ACTION(() => {
                        last = star;
                        return { variables: [C.astFactory.wildcard(C.astFactory.sourceLocation(star))], ...distRed };
                    });
                } },
            { ALT: () => {
                    const usedVars = [];
                    const variables = [];
                    AT_LEAST_ONE(() => OR3([
                        { ALT: () => {
                                const raw = SUBRULE1(general_js_1.var_);
                                ACTION(() => {
                                    if (!C.skipValidation && usedVars.some(v => v.value === raw.value)) {
                                        throw new Error(`Variable ${raw.value} used more than once in SELECT clause`);
                                    }
                                    usedVars.push(raw);
                                    variables.push(raw);
                                    last = raw;
                                });
                            } },
                        { ALT: () => {
                                const open = CONSUME(l.symbols.LParen);
                                const expr = SUBRULE1(expression_js_1.expression);
                                CONSUME(l.as);
                                const variable = SUBRULE2(general_js_1.var_);
                                const close = CONSUME(l.symbols.RParen);
                                ACTION(() => {
                                    last = close;
                                    if (!C.skipValidation && usedVars.some(v => v.value === variable.value)) {
                                        throw new Error(`Variable ${variable.value} used more than once in SELECT clause`);
                                    }
                                    usedVars.push(variable);
                                    variables.push(C.astFactory.patternBind(expr, variable, C.astFactory.sourceLocation(open, last)));
                                });
                            } },
                    ]));
                    return { variables, ...distRed };
                } },
        ]);
        ACTION(() => !couldParseAgg && C.parseMode.delete('canParseAggregate'));
        return ACTION(() => C.astFactory.wrap(val, C.astFactory.sourceLocation(select, last)));
    },
    gImpl: ({ SUBRULE, PRINT_WORD, PRINT_ON_EMPTY }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => {
            PRINT_ON_EMPTY('SELECT ');
            if (ast.val.distinct) {
                PRINT_WORD('DISTINCT');
            }
            else if (ast.val.reduced) {
                PRINT_WORD('REDUCED');
            }
        });
        for (const variable of ast.val.variables) {
            if (F.isWildcard(variable)) {
                F.printFilter(ast, () => PRINT_WORD('*'));
            }
            else if (F.isTerm(variable)) {
                SUBRULE(general_js_1.var_, variable);
            }
            else {
                F.printFilter(ast, () => PRINT_WORD('('));
                SUBRULE(expression_js_1.expression, variable.expression);
                F.printFilter(ast, () => PRINT_WORD('AS'));
                SUBRULE(general_js_1.var_, variable.variable);
                F.printFilter(ast, () => PRINT_WORD(')'));
            }
            F.printFilter(ast, () => PRINT_WORD(''));
        }
        F.printFilter(ast, () => PRINT_WORD(''));
    },
};
/**
 * [[10]](https://www.w3.org/TR/sparql11-query/#rConstructQuery)
 */
exports.constructQuery = {
    name: 'constructQuery',
    impl: ({ ACTION, SUBRULE1, SUBRULE2, CONSUME, OR }) => (C) => {
        const construct = CONSUME(l.construct);
        return OR([
            { ALT: () => {
                    const template = SUBRULE1(exports.constructTemplate);
                    const from = SUBRULE1(dataSetClause_js_1.datasetClauseStar);
                    const where = SUBRULE1(whereClause_js_1.whereClause);
                    const modifiers = SUBRULE1(solutionModifier_js_1.solutionModifier);
                    return ACTION(() => ({
                        subType: 'construct',
                        template: template.val,
                        datasets: from,
                        where: where.val,
                        solutionModifiers: modifiers,
                        loc: C.astFactory.sourceLocation(construct, where, modifiers.group, modifiers.having, modifiers.order, modifiers.limitOffset),
                    }));
                } },
            { ALT: () => {
                    const from = SUBRULE2(dataSetClause_js_1.datasetClauseStar);
                    CONSUME(l.where);
                    // ConstructTemplate is same as '{' TriplesTemplate? '}'
                    const template = SUBRULE2(exports.constructTemplate);
                    const modifiers = SUBRULE2(solutionModifier_js_1.solutionModifier);
                    return ACTION(() => ({
                        subType: 'construct',
                        template: template.val,
                        datasets: from,
                        where: C.astFactory.patternGroup([template.val], C.astFactory.sourceLocation()),
                        solutionModifiers: modifiers,
                        loc: C.astFactory.sourceLocation(construct, template, modifiers.group, modifiers.having, modifiers.order, modifiers.limitOffset),
                    }));
                } },
        ]);
    },
    gImpl: ({ SUBRULE, PRINT_WORD, PRINT_ON_EMPTY, PRINT_ON_OWN_LINE, NEW_LINE }) => (ast, C) => {
        const { astFactory: F, indentInc } = C;
        F.printFilter(ast, () => PRINT_ON_EMPTY('CONSTRUCT '));
        if (!F.isSourceLocationNoMaterialize(ast.where.loc)) {
            // You are NOT in second case construct
            F.printFilter(ast, () => {
                C[core_1.traqulaIndentation] += indentInc;
                PRINT_WORD('{');
                NEW_LINE();
            });
            SUBRULE(tripleBlock_js_1.triplesBlock, ast.template);
            F.printFilter(ast, () => {
                C[core_1.traqulaIndentation] -= indentInc;
                PRINT_ON_OWN_LINE('}');
            });
        }
        SUBRULE(dataSetClause_js_1.datasetClauseStar, ast.datasets);
        if (F.isSourceLocationNoMaterialize(ast.where.loc)) {
            SUBRULE(whereClause_js_1.whereClause, F.wrap(F.patternGroup([ast.template], ast.template.loc), ast.template.loc));
        }
        else {
            SUBRULE(whereClause_js_1.whereClause, F.wrap(ast.where, ast.where.loc));
        }
        SUBRULE(solutionModifier_js_1.solutionModifier, ast.solutionModifiers);
    },
};
/**
 * [[11]](https://www.w3.org/TR/sparql11-query/#rDescribeQuery)
 */
exports.describeQuery = {
    name: 'describeQuery',
    impl: ({ ACTION, AT_LEAST_ONE, SUBRULE1, CONSUME, OPTION, OR }) => (C) => {
        const describe = CONSUME(l.describe);
        const variables = OR([
            { ALT: () => {
                    const variables = [];
                    AT_LEAST_ONE(() => {
                        variables.push(SUBRULE1(general_js_1.varOrIri));
                    });
                    return variables;
                } },
            { ALT: () => {
                    const star = CONSUME(l.symbols.star);
                    return [ACTION(() => C.astFactory.wildcard(C.astFactory.sourceLocation(star)))];
                } },
        ]);
        const from = SUBRULE1(dataSetClause_js_1.datasetClauseStar);
        const where = OPTION(() => SUBRULE1(whereClause_js_1.whereClause));
        const modifiers = SUBRULE1(solutionModifier_js_1.solutionModifier);
        return ACTION(() => ({
            subType: 'describe',
            variables,
            datasets: from,
            ...(where && { where: where.val }),
            solutionModifiers: modifiers,
            loc: C.astFactory.sourceLocation(describe, ...variables, from, where, modifiers.group, modifiers.having, modifiers.order, modifiers.limitOffset),
        }));
    },
    gImpl: ({ SUBRULE, PRINT_WORD, PRINT_ON_EMPTY }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => PRINT_ON_EMPTY('DESCRIBE '));
        if (F.isWildcard(ast.variables[0])) {
            F.printFilter(ast, () => PRINT_WORD('*'));
        }
        else {
            for (const variable of ast.variables) {
                SUBRULE(general_js_1.varOrTerm, variable);
            }
        }
        SUBRULE(dataSetClause_js_1.datasetClauseStar, ast.datasets);
        if (ast.where) {
            SUBRULE(whereClause_js_1.whereClause, F.wrap(ast.where, ast.loc));
        }
        SUBRULE(solutionModifier_js_1.solutionModifier, ast.solutionModifiers);
    },
};
/**
 * [[12]](https://www.w3.org/TR/sparql11-query/#rAskQuery)
 */
exports.askQuery = {
    name: 'askQuery',
    impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
        const ask = CONSUME(l.ask);
        const from = SUBRULE(dataSetClause_js_1.datasetClauseStar);
        const where = SUBRULE(whereClause_js_1.whereClause);
        const modifiers = SUBRULE(solutionModifier_js_1.solutionModifier);
        return ACTION(() => ({
            subType: 'ask',
            datasets: from,
            where: where.val,
            solutionModifiers: modifiers,
            loc: C.astFactory.sourceLocation(ask, from, where, modifiers.group, modifiers.having, modifiers.order, modifiers.limitOffset),
        }));
    },
    gImpl: ({ SUBRULE, PRINT_ON_EMPTY }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => PRINT_ON_EMPTY('ASK '));
        SUBRULE(dataSetClause_js_1.datasetClauseStar, ast.datasets);
        SUBRULE(whereClause_js_1.whereClause, F.wrap(ast.where, ast.loc));
        SUBRULE(solutionModifier_js_1.solutionModifier, ast.solutionModifiers);
    },
};
/**
 * [[28]](https://www.w3.org/TR/sparql11-query/#rValuesClause)
 */
exports.valuesClause = {
    name: 'valuesClause',
    impl: ({ OPTION, SUBRULE }) => () => OPTION(() => SUBRULE(whereClause_js_1.inlineData)),
};
/**
 * [[73]](https://www.w3.org/TR/sparql11-query/#ConstructTemplate)
 */
exports.constructTemplate = {
    name: 'constructTemplate',
    impl: ({ ACTION, SUBRULE1, CONSUME, OPTION }) => (C) => {
        const open = CONSUME(l.symbols.LCurly);
        const triples = OPTION(() => SUBRULE1(exports.constructTriples));
        const close = CONSUME(l.symbols.RCurly);
        return ACTION(() => C.astFactory.wrap(triples ?? C.astFactory.patternBgp([], C.astFactory.sourceLocation()), C.astFactory.sourceLocation(open, close)));
    },
};
/**
 * [[12]](https://www.w3.org/TR/sparql11-query/#rConstructTriples)
 */
exports.constructTriples = {
    name: 'constructTriples',
    impl: tripleBlock_js_1.triplesTemplate.impl,
};
//# sourceMappingURL=queryUnit.js.map