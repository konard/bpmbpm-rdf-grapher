"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.iriOrFunction = exports.brackettedExpression = exports.primaryExpression = exports.unaryExpression = exports.multiplicativeExpression = exports.additiveExpression = exports.numericExpression = exports.relationalExpression = exports.valueLogical = exports.conditionalAndExpression = exports.conditionalOrExpression = exports.expression = exports.expressionList = exports.argList = void 0;
const l = __importStar(require("../lexer/index.js"));
const builtIn_js_1 = require("./builtIn.js");
const general_js_1 = require("./general.js");
const literals_js_1 = require("./literals.js");
const whereClause_js_1 = require("./whereClause.js");
exports.argList = {
    name: 'argList',
    impl: ({ ACTION, CONSUME, SUBRULE1, OPTION, OR, AT_LEAST_ONE_SEP }) => C => OR([
        { ALT: () => {
                const nil = CONSUME(l.terminals.nil);
                return ACTION(() => C.astFactory.wrap({ args: [], distinct: false }, C.astFactory.sourceLocation(nil)));
            } },
        { ALT: () => {
                const args = [];
                const open = CONSUME(l.symbols.LParen);
                const distinct = OPTION(() => {
                    CONSUME(l.distinct);
                    return true;
                }) ?? false;
                AT_LEAST_ONE_SEP({
                    SEP: l.symbols.comma,
                    DEF: () => {
                        const arg = SUBRULE1(exports.expression);
                        args.push(arg);
                    },
                });
                const close = CONSUME(l.symbols.RParen);
                return ACTION(() => C.astFactory.wrap({ args, distinct }, C.astFactory.sourceLocation(open, close)));
            } },
    ]),
    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => {
            PRINT_WORD('(');
            if (ast.val.distinct) {
                PRINT_WORD('DISTINCT');
            }
        });
        const [head, ...tail] = ast.val.args;
        if (head) {
            SUBRULE(exports.expression, head);
        }
        for (const expr of tail) {
            F.printFilter(ast, () => PRINT_WORD(','));
            SUBRULE(exports.expression, expr);
        }
        F.printFilter(ast, () => PRINT_WORD(')'));
    },
};
/**
 * [[72]](https://www.w3.org/TR/sparql11-query/#rConstructTemplate)
 */
exports.expressionList = {
    name: 'expressionList',
    impl: ({ ACTION, CONSUME, MANY, OR, SUBRULE1, SUBRULE2 }) => C => OR([
        { ALT: () => {
                const nil = CONSUME(l.terminals.nil);
                return ACTION(() => C.astFactory.wrap([], C.astFactory.sourceLocation(nil)));
            } },
        { ALT: () => {
                const open = CONSUME(l.symbols.LParen);
                const expr1 = SUBRULE1(exports.expression);
                const args = [expr1];
                MANY(() => {
                    CONSUME(l.symbols.comma);
                    const expr = SUBRULE2(exports.expression);
                    args.push(expr);
                });
                const close = CONSUME(l.symbols.RParen);
                return ACTION(() => C.astFactory.wrap(args, C.astFactory.sourceLocation(open, close)));
            } },
    ]),
};
const infixOperators = new Set(['in', 'notin', '||', '&&', '=', '!=', '<', '>', '<=', '>=', '+', '-', '*', '/']);
const prefixOperator = { '!': '', uplus: '+', uminus: '-' };
/**
 * [[110]](https://www.w3.org/TR/sparql11-query/#rExpression)
 */
exports.expression = {
    name: 'expression',
    impl: ({ SUBRULE }) => () => SUBRULE(exports.conditionalOrExpression),
    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
        if (F.isTerm(ast)) {
            SUBRULE(general_js_1.varOrTerm, ast);
        }
        else if (F.isExpressionOperator(ast)) {
            if (infixOperators.has(ast.operator)) {
                const [left, ...right] = ast.args;
                F.printFilter(ast, () => PRINT_WORD('('));
                SUBRULE(exports.expression, left);
                F.printFilter(ast, () => {
                    if (ast.operator === 'notin') {
                        PRINT_WORD('NOT IN');
                    }
                    else if (ast.operator === 'in') {
                        PRINT_WORD('IN');
                    }
                    else {
                        PRINT_WORD(ast.operator.toUpperCase());
                    }
                });
                if (right.length === 1) {
                    SUBRULE(exports.expression, right[0]);
                }
                else {
                    SUBRULE(exports.argList, F.wrap({ args: right, distinct: false }, ast.loc));
                }
                F.printFilter(ast, () => PRINT_WORD(')'));
            }
            else if (typeof prefixOperator[ast.operator] === 'string') {
                const [expr] = ast.args;
                F.printFilter(ast, () => PRINT_WORD(prefixOperator[ast.operator] || ast.operator.toUpperCase()));
                SUBRULE(exports.expression, expr);
            }
            else {
                F.printFilter(ast, () => PRINT_WORD(ast.operator.toUpperCase(), '('));
                const [head, ...tail] = ast.args;
                if (head) {
                    SUBRULE(exports.expression, head);
                }
                for (const arg of tail) {
                    F.printFilter(ast, () => PRINT_WORD(','));
                    SUBRULE(exports.expression, arg);
                }
                F.printFilter(ast, () => PRINT_WORD(')'));
            }
        }
        else if (F.isExpressionPatternOperation(ast)) {
            const patterns = ast.args;
            F.printFilter(ast, () => PRINT_WORD(ast.operator === 'exists' ? 'EXISTS' : 'NOT EXISTS'));
            SUBRULE(whereClause_js_1.groupGraphPattern, patterns);
        }
        else if (F.isExpressionFunctionCall(ast)) {
            SUBRULE(exports.iriOrFunction, ast);
        }
        else if (F.isExpressionAggregate(ast)) {
            SUBRULE(builtIn_js_1.aggregate, ast);
        }
    },
};
function constructLeftDeep(startGenerator, restGenerator, ACTION, MANY) {
    // By using iterExpression, we avoid creating unnecessary arrays
    let iterExpr = startGenerator();
    MANY(() => {
        const res = restGenerator();
        ACTION(() => {
            iterExpr = res(iterExpr);
        });
    });
    return iterExpr;
}
/**
 * [[111]](https://www.w3.org/TR/sparql11-query/#rConditionalOrExpression)
 */
exports.conditionalOrExpression = {
    name: 'conditionalOrExpression',
    impl: ({ ACTION, MANY, CONSUME, SUBRULE1, SUBRULE2 }) => C => constructLeftDeep(() => SUBRULE1(exports.conditionalAndExpression), () => {
        CONSUME(l.symbols.logicOr);
        const args = SUBRULE2(exports.conditionalAndExpression);
        return left => ACTION(() => C.astFactory.expressionOperation('||', [left, args], C.astFactory.sourceLocation(left, args)));
    }, ACTION, MANY),
};
/**
 * [[112]](https://www.w3.org/TR/sparql11-query/#rConditionalAndExpression)
 */
exports.conditionalAndExpression = {
    name: 'conditionalAndExpression',
    impl: ({ ACTION, MANY, SUBRULE1, SUBRULE2, CONSUME }) => C => constructLeftDeep(() => SUBRULE1(exports.valueLogical), () => {
        CONSUME(l.symbols.logicAnd);
        const arg = SUBRULE2(exports.valueLogical);
        return left => ACTION(() => C.astFactory.expressionOperation('&&', [left, arg], C.astFactory.sourceLocation(left, arg)));
    }, ACTION, MANY),
};
/**
 * [[113]](https://www.w3.org/TR/sparql11-query/#rValueLogical)
 */
exports.valueLogical = {
    name: 'valueLogical',
    impl: ({ SUBRULE }) => () => SUBRULE(exports.relationalExpression),
};
/**
 * [[114]](https://www.w3.org/TR/sparql11-query/#rRelationalExpression)
 */
exports.relationalExpression = {
    name: 'relationalExpression',
    impl: ({ ACTION, CONSUME, SUBRULE1, SUBRULE2, OPTION, OR1, OR2, OR3 }) => (C) => {
        const args1 = SUBRULE1(exports.numericExpression);
        const expression = OPTION(() => OR1([
            { ALT: () => {
                    // Stay in numeric;
                    const operator = OR2([
                        { ALT: () => CONSUME(l.symbols.equal) },
                        { ALT: () => CONSUME(l.symbols.notEqual) },
                        { ALT: () => CONSUME(l.symbols.lessThan) },
                        { ALT: () => CONSUME(l.symbols.greaterThan) },
                        { ALT: () => CONSUME(l.symbols.lessThanEqual) },
                        { ALT: () => CONSUME(l.symbols.greaterThanEqual) },
                    ]);
                    const expr = SUBRULE2(exports.numericExpression);
                    return ACTION(() => C.astFactory.expressionOperation(operator.image, [args1, expr], C.astFactory.sourceLocation(args1, expr)));
                } },
            { ALT: () => {
                    const operator = OR3([
                        { ALT: () => CONSUME(l.in_) },
                        { ALT: () => CONSUME(l.notIn) },
                    ]);
                    const args = SUBRULE1(exports.expressionList);
                    return ACTION(() => C.astFactory.expressionOperation(operator.image, [args1, ...args.val], C.astFactory.sourceLocation(args1, args)));
                } },
        ]));
        return expression ?? args1;
    },
};
/**
 * [[115]](https://www.w3.org/TR/sparql11-query/#rNumericExpression)
 */
exports.numericExpression = {
    name: 'numericExpression',
    impl: ({ SUBRULE }) => () => SUBRULE(exports.additiveExpression),
};
/**
 * [[116]](https://www.w3.org/TR/sparql11-query/#rAdditiveExpression)
 */
exports.additiveExpression = {
    name: 'additiveExpression',
    impl: ({ ACTION, SUBRULE, CONSUME, SUBRULE1, SUBRULE2, MANY1, MANY2, OR1, OR2, OR3, OR4 }) => C => constructLeftDeep(() => SUBRULE1(exports.multiplicativeExpression), () => OR1([
        { ALT: () => {
                // Multiplicative expression as 2nd argument
                const operator = OR2([
                    { ALT: () => CONSUME(l.symbols.opPlus) },
                    { ALT: () => CONSUME(l.symbols.opMinus) },
                ]);
                const arg = SUBRULE2(exports.multiplicativeExpression);
                return ACTION(() => left => C.astFactory.expressionOperation(operator.image, [left, arg], C.astFactory.sourceLocation(left, arg)));
            } },
        { ALT: () => {
                // The operator of this alternative is actually parsed as part of the signed numeric literal. (note #6)
                const { operator, startInt } = OR3([
                    { ALT: () => {
                            // Note #6. No spaces are allowed between the sign and a number.
                            // In this rule however, we do not want to care about this.
                            const integer = SUBRULE(literals_js_1.numericLiteralPositive);
                            return ACTION(() => {
                                integer.value = integer.value.replace(/^\+/u, '');
                                return {
                                    operator: '+',
                                    startInt: integer,
                                };
                            });
                        } },
                    { ALT: () => {
                            const integer = SUBRULE(literals_js_1.numericLiteralNegative);
                            return ACTION(() => {
                                integer.value = integer.value.replace(/^-/u, '');
                                return {
                                    operator: '-',
                                    startInt: integer,
                                };
                            });
                        } },
                ]);
                const multiplicativeExpr = constructLeftDeep(() => ACTION(() => startInt), () => {
                    const innerOperator = OR4([
                        { ALT: () => CONSUME(l.symbols.star) },
                        { ALT: () => CONSUME(l.symbols.slash) },
                    ]);
                    const innerExpr = SUBRULE1(exports.unaryExpression);
                    return ACTION(() => leftInner => C.astFactory.expressionOperation(innerOperator.image, [leftInner, innerExpr], C.astFactory.sourceLocation(leftInner, innerExpr)));
                }, ACTION, MANY2);
                return left => C.astFactory.expressionOperation(operator, [left, multiplicativeExpr], C.astFactory.sourceLocation(left, multiplicativeExpr));
            } },
    ]), ACTION, MANY1),
};
/**
 * [[117]](https://www.w3.org/TR/sparql11-query/#rMultiplicativeExpression)
 */
exports.multiplicativeExpression = {
    name: 'multiplicativeExpression',
    impl: ({ ACTION, CONSUME, MANY, SUBRULE1, SUBRULE2, OR }) => C => constructLeftDeep(() => SUBRULE1(exports.unaryExpression), () => {
        const operator = OR([
            { ALT: () => CONSUME(l.symbols.star) },
            { ALT: () => CONSUME(l.symbols.slash) },
        ]);
        const expr = SUBRULE2(exports.unaryExpression);
        return (left) => ({
            type: 'expression',
            subType: 'operation',
            operator: operator.image,
            args: [left, expr],
            loc: C.astFactory.sourceLocation(left, expr),
        });
    }, ACTION, MANY),
};
/**
 * [[118]](https://www.w3.org/TR/sparql11-query/#rUnaryExpression)
 */
exports.unaryExpression = {
    name: 'unaryExpression',
    impl: ({ ACTION, CONSUME, SUBRULE1, SUBRULE2, OR1, OR2 }) => C => OR1([
        { ALT: () => SUBRULE1(exports.primaryExpression) },
        { ALT: () => {
                const operator = OR2([
                    { ALT: () => CONSUME(l.symbols.exclamation) },
                    { ALT: () => CONSUME(l.symbols.opPlus) },
                    { ALT: () => CONSUME(l.symbols.opMinus) },
                ]);
                const expr = SUBRULE2(exports.primaryExpression);
                return ACTION(() => C.astFactory.expressionOperation(operator.image === '!' ? '!' : (operator.image === '+' ? 'UPLUS' : 'UMINUS'), [expr], C.astFactory.sourceLocation(operator, expr)));
            } },
    ]),
};
/**
 * [[119]](https://www.w3.org/TR/sparql11-query/#rPrimaryExpression)
 */
exports.primaryExpression = {
    name: 'primaryExpression',
    impl: ({ SUBRULE, OR }) => () => OR([
        { ALT: () => SUBRULE(exports.brackettedExpression) },
        { ALT: () => SUBRULE(builtIn_js_1.builtInCall) },
        { ALT: () => SUBRULE(exports.iriOrFunction) },
        { ALT: () => SUBRULE(literals_js_1.rdfLiteral) },
        { ALT: () => SUBRULE(literals_js_1.numericLiteral) },
        { ALT: () => SUBRULE(literals_js_1.booleanLiteral) },
        { ALT: () => SUBRULE(general_js_1.var_) },
    ]),
};
/**
 * [[120]](https://www.w3.org/TR/sparql11-query/#rBrackettedExpression)
 */
exports.brackettedExpression = {
    name: 'brackettedExpression',
    impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
        const open = CONSUME(l.symbols.LParen);
        const expr = SUBRULE(exports.expression);
        const close = CONSUME(l.symbols.RParen);
        return ACTION(() => {
            expr.loc = C.astFactory.sourceLocation(open, close);
            return expr;
        });
    },
};
/**
 * [[128]](https://www.w3.org/TR/sparql11-query/#ririOrFunction)
 */
exports.iriOrFunction = {
    name: 'iriOrFunction',
    impl: ({ ACTION, SUBRULE, OPTION }) => (C) => {
        const iriVal = SUBRULE(literals_js_1.iri);
        const functionCall = OPTION(() => {
            const args = SUBRULE(exports.argList);
            return ACTION(() => {
                const distinct = args.val.distinct;
                if (!C.parseMode.has('canParseAggregate') && distinct) {
                    throw new Error(`DISTINCT implies that this function is an aggregated function, which is not allowed in this context.`);
                }
                return {
                    type: 'expression',
                    subType: 'functionCall',
                    function: iriVal,
                    args: args.val.args,
                    distinct,
                    loc: C.astFactory.sourceLocation(iriVal, args),
                };
            });
        });
        return functionCall ?? iriVal;
    },
    gImpl: ({ SUBRULE }) => (ast, { astFactory: F }) => {
        if (F.isTermNamed(ast)) {
            SUBRULE(literals_js_1.iri, ast);
        }
        else {
            SUBRULE(literals_js_1.iri, ast.function);
            SUBRULE(exports.argList, F.wrap({ args: ast.args, distinct: ast.distinct }, ast.loc));
        }
    },
};
//# sourceMappingURL=expression.js.map