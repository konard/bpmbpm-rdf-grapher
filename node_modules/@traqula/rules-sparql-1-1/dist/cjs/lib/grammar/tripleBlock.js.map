{"version":3,"file":"tripleBlock.js","sourceRoot":"","sources":["../../../../lib/grammar/tripleBlock.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IToken } from '@traqula/chevrotain';\nimport { traqulaIndentation } from '@traqula/core';\nimport * as l from '../lexer/index.js';\nimport type { SparqlGrammarRule, SparqlRule } from '../sparql11HelperTypes.js';\nimport type {\n  BasicGraphPattern,\n  GraphNode,\n  Path,\n  PatternBgp,\n  Term,\n  TermVariable,\n  TripleCollection,\n  TripleCollectionBlankNodeProperties,\n  TripleCollectionList,\n  TripleNesting,\n} from '../Sparql11types.js';\nimport { CommonIRIs } from '../utils.js';\nimport { var_, varOrTerm, verb } from './general.js';\nimport { path, pathGenerator } from './propertyPaths.js';\n\nfunction triplesDotSeperated(triplesSameSubjectSubrule: SparqlGrammarRule<string, BasicGraphPattern>):\nSparqlGrammarRule<string, PatternBgp>['impl'] {\n  return ({ ACTION, AT_LEAST_ONE, SUBRULE, CONSUME, OPTION }) => (C) => {\n    const triples: BasicGraphPattern = [];\n\n    let parsedDot = true;\n    let dotToken: undefined | IToken;\n    AT_LEAST_ONE({\n      GATE: () => parsedDot,\n      DEF: () => {\n        parsedDot = false;\n        const template = SUBRULE(triplesSameSubjectSubrule);\n        ACTION(() => {\n          triples.push(...template);\n        });\n        OPTION(() => {\n          dotToken = CONSUME(l.symbols.dot);\n          parsedDot = true;\n        });\n      },\n    });\n    return ACTION(() => C.astFactory.patternBgp(triples, C.astFactory.sourceLocation(...triples, dotToken)));\n  };\n}\n\n/**\n * [[55]](https://www.w3.org/TR/sparql11-query/#rTriplesBlock)\n */\nexport const triplesBlock: SparqlRule<'triplesBlock', PatternBgp> = <const>{\n  name: 'triplesBlock',\n  impl: implArgs => C => triplesDotSeperated(triplesSameSubjectPath)(implArgs)(C),\n  gImpl: ({ SUBRULE, PRINT_WORD, HANDLE_LOC, NEW_LINE }) => (ast, { astFactory: F }) => {\n    for (const [ index, triple ] of ast.triples.entries()) {\n      HANDLE_LOC(triple, () => {\n        const nextTriple = ast.triples.at(index + 1);\n        if (F.isTripleCollection(triple)) {\n          SUBRULE(graphNodePath, triple);\n          // A top level tripleCollection block means that it is either not used in a triple\n          //   - or is the subject of a triple. In case it is the subject,\n          //   the identifier of the block will be the subject of the next triple and that subject is not materialized.\n          const isSubjectOfTriple = nextTriple?.type === 'triple' &&\n            F.isSourceLocationNoMaterialize(nextTriple.subject.loc);\n          if (!isSubjectOfTriple) {\n            F.printFilter(triple, () => {\n              PRINT_WORD('.');\n              NEW_LINE();\n            });\n          }\n        } else {\n          // Subject\n          SUBRULE(graphNodePath, triple.subject);\n          F.printFilter(triple, () => PRINT_WORD(''));\n          // Predicate\n          if (F.isTerm(triple.predicate) && F.isTermVariable(triple.predicate)) {\n            SUBRULE(varOrTerm, triple.predicate);\n          } else {\n            SUBRULE(pathGenerator, triple.predicate, undefined);\n          }\n          F.printFilter(triple, () => PRINT_WORD(''));\n          // Object\n          SUBRULE(graphNodePath, triple.object);\n\n          // If no more things, or a top level collection (only possible if new block was part), or new subject: add DOT\n          if (nextTriple === undefined || F.isTripleCollection(nextTriple) ||\n            !F.isSourceLocationNoMaterialize(nextTriple.subject.loc)) {\n            F.printFilter(ast, () => {\n              PRINT_WORD('.');\n              NEW_LINE();\n            });\n          } else if (F.isSourceLocationNoMaterialize(nextTriple.predicate.loc)) {\n            F.printFilter(ast, () => PRINT_WORD(','));\n          } else {\n            F.printFilter(ast, () => {\n              PRINT_WORD(';');\n              NEW_LINE();\n            });\n          }\n        }\n      });\n    }\n  },\n};\n\n/**\n * [[75]](https://www.w3.org/TR/sparql11-query/#rTriplesSameSubject)\n * [[81]](https://www.w3.org/TR/sparql11-query/#rTriplesSameSubjectPath)\n * CONTRACT: triples generated from the subject come first, then comes the main triple,\n *  and then come the triples from the object. Only the first occurrence of a term has `SourceLocationType = source`\n */\nfunction triplesSameSubjectImpl<T extends string>(name: T, allowPaths: boolean):\nSparqlGrammarRule<T, BasicGraphPattern> {\n  return <const> {\n    name,\n    impl: ({ ACTION, SUBRULE, OR }) => C => OR<BasicGraphPattern>([\n      { ALT: () => {\n        const subject = SUBRULE(varOrTerm);\n        const res = SUBRULE(\n          allowPaths ? propertyListPathNotEmpty : propertyListNotEmpty,\n          ACTION(() => C.astFactory.dematerialized(subject)),\n        );\n        // Only the first occurrence of a subject is actually materialized.\n        return ACTION(() => {\n          if (res.length > 0) {\n            res[0].subject = subject;\n            res[0].loc = C.astFactory.sourceLocation(subject, res[0]);\n          }\n          return res;\n        });\n      } },\n      { ALT: () => {\n        const subjectNode = SUBRULE(allowPaths ? triplesNodePath : triplesNode);\n        const restNode = SUBRULE(\n          allowPaths ? propertyListPath : propertyList,\n          ACTION(() => C.astFactory.graphNodeIdentifier(subjectNode)),\n        );\n        return ACTION(() => {\n          if (restNode.length === 0) {\n            return [ subjectNode ];\n          }\n          restNode[0].subject = subjectNode;\n          restNode[0].loc = C.astFactory.sourceLocation(subjectNode, restNode[0]);\n          return restNode;\n        });\n      } },\n    ]),\n  };\n}\nexport const triplesSameSubject = triplesSameSubjectImpl('triplesSameSubject', false);\nexport const triplesSameSubjectPath = triplesSameSubjectImpl('triplesSameSubjectPath', true);\n\n/**\n * [[52]](https://www.w3.org/TR/sparql11-query/#rTriplesTemplate)\n */\nexport const triplesTemplate: SparqlGrammarRule<'triplesTemplate', PatternBgp> = <const> {\n  name: 'triplesTemplate',\n  impl: triplesDotSeperated(triplesSameSubject),\n};\n\n/**\n * [[76]](https://www.w3.org/TR/sparql11-query/#rPropertyList)\n * [[82]](https://www.w3.org/TR/sparql11-query/#rPropertyListPath)\n */\nfunction propertyListImpl<T extends string>(name: T, allowPaths: boolean):\nSparqlGrammarRule<T, TripleNesting[], [TripleNesting['subject']]> {\n  return {\n    name,\n    impl: ({ SUBRULE, OPTION }) => (_, subject) =>\n      OPTION(() => SUBRULE(allowPaths ? propertyListPathNotEmpty : propertyListNotEmpty, subject)) ?? [],\n  };\n}\nexport const propertyList = propertyListImpl('propertyList', false);\nexport const propertyListPath = propertyListImpl('propertyListPath', true);\n\n// We could use gates for this, but in that case,\n// a grammar not in need of paths would still have to include the path rules\n/**\n * [[77]](https://www.w3.org/TR/sparql11-query/#rPropertyListNotEmpty)\n * [[83]](https://www.w3.org/TR/sparql11-query/#rPropertyListPathNotEmpty)\n */\nfunction propertyListNotEmptyImplementation<T extends string>(\n  name: T,\n  allowPaths: boolean,\n): SparqlGrammarRule<T, TripleNesting[], [TripleNesting['subject']]> {\n  return {\n    name,\n    impl: ({ ACTION, CONSUME, AT_LEAST_ONE, SUBRULE1, MANY2, OR1 }) => (_, subject) => {\n      const result: TripleNesting[] = [];\n      let parsedSemi = true;\n\n      AT_LEAST_ONE({\n        GATE: () => parsedSemi,\n        DEF: () => {\n          parsedSemi = false;\n          const predicate = allowPaths ?\n            OR1<TermVariable | Path>([\n              { ALT: () => SUBRULE1(verbPath) },\n              { ALT: () => SUBRULE1(verbSimple) },\n            ]) :\n            SUBRULE1(verb);\n          const triples = SUBRULE1(\n            allowPaths ? objectListPath : objectList,\n            subject,\n            predicate,\n          );\n\n          MANY2(() => {\n            CONSUME(l.symbols.semi);\n            parsedSemi = true;\n          });\n\n          ACTION(() => {\n            result.push(...triples);\n          });\n        },\n      });\n      return result;\n    },\n  };\n}\nexport const propertyListNotEmpty = propertyListNotEmptyImplementation('propertyListNotEmpty', false);\nexport const propertyListPathNotEmpty = propertyListNotEmptyImplementation('propertyListPathNotEmpty', true);\n\n/**\n * [[84]](https://www.w3.org/TR/sparql11-query/#rVerbPath)\n */\nexport const verbPath: SparqlGrammarRule<'verbPath', Path> = <const> {\n  name: 'verbPath',\n  impl: ({ SUBRULE }) => () => SUBRULE(path),\n};\n\n/**\n * [[85]](https://www.w3.org/TR/sparql11-query/#rVerbSimple)\n */\nexport const verbSimple: SparqlGrammarRule<'verbSimple', TermVariable> = <const> {\n  name: 'verbSimple',\n  impl: ({ SUBRULE }) => () => SUBRULE(var_),\n};\n\n/**\n * [[79]](https://www.w3.org/TR/sparql11-query/#rObjectList)\n * [[86]](https://www.w3.org/TR/sparql11-query/#rObjectListPath)\n */\nfunction objectListImpl<T extends string>(name: T, allowPaths: boolean):\nSparqlGrammarRule<T, TripleNesting[], [TripleNesting['subject'], TripleNesting['predicate']]> {\n  return <const> {\n    name,\n    impl: ({ ACTION, SUBRULE, AT_LEAST_ONE_SEP }) => (_, subj, pred) => {\n      const objects: TripleNesting[] = [];\n      AT_LEAST_ONE_SEP({\n        SEP: l.symbols.comma,\n        DEF: () => {\n          const objectTriple = SUBRULE(allowPaths ? objectPath : object, subj, pred);\n          ACTION(() => {\n            objects.push(objectTriple);\n          });\n        },\n      });\n      return objects;\n    },\n  };\n}\nexport const objectList = objectListImpl('objectList', false);\nexport const objectListPath = objectListImpl('objectListPath', true);\n\n/**\n * [[80]](https://www.w3.org/TR/sparql11-query/#rObject)\n * [[87]](https://www.w3.org/TR/sparql11-query/#rObjectPath)\n */\nfunction objectImpl<T extends string>(name: T, allowPaths: boolean):\nSparqlGrammarRule<T, TripleNesting, [TripleNesting['subject'], TripleNesting['predicate']]> {\n  return {\n    name,\n    impl: ({ ACTION, SUBRULE }) => (C, subject, predicate) => {\n      const node = SUBRULE(allowPaths ? graphNodePath : graphNode);\n      return ACTION(() =>\n        C.astFactory.triple(subject, predicate, node));\n    },\n  };\n}\nexport const object = objectImpl('object', false);\nexport const objectPath = objectImpl('objectPath', true);\n\n/**\n * [[102]](https://www.w3.org/TR/sparql11-query/#rCollection)\n * [[103]](https://www.w3.org/TR/sparql11-query/#rCollectionPath)\n */\nfunction collectionImpl<T extends string>(name: T, allowPaths: boolean): SparqlRule<T, TripleCollectionList> {\n  return {\n    name,\n    impl: ({ ACTION, AT_LEAST_ONE, SUBRULE, CONSUME }) => (C) => {\n      // Construct a [cons list](https://en.wikipedia.org/wiki/Cons#Lists),\n      // here called a [RDF collection](https://www.w3.org/TR/sparql11-query/#collections).\n      const terms: GraphNode[] = [];\n\n      const startToken = CONSUME(l.symbols.LParen);\n\n      AT_LEAST_ONE(() => {\n        terms.push(SUBRULE(allowPaths ? graphNodePath : graphNode));\n      });\n      const endToken = CONSUME(l.symbols.RParen);\n\n      return ACTION(() => {\n        const F = C.astFactory;\n        const triples: TripleNesting[] = [];\n        // The triples created in your recursion\n        const predFirst = F.termNamed(F.sourceLocation(), CommonIRIs.FIRST, undefined);\n        const predRest = F.termNamed(F.sourceLocation(), CommonIRIs.REST, undefined);\n        const predNil = F.termNamed(F.sourceLocation(), CommonIRIs.NIL, undefined);\n\n        const listHead = F.termBlank(undefined, F.sourceLocation());\n        let iterHead: TripleNesting['object'] = listHead;\n        for (const [ index, term ] of terms.entries()) {\n          const lastInList = index === terms.length - 1;\n\n          const headTriple: TripleNesting = F.triple(\n            iterHead,\n            predFirst,\n            term,\n          );\n          triples.push(headTriple);\n\n          // If not the last, create new iterHead, otherwise, close list\n          if (lastInList) {\n            const nilTriple: TripleNesting = F.triple(iterHead, predRest, predNil);\n            triples.push(nilTriple);\n          } else {\n            const tail = F.termBlank(undefined, F.sourceLocation());\n            const linkTriple: TripleNesting = F.triple(iterHead, predRest, tail);\n            triples.push(linkTriple);\n            iterHead = tail;\n          }\n        }\n        return F.tripleCollectionList(listHead, triples, F.sourceLocation(startToken, endToken));\n      });\n    },\n    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {\n      F.printFilter(ast, () => PRINT_WORD('('));\n      // Only every 2 triple is relevant. The odd triples are linking triples.\n      for (const [ idx, triple ] of ast.triples.entries()) {\n        if (idx % 2 === 0) {\n          SUBRULE(allowPaths ? graphNodePath : graphNode, triple.object);\n        }\n      }\n      F.printFilter(ast, () => PRINT_WORD(')'));\n    },\n  };\n}\nexport const collection = collectionImpl('collection', false);\nexport const collectionPath = collectionImpl('collectionPath', true);\n\n/**\n * [[98]](https://www.w3.org/TR/sparql11-query/#rTriplesNode)\n * [[100]](https://www.w3.org/TR/sparql11-query/#rTriplesNodePath)\n */\nfunction triplesNodeImpl<T extends string>(name: T, allowPaths: boolean): SparqlRule<T, TripleCollection> {\n  return <const>{\n    name,\n    impl: ({ SUBRULE, OR }) => () => OR<TripleCollection>([\n      { ALT: () => SUBRULE(allowPaths ? collectionPath : collection) },\n      { ALT: () => SUBRULE(allowPaths ? blankNodePropertyListPath : blankNodePropertyList) },\n    ]),\n    gImpl: ({ SUBRULE }) => ast => ast.subType === 'list' ?\n      SUBRULE(allowPaths ? collectionPath : collection, ast) :\n      SUBRULE(allowPaths ? blankNodePropertyListPath : blankNodePropertyList, ast),\n  };\n}\nexport const triplesNode = triplesNodeImpl('triplesNode', false);\nexport const triplesNodePath = triplesNodeImpl('triplesNodePath', true);\n\n/**\n * [[99]](https://www.w3.org/TR/sparql11-query/#rBlankNodePropertyList)\n * [[101]](https://www.w3.org/TR/sparql11-query/#rBlankNodePropertyListPath)\n */\nfunction blankNodePropertyListImpl<T extends string>(name: T, allowPaths: boolean):\nSparqlRule<T, TripleCollectionBlankNodeProperties> {\n  const propertyPathNotEmptyImpl = allowPaths ? propertyListPathNotEmpty : propertyListNotEmpty;\n  return {\n    name,\n    impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {\n      const startToken = CONSUME(l.symbols.LSquare);\n\n      const blankNode = ACTION(() =>\n        C.astFactory.termBlank(undefined, C.astFactory.sourceLocation()));\n\n      const propList = SUBRULE(propertyPathNotEmptyImpl, blankNode);\n      const endToken = CONSUME(l.symbols.RSquare);\n\n      return ACTION(() => C.astFactory.tripleCollectionBlankNodeProperties(\n        blankNode,\n        propList,\n        C.astFactory.sourceLocation(startToken, endToken),\n      ));\n    },\n    gImpl: ({ SUBRULE, PRINT, PRINT_WORD, HANDLE_LOC, PRINT_ON_EMPTY, NEW_LINE }) => (ast, c) => {\n      const { astFactory: F, indentInc } = c;\n      F.printFilter(ast, () => {\n        c[traqulaIndentation] += indentInc;\n        PRINT('[');\n        NEW_LINE();\n      });\n      for (const triple of ast.triples) {\n        HANDLE_LOC(triple, () => {\n          // Predicate\n          if (F.isTerm(triple.predicate) && F.isTermVariable(triple.predicate)) {\n            SUBRULE(varOrTerm, triple.predicate);\n          } else {\n            SUBRULE(pathGenerator, triple.predicate, undefined);\n          }\n          F.printFilter(triple, () => PRINT_WORD(''));\n          // Object\n          SUBRULE(graphNodePath, triple.object);\n\n          F.printFilter(ast, () => {\n            PRINT_WORD(';');\n            NEW_LINE();\n          });\n        });\n      }\n      F.printFilter(ast, () => {\n        c[traqulaIndentation] -= indentInc;\n        PRINT_ON_EMPTY(']');\n      });\n    },\n  };\n}\nexport const blankNodePropertyList = blankNodePropertyListImpl('blankNodePropertyList', false);\nexport const blankNodePropertyListPath = blankNodePropertyListImpl('blankNodePropertyListPath', true);\n\n/**\n * [[103]](https://www.w3.org/TR/sparql11-query/#rGraphNode)\n * [[105]](https://www.w3.org/TR/sparql11-query/#rGraphNodePath)\n */\nfunction graphNodeImpl<T extends string>(name: T, allowPaths: boolean): SparqlRule<T, Term | TripleCollection> {\n  const triplesNodeRule = allowPaths ? triplesNodePath : triplesNode;\n  return {\n    name,\n    impl: ({ SUBRULE, OR }) => C => OR<Term | TripleCollection>([\n      { ALT: () => SUBRULE(varOrTerm) },\n      {\n        GATE: () => C.parseMode.has('canCreateBlankNodes'),\n        ALT: () => SUBRULE(triplesNodeRule),\n      },\n    ]),\n    gImpl: ({ SUBRULE }) => (ast, { astFactory: F }) => {\n      if (F.isTerm(ast)) {\n        SUBRULE(varOrTerm, ast);\n      } else {\n        SUBRULE(triplesNodeRule, ast);\n      }\n    },\n  };\n}\nexport const graphNode = graphNodeImpl('graphNode', false);\nexport const graphNodePath = graphNodeImpl('graphNodePath', true);\n"]}