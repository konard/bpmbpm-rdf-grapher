"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.graphNodePath = exports.graphNode = exports.blankNodePropertyListPath = exports.blankNodePropertyList = exports.triplesNodePath = exports.triplesNode = exports.collectionPath = exports.collection = exports.objectPath = exports.object = exports.objectListPath = exports.objectList = exports.verbSimple = exports.verbPath = exports.propertyListPathNotEmpty = exports.propertyListNotEmpty = exports.propertyListPath = exports.propertyList = exports.triplesTemplate = exports.triplesSameSubjectPath = exports.triplesSameSubject = exports.triplesBlock = void 0;
const core_1 = require("@traqula/core");
const l = __importStar(require("../lexer/index.js"));
const utils_js_1 = require("../utils.js");
const general_js_1 = require("./general.js");
const propertyPaths_js_1 = require("./propertyPaths.js");
function triplesDotSeperated(triplesSameSubjectSubrule) {
    return ({ ACTION, AT_LEAST_ONE, SUBRULE, CONSUME, OPTION }) => (C) => {
        const triples = [];
        let parsedDot = true;
        let dotToken;
        AT_LEAST_ONE({
            GATE: () => parsedDot,
            DEF: () => {
                parsedDot = false;
                const template = SUBRULE(triplesSameSubjectSubrule);
                ACTION(() => {
                    triples.push(...template);
                });
                OPTION(() => {
                    dotToken = CONSUME(l.symbols.dot);
                    parsedDot = true;
                });
            },
        });
        return ACTION(() => C.astFactory.patternBgp(triples, C.astFactory.sourceLocation(...triples, dotToken)));
    };
}
/**
 * [[55]](https://www.w3.org/TR/sparql11-query/#rTriplesBlock)
 */
exports.triplesBlock = {
    name: 'triplesBlock',
    impl: implArgs => C => triplesDotSeperated(exports.triplesSameSubjectPath)(implArgs)(C),
    gImpl: ({ SUBRULE, PRINT_WORD, HANDLE_LOC, NEW_LINE }) => (ast, { astFactory: F }) => {
        for (const [index, triple] of ast.triples.entries()) {
            HANDLE_LOC(triple, () => {
                const nextTriple = ast.triples.at(index + 1);
                if (F.isTripleCollection(triple)) {
                    SUBRULE(exports.graphNodePath, triple);
                    // A top level tripleCollection block means that it is either not used in a triple
                    //   - or is the subject of a triple. In case it is the subject,
                    //   the identifier of the block will be the subject of the next triple and that subject is not materialized.
                    const isSubjectOfTriple = nextTriple?.type === 'triple' &&
                        F.isSourceLocationNoMaterialize(nextTriple.subject.loc);
                    if (!isSubjectOfTriple) {
                        F.printFilter(triple, () => {
                            PRINT_WORD('.');
                            NEW_LINE();
                        });
                    }
                }
                else {
                    // Subject
                    SUBRULE(exports.graphNodePath, triple.subject);
                    F.printFilter(triple, () => PRINT_WORD(''));
                    // Predicate
                    if (F.isTerm(triple.predicate) && F.isTermVariable(triple.predicate)) {
                        SUBRULE(general_js_1.varOrTerm, triple.predicate);
                    }
                    else {
                        SUBRULE(propertyPaths_js_1.pathGenerator, triple.predicate, undefined);
                    }
                    F.printFilter(triple, () => PRINT_WORD(''));
                    // Object
                    SUBRULE(exports.graphNodePath, triple.object);
                    // If no more things, or a top level collection (only possible if new block was part), or new subject: add DOT
                    if (nextTriple === undefined || F.isTripleCollection(nextTriple) ||
                        !F.isSourceLocationNoMaterialize(nextTriple.subject.loc)) {
                        F.printFilter(ast, () => {
                            PRINT_WORD('.');
                            NEW_LINE();
                        });
                    }
                    else if (F.isSourceLocationNoMaterialize(nextTriple.predicate.loc)) {
                        F.printFilter(ast, () => PRINT_WORD(','));
                    }
                    else {
                        F.printFilter(ast, () => {
                            PRINT_WORD(';');
                            NEW_LINE();
                        });
                    }
                }
            });
        }
    },
};
/**
 * [[75]](https://www.w3.org/TR/sparql11-query/#rTriplesSameSubject)
 * [[81]](https://www.w3.org/TR/sparql11-query/#rTriplesSameSubjectPath)
 * CONTRACT: triples generated from the subject come first, then comes the main triple,
 *  and then come the triples from the object. Only the first occurrence of a term has `SourceLocationType = source`
 */
function triplesSameSubjectImpl(name, allowPaths) {
    return {
        name,
        impl: ({ ACTION, SUBRULE, OR }) => C => OR([
            { ALT: () => {
                    const subject = SUBRULE(general_js_1.varOrTerm);
                    const res = SUBRULE(allowPaths ? exports.propertyListPathNotEmpty : exports.propertyListNotEmpty, ACTION(() => C.astFactory.dematerialized(subject)));
                    // Only the first occurrence of a subject is actually materialized.
                    return ACTION(() => {
                        if (res.length > 0) {
                            res[0].subject = subject;
                            res[0].loc = C.astFactory.sourceLocation(subject, res[0]);
                        }
                        return res;
                    });
                } },
            { ALT: () => {
                    const subjectNode = SUBRULE(allowPaths ? exports.triplesNodePath : exports.triplesNode);
                    const restNode = SUBRULE(allowPaths ? exports.propertyListPath : exports.propertyList, ACTION(() => C.astFactory.graphNodeIdentifier(subjectNode)));
                    return ACTION(() => {
                        if (restNode.length === 0) {
                            return [subjectNode];
                        }
                        restNode[0].subject = subjectNode;
                        restNode[0].loc = C.astFactory.sourceLocation(subjectNode, restNode[0]);
                        return restNode;
                    });
                } },
        ]),
    };
}
exports.triplesSameSubject = triplesSameSubjectImpl('triplesSameSubject', false);
exports.triplesSameSubjectPath = triplesSameSubjectImpl('triplesSameSubjectPath', true);
/**
 * [[52]](https://www.w3.org/TR/sparql11-query/#rTriplesTemplate)
 */
exports.triplesTemplate = {
    name: 'triplesTemplate',
    impl: triplesDotSeperated(exports.triplesSameSubject),
};
/**
 * [[76]](https://www.w3.org/TR/sparql11-query/#rPropertyList)
 * [[82]](https://www.w3.org/TR/sparql11-query/#rPropertyListPath)
 */
function propertyListImpl(name, allowPaths) {
    return {
        name,
        impl: ({ SUBRULE, OPTION }) => (_, subject) => OPTION(() => SUBRULE(allowPaths ? exports.propertyListPathNotEmpty : exports.propertyListNotEmpty, subject)) ?? [],
    };
}
exports.propertyList = propertyListImpl('propertyList', false);
exports.propertyListPath = propertyListImpl('propertyListPath', true);
// We could use gates for this, but in that case,
// a grammar not in need of paths would still have to include the path rules
/**
 * [[77]](https://www.w3.org/TR/sparql11-query/#rPropertyListNotEmpty)
 * [[83]](https://www.w3.org/TR/sparql11-query/#rPropertyListPathNotEmpty)
 */
function propertyListNotEmptyImplementation(name, allowPaths) {
    return {
        name,
        impl: ({ ACTION, CONSUME, AT_LEAST_ONE, SUBRULE1, MANY2, OR1 }) => (_, subject) => {
            const result = [];
            let parsedSemi = true;
            AT_LEAST_ONE({
                GATE: () => parsedSemi,
                DEF: () => {
                    parsedSemi = false;
                    const predicate = allowPaths ?
                        OR1([
                            { ALT: () => SUBRULE1(exports.verbPath) },
                            { ALT: () => SUBRULE1(exports.verbSimple) },
                        ]) :
                        SUBRULE1(general_js_1.verb);
                    const triples = SUBRULE1(allowPaths ? exports.objectListPath : exports.objectList, subject, predicate);
                    MANY2(() => {
                        CONSUME(l.symbols.semi);
                        parsedSemi = true;
                    });
                    ACTION(() => {
                        result.push(...triples);
                    });
                },
            });
            return result;
        },
    };
}
exports.propertyListNotEmpty = propertyListNotEmptyImplementation('propertyListNotEmpty', false);
exports.propertyListPathNotEmpty = propertyListNotEmptyImplementation('propertyListPathNotEmpty', true);
/**
 * [[84]](https://www.w3.org/TR/sparql11-query/#rVerbPath)
 */
exports.verbPath = {
    name: 'verbPath',
    impl: ({ SUBRULE }) => () => SUBRULE(propertyPaths_js_1.path),
};
/**
 * [[85]](https://www.w3.org/TR/sparql11-query/#rVerbSimple)
 */
exports.verbSimple = {
    name: 'verbSimple',
    impl: ({ SUBRULE }) => () => SUBRULE(general_js_1.var_),
};
/**
 * [[79]](https://www.w3.org/TR/sparql11-query/#rObjectList)
 * [[86]](https://www.w3.org/TR/sparql11-query/#rObjectListPath)
 */
function objectListImpl(name, allowPaths) {
    return {
        name,
        impl: ({ ACTION, SUBRULE, AT_LEAST_ONE_SEP }) => (_, subj, pred) => {
            const objects = [];
            AT_LEAST_ONE_SEP({
                SEP: l.symbols.comma,
                DEF: () => {
                    const objectTriple = SUBRULE(allowPaths ? exports.objectPath : exports.object, subj, pred);
                    ACTION(() => {
                        objects.push(objectTriple);
                    });
                },
            });
            return objects;
        },
    };
}
exports.objectList = objectListImpl('objectList', false);
exports.objectListPath = objectListImpl('objectListPath', true);
/**
 * [[80]](https://www.w3.org/TR/sparql11-query/#rObject)
 * [[87]](https://www.w3.org/TR/sparql11-query/#rObjectPath)
 */
function objectImpl(name, allowPaths) {
    return {
        name,
        impl: ({ ACTION, SUBRULE }) => (C, subject, predicate) => {
            const node = SUBRULE(allowPaths ? exports.graphNodePath : exports.graphNode);
            return ACTION(() => C.astFactory.triple(subject, predicate, node));
        },
    };
}
exports.object = objectImpl('object', false);
exports.objectPath = objectImpl('objectPath', true);
/**
 * [[102]](https://www.w3.org/TR/sparql11-query/#rCollection)
 * [[103]](https://www.w3.org/TR/sparql11-query/#rCollectionPath)
 */
function collectionImpl(name, allowPaths) {
    return {
        name,
        impl: ({ ACTION, AT_LEAST_ONE, SUBRULE, CONSUME }) => (C) => {
            // Construct a [cons list](https://en.wikipedia.org/wiki/Cons#Lists),
            // here called a [RDF collection](https://www.w3.org/TR/sparql11-query/#collections).
            const terms = [];
            const startToken = CONSUME(l.symbols.LParen);
            AT_LEAST_ONE(() => {
                terms.push(SUBRULE(allowPaths ? exports.graphNodePath : exports.graphNode));
            });
            const endToken = CONSUME(l.symbols.RParen);
            return ACTION(() => {
                const F = C.astFactory;
                const triples = [];
                // The triples created in your recursion
                const predFirst = F.termNamed(F.sourceLocation(), utils_js_1.CommonIRIs.FIRST, undefined);
                const predRest = F.termNamed(F.sourceLocation(), utils_js_1.CommonIRIs.REST, undefined);
                const predNil = F.termNamed(F.sourceLocation(), utils_js_1.CommonIRIs.NIL, undefined);
                const listHead = F.termBlank(undefined, F.sourceLocation());
                let iterHead = listHead;
                for (const [index, term] of terms.entries()) {
                    const lastInList = index === terms.length - 1;
                    const headTriple = F.triple(iterHead, predFirst, term);
                    triples.push(headTriple);
                    // If not the last, create new iterHead, otherwise, close list
                    if (lastInList) {
                        const nilTriple = F.triple(iterHead, predRest, predNil);
                        triples.push(nilTriple);
                    }
                    else {
                        const tail = F.termBlank(undefined, F.sourceLocation());
                        const linkTriple = F.triple(iterHead, predRest, tail);
                        triples.push(linkTriple);
                        iterHead = tail;
                    }
                }
                return F.tripleCollectionList(listHead, triples, F.sourceLocation(startToken, endToken));
            });
        },
        gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
            F.printFilter(ast, () => PRINT_WORD('('));
            // Only every 2 triple is relevant. The odd triples are linking triples.
            for (const [idx, triple] of ast.triples.entries()) {
                if (idx % 2 === 0) {
                    SUBRULE(allowPaths ? exports.graphNodePath : exports.graphNode, triple.object);
                }
            }
            F.printFilter(ast, () => PRINT_WORD(')'));
        },
    };
}
exports.collection = collectionImpl('collection', false);
exports.collectionPath = collectionImpl('collectionPath', true);
/**
 * [[98]](https://www.w3.org/TR/sparql11-query/#rTriplesNode)
 * [[100]](https://www.w3.org/TR/sparql11-query/#rTriplesNodePath)
 */
function triplesNodeImpl(name, allowPaths) {
    return {
        name,
        impl: ({ SUBRULE, OR }) => () => OR([
            { ALT: () => SUBRULE(allowPaths ? exports.collectionPath : exports.collection) },
            { ALT: () => SUBRULE(allowPaths ? exports.blankNodePropertyListPath : exports.blankNodePropertyList) },
        ]),
        gImpl: ({ SUBRULE }) => ast => ast.subType === 'list' ?
            SUBRULE(allowPaths ? exports.collectionPath : exports.collection, ast) :
            SUBRULE(allowPaths ? exports.blankNodePropertyListPath : exports.blankNodePropertyList, ast),
    };
}
exports.triplesNode = triplesNodeImpl('triplesNode', false);
exports.triplesNodePath = triplesNodeImpl('triplesNodePath', true);
/**
 * [[99]](https://www.w3.org/TR/sparql11-query/#rBlankNodePropertyList)
 * [[101]](https://www.w3.org/TR/sparql11-query/#rBlankNodePropertyListPath)
 */
function blankNodePropertyListImpl(name, allowPaths) {
    const propertyPathNotEmptyImpl = allowPaths ? exports.propertyListPathNotEmpty : exports.propertyListNotEmpty;
    return {
        name,
        impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
            const startToken = CONSUME(l.symbols.LSquare);
            const blankNode = ACTION(() => C.astFactory.termBlank(undefined, C.astFactory.sourceLocation()));
            const propList = SUBRULE(propertyPathNotEmptyImpl, blankNode);
            const endToken = CONSUME(l.symbols.RSquare);
            return ACTION(() => C.astFactory.tripleCollectionBlankNodeProperties(blankNode, propList, C.astFactory.sourceLocation(startToken, endToken)));
        },
        gImpl: ({ SUBRULE, PRINT, PRINT_WORD, HANDLE_LOC, PRINT_ON_EMPTY, NEW_LINE }) => (ast, c) => {
            const { astFactory: F, indentInc } = c;
            F.printFilter(ast, () => {
                c[core_1.traqulaIndentation] += indentInc;
                PRINT('[');
                NEW_LINE();
            });
            for (const triple of ast.triples) {
                HANDLE_LOC(triple, () => {
                    // Predicate
                    if (F.isTerm(triple.predicate) && F.isTermVariable(triple.predicate)) {
                        SUBRULE(general_js_1.varOrTerm, triple.predicate);
                    }
                    else {
                        SUBRULE(propertyPaths_js_1.pathGenerator, triple.predicate, undefined);
                    }
                    F.printFilter(triple, () => PRINT_WORD(''));
                    // Object
                    SUBRULE(exports.graphNodePath, triple.object);
                    F.printFilter(ast, () => {
                        PRINT_WORD(';');
                        NEW_LINE();
                    });
                });
            }
            F.printFilter(ast, () => {
                c[core_1.traqulaIndentation] -= indentInc;
                PRINT_ON_EMPTY(']');
            });
        },
    };
}
exports.blankNodePropertyList = blankNodePropertyListImpl('blankNodePropertyList', false);
exports.blankNodePropertyListPath = blankNodePropertyListImpl('blankNodePropertyListPath', true);
/**
 * [[103]](https://www.w3.org/TR/sparql11-query/#rGraphNode)
 * [[105]](https://www.w3.org/TR/sparql11-query/#rGraphNodePath)
 */
function graphNodeImpl(name, allowPaths) {
    const triplesNodeRule = allowPaths ? exports.triplesNodePath : exports.triplesNode;
    return {
        name,
        impl: ({ SUBRULE, OR }) => C => OR([
            { ALT: () => SUBRULE(general_js_1.varOrTerm) },
            {
                GATE: () => C.parseMode.has('canCreateBlankNodes'),
                ALT: () => SUBRULE(triplesNodeRule),
            },
        ]),
        gImpl: ({ SUBRULE }) => (ast, { astFactory: F }) => {
            if (F.isTerm(ast)) {
                SUBRULE(general_js_1.varOrTerm, ast);
            }
            else {
                SUBRULE(triplesNodeRule, ast);
            }
        },
    };
}
exports.graphNode = graphNodeImpl('graphNode', false);
exports.graphNodePath = graphNodeImpl('graphNodePath', true);
//# sourceMappingURL=tripleBlock.js.map