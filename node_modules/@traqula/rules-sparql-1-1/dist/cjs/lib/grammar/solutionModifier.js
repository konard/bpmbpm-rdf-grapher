"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.offsetClause = exports.limitClause = exports.limitOffsetClauses = exports.orderCondition = exports.orderClause = exports.havingCondition = exports.havingClause = exports.groupCondition = exports.groupClause = exports.solutionModifier = void 0;
const l = __importStar(require("../lexer/index.js"));
const builtIn_js_1 = require("./builtIn.js");
const expression_js_1 = require("./expression.js");
const general_js_1 = require("./general.js");
const whereClause_js_1 = require("./whereClause.js");
/**
 * [[18]](https://www.w3.org/TR/sparql11-query/#rSolutionModifier)
 */
exports.solutionModifier = {
    name: 'solutionModifier',
    impl: ({ ACTION, SUBRULE, OPTION1, OPTION2, OPTION3, OPTION4 }) => () => {
        const group = OPTION1(() => SUBRULE(exports.groupClause));
        const having = OPTION2(() => SUBRULE(exports.havingClause));
        const order = OPTION3(() => SUBRULE(exports.orderClause));
        const limitOffset = OPTION4(() => SUBRULE(exports.limitOffsetClauses));
        return ACTION(() => ({
            ...(limitOffset && { limitOffset }),
            ...(group && { group }),
            ...(having && { having }),
            ...(order && { order }),
        }));
    },
    gImpl: ({ SUBRULE }) => (ast) => {
        if (ast.group) {
            SUBRULE(exports.groupClause, ast.group);
        }
        if (ast.having) {
            SUBRULE(exports.havingClause, ast.having);
        }
        if (ast.order) {
            SUBRULE(exports.orderClause, ast.order);
        }
        if (ast.limitOffset) {
            SUBRULE(exports.limitOffsetClauses, ast.limitOffset);
        }
    },
};
/**
 * [[19]](https://www.w3.org/TR/sparql11-query/#rGroupClause)
 */
exports.groupClause = {
    name: 'groupClause',
    impl: ({ ACTION, AT_LEAST_ONE, SUBRULE1, CONSUME }) => (C) => {
        const groupings = [];
        const start = CONSUME(l.groupByGroup);
        CONSUME(l.by);
        AT_LEAST_ONE(() => {
            groupings.push(SUBRULE1(exports.groupCondition));
        });
        return ACTION(() => ({
            type: 'solutionModifier',
            subType: 'group',
            groupings,
            loc: C.astFactory.sourceLocation(start, groupings.at(-1)),
        }));
    },
    gImpl: ({ PRINT_WORDS, SUBRULE, PRINT_ON_EMPTY }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => {
            PRINT_ON_EMPTY('GROUP BY ');
        });
        for (const grouping of ast.groupings) {
            if (F.isExpression(grouping)) {
                SUBRULE(expression_js_1.expression, grouping);
            }
            else {
                F.printFilter(ast, () => PRINT_WORDS('('));
                SUBRULE(expression_js_1.expression, grouping.value);
                F.printFilter(ast, () => PRINT_WORDS('AS'));
                SUBRULE(general_js_1.var_, grouping.variable);
                F.printFilter(ast, () => PRINT_WORDS(')'));
            }
        }
    },
};
/**
 * [[20]](https://www.w3.org/TR/sparql11-query/#rGroupCondition)
 */
exports.groupCondition = {
    name: 'groupCondition',
    impl: ({ ACTION, SUBRULE, CONSUME, SUBRULE1, SUBRULE2, OPTION, OR }) => C => OR([
        { ALT: () => SUBRULE(builtIn_js_1.builtInCall) },
        { ALT: () => SUBRULE(whereClause_js_1.functionCall) },
        { ALT: () => SUBRULE2(general_js_1.var_) },
        {
            ALT: () => {
                // Creates a bracketted expression or a Bind.
                const open = CONSUME(l.symbols.LParen);
                const expressionValue = SUBRULE(expression_js_1.expression);
                const variable = OPTION(() => {
                    CONSUME(l.as);
                    return SUBRULE1(general_js_1.var_);
                });
                const close = CONSUME(l.symbols.RParen);
                return ACTION(() => {
                    if (variable !== undefined) {
                        return {
                            variable,
                            value: expressionValue,
                            loc: C.astFactory.sourceLocation(open, close),
                        };
                    }
                    return expressionValue;
                });
            },
        },
    ]),
};
/**
 * [[21]](https://www.w3.org/TR/sparql11-query/#rHavingClause)
 */
exports.havingClause = {
    name: 'havingClause',
    impl: ({ ACTION, AT_LEAST_ONE, SUBRULE, CONSUME }) => (C) => {
        const having = CONSUME(l.having);
        const expressions = [];
        const couldParseAgg = ACTION(() => C.parseMode.has('canParseAggregate') || !C.parseMode.add('canParseAggregate'));
        AT_LEAST_ONE(() => {
            expressions.push(SUBRULE(exports.havingCondition));
        });
        ACTION(() => !couldParseAgg && C.parseMode.delete('canParseAggregate'));
        return ACTION(() => C.astFactory.solutionModifierHaving(expressions, C.astFactory.sourceLocation(having, expressions.at(-1))));
    },
    gImpl: ({ PRINT_ON_EMPTY, SUBRULE }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => {
            PRINT_ON_EMPTY('HAVING ');
        });
        for (const having of ast.having) {
            SUBRULE(expression_js_1.expression, having);
        }
    },
};
/**
 * [[22]](https://www.w3.org/TR/sparql11-query/#rHavingCondition)
 */
exports.havingCondition = {
    name: 'havingCondition',
    impl: ({ SUBRULE }) => () => SUBRULE(whereClause_js_1.constraint),
};
/**
 * [[23]](https://www.w3.org/TR/sparql11-query/#rOrderClause)
 */
exports.orderClause = {
    name: 'orderClause',
    impl: ({ ACTION, AT_LEAST_ONE, SUBRULE1, CONSUME }) => (C) => {
        const order = CONSUME(l.order);
        CONSUME(l.by);
        const orderings = [];
        const couldParseAgg = ACTION(() => C.parseMode.has('canParseAggregate') || !C.parseMode.add('canParseAggregate'));
        AT_LEAST_ONE(() => {
            orderings.push(SUBRULE1(exports.orderCondition));
        });
        ACTION(() => !couldParseAgg && C.parseMode.delete('canParseAggregate'));
        return ACTION(() => C.astFactory.solutionModifierOrder(orderings, C.astFactory.sourceLocation(order, orderings.at(-1))));
    },
    gImpl: ({ PRINT_WORDS, PRINT_ON_EMPTY, SUBRULE }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => {
            PRINT_ON_EMPTY('ORDER BY ');
        });
        for (const ordering of ast.orderDefs) {
            if (ordering.descending) {
                F.printFilter(ast, () => PRINT_WORDS('DESC'));
            }
            else {
                F.printFilter(ast, () => PRINT_WORDS('ASC'));
            }
            F.printFilter(ast, () => PRINT_WORDS('('));
            SUBRULE(expression_js_1.expression, ordering.expression);
            F.printFilter(ast, () => PRINT_WORDS(')'));
        }
    },
};
/**
 * [[24]](https://www.w3.org/TR/sparql11-query/#rOrderCondition)
 */
exports.orderCondition = {
    name: 'orderCondition',
    impl: ({ ACTION, SUBRULE, CONSUME, OR1, OR2 }) => C => OR1([
        { ALT: () => {
                const descending = OR2([
                    { ALT: () => {
                            const token = CONSUME(l.orderAsc);
                            return [false, token];
                        } },
                    { ALT: () => {
                            const token = CONSUME(l.orderDesc);
                            return [true, token];
                        } },
                ]);
                const expr = SUBRULE(expression_js_1.brackettedExpression);
                return ACTION(() => ({
                    expression: expr,
                    descending: descending[0],
                    loc: C.astFactory.sourceLocation(descending[1], expr),
                }));
            } },
        { ALT: () => {
                const expr = SUBRULE(whereClause_js_1.constraint);
                return ACTION(() => ({ expression: expr, descending: false, loc: expr.loc }));
            } },
        { ALT: () => {
                const expr = SUBRULE(general_js_1.var_);
                return ACTION(() => ({ expression: expr, descending: false, loc: expr.loc }));
            } },
    ]),
};
/**
 * Parses limit and or offset in any order.
 * [[25]](https://www.w3.org/TR/sparql11-query/#rLimitOffsetClauses)
 */
exports.limitOffsetClauses = {
    name: 'limitOffsetClauses',
    impl: ({ ACTION, SUBRULE1, SUBRULE2, OPTION1, OPTION2, OR }) => C => OR([
        { ALT: () => {
                const limit = SUBRULE1(exports.limitClause);
                const offset = OPTION1(() => SUBRULE1(exports.offsetClause));
                return ACTION(() => C.astFactory.solutionModifierLimitOffset(limit.val, offset?.val, C.astFactory.sourceLocation(limit, ...(offset ? [offset] : []))));
            } },
        { ALT: () => {
                const offset = SUBRULE2(exports.offsetClause);
                const limit = OPTION2(() => SUBRULE2(exports.limitClause));
                return ACTION(() => C.astFactory.solutionModifierLimitOffset(limit?.val, offset.val, C.astFactory.sourceLocation(offset, limit)));
            } },
    ]),
    gImpl: ({ PRINT_WORDS, NEW_LINE }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => {
            NEW_LINE();
            if (ast.limit) {
                PRINT_WORDS('LIMIT', String(ast.limit));
            }
            if (ast.offset) {
                PRINT_WORDS('OFFSET', String(ast.offset));
            }
        });
    },
};
/**
 * [[26]](https://www.w3.org/TR/sparql11-query/#rLimitClause)
 */
exports.limitClause = {
    name: 'limitClause',
    impl: ({ ACTION, CONSUME }) => (C) => {
        const offset = CONSUME(l.limit);
        const value = CONSUME(l.terminals.integer);
        const val = Number.parseInt(value.image, 10);
        return ACTION(() => C.astFactory.wrap(val, C.astFactory.sourceLocation(offset, value)));
    },
};
/**
 * [[27]](https://www.w3.org/TR/sparql11-query/#rWhereClause)
 */
exports.offsetClause = {
    name: 'offsetClause',
    impl: ({ CONSUME, ACTION }) => (C) => {
        const offset = CONSUME(l.offset);
        const value = CONSUME(l.terminals.integer);
        const val = Number.parseInt(value.image, 10);
        return ACTION(() => C.astFactory.wrap(val, C.astFactory.sourceLocation(offset, value)));
    },
};
//# sourceMappingURL=solutionModifier.js.map