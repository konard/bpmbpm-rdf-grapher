"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MinimalSparqlParser = void 0;
exports.completeParseContext = completeParseContext;
exports.completeGeneratorContext = completeGeneratorContext;
exports.copyParseContext = copyParseContext;
const core_1 = require("@traqula/core");
const astFactory_js_1 = require("./astFactory.js");
function completeParseContext(context) {
    return {
        astFactory: context.astFactory ?? new astFactory_js_1.AstFactory({ tracksSourceLocation: false }),
        baseIRI: context.baseIRI,
        prefixes: { ...context.prefixes },
        parseMode: context.parseMode ? new Set(context.parseMode) : new Set(['canParseVars', 'canCreateBlankNodes']),
        skipValidation: context.skipValidation ?? false,
    };
}
function completeGeneratorContext(context) {
    return {
        astFactory: context.astFactory ?? new astFactory_js_1.AstFactory(),
        origSource: context.origSource ?? '',
        offset: context.offset,
        [core_1.traqulaIndentation]: context[core_1.traqulaIndentation] ?? 0,
        [core_1.traqulaNewlineAlternative]: context[core_1.traqulaNewlineAlternative] ?? ' ',
        indentInc: context.indentInc ?? 2,
    };
}
function copyParseContext(context) {
    return {
        ...context,
        prefixes: { ...context.prefixes },
        parseMode: new Set(context.parseMode),
    };
}
class MinimalSparqlParser {
    parser;
    defaultContext;
    coreTransformer = new core_1.TransformerObject();
    constructor(parser, defaultContext = {}) {
        this.parser = parser;
        this.defaultContext = completeParseContext(defaultContext);
    }
    /**
     * Parse a query string starting from the
     * [QueryUnit](https://www.w3.org/TR/sparql11-query/#rQueryUnit)
     * or [QueryUpdate](https://www.w3.org/TR/sparql11-query/#rUpdateUnit) rules.
     * @param query
     * @param context
     */
    parse(query, context = {}) {
        const ast = this.parser.queryOrUpdate(query, copyParseContext({ ...this.defaultContext, ...context }));
        ast.loc = this.defaultContext.astFactory.sourceLocationInlinedSource(query, ast.loc, 0, Number.MAX_SAFE_INTEGER);
        return ast;
    }
    /**
     * Parse a query string starting from the [Path](https://www.w3.org/TR/sparql11-query/#rPath) grammar rule.
     * @param query
     * @param context
     */
    parsePath(query, context = {}) {
        const ast = this.parser.path(query, copyParseContext({ ...this.defaultContext, ...context }));
        ast.loc = this.defaultContext.astFactory.sourceLocationInlinedSource(query, ast.loc, 0, Number.MAX_SAFE_INTEGER);
        if (this.defaultContext.astFactory.isPathPure(ast)) {
            return {
                ...ast,
                prefixes: {},
            };
        }
        return ast;
    }
}
exports.MinimalSparqlParser = MinimalSparqlParser;
//# sourceMappingURL=MinimalSparqlParser.js.map