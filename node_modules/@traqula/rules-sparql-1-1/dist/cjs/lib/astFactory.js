"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AstFactory = void 0;
const core_1 = require("@traqula/core");
const ContextFactory_js_1 = require("./factoryMixins/ContextFactory.js");
const ExpressionFactory_js_1 = require("./factoryMixins/ExpressionFactory.js");
const GraphRefFactory_js_1 = require("./factoryMixins/GraphRefFactory.js");
const mixins_js_1 = require("./factoryMixins/mixins.js");
const PathFactory_js_1 = require("./factoryMixins/PathFactory.js");
const Patternfactory_js_1 = require("./factoryMixins/Patternfactory.js");
const QueryFactory_js_1 = require("./factoryMixins/QueryFactory.js");
const SolutionModifiersFactory_js_1 = require("./factoryMixins/SolutionModifiersFactory.js");
const TermFactory_js_1 = require("./factoryMixins/TermFactory.js");
const UpdateOperationFactory_js_1 = require("./factoryMixins/UpdateOperationFactory.js");
/**
 * A factory that helps you create, and check types for AST nodes for SPARQL 1.1
 */
class AstFactory extends (0, mixins_js_1.asArg)(core_1.AstCoreFactory)
    .call(ContextFactory_js_1.ContextFactoryMixin)
    .call(ExpressionFactory_js_1.ExpressionFactoryMixin)
    .call(GraphRefFactory_js_1.GraphRefFactoryMixin)
    .call(PathFactory_js_1.PathFactoryMixin)
    .call(Patternfactory_js_1.PatternFactoryMixin)
    .call(QueryFactory_js_1.QueryFactoryMixin)
    .call(SolutionModifiersFactory_js_1.SolutionModifiersFactoryMixin)
    .call(TermFactory_js_1.TermFactoryMixin)
    .call(UpdateOperationFactory_js_1.UpdateOperationFactoryMixin)
    .returns() {
    alwaysSparql11(obj) {
        return true;
    }
    isPath(obj) {
        return this.isPathPure(obj) || this.isTermNamed(obj);
    }
    isExpression(obj) {
        return this.isExpressionPure(obj) || this.isTermNamed(obj) || this.isTermVariable(obj) || this.isTermLiteral(obj);
    }
    graphNodeIdentifier(graphNode) {
        return graphNode.type === 'tripleCollection' ? graphNode.identifier : graphNode;
    }
    triple(subject, predicate, object, loc) {
        return {
            type: 'triple',
            subject,
            predicate,
            object,
            loc: loc ?? this.sourceLocation(subject, predicate, object),
        };
    }
    isTriple(obj) {
        return this.isOfType(obj, 'triple');
    }
    datasetClauses(clauses, loc) {
        return {
            type: 'datasetClauses',
            clauses,
            loc,
        };
    }
    isDatasetClauses(obj) {
        return this.isOfType(obj, 'datasetClauses');
    }
    wildcard(loc) {
        return { type: 'wildcard', loc };
    }
    isWildcard(obj) {
        return this.isOfType(obj, 'wildcard');
    }
    isTripleCollection(obj) {
        return this.isOfType(obj, 'tripleCollection');
    }
    tripleCollectionBlankNodeProperties(identifier, triples, loc) {
        return {
            type: 'tripleCollection',
            subType: 'blankNodeProperties',
            identifier,
            triples,
            loc,
        };
    }
    isTripleCollectionBlankNodeProperties(obj) {
        return this.isOfSubType(obj, 'tripleCollection', 'blankNodeProperties');
    }
    tripleCollectionList(identifier, triples, loc) {
        return {
            type: 'tripleCollection',
            subType: 'list',
            identifier,
            triples,
            loc,
        };
    }
    isTripleCollectionList(obj) {
        return this.isOfSubType(obj, 'tripleCollection', 'list');
    }
    graphQuads(graph, triples, loc) {
        return {
            type: 'graph',
            graph,
            triples,
            loc,
        };
    }
    isGraphQuads(obj) {
        return super.isOfType(obj, 'graph');
    }
    isUpdate(obj) {
        return super.isOfType(obj, 'update');
    }
}
exports.AstFactory = AstFactory;
//# sourceMappingURL=astFactory.js.map