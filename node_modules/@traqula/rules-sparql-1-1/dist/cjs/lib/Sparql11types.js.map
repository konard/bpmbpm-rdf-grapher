{"version":3,"file":"Sparql11types.js","sourceRoot":"","sources":["../../../lib/Sparql11types.ts"],"names":[],"mappings":"","sourcesContent":["import type { Localized, Node } from '@traqula/core';\n\nexport type Sparql11Nodes =\n  | GraphRef\n  | GraphQuads\n  | UpdateOperation\n  | Update\n  | Query\n  | DatasetClauses\n  | TripleCollection\n  | TripleNesting\n  | Pattern\n  | SolutionModifier\n  | Expression\n  | Path\n  | ContextDefinition\n  | Wildcard\n  | Term;\n\nexport type GraphRefBase = Node & {\n  type: 'graphRef';\n  subType: string;\n};\nexport type GraphRefDefault = GraphRefBase & {\n  subType: 'default';\n};\nexport type GraphRefNamed = GraphRefBase & {\n  subType: 'named';\n};\nexport type GraphRefAll = GraphRefBase & {\n  subType: 'all';\n};\nexport type GraphRefSpecific = GraphRefBase & {\n  subType: 'specific';\n  graph: TermIri;\n};\nexport type GraphRef =\n  | GraphRefDefault\n  | GraphRefNamed\n  | GraphRefAll\n  | GraphRefSpecific;\n\nexport type Quads = PatternBgp | GraphQuads;\n\nexport type GraphQuads = Node & {\n  type: 'graph';\n  graph: TermIri | TermVariable;\n  triples: PatternBgp;\n};\n\n// https://www.w3.org/TR/sparql11-query/#rUpdate1\nexport type UpdateOperationBase = Node & { type: 'updateOperation'; subType: string };\nexport type UpdateOperationLoad = UpdateOperationBase & {\n  subType: 'load';\n  silent: boolean;\n  source: TermIri;\n  destination?: GraphRefSpecific;\n};\ntype UpdateOperationClearDropCreateBase = UpdateOperationBase & {\n  subType: 'clear' | 'drop' | 'create';\n  silent: boolean;\n  destination: GraphRef;\n};\nexport type UpdateOperationClear = UpdateOperationClearDropCreateBase & { subType: 'clear' };\nexport type UpdateOperationDrop = UpdateOperationClearDropCreateBase & { subType: 'drop' };\nexport type UpdateOperationCreate = UpdateOperationClearDropCreateBase & {\n  subType: 'create';\n  destination: GraphRefSpecific;\n};\ntype UpdateOperationAddMoveCopy = UpdateOperationBase & {\n  subType: 'add' | 'move' | 'copy';\n  silent: boolean;\n  source: GraphRefDefault | GraphRefSpecific;\n  destination: GraphRefDefault | GraphRefSpecific;\n};\nexport type UpdateOperationAdd = UpdateOperationAddMoveCopy & { subType: 'add' };\nexport type UpdateOperationMove = UpdateOperationAddMoveCopy & { subType: 'move' };\nexport type UpdateOperationCopy = UpdateOperationAddMoveCopy & { subType: 'copy' };\ntype UpdateOperationInsertDeleteDelWhere = UpdateOperationBase & {\n  subType: 'insertdata' | 'deletedata' | 'deletewhere';\n  data: Quads[];\n};\nexport type UpdateOperationInsertData = UpdateOperationInsertDeleteDelWhere & { subType: 'insertdata' };\nexport type UpdateOperationDeleteData = UpdateOperationInsertDeleteDelWhere & { subType: 'deletedata' };\nexport type UpdateOperationDeleteWhere = UpdateOperationInsertDeleteDelWhere & { subType: 'deletewhere' };\nexport type UpdateOperationModify = UpdateOperationBase & {\n  subType: 'modify';\n  graph: TermIri | undefined;\n  insert: Quads[];\n  delete: Quads[];\n  from: DatasetClauses;\n  where: PatternGroup;\n};\nexport type UpdateOperation =\n  | UpdateOperationLoad\n  | UpdateOperationClear\n  | UpdateOperationDrop\n  | UpdateOperationCreate\n  | UpdateOperationAdd\n  | UpdateOperationMove\n  | UpdateOperationCopy\n  | UpdateOperationInsertData\n  | UpdateOperationDeleteData\n  | UpdateOperationDeleteWhere\n  | UpdateOperationModify;\n\n// https://www.w3.org/TR/sparql11-query/#rUpdate\nexport type Update = Node & {\n  type: 'update';\n  updates: {\n    operation?: UpdateOperation;\n    context: ContextDefinition[];\n  }[];\n};\n\n// https://www.w3.org/TR/sparql11-query/#rQueryUnit\nexport type QueryBase = Node & {\n  type: 'query';\n  subType: string;\n\n  context: ContextDefinition[];\n  values?: PatternValues;\n  solutionModifiers: SolutionModifiers;\n  datasets: DatasetClauses;\n  where?: PatternGroup;\n};\nexport type QuerySelect = QueryBase & {\n  subType: 'select';\n  variables: (TermVariable | PatternBind)[] | [Wildcard];\n  distinct?: true;\n  reduced?: true;\n  where: PatternGroup;\n};\nexport type QueryConstruct = QueryBase & {\n  subType: 'construct';\n  template: PatternBgp;\n  where: PatternGroup;\n};\nexport type QueryDescribe = QueryBase & {\n  subType: 'describe';\n  variables: (TermVariable | TermIri)[] | [Wildcard];\n};\nexport type QueryAsk = QueryBase & {\n  subType: 'ask';\n  where: PatternGroup;\n};\nexport type Query =\n  | QuerySelect\n  | QueryConstruct\n  | QueryDescribe\n  | QueryAsk;\n\nexport type SparqlQuery = Query | Update;\n\n// https://www.w3.org/TR/sparql11-query/#rDatasetClause\nexport type DatasetClauses = Node & {\n  type: 'datasetClauses';\n  clauses: { clauseType: 'default' | 'named'; value: TermIri }[];\n};\n\n// https://www.w3.org/TR/sparql11-query/#rGraphNode\nexport type TripleCollectionBase = Node & {\n  type: 'tripleCollection';\n  subType: string;\n  triples: TripleNesting[];\n  identifier: Term;\n};\n/**\n * The subject of the triples does not have a string manifestation.\n */\nexport type TripleCollectionList = TripleCollectionBase & {\n  subType: 'list';\n  identifier: TermBlank;\n};\n/**\n * Bot subject and predicate of the triples do not have a string manifestation.\n */\nexport type TripleCollectionBlankNodeProperties = TripleCollectionBase & {\n  subType: 'blankNodeProperties';\n  identifier: TermBlank;\n};\nexport type TripleCollection =\n  | TripleCollectionList\n  | TripleCollectionBlankNodeProperties;\n\n// https://www.w3.org/TR/sparql11-query/#rGraphNode\nexport type GraphNode = Term | TripleCollection;\n\n// https://www.w3.org/TR/sparql11-query/#rTriplesBlock\nexport type TripleNesting = Node & {\n  type: 'triple';\n  subject: GraphNode;\n  predicate: TermIri | TermVariable | Path;\n  object: GraphNode;\n};\n\nexport type PatternBase = Node & { type: 'pattern'; subType: string };\nexport type PatternFilter = PatternBase & {\n  subType: 'filter';\n  expression: Expression;\n};\nexport type PatternMinus = PatternBase & {\n  subType: 'minus';\n  patterns: Pattern[];\n};\n\nexport type PatternGroup = PatternBase & {\n  subType: 'group';\n  patterns: Pattern[];\n};\nexport type PatternOptional = PatternBase & {\n  subType: 'optional';\n  patterns: Pattern[];\n};\nexport type PatternGraph = PatternBase & {\n  subType: 'graph';\n  name: TermIri | TermVariable;\n  patterns: Pattern[];\n};\nexport type PatternUnion = PatternBase & {\n  subType: 'union';\n  patterns: PatternGroup[];\n};\nexport type BasicGraphPattern = (TripleNesting | TripleCollection)[];\nexport type PatternBgp = PatternBase & {\n  subType: 'bgp';\n  /**\n   * Only the first appearance of a subject and predicate have a string manifestation\n   */\n  triples: BasicGraphPattern;\n};\nexport type PatternBind = PatternBase & {\n  subType: 'bind';\n  expression: Expression;\n  variable: TermVariable;\n};\nexport type PatternService = PatternBase & {\n  subType: 'service';\n  name: TermIri | TermVariable;\n  silent: boolean;\n  patterns: Pattern[];\n};\n/**\n * A single list of assignments maps the variable identifier to the value\n */\nexport type ValuePatternRow = Record<string, TermIri | TermLiteral | undefined>;\nexport type PatternValues = PatternBase & {\n  subType: 'values';\n  variables: TermVariable[];\n  values: ValuePatternRow[];\n};\nexport type SubSelect = QuerySelect;\n\nexport type Pattern =\n  | PatternBgp\n  | PatternGroup\n  | PatternUnion\n  | PatternOptional\n  | PatternMinus\n  | PatternGraph\n  | PatternService\n  | PatternFilter\n  | PatternBind\n  | PatternValues\n  | SubSelect;\n\nexport type SolutionModifiers = {\n  group?: SolutionModifierGroup;\n  having?: SolutionModifierHaving;\n  order?: SolutionModifierOrder;\n  limitOffset?: SolutionModifierLimitOffset;\n};\nexport type SolutionModifierBase = Node & { type: 'solutionModifier'; subType: string };\nexport type SolutionModifierGroupBind = Localized & {\n  variable: TermVariable;\n  value: Expression;\n};\nexport type SolutionModifierGroup = SolutionModifierBase & {\n  subType: 'group';\n  groupings: (Expression | SolutionModifierGroupBind)[];\n};\nexport type SolutionModifierHaving = SolutionModifierBase & {\n  subType: 'having';\n  having: Expression[];\n};\nexport type Ordering = Localized & {\n  descending: boolean;\n  expression: Expression;\n};\nexport type SolutionModifierOrder = SolutionModifierBase & {\n  subType: 'order';\n  orderDefs: Ordering[];\n};\nexport type SolutionModifierLimitOffset = SolutionModifierBase\n  & { subType: 'limitOffset'; limit: number | undefined; offset: number | undefined };\n\nexport type SolutionModifier =\n  | SolutionModifierGroup\n  | SolutionModifierHaving\n  | SolutionModifierOrder\n  | SolutionModifierLimitOffset;\n\nexport type ExpressionBase = Node & { type: 'expression'; subType: string };\n\ntype ExpressionAggregateBase = ExpressionBase & {\n  subType: 'aggregate';\n  distinct: boolean;\n  expression: [Expression | Wildcard];\n};\nexport type ExpressionAggregateDefault = ExpressionAggregateBase & {\n  expression: [Expression];\n  aggregation: string;\n};\nexport type ExpressionAggregateOnWildcard = ExpressionAggregateBase & {\n  expression: [Wildcard];\n  aggregation: string;\n};\nexport type ExpressionAggregateSeparator = ExpressionAggregateBase & {\n  expression: [Expression];\n  aggregation: string;\n  separator: string;\n};\nexport type ExpressionAggregate =\n  | ExpressionAggregateDefault\n  | ExpressionAggregateOnWildcard\n  | ExpressionAggregateSeparator;\n\nexport type ExpressionOperation = ExpressionBase & {\n  subType: 'operation';\n  operator: string;\n  args: Expression[];\n};\n\nexport type ExpressionPatternOperation = ExpressionBase & {\n  subType: 'patternOperation';\n  operator: string;\n  // Can be a pattern in case of exists and not exists\n  args: PatternGroup;\n};\n\nexport type ExpressionFunctionCall = ExpressionBase & {\n  subType: 'functionCall';\n  function: TermIri;\n  distinct: boolean;\n  args: Expression[];\n};\n\nexport type Expression =\n  | ExpressionOperation\n  | ExpressionPatternOperation\n  | ExpressionFunctionCall\n  | ExpressionAggregate\n  | TermIri\n  | TermVariable\n  | TermLiteral;\n\nexport type PropertyPathBase = Node & { type: 'path'; subType: string };\nexport type PropertyPathChain = PropertyPathBase & {\n  subType: '|' | '/';\n  items: Path[];\n};\n\nexport type PathModified = PropertyPathBase & {\n  subType: '?' | '*' | '+' | '^';\n  items: [Path];\n};\n\nexport type PathNegatedElt = PropertyPathBase & {\n  subType: '^';\n  items: [TermIri];\n};\n\nexport type PathAlternativeLimited = PropertyPathBase & {\n  subType: '|';\n  items: (TermIri | PathNegatedElt)[];\n};\n\nexport type PathNegated = PropertyPathBase & {\n  subType: '!';\n  items: [TermIri | PathNegatedElt | PathAlternativeLimited];\n};\n\n// [[88]](https://www.w3.org/TR/sparql11-query/#rPath)\nexport type Path =\n  | TermIri\n  | PropertyPathChain\n  | PathModified\n  | PathNegated;\nexport type PathPure = PropertyPathChain | PathModified | PathNegated;\n\nexport type ContextDefinitionBase_ = Node & { type: 'contextDef'; subType: string };\nexport type ContextDefinitionPrefix = ContextDefinitionBase_ & {\n  subType: 'prefix';\n  key: string;\n  value: TermIriFull;\n};\nexport type ContextDefinitionBase = ContextDefinitionBase_ & {\n  subType: 'base';\n  value: TermIriFull;\n};\nexport type ContextDefinition = ContextDefinitionPrefix | ContextDefinitionBase;\n\nexport type Wildcard = Node & {\n  type: 'wildcard';\n};\n\nexport type TermBase = Node & { type: 'term'; subType: string };\nexport type TermLiteralBase = TermBase & {\n  subType: 'literal';\n  value: string;\n};\nexport type TermLiteralStr = TermLiteralBase & { langOrIri: undefined };\nexport type TermLiteralLangStr = TermLiteralBase & { langOrIri: string };\nexport type TermLiteralTyped = TermLiteralBase & { langOrIri: TermIri };\nexport type TermLiteral = TermLiteralStr | TermLiteralLangStr | TermLiteralTyped;\n\nexport type TermVariable = TermBase & {\n  subType: 'variable';\n  value: string;\n};\n\nexport type TermIriBase = TermBase & { subType: 'namedNode' };\nexport type TermIriFull = TermIriBase & { value: string };\nexport type TermIriPrefixed = TermIriBase & {\n  value: string;\n  prefix: string;\n};\nexport type TermIri = TermIriFull | TermIriPrefixed;\n\nexport type TermBlank = TermBase & { subType: 'blankNode' } & { label: string };\n\nexport type GraphTerm = TermIri | TermBlank | TermLiteral;\nexport type Term = GraphTerm | TermVariable;\n"]}