{"version":3,"file":"validators.js","sourceRoot":"","sources":["../../../../lib/validation/validators.ts"],"names":[],"mappings":"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","sourcesContent":["import { AstFactory } from '../astFactory.js';\nimport type {\n  Wildcard,\n  Expression,\n  ExpressionAggregate,\n  Pattern,\n  QuerySelect,\n  TermVariable,\n  SolutionModifierGroupBind,\n  Update,\n  PatternBind,\n  Sparql11Nodes,\n} from '../Sparql11types.js';\nimport { AstTransformer } from '../utils.js';\n\nconst F = new AstFactory();\nconst transformer = new AstTransformer();\n\n/**\n * Get all 'aggregate' rules from an expression\n */\nfunction getAggregatesOfExpression(expression: Expression): ExpressionAggregate[] {\n  if (F.isExpressionAggregate(expression)) {\n    return [ expression ];\n  }\n  if (F.isExpressionOperator(expression)) {\n    const aggregates: ExpressionAggregate[] = [];\n    for (const arg of expression.args) {\n      aggregates.push(...getAggregatesOfExpression(arg));\n    }\n    return aggregates;\n  }\n  return [];\n}\n\n/**\n * Return the variable value id of an expression if bounded\n */\nfunction getExpressionId(expression: SolutionModifierGroupBind | Expression | TermVariable): string | undefined {\n  // Check if grouping\n  if (F.isTerm(expression) && F.isTermVariable(expression)) {\n    return expression.value;\n  }\n  if (F.isExpression(expression)) {\n    if (F.isExpressionAggregate(expression) && F.isTermVariable(expression.expression[0])) {\n      return expression.expression[0].value;\n    }\n    return undefined;\n  }\n  return expression.variable.value;\n}\n\n/**\n * Get all variables used in an expression\n */\nfunction getVariablesFromExpression(expression: Expression, variables: Set<string>): void {\n  if (F.isExpressionOperator(expression)) {\n    for (const expr of expression.args) {\n      getVariablesFromExpression(expr, variables);\n    }\n  } else if (F.isTerm(expression) && F.isTermVariable(expression)) {\n    variables.add(expression.value);\n  }\n}\n\n/**\n * Verify that the projected variables (select head) are allowed:\n * - no group-by on select *\n * - if group-by, selected variables need to be collected by the group-by\n * - 'select ?var as ?other', ?other cannot be in scope\n */\nexport function queryProjectionIsGood(query: Pick<QuerySelect, 'variables' | 'solutionModifiers' | 'where'>): void {\n  // NoGroupByOnWildcardSelect\n  if (query.variables.length === 1 && F.isWildcard(query.variables[0])) {\n    if (query.solutionModifiers.group !== undefined) {\n      throw new Error('GROUP BY not allowed with wildcard');\n    }\n    return;\n  }\n\n  // CannotProjectUngroupedVars - can be skipped if `SELECT *`\n  // Check for projection of ungrouped variable\n  // Check can be skipped in case of wildcard select.\n  const variables = <Exclude<typeof query.variables, [Wildcard]>> query.variables;\n  const hasCountAggregate = variables.flatMap(\n    varVal => F.isTerm(varVal) ? [] : getAggregatesOfExpression(varVal.expression),\n  ).some(agg => agg.aggregation === 'count' && !agg.expression.some(arg => F.isWildcard(arg)));\n  const groupBy = query.solutionModifiers.group;\n  if (hasCountAggregate || groupBy) {\n    // We have to check whether\n    //  1. Variables used in projection are usable given the group by clause\n    //  2. A selectCount will create an implicit group by clause.\n    for (const selectVar of variables) {\n      if (F.isTerm(selectVar)) {\n        if (!groupBy || !groupBy.groupings.map(groupvar => getExpressionId(groupvar))\n          .includes((getExpressionId(selectVar)))) {\n          throw new Error('Variable not allowed in projection');\n        }\n      } else if (getAggregatesOfExpression(selectVar.expression).length === 0) {\n        // Current value binding does not use aggregates\n        const usedvars = new Set<string>();\n        getVariablesFromExpression(selectVar.expression, usedvars);\n        for (const usedvar of usedvars) {\n          if (!groupBy || !groupBy.groupings.map(groupVar => getExpressionId(groupVar))\n            .includes(usedvar)) {\n            throw new Error(`Use of ungrouped variable in projection of operation (?${usedvar})`);\n          }\n        }\n      }\n    }\n  }\n\n  // NOTE 12: Check if id of each AS-selected column is not yet bound by subquery\n  const subqueries = query.where.patterns.filter(pattern => pattern.type === 'query');\n  if (subqueries.length > 0) {\n    const selectBoundedVars = new Set<string>();\n    for (const variable of variables) {\n      if ('variable' in variable) {\n        selectBoundedVars.add(variable.variable.value);\n      }\n    }\n\n    // Look at in scope variables\n    const vars = subqueries.flatMap<TermVariable | PatternBind | Wildcard>(sub => sub.variables)\n      .map(v => F.isTerm(v) ? v.value : (F.isWildcard(v) ? '*' : v.variable.value));\n    const subqueryIds = new Set(vars);\n    for (const selectedVarId of selectBoundedVars) {\n      if (subqueryIds.has(selectedVarId)) {\n        throw new Error(`Target id of 'AS' (?${selectedVarId}) already used in subquery`);\n      }\n    }\n  }\n}\n\nexport function findPatternBoundedVars(\n  op: Sparql11Nodes | undefined | (Sparql11Nodes | undefined)[],\n  boundedVars: Set<string>,\n): void {\n  function recurse(x: Parameters<(typeof findPatternBoundedVars)>[0]): void {\n    findPatternBoundedVars(x, boundedVars);\n  }\n  if (op === undefined) {\n    return;\n  }\n  if (Array.isArray(op)) {\n    for (const iter of op) {\n      recurse(iter);\n    }\n  } else if (F.isQuery(op)) {\n    if (F.isQuerySelect(op) || F.isQueryDescribe(op)) {\n      recurse([\n        ...(op.variables.some(x => F.isWildcard(x)) ? [ op.where ] : op.variables),\n        op.solutionModifiers.group,\n        op.values,\n      ]);\n    } else {\n      recurse(op.solutionModifiers.group);\n    }\n  } else if (F.isTriple(op)) {\n    recurse([ op.subject, op.predicate, op.object ]);\n  } else if (F.isPathPure(op)) {\n    recurse(op.items);\n  } else if (F.isTripleCollection(op)) {\n    recurse([ op.identifier, ...op.triples ]);\n  } else if (F.isSolutionModifierGroup(op)) {\n    recurse(op.groupings.filter(g => 'variable' in g).map(x => x.variable));\n  } else if (F.isSolutionModifierHaving(op)) {\n    recurse(op.having);\n  } else if (F.isSolutionModifierOrder(op)) {\n    recurse(op.orderDefs.map(x => x.expression));\n  } else if (F.isPatternValues(op)) {\n    for (const v of Object.keys(op.values.at(0) ?? {})) {\n      boundedVars.add(v);\n    }\n  } else if (F.isPatternBgp(op)) {\n    recurse(op.triples);\n  } else if (F.isPatternGroup(op) || F.isPatternUnion(op) || F.isPatternOptional(op)) {\n    recurse(op.patterns);\n  } else if (F.isPatternService(op) || F.isPatternGraph(op)) {\n    recurse([ op.name, ...op.patterns ]);\n  } else if (F.isPatternBind(op)) {\n    recurse(op.variable);\n  } else if (F.isTermVariable(op)) {\n    boundedVars.add(op.value);\n  }\n}\n\n/**\n * NOTE 13 and https://www.w3.org/TR/sparql11-query/#variableScope\n * > In BIND (expr AS v) requires that the variable v is not in-scope from the preceeding elements in the\n *    group graph pattern in which it is used.\n */\nexport function checkNote13(patterns: Pattern[]): void {\n  for (const [ index, pattern ] of patterns.entries()) {\n    if (F.isPatternBind(pattern) && index > 0 && F.isPatternBgp(patterns[index - 1])) {\n      const bgp = patterns[index - 1];\n      // Find variables used.\n      const variables: TermVariable[] = [];\n      // TODO: this is slow! 2.6% self execution\n      transformer.visitNodeSpecific(bgp, {}, { term: { variable: { visitor: (var_) => {\n        variables.push(var_);\n      } }}});\n      if (variables.some(var_ => var_.value === pattern.variable.value)) {\n        throw new Error(`Variable used to bind is already bound (?${pattern.variable.value})`);\n      }\n    }\n  }\n\n  const boundedVars = new Set<string>();\n  for (const pattern of patterns) {\n    // Element can be bind, in that case, check note 13. If it is not, buildup set of bounded variables.\n    if (F.isPatternBind(pattern)) {\n      if (boundedVars.has(pattern.variable.value)) {\n        throw new Error(`Variable used to bind is already bound (?${pattern.variable.value})`);\n      }\n    } else {\n      findPatternBoundedVars(pattern, boundedVars);\n    }\n  }\n}\n\n/**\n * https://www.w3.org/TR/sparql11-query/#grammarBNodes\n * > two INSERT DATA operations within a single SPARQL Update request\n */\nexport function updateNoReuseBlankNodeLabels(updateQuery: Update): void {\n  const blankLabelsUsedInInsertData = new Set<string>();\n  for (const update of updateQuery.updates) {\n    if (!update.operation) {\n      continue;\n    }\n    const operation = update.operation;\n    if (operation.subType === 'insertdata') {\n      const blankNodesHere = new Set<string>();\n      transformer.visitNodeSpecific(operation, {}, { term: { blankNode: { visitor: (blankNode) => {\n        blankNodesHere.add(blankNode.label);\n        if (blankLabelsUsedInInsertData.has(blankNode.label)) {\n          throw new Error('Detected reuse blank node across different INSERT DATA clauses');\n        }\n      } }}});\n      for (const blankNode of blankNodesHere) {\n        blankLabelsUsedInInsertData.add(blankNode);\n      }\n    }\n  }\n}\n"]}