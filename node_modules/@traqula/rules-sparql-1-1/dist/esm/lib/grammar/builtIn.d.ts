import type { IOrAlt } from '@traqula/chevrotain';
import type { ImplArgs } from '@traqula/core';
import type { SparqlGrammarRule, SparqlRule } from '../sparql11HelperTypes.js';
import type { Expression, ExpressionAggregate, ExpressionAggregateDefault, ExpressionAggregateOnWildcard, ExpressionAggregateSeparator } from '../Sparql11types.js';
export declare const builtInStr: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInStr", [Expression]>;
export declare const builtInLang: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInLang", [Expression]>;
export declare const builtInLangmatches: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInLangmatches", [Expression, Expression]>;
export declare const builtInDatatype: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInDatatype", [Expression]>;
export declare const builtInBound: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInBound", [import("../Sparql11types.js").TermVariable]>;
export declare const builtInIri: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInIri", [Expression]>;
export declare const builtInUri: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInUri", [Expression]>;
export declare const builtInBnodeSparqlJs: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInBnode", [Expression] | []>;
export declare const builtInRand: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInRand", []>;
export declare const builtInAbs: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInAbs", [Expression]>;
export declare const builtInCeil: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInCeil", [Expression]>;
export declare const builtInFloor: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInFloor", [Expression]>;
export declare const builtInRound: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInRound", [Expression]>;
export declare const builtInConcat: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInConcat", Expression[]>;
export declare const builtInStrlen: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInStrlen", [Expression]>;
export declare const builtInUcase: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInUcase", [Expression]>;
export declare const builtInLcase: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInLcase", [Expression]>;
export declare const builtInEncode_for_uri: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInEncode_for_uri", [Expression]>;
export declare const builtInContains: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInContains", [Expression, Expression]>;
export declare const builtInStrstarts: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInStrstarts", [Expression, Expression]>;
export declare const builtInStrends: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInStrends", [Expression, Expression]>;
export declare const builtInStrbefore: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInStrbefore", [Expression, Expression]>;
export declare const builtInStrafter: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInStrafter", [Expression, Expression]>;
export declare const builtInYear: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInYear", [Expression]>;
export declare const builtInMonth: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInMonth", [Expression]>;
export declare const builtInDay: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInDay", [Expression]>;
export declare const builtInHours: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInHours", [Expression]>;
export declare const builtInMinutes: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInMinutes", [Expression]>;
export declare const builtInSeconds: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInSeconds", [Expression]>;
export declare const builtInTimezone: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInTimezone", [Expression]>;
export declare const builtInTz: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInTz", [Expression]>;
export declare const builtInNow: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInNow", []>;
export declare const builtInUuid: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInUuid", []>;
export declare const builtInStruuid: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInStruuid", []>;
export declare const builtInMd5: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInMd5", [Expression]>;
export declare const builtInSha1: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInSha1", [Expression]>;
export declare const builtInSha256: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInSha256", [Expression]>;
export declare const builtInSha384: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInSha384", [Expression]>;
export declare const builtInSha512: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInSha512", [Expression]>;
export declare const builtInCoalesce: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInCoalesce", Expression[]>;
export declare const builtInIf: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInIf", [Expression, Expression, Expression]>;
export declare const builtInStrlang: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInStrlang", [Expression, Expression]>;
export declare const builtInStrdt: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInStrdt", [Expression, Expression]>;
export declare const builtInSameterm: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInSameterm", [Expression, Expression]>;
export declare const builtInIsiri: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInIsiri", [Expression]>;
export declare const builtInIsuri: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInIsuri", [Expression]>;
export declare const builtInIsblank: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInIsblank", [Expression]>;
export declare const builtInIsliteral: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInIsliteral", [Expression]>;
export declare const builtInIsnumeric: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInIsnumeric", [Expression]>;
export declare function builtInCallList(SUBRULE: ImplArgs['SUBRULE']): IOrAlt<Expression>[];
/**
 * [[121]](https://www.w3.org/TR/sparql11-query/#rBuiltInCall)
 */
export declare const builtInCall: SparqlGrammarRule<'builtInCall', Expression>;
/**
 * [[122]](https://www.w3.org/TR/sparql11-query/#rBuiltInCall)
 */
export declare const regexExpression: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInRegex", [Expression, Expression] | [Expression, Expression, Expression]>;
/**
 * [[123]](https://www.w3.org/TR/sparql11-query/#rBuiltInCall)
 */
export declare const substringExpression: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInSubstr", [Expression, Expression] | [Expression, Expression, Expression]>;
/**
 * [[124]](https://www.w3.org/TR/sparql11-query/#rBuiltInCall)
 */
export declare const strReplaceExpression: import("../expressionHelpers.js").RuleDefExpressionFunctionX<"builtInReplace", [Expression, Expression, Expression] | [Expression, Expression, Expression, Expression]>;
/**
 * [[125]](https://www.w3.org/TR/sparql11-query/#rBuiltInCall)
 */
export declare const existsFunc: SparqlGrammarRule<"builtInExists", import("../Sparql11types.js").ExpressionPatternOperation>;
/**
 * [[126]](https://www.w3.org/TR/sparql11-query/#rBuiltInCall)
 */
export declare const notExistsFunc: SparqlGrammarRule<"builtInNotexists", import("../Sparql11types.js").ExpressionPatternOperation>;
export declare const aggregateCount: SparqlGrammarRule<'builtInCount', ExpressionAggregateOnWildcard | ExpressionAggregateDefault>;
export declare const aggregateSum: import("../expressionHelpers.js").RuleDefExpressionAggregatorX<"builtInSum">;
export declare const aggregateMin: import("../expressionHelpers.js").RuleDefExpressionAggregatorX<"builtInMin">;
export declare const aggregateMax: import("../expressionHelpers.js").RuleDefExpressionAggregatorX<"builtInMax">;
export declare const aggregateAvg: import("../expressionHelpers.js").RuleDefExpressionAggregatorX<"builtInAvg">;
export declare const aggregateSample: import("../expressionHelpers.js").RuleDefExpressionAggregatorX<"builtInSample">;
export declare const aggregateGroup_concat: SparqlGrammarRule<'builtInGroup_concat', ExpressionAggregateDefault | ExpressionAggregateSeparator>;
/**
 * [[127]](https://www.w3.org/TR/sparql11-query/#rBuiltInCall)
 */
export declare const aggregate: SparqlRule<'aggregate', ExpressionAggregate>;
