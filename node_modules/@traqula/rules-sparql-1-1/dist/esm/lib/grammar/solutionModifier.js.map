{"version":3,"file":"solutionModifier.js","sourceRoot":"","sources":["../../../../lib/grammar/solutionModifier.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IToken } from '@traqula/chevrotain';\nimport type { Wrap } from '@traqula/core';\nimport * as l from '../lexer/index.js';\nimport type { SparqlGrammarRule, SparqlRule } from '../sparql11HelperTypes.js';\nimport type {\n  Expression,\n  SolutionModifierGroup,\n  SolutionModifierGroupBind,\n  SolutionModifierHaving,\n  SolutionModifierOrder,\n  Ordering,\n  SolutionModifierLimitOffset,\n  SolutionModifiers,\n} from '../Sparql11types.js';\nimport { builtInCall } from './builtIn.js';\nimport { brackettedExpression, expression } from './expression.js';\nimport { var_ } from './general.js';\nimport { constraint, functionCall } from './whereClause.js';\n\n/**\n * [[18]](https://www.w3.org/TR/sparql11-query/#rSolutionModifier)\n */\nexport const solutionModifier: SparqlRule<'solutionModifier', SolutionModifiers> = <const> {\n  name: 'solutionModifier',\n  impl: ({ ACTION, SUBRULE, OPTION1, OPTION2, OPTION3, OPTION4 }) => () => {\n    const group = OPTION1(() => SUBRULE(groupClause));\n    const having = OPTION2(() => SUBRULE(havingClause));\n    const order = OPTION3(() => SUBRULE(orderClause));\n    const limitOffset = OPTION4(() => SUBRULE(limitOffsetClauses));\n    return ACTION(() => ({\n      ...(limitOffset && { limitOffset }),\n      ...(group && { group }),\n      ...(having && { having }),\n      ...(order && { order }),\n    }));\n  },\n  gImpl: ({ SUBRULE }) => (ast) => {\n    if (ast.group) {\n      SUBRULE(groupClause, ast.group);\n    }\n    if (ast.having) {\n      SUBRULE(havingClause, ast.having);\n    }\n    if (ast.order) {\n      SUBRULE(orderClause, ast.order);\n    }\n    if (ast.limitOffset) {\n      SUBRULE(limitOffsetClauses, ast.limitOffset);\n    }\n  },\n};\n\n/**\n * [[19]](https://www.w3.org/TR/sparql11-query/#rGroupClause)\n */\nexport const groupClause: SparqlRule<'groupClause', SolutionModifierGroup> = <const> {\n  name: 'groupClause',\n  impl: ({ ACTION, AT_LEAST_ONE, SUBRULE1, CONSUME }) => (C) => {\n    const groupings: (Expression | SolutionModifierGroupBind)[] = [];\n    const start = CONSUME(l.groupByGroup);\n    CONSUME(l.by);\n    AT_LEAST_ONE(() => {\n      groupings.push(SUBRULE1(groupCondition));\n    });\n\n    return ACTION(() => ({\n      type: 'solutionModifier',\n      subType: 'group',\n      groupings,\n      loc: C.astFactory.sourceLocation(start, groupings.at(-1)),\n    }));\n  },\n  gImpl: ({ PRINT_WORDS, SUBRULE, PRINT_ON_EMPTY }) => (ast, { astFactory: F }) => {\n    F.printFilter(ast, () => {\n      PRINT_ON_EMPTY('GROUP BY ');\n    });\n    for (const grouping of ast.groupings) {\n      if (F.isExpression(grouping)) {\n        SUBRULE(expression, grouping);\n      } else {\n        F.printFilter(ast, () => PRINT_WORDS('('));\n        SUBRULE(expression, grouping.value);\n        F.printFilter(ast, () => PRINT_WORDS('AS'));\n        SUBRULE(var_, grouping.variable);\n        F.printFilter(ast, () => PRINT_WORDS(')'));\n      }\n    }\n  },\n};\n\n/**\n * [[20]](https://www.w3.org/TR/sparql11-query/#rGroupCondition)\n */\nexport const groupCondition: SparqlGrammarRule<'groupCondition', Expression | SolutionModifierGroupBind> = <const>{\n  name: 'groupCondition',\n  impl: ({ ACTION, SUBRULE, CONSUME, SUBRULE1, SUBRULE2, OPTION, OR }) => C =>\n    OR<Expression | SolutionModifierGroupBind>([\n      { ALT: () => SUBRULE(builtInCall) },\n      { ALT: () => SUBRULE(functionCall) },\n      { ALT: () => SUBRULE2(var_) },\n      {\n        ALT: () => {\n          // Creates a bracketted expression or a Bind.\n          const open = CONSUME(l.symbols.LParen);\n          const expressionValue = SUBRULE(expression);\n          const variable = OPTION(() => {\n            CONSUME(l.as);\n            return SUBRULE1(var_);\n          });\n          const close = CONSUME(l.symbols.RParen);\n          return ACTION(() => {\n            if (variable !== undefined) {\n              return {\n                variable,\n                value: expressionValue,\n                loc: C.astFactory.sourceLocation(open, close),\n              } satisfies SolutionModifierGroupBind;\n            }\n            return expressionValue;\n          });\n        },\n      },\n    ]),\n};\n\n/**\n * [[21]](https://www.w3.org/TR/sparql11-query/#rHavingClause)\n */\nexport const havingClause: SparqlRule<'havingClause', SolutionModifierHaving> = <const> {\n  name: 'havingClause',\n  impl: ({ ACTION, AT_LEAST_ONE, SUBRULE, CONSUME }) => (C) => {\n    const having = CONSUME(l.having);\n    const expressions: Expression[] = [];\n\n    const couldParseAgg = ACTION(() =>\n      C.parseMode.has('canParseAggregate') || !C.parseMode.add('canParseAggregate'));\n    AT_LEAST_ONE(() => {\n      expressions.push(SUBRULE(havingCondition));\n    });\n    ACTION(() => !couldParseAgg && C.parseMode.delete('canParseAggregate'));\n\n    return ACTION(() =>\n      C.astFactory.solutionModifierHaving(expressions, C.astFactory.sourceLocation(having, expressions.at(-1))));\n  },\n  gImpl: ({ PRINT_ON_EMPTY, SUBRULE }) => (ast, { astFactory: F }) => {\n    F.printFilter(ast, () => {\n      PRINT_ON_EMPTY('HAVING ');\n    });\n    for (const having of ast.having) {\n      SUBRULE(expression, having);\n    }\n  },\n};\n\n/**\n * [[22]](https://www.w3.org/TR/sparql11-query/#rHavingCondition)\n */\nexport const havingCondition: SparqlGrammarRule<'havingCondition', Expression> = <const> {\n  name: 'havingCondition',\n  impl: ({ SUBRULE }) => () => SUBRULE(constraint),\n};\n\n/**\n * [[23]](https://www.w3.org/TR/sparql11-query/#rOrderClause)\n */\nexport const orderClause: SparqlRule<'orderClause', SolutionModifierOrder> = <const> {\n  name: 'orderClause',\n  impl: ({ ACTION, AT_LEAST_ONE, SUBRULE1, CONSUME }) => (C) => {\n    const order = CONSUME(l.order);\n    CONSUME(l.by);\n    const orderings: Ordering[] = [];\n\n    const couldParseAgg = ACTION(() =>\n      C.parseMode.has('canParseAggregate') || !C.parseMode.add('canParseAggregate'));\n    AT_LEAST_ONE(() => {\n      orderings.push(SUBRULE1(orderCondition));\n    });\n    ACTION(() => !couldParseAgg && C.parseMode.delete('canParseAggregate'));\n\n    return ACTION(() =>\n      C.astFactory.solutionModifierOrder(orderings, C.astFactory.sourceLocation(order, orderings.at(-1))));\n  },\n  gImpl: ({ PRINT_WORDS, PRINT_ON_EMPTY, SUBRULE }) => (ast, { astFactory: F }) => {\n    F.printFilter(ast, () => {\n      PRINT_ON_EMPTY('ORDER BY ');\n    });\n    for (const ordering of ast.orderDefs) {\n      if (ordering.descending) {\n        F.printFilter(ast, () => PRINT_WORDS('DESC'));\n      } else {\n        F.printFilter(ast, () => PRINT_WORDS('ASC'));\n      }\n      F.printFilter(ast, () => PRINT_WORDS('('));\n      SUBRULE(expression, ordering.expression);\n      F.printFilter(ast, () => PRINT_WORDS(')'));\n    }\n  },\n};\n\n/**\n * [[24]](https://www.w3.org/TR/sparql11-query/#rOrderCondition)\n */\nexport const orderCondition: SparqlGrammarRule<'orderCondition', Ordering> = <const> {\n  name: 'orderCondition',\n  impl: ({ ACTION, SUBRULE, CONSUME, OR1, OR2 }) => C => OR1<Ordering>([\n    { ALT: () => {\n      const descending = OR2<[boolean, IToken]>([\n        { ALT: () => {\n          const token = CONSUME(l.orderAsc);\n          return <const>[ false, token ];\n        } },\n        { ALT: () => {\n          const token = CONSUME(l.orderDesc);\n          return <const> [ true, token ];\n        } },\n      ]);\n\n      const expr = SUBRULE(brackettedExpression);\n\n      return ACTION(() => ({\n        expression: expr,\n        descending: descending[0],\n        loc: C.astFactory.sourceLocation(descending[1], expr),\n      }));\n    } },\n    { ALT: () => {\n      const expr = SUBRULE(constraint);\n      return ACTION(() => ({ expression: expr, descending: false, loc: expr.loc }));\n    } },\n    { ALT: () => {\n      const expr = SUBRULE(var_);\n      return ACTION(() => ({ expression: expr, descending: false, loc: expr.loc }));\n    } },\n  ]),\n};\n\n/**\n * Parses limit and or offset in any order.\n * [[25]](https://www.w3.org/TR/sparql11-query/#rLimitOffsetClauses)\n */\nexport const limitOffsetClauses: SparqlRule<'limitOffsetClauses', SolutionModifierLimitOffset> = <const> {\n  name: 'limitOffsetClauses',\n  impl: ({ ACTION, SUBRULE1, SUBRULE2, OPTION1, OPTION2, OR }) => C => OR([\n    { ALT: () => {\n      const limit = SUBRULE1(limitClause);\n      const offset = OPTION1(() => SUBRULE1(offsetClause));\n      return ACTION(() => C.astFactory.solutionModifierLimitOffset(\n        limit.val,\n        offset?.val,\n        C.astFactory.sourceLocation(limit, ...(offset ? [ offset ] : [])),\n      ));\n    } },\n    { ALT: () => {\n      const offset = SUBRULE2(offsetClause);\n      const limit = OPTION2(() => SUBRULE2(limitClause));\n      return ACTION(() => C.astFactory.solutionModifierLimitOffset(\n        limit?.val,\n        offset.val,\n        C.astFactory.sourceLocation(offset, limit),\n      ));\n    } },\n  ]),\n  gImpl: ({ PRINT_WORDS, NEW_LINE }) => (ast, { astFactory: F }) => {\n    F.printFilter(ast, () => {\n      NEW_LINE();\n      if (ast.limit) {\n        PRINT_WORDS('LIMIT', String(ast.limit));\n      }\n      if (ast.offset) {\n        PRINT_WORDS('OFFSET', String(ast.offset));\n      }\n    });\n  },\n};\n\n/**\n * [[26]](https://www.w3.org/TR/sparql11-query/#rLimitClause)\n */\nexport const limitClause: SparqlGrammarRule<'limitClause', Wrap<number>> = <const> {\n  name: 'limitClause',\n  impl: ({ ACTION, CONSUME }) => (C) => {\n    const offset = CONSUME(l.limit);\n    const value = CONSUME(l.terminals.integer);\n    const val = Number.parseInt(value.image, 10);\n    return ACTION(() => C.astFactory.wrap(val, C.astFactory.sourceLocation(offset, value)));\n  },\n};\n\n/**\n * [[27]](https://www.w3.org/TR/sparql11-query/#rWhereClause)\n */\nexport const offsetClause: SparqlGrammarRule<'offsetClause', Wrap<number>> = <const> {\n  name: <const> 'offsetClause',\n  impl: ({ CONSUME, ACTION }) => (C) => {\n    const offset = CONSUME(l.offset);\n    const value = CONSUME(l.terminals.integer);\n    const val = Number.parseInt(value.image, 10);\n    return ACTION(() => C.astFactory.wrap(val, C.astFactory.sourceLocation(offset, value)));\n  },\n};\n"]}