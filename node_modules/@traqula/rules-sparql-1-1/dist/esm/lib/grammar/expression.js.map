{"version":3,"file":"expression.js","sourceRoot":"","sources":["../../../../lib/grammar/expression.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ImplArgs, RuleDefReturn, Wrap } from '@traqula/core';\nimport * as l from '../lexer/index.js';\nimport type { SparqlGrammarRule, SparqlRule } from '../sparql11HelperTypes.js';\nimport type {\n  Expression,\n  ExpressionFunctionCall,\n  ExpressionOperation,\n  TermIri,\n  TermLiteral,\n} from '../Sparql11types.js';\nimport { aggregate, builtInCall } from './builtIn.js';\nimport {\n  var_,\n  varOrTerm,\n} from './general.js';\nimport {\n  booleanLiteral,\n  iri,\n  numericLiteral,\n  numericLiteralNegative,\n  numericLiteralPositive,\n  rdfLiteral,\n} from './literals.js';\nimport { groupGraphPattern } from './whereClause.js';\n\n/**\n * [[71]](https://www.w3.org/TR/sparql11-query/#rArgList)\n */\nexport interface IArgList {\n  args: Expression[];\n  distinct: boolean;\n}\nexport const argList: SparqlRule<'argList', Wrap<IArgList>> = <const> {\n  name: 'argList',\n  impl: ({ ACTION, CONSUME, SUBRULE1, OPTION, OR, AT_LEAST_ONE_SEP }) => C =>\n    OR<RuleDefReturn<typeof argList>>([\n      { ALT: () => {\n        const nil = CONSUME(l.terminals.nil);\n        return ACTION(() =>\n          C.astFactory.wrap({ args: [], distinct: false }, C.astFactory.sourceLocation(nil)));\n      } },\n      { ALT: () => {\n        const args: Expression[] = [];\n        const open = CONSUME(l.symbols.LParen);\n        const distinct = OPTION(() => {\n          CONSUME(l.distinct);\n          return true;\n        }) ?? false;\n\n        AT_LEAST_ONE_SEP({\n          SEP: l.symbols.comma,\n          DEF: () => {\n            const arg = SUBRULE1(expression);\n            args.push(arg);\n          },\n        });\n        const close = CONSUME(l.symbols.RParen);\n        return ACTION(() =>\n          C.astFactory.wrap({ args, distinct }, C.astFactory.sourceLocation(open, close)));\n      } },\n    ]),\n  gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {\n    F.printFilter(ast, () => {\n      PRINT_WORD('(');\n      if (ast.val.distinct) {\n        PRINT_WORD('DISTINCT');\n      }\n    });\n    const [ head, ...tail ] = ast.val.args;\n    if (head) {\n      SUBRULE(expression, head);\n    }\n    for (const expr of tail) {\n      F.printFilter(ast, () => PRINT_WORD(','));\n      SUBRULE(expression, expr);\n    }\n    F.printFilter(ast, () => PRINT_WORD(')'));\n  },\n};\n\n/**\n * [[72]](https://www.w3.org/TR/sparql11-query/#rConstructTemplate)\n */\nexport const expressionList: SparqlGrammarRule<'expressionList', Wrap<Expression[]>> = <const> {\n  name: 'expressionList',\n  impl: ({ ACTION, CONSUME, MANY, OR, SUBRULE1, SUBRULE2 }) => C => OR([\n    { ALT: () => {\n      const nil = CONSUME(l.terminals.nil);\n      return ACTION(() => C.astFactory.wrap([], C.astFactory.sourceLocation(nil)));\n    } },\n    { ALT: () => {\n      const open = CONSUME(l.symbols.LParen);\n      const expr1 = SUBRULE1(expression);\n      const args: Expression[] = [ expr1 ];\n      MANY(() => {\n        CONSUME(l.symbols.comma);\n        const expr = SUBRULE2(expression);\n        args.push(expr);\n      });\n      const close = CONSUME(l.symbols.RParen);\n      return ACTION(() => C.astFactory.wrap(args, C.astFactory.sourceLocation(open, close)));\n    } },\n  ]),\n};\n\nconst infixOperators = new Set([ 'in', 'notin', '||', '&&', '=', '!=', '<', '>', '<=', '>=', '+', '-', '*', '/' ]);\nconst prefixOperator: Record<string, string> = { '!': '', uplus: '+', uminus: '-' };\n\n/**\n * [[110]](https://www.w3.org/TR/sparql11-query/#rExpression)\n */\nexport const expression: SparqlRule<'expression', Expression> = <const> {\n  name: 'expression',\n  impl: ({ SUBRULE }) => () => SUBRULE(conditionalOrExpression),\n  gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {\n    if (F.isTerm(ast)) {\n      SUBRULE(varOrTerm, ast);\n    } else if (F.isExpressionOperator(ast)) {\n      if (infixOperators.has(ast.operator)) {\n        const [ left, ...right ] = ast.args;\n        F.printFilter(ast, () => PRINT_WORD('('));\n        SUBRULE(expression, left);\n        F.printFilter(ast, () => {\n          if (ast.operator === 'notin') {\n            PRINT_WORD('NOT IN');\n          } else if (ast.operator === 'in') {\n            PRINT_WORD('IN');\n          } else {\n            PRINT_WORD(ast.operator.toUpperCase());\n          }\n        });\n        if (right.length === 1) {\n          SUBRULE(expression, right[0]);\n        } else {\n          SUBRULE(argList, F.wrap({ args: right, distinct: false }, ast.loc));\n        }\n        F.printFilter(ast, () => PRINT_WORD(')'));\n      } else if (typeof prefixOperator[ast.operator] === 'string') {\n        const [ expr ] = <[Expression]>ast.args;\n        F.printFilter(ast, () => PRINT_WORD(prefixOperator[ast.operator] || ast.operator.toUpperCase()));\n        SUBRULE(expression, expr);\n      } else {\n        F.printFilter(ast, () => PRINT_WORD(ast.operator.toUpperCase(), '('));\n        const [ head, ...tail ] = ast.args;\n        if (head) {\n          SUBRULE(expression, head);\n        }\n        for (const arg of tail) {\n          F.printFilter(ast, () => PRINT_WORD(','));\n          SUBRULE(expression, arg);\n        }\n        F.printFilter(ast, () => PRINT_WORD(')'));\n      }\n    } else if (F.isExpressionPatternOperation(ast)) {\n      const patterns = ast.args;\n      F.printFilter(ast, () => PRINT_WORD(ast.operator === 'exists' ? 'EXISTS' : 'NOT EXISTS'));\n      SUBRULE(groupGraphPattern, patterns);\n    } else if (F.isExpressionFunctionCall(ast)) {\n      SUBRULE(iriOrFunction, ast);\n    } else if (F.isExpressionAggregate(ast)) {\n      SUBRULE(aggregate, ast);\n    }\n  },\n};\n\ntype LeftDeepBuildArgs = (left: Expression) => ExpressionOperation;\n\nfunction constructLeftDeep(\n  startGenerator: () => Expression,\n  restGenerator: () => LeftDeepBuildArgs,\n  ACTION: ImplArgs['ACTION'],\n  MANY: ImplArgs['MANY'],\n): ExpressionOperation | Expression {\n  // By using iterExpression, we avoid creating unnecessary arrays\n  let iterExpr = startGenerator();\n  MANY(() => {\n    const res = restGenerator();\n    ACTION(() => {\n      iterExpr = res(iterExpr);\n    });\n  });\n  return iterExpr;\n}\n\n/**\n * [[111]](https://www.w3.org/TR/sparql11-query/#rConditionalOrExpression)\n */\nexport const conditionalOrExpression: SparqlGrammarRule<'conditionalOrExpression', ExpressionOperation | Expression> =\n  <const> {\n    name: 'conditionalOrExpression',\n    impl: ({ ACTION, MANY, CONSUME, SUBRULE1, SUBRULE2 }) => C => constructLeftDeep(\n      () => SUBRULE1(conditionalAndExpression),\n      () => {\n        CONSUME(l.symbols.logicOr);\n        const args = SUBRULE2(conditionalAndExpression);\n        return left => ACTION(() =>\n          C.astFactory.expressionOperation('||', [ left, args ], C.astFactory.sourceLocation(left, args)));\n      },\n      ACTION,\n      MANY,\n    ),\n  };\n\n/**\n * [[112]](https://www.w3.org/TR/sparql11-query/#rConditionalAndExpression)\n */\nexport const conditionalAndExpression: SparqlGrammarRule<'conditionalAndExpression', Expression> = <const> {\n  name: 'conditionalAndExpression',\n  impl: ({ ACTION, MANY, SUBRULE1, SUBRULE2, CONSUME }) => C => constructLeftDeep(\n    () => SUBRULE1(valueLogical),\n    () => {\n      CONSUME(l.symbols.logicAnd);\n      const arg = SUBRULE2(valueLogical);\n      return left => ACTION(() =>\n        C.astFactory.expressionOperation('&&', [ left, arg ], C.astFactory.sourceLocation(left, arg)));\n    },\n    ACTION,\n    MANY,\n  ),\n};\n\n/**\n * [[113]](https://www.w3.org/TR/sparql11-query/#rValueLogical)\n */\nexport const valueLogical: SparqlGrammarRule<'valueLogical', Expression> = <const> {\n  name: 'valueLogical',\n  impl: ({ SUBRULE }) => () => SUBRULE(relationalExpression),\n};\n\n/**\n * [[114]](https://www.w3.org/TR/sparql11-query/#rRelationalExpression)\n */\nexport const relationalExpression:\nSparqlGrammarRule<'relationalExpression', ExpressionOperation | Expression> = <const>{\n  name: 'relationalExpression',\n  impl: ({ ACTION, CONSUME, SUBRULE1, SUBRULE2, OPTION, OR1, OR2, OR3 }) => (C) => {\n    const args1 = SUBRULE1(numericExpression);\n    const expression = OPTION<ExpressionOperation>(() =>\n      OR1<ExpressionOperation>([\n        { ALT: () => {\n          // Stay in numeric;\n          const operator = OR2([\n            { ALT: () => CONSUME(l.symbols.equal) },\n            { ALT: () => CONSUME(l.symbols.notEqual) },\n            { ALT: () => CONSUME(l.symbols.lessThan) },\n            { ALT: () => CONSUME(l.symbols.greaterThan) },\n            { ALT: () => CONSUME(l.symbols.lessThanEqual) },\n            { ALT: () => CONSUME(l.symbols.greaterThanEqual) },\n          ]);\n          const expr = SUBRULE2(numericExpression);\n          return ACTION(() => C.astFactory.expressionOperation(\n            operator.image,\n            [ args1, expr ],\n            C.astFactory.sourceLocation(args1, expr),\n          ));\n        } },\n        { ALT: () => {\n          const operator = OR3([\n            { ALT: () => CONSUME(l.in_) },\n            { ALT: () => CONSUME(l.notIn) },\n          ]);\n          const args = SUBRULE1(expressionList);\n          return ACTION(() => C.astFactory.expressionOperation(\n            operator.image,\n            [ args1, ...args.val ],\n            C.astFactory.sourceLocation(args1, args),\n          ));\n        } },\n      ]));\n    return expression ?? args1;\n  },\n};\n\n/**\n * [[115]](https://www.w3.org/TR/sparql11-query/#rNumericExpression)\n */\nexport const numericExpression: SparqlGrammarRule<'numericExpression', Expression> = <const> {\n  name: 'numericExpression',\n  impl: ({ SUBRULE }) => () => SUBRULE(additiveExpression),\n};\n\n/**\n * [[116]](https://www.w3.org/TR/sparql11-query/#rAdditiveExpression)\n */\nexport const additiveExpression: SparqlGrammarRule<'additiveExpression', Expression> = <const> {\n  name: 'additiveExpression',\n  impl: ({ ACTION, SUBRULE, CONSUME, SUBRULE1, SUBRULE2, MANY1, MANY2, OR1, OR2, OR3, OR4 }) => C =>\n    constructLeftDeep(\n      () => SUBRULE1(multiplicativeExpression),\n      () => OR1<(left: Expression) => ExpressionOperation>([\n        { ALT: () => {\n          // Multiplicative expression as 2nd argument\n          const operator = OR2([\n            { ALT: () => CONSUME(l.symbols.opPlus) },\n            { ALT: () => CONSUME(l.symbols.opMinus) },\n          ]);\n          const arg = SUBRULE2(multiplicativeExpression);\n          return ACTION(() => left =>\n            C.astFactory.expressionOperation(operator.image, [ left, arg ], C.astFactory.sourceLocation(left, arg)));\n        } },\n        { ALT: () => {\n          // The operator of this alternative is actually parsed as part of the signed numeric literal. (note #6)\n          const { operator, startInt } = OR3<{ operator: '+' | '-'; startInt: TermLiteral }>([\n            { ALT: () => {\n              // Note #6. No spaces are allowed between the sign and a number.\n              // In this rule however, we do not want to care about this.\n              const integer = SUBRULE(numericLiteralPositive);\n              return ACTION(() => {\n                integer.value = integer.value.replace(/^\\+/u, '');\n                return <const> {\n                  operator: '+',\n                  startInt: integer,\n                };\n              });\n            } },\n            { ALT: () => {\n              const integer = SUBRULE(numericLiteralNegative);\n              return ACTION(() => {\n                integer.value = integer.value.replace(/^-/u, '');\n                return <const> {\n                  operator: '-',\n                  startInt: integer,\n                };\n              });\n            } },\n          ]);\n          const multiplicativeExpr = constructLeftDeep(\n            () => ACTION(() => startInt),\n            () => {\n              const innerOperator = OR4([\n                { ALT: () => CONSUME(l.symbols.star) },\n                { ALT: () => CONSUME(l.symbols.slash) },\n              ]);\n              const innerExpr = SUBRULE1(unaryExpression);\n              return ACTION(() => leftInner => C.astFactory.expressionOperation(\n                innerOperator.image,\n                [ leftInner, innerExpr ],\n                C.astFactory.sourceLocation(leftInner, innerExpr),\n              ));\n            },\n            ACTION,\n            MANY2,\n          );\n          return left => C.astFactory.expressionOperation(\n            operator,\n            [ left, multiplicativeExpr ],\n            C.astFactory.sourceLocation(left, multiplicativeExpr),\n          );\n        } },\n      ]),\n      ACTION,\n      MANY1,\n    ),\n};\n\n/**\n * [[117]](https://www.w3.org/TR/sparql11-query/#rMultiplicativeExpression)\n */\nexport const multiplicativeExpression: SparqlGrammarRule<'multiplicativeExpression', Expression> = <const> {\n  name: 'multiplicativeExpression',\n  impl: ({ ACTION, CONSUME, MANY, SUBRULE1, SUBRULE2, OR }) => C => constructLeftDeep(\n    () => SUBRULE1(unaryExpression),\n    () => {\n      const operator = OR([\n        { ALT: () => CONSUME(l.symbols.star) },\n        { ALT: () => CONSUME(l.symbols.slash) },\n      ]);\n      const expr = SUBRULE2(unaryExpression);\n      return (left: Expression) => ({\n        type: 'expression',\n        subType: 'operation',\n        operator: operator.image,\n        args: [ left, expr ],\n        loc: C.astFactory.sourceLocation(left, expr),\n      });\n    },\n    ACTION,\n    MANY,\n  ),\n};\n\n/**\n * [[118]](https://www.w3.org/TR/sparql11-query/#rUnaryExpression)\n */\nexport const unaryExpression: SparqlGrammarRule<'unaryExpression', Expression> = <const> {\n  name: 'unaryExpression',\n  impl: ({ ACTION, CONSUME, SUBRULE1, SUBRULE2, OR1, OR2 }) => C => OR1<Expression>([\n    { ALT: () => SUBRULE1(primaryExpression) },\n    { ALT: () => {\n      const operator = OR2([\n        { ALT: () => CONSUME(l.symbols.exclamation) },\n        { ALT: () => CONSUME(l.symbols.opPlus) },\n        { ALT: () => CONSUME(l.symbols.opMinus) },\n      ]);\n      const expr = SUBRULE2(primaryExpression);\n      return ACTION(() => C.astFactory.expressionOperation(\n        operator.image === '!' ? '!' : (operator.image === '+' ? 'UPLUS' : 'UMINUS'),\n        [ expr ],\n        C.astFactory.sourceLocation(operator, expr),\n      ));\n    } },\n  ]),\n};\n\n/**\n * [[119]](https://www.w3.org/TR/sparql11-query/#rPrimaryExpression)\n */\nexport const primaryExpression: SparqlGrammarRule<'primaryExpression', Expression> = <const> {\n  name: 'primaryExpression',\n  impl: ({ SUBRULE, OR }) => () => OR([\n    { ALT: () => SUBRULE(brackettedExpression) },\n    { ALT: () => SUBRULE(builtInCall) },\n    { ALT: () => SUBRULE(iriOrFunction) },\n    { ALT: () => SUBRULE(rdfLiteral) },\n    { ALT: () => SUBRULE(numericLiteral) },\n    { ALT: () => SUBRULE(booleanLiteral) },\n    { ALT: () => SUBRULE(var_) },\n  ]),\n};\n\n/**\n * [[120]](https://www.w3.org/TR/sparql11-query/#rBrackettedExpression)\n */\nexport const brackettedExpression: SparqlGrammarRule<'brackettedExpression', Expression> = <const> {\n  name: 'brackettedExpression',\n  impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {\n    const open = CONSUME(l.symbols.LParen);\n    const expr = SUBRULE(expression);\n    const close = CONSUME(l.symbols.RParen);\n    return ACTION(() => {\n      expr.loc = C.astFactory.sourceLocation(open, close);\n      return expr;\n    });\n  },\n};\n\n/**\n * [[128]](https://www.w3.org/TR/sparql11-query/#ririOrFunction)\n */\nexport const iriOrFunction: SparqlRule<'iriOrFunction', TermIri | ExpressionFunctionCall> = <const> {\n  name: 'iriOrFunction',\n  impl: ({ ACTION, SUBRULE, OPTION }) => (C) => {\n    const iriVal = SUBRULE(iri);\n    const functionCall = OPTION<ExpressionFunctionCall>(() => {\n      const args = SUBRULE(argList);\n      return ACTION(() => {\n        const distinct = args.val.distinct;\n        if (!C.parseMode.has('canParseAggregate') && distinct) {\n          throw new Error(`DISTINCT implies that this function is an aggregated function, which is not allowed in this context.`);\n        }\n        return {\n          type: 'expression',\n          subType: 'functionCall',\n          function: iriVal,\n          args: args.val.args,\n          distinct,\n          loc: C.astFactory.sourceLocation(iriVal, args),\n        };\n      });\n    });\n    return functionCall ?? iriVal;\n  },\n  gImpl: ({ SUBRULE }) => (ast, { astFactory: F }) => {\n    if (F.isTermNamed(ast)) {\n      SUBRULE(iri, ast);\n    } else {\n      SUBRULE(iri, ast.function);\n      SUBRULE(argList, F.wrap({ args: ast.args, distinct: ast.distinct }, ast.loc));\n    }\n  },\n};\n"]}