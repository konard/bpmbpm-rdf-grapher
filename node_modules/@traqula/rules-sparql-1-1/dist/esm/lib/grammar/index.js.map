{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../lib/grammar/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { symbols } from '../lexer/index.js';\nimport type { SparqlRule } from '../sparql11HelperTypes.js';\nimport type { Query, SparqlQuery, Update } from '../Sparql11types.js';\nimport { updateNoReuseBlankNodeLabels } from '../validation/validators.js';\nimport { prologue } from './general.js';\nimport type { HandledByBase } from './queryUnit.js';\nimport { query, askQuery, constructQuery, describeQuery, selectQuery, valuesClause } from './queryUnit.js';\nimport { update, update1 } from './updateUnit.js';\n\nexport * from './queryUnit.js';\nexport * from './updateUnit.js';\nexport * from './builtIn.js';\nexport * from './dataSetClause.js';\nexport * from './expression.js';\nexport * from '../expressionHelpers.js';\nexport * from './general.js';\nexport * from './literals.js';\nexport * from './propertyPaths.js';\nexport * from './solutionModifier.js';\nexport * from './tripleBlock.js';\nexport * from './whereClause.js';\n\n/**\n * Query or update, optimized for the Query case.\n * One could implement a new rule that does not use BACKTRACK.\n */\nexport const queryOrUpdate: SparqlRule<'queryOrUpdate', SparqlQuery> = {\n  name: 'queryOrUpdate',\n  impl: ({ ACTION, SUBRULE, OR1, OR2, MANY, OPTION1, CONSUME, SUBRULE2 }) => (C) => {\n    const prologueValues = SUBRULE(prologue);\n    return OR1<Query | Update>([\n      { ALT: () => {\n        const subType = OR2<Omit<Query, HandledByBase>>([\n          { ALT: () => SUBRULE(selectQuery) },\n          { ALT: () => SUBRULE(constructQuery) },\n          { ALT: () => SUBRULE(describeQuery) },\n          { ALT: () => SUBRULE(askQuery) },\n        ]);\n        const values = SUBRULE(valuesClause);\n        return ACTION(() => (<Query>{\n          context: prologueValues,\n          ...subType,\n          type: 'query',\n          ...(values && { values }),\n          loc: C.astFactory.sourceLocation(\n            prologueValues.at(0),\n            subType,\n            values,\n          ),\n        }));\n      } },\n      { ALT: () => {\n        const updates: Update['updates'] = [];\n        updates.push({ context: prologueValues });\n        let parsedSemi = true;\n        MANY({\n          GATE: () => parsedSemi,\n          DEF: () => {\n            parsedSemi = false;\n            updates.at(-1)!.operation = SUBRULE(update1);\n\n            OPTION1(() => {\n              CONSUME(symbols.semi);\n\n              parsedSemi = true;\n              const innerPrologue = SUBRULE2(prologue);\n              updates.push({ context: innerPrologue });\n            });\n          },\n        });\n        return ACTION(() => {\n          const update = {\n            type: 'update',\n            updates,\n            loc: C.astFactory.sourceLocation(\n              ...updates.flatMap(x => [ ...x.context, x.operation ]),\n            ),\n          } satisfies Update;\n          if (!C.skipValidation) {\n            updateNoReuseBlankNodeLabels(update);\n          }\n          return update;\n        });\n      } },\n    ]);\n  },\n  gImpl: ({ SUBRULE }) => (ast, { astFactory: F }) => {\n    if (F.isQuery(ast)) {\n      SUBRULE(query, ast);\n    } else {\n      SUBRULE(update, ast);\n    }\n  },\n};\n"]}