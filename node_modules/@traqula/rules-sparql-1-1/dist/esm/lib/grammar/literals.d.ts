import type { SparqlGrammarRule, SparqlRule } from '../sparql11HelperTypes.js';
import type { TermBlank, TermIri, TermIriFull, TermIriPrefixed, TermLiteral, TermLiteralStr, TermLiteralTyped } from '../Sparql11types.js';
export declare function stringEscapedLexical(str: string): string;
/**
 * [[120]](https://www.w3.org/TR/sparql11-query/#rRDFLiteral)
 */
export declare const rdfLiteral: SparqlRule<'rdfLiteral', TermLiteral>;
/**
 * Parses a numeric literal.
 * [[130]](https://www.w3.org/TR/sparql11-query/#rNumericLiteral)
 */
export declare const numericLiteral: SparqlGrammarRule<'numericLiteral', TermLiteralTyped>;
/**
 * Parses an unsigned numeric literal.
 * [[131]](https://www.w3.org/TR/sparql11-query/#rNumericLiteralUnsigned)
 */
export declare const numericLiteralUnsigned: SparqlGrammarRule<'numericLiteralUnsigned', TermLiteralTyped>;
/**
 * Parses a positive numeric literal.
 * [[132]](https://www.w3.org/TR/sparql11-query/#rNumericLiteralPositive)
 */
export declare const numericLiteralPositive: SparqlGrammarRule<'numericLiteralPositive', TermLiteralTyped>;
/**
 * Parses a negative numeric literal.
 * [[133]](https://www.w3.org/TR/sparql11-query/#rNumericLiteralNegative)
 */
export declare const numericLiteralNegative: SparqlGrammarRule<'numericLiteralNegative', TermLiteralTyped>;
/**
 * Parses a boolean literal.
 * [[134]](https://www.w3.org/TR/sparql11-query/#rBooleanLiteral)
 */
export declare const booleanLiteral: SparqlGrammarRule<'booleanLiteral', TermLiteralTyped>;
/**
 * Parses a string literal.
 * [[135]](https://www.w3.org/TR/sparql11-query/#rString)
 */
export declare const string: SparqlGrammarRule<'string', TermLiteralStr>;
/**
 * Parses a named node, either as an IRI or as a prefixed name.
 * [[136]](https://www.w3.org/TR/sparql11-query/#riri)
 */
export declare const iri: SparqlRule<'iri', TermIri>;
export declare const iriFull: SparqlRule<'iriFull', TermIriFull>;
/**
 * Parses a named node with a prefix. Looks up the prefix in the context and returns the full IRI.
 * [[137]](https://www.w3.org/TR/sparql11-query/#rPrefixedName)
 */
export declare const prefixedName: SparqlRule<'prefixedName', TermIriPrefixed>;
export declare const canCreateBlankNodes: unique symbol;
/**
 * Parses blank note and throws an error if 'canCreateBlankNodes' is not in the current parserMode.
 * [[138]](https://www.w3.org/TR/sparql11-query/#rBlankNode)
 */
export declare const blankNode: SparqlRule<'blankNode', TermBlank>;
export declare const verbA: SparqlGrammarRule<'VerbA', TermIriFull>;
