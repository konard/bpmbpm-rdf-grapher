{"version":3,"file":"literals.js","sourceRoot":"","sources":["../../../../lib/grammar/literals.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IToken } from '@traqula/chevrotain';\nimport * as l from '../lexer/index.js';\nimport type { SparqlGrammarRule, SparqlRule } from '../sparql11HelperTypes.js';\nimport type {\n  TermBlank,\n  TermIri,\n  TermIriFull,\n  TermIriPrefixed,\n  TermLiteral,\n  TermLiteralStr,\n  TermLiteralTyped,\n} from '../Sparql11types.js';\nimport { CommonIRIs } from '../utils.js';\n\nexport function stringEscapedLexical(str: string): string {\n  const lexical = str.replaceAll(/[\"\\\\\\t\\n\\r\\b\\f]/gu, (char) => {\n    switch (char) {\n      case '\\t':\n        return '\\\\t';\n      case '\\n':\n        return '\\\\n';\n      case '\\r':\n        return '\\\\r';\n      case '\\b':\n        return '\\\\b';\n      case '\\f':\n        return '\\\\f';\n      case '\"':\n        return '\\\\\"';\n      case '\\\\':\n        return '\\\\\\\\';\n      default:\n        return char;\n    }\n  });\n  return `\"${lexical}\"`;\n}\n\n/**\n * [[120]](https://www.w3.org/TR/sparql11-query/#rRDFLiteral)\n */\nexport const rdfLiteral: SparqlRule<'rdfLiteral', TermLiteral> = <const> {\n  name: 'rdfLiteral',\n  impl: ({ ACTION, SUBRULE1, CONSUME, OPTION, OR }) => (C) => {\n    const value = SUBRULE1(string);\n    return OPTION(() => OR<TermLiteral>([\n      { ALT: () => {\n        const lang = CONSUME(l.terminals.langTag);\n        return ACTION(() => C.astFactory.termLiteral(\n          C.astFactory.sourceLocation(value, lang),\n          value.value,\n          lang.image.slice(1).toLowerCase(),\n        ));\n      } },\n      { ALT: () => {\n        CONSUME(l.symbols.hathat);\n        const iriVal = SUBRULE1(iri);\n        return ACTION(() => C.astFactory.termLiteral(\n          C.astFactory.sourceLocation(value, iriVal),\n          value.value,\n          iriVal,\n        ));\n      } },\n    ])) ?? value;\n  },\n  gImpl: ({ SUBRULE, PRINT, PRINT_WORD }) => (ast, { astFactory }) => {\n    if (!ast.langOrIri || typeof ast.langOrIri === 'string') {\n      // String or langdir string - no sub loc.\n      astFactory.printFilter(ast, () => {\n        PRINT_WORD('');\n        PRINT(stringEscapedLexical(ast.value));\n      });\n      if (typeof ast.langOrIri === 'string') {\n        astFactory.printFilter(ast, () => PRINT('@', ast.langOrIri));\n      }\n    } else if (astFactory.isSourceLocationNoMaterialize(ast.langOrIri.loc)) {\n      // You have a typed literal. -- If type is not materialized, print raw\n      astFactory.printFilter(ast, () => {\n        PRINT_WORD(ast.value);\n      });\n    } else {\n      astFactory.printFilter(ast, () => {\n        PRINT_WORD('');\n        PRINT(stringEscapedLexical(ast.value), '^^');\n      });\n      SUBRULE(iri, ast.langOrIri);\n    }\n  },\n};\n\n/**\n * Parses a numeric literal.\n * [[130]](https://www.w3.org/TR/sparql11-query/#rNumericLiteral)\n */\nexport const numericLiteral: SparqlGrammarRule<'numericLiteral', TermLiteralTyped> = <const> {\n  name: 'numericLiteral',\n  impl: ({ SUBRULE, OR }) => () => OR([\n    { ALT: () => SUBRULE(numericLiteralUnsigned) },\n    { ALT: () => SUBRULE(numericLiteralPositive) },\n    { ALT: () => SUBRULE(numericLiteralNegative) },\n  ]),\n};\n\n/**\n * Parses an unsigned numeric literal.\n * [[131]](https://www.w3.org/TR/sparql11-query/#rNumericLiteralUnsigned)\n */\nexport const numericLiteralUnsigned: SparqlGrammarRule<'numericLiteralUnsigned', TermLiteralTyped> = <const> {\n  name: 'numericLiteralUnsigned',\n  impl: ({ ACTION, CONSUME, OR }) => (C) => {\n    const parsed = OR<[IToken, string]>([\n      { ALT: () => <const> [ CONSUME(l.terminals.integer), CommonIRIs.INTEGER ]},\n      { ALT: () => <const> [ CONSUME(l.terminals.decimal), CommonIRIs.DECIMAL ]},\n      { ALT: () => <const> [ CONSUME(l.terminals.double), CommonIRIs.DOUBLE ]},\n    ]);\n    return ACTION(() => C.astFactory.termLiteral(\n      C.astFactory.sourceLocation(parsed[0]),\n      parsed[0].image,\n      C.astFactory.termNamed(C.astFactory.sourceLocation(), parsed[1]),\n    ));\n  },\n};\n\n/**\n * Parses a positive numeric literal.\n * [[132]](https://www.w3.org/TR/sparql11-query/#rNumericLiteralPositive)\n */\nexport const numericLiteralPositive: SparqlGrammarRule<'numericLiteralPositive', TermLiteralTyped> = <const> {\n  name: 'numericLiteralPositive',\n  impl: ({ ACTION, CONSUME, OR }) => (C) => {\n    const parsed = OR<[IToken, string]>([\n      { ALT: () => <const> [ CONSUME(l.terminals.integerPositive), CommonIRIs.INTEGER ]},\n      { ALT: () => <const> [ CONSUME(l.terminals.decimalPositive), CommonIRIs.DECIMAL ]},\n      { ALT: () => <const> [ CONSUME(l.terminals.doublePositive), CommonIRIs.DOUBLE ]},\n    ]);\n    return ACTION(() => C.astFactory.termLiteral(\n      C.astFactory.sourceLocation(parsed[0]),\n      parsed[0].image,\n      C.astFactory.termNamed(C.astFactory.sourceLocation(), parsed[1]),\n    ));\n  },\n};\n\n/**\n * Parses a negative numeric literal.\n * [[133]](https://www.w3.org/TR/sparql11-query/#rNumericLiteralNegative)\n */\nexport const numericLiteralNegative: SparqlGrammarRule<'numericLiteralNegative', TermLiteralTyped> = <const> {\n  name: 'numericLiteralNegative',\n  impl: ({ ACTION, CONSUME, OR }) => (C) => {\n    const parsed = OR<[IToken, string]>([\n      { ALT: () => <const> [ CONSUME(l.terminals.integerNegative), CommonIRIs.INTEGER ]},\n      { ALT: () => <const> [ CONSUME(l.terminals.decimalNegative), CommonIRIs.DECIMAL ]},\n      { ALT: () => <const> [ CONSUME(l.terminals.doubleNegative), CommonIRIs.DOUBLE ]},\n    ]);\n    return ACTION(() => C.astFactory.termLiteral(\n      C.astFactory.sourceLocation(parsed[0]),\n      parsed[0].image,\n      C.astFactory.termNamed(C.astFactory.sourceLocation(), parsed[1]),\n    ));\n  },\n};\n\n/**\n * Parses a boolean literal.\n * [[134]](https://www.w3.org/TR/sparql11-query/#rBooleanLiteral)\n */\nexport const booleanLiteral: SparqlGrammarRule<'booleanLiteral', TermLiteralTyped> = <const> {\n  name: 'booleanLiteral',\n  impl: ({ ACTION, CONSUME, OR }) => (C) => {\n    const token = OR([\n      { ALT: () => CONSUME(l.true_) },\n      { ALT: () => CONSUME(l.false_) },\n    ]);\n\n    return ACTION(() => C.astFactory.termLiteral(\n      C.astFactory.sourceLocation(token),\n      token.image.toLowerCase(),\n      C.astFactory.termNamed(C.astFactory.sourceLocation(), CommonIRIs.BOOLEAN),\n    ));\n  },\n};\n\n/**\n * Parses a string literal.\n * [[135]](https://www.w3.org/TR/sparql11-query/#rString)\n */\nexport const string: SparqlGrammarRule<'string', TermLiteralStr> = <const> {\n  name: 'string',\n  impl: ({ ACTION, CONSUME, OR }) => (C) => {\n    const x = OR([\n      { ALT: () => {\n        const token = CONSUME(l.terminals.stringLiteral1);\n        return <const>[ token, token.image.slice(1, -1) ];\n      } },\n      { ALT: () => {\n        const token = CONSUME(l.terminals.stringLiteral2);\n        return <const>[ token, token.image.slice(1, -1) ];\n      } },\n      { ALT: () => {\n        const token = CONSUME(l.terminals.stringLiteralLong1);\n        return <const>[ token, token.image.slice(3, -3) ];\n      } },\n      { ALT: () => {\n        const token = CONSUME(l.terminals.stringLiteralLong2);\n        return <const>[ token, token.image.slice(3, -3) ];\n      } },\n    ]);\n    // Handle string escapes (19.7). (19.2 is handled at input level.)\n    return ACTION(() => {\n      const F = C.astFactory;\n      const value = x[1].replaceAll(/\\\\([tnrbf\"'\\\\])/gu, (_, char: string) => {\n        switch (char) {\n          case 't':\n            return '\\t';\n          case 'n':\n            return '\\n';\n          case 'r':\n            return '\\r';\n          case 'b':\n            return '\\b';\n          case 'f':\n            return '\\f';\n          default:\n            return char;\n        }\n      });\n      return F.termLiteral(F.sourceLocation(x[0]), value);\n    });\n  },\n};\n\n/**\n * Parses a named node, either as an IRI or as a prefixed name.\n * [[136]](https://www.w3.org/TR/sparql11-query/#riri)\n */\nexport const iri: SparqlRule<'iri', TermIri> = <const> {\n  name: 'iri',\n  impl: ({ SUBRULE, OR }) => () => OR<TermIri>([\n    { ALT: () => SUBRULE(iriFull) },\n    { ALT: () => SUBRULE(prefixedName) },\n  ]),\n  gImpl: ({ SUBRULE }) => (ast, { astFactory: F }) =>\n    F.isTermNamedPrefixed(ast) ? SUBRULE(prefixedName, ast) : SUBRULE(iriFull, ast),\n};\n\nexport const iriFull: SparqlRule<'iriFull', TermIriFull> = <const> {\n  name: 'iriFull',\n  impl: ({ ACTION, CONSUME }) => (C) => {\n    const iriToken = CONSUME(l.terminals.iriRef);\n    return ACTION(() => C.astFactory.termNamed(C.astFactory.sourceLocation(iriToken), iriToken.image.slice(1, -1)));\n  },\n  gImpl: ({ PRINT }) => (ast, { astFactory: F }) => {\n    F.printFilter(ast, () => PRINT('<', ast.value, '>'));\n  },\n};\n\n/**\n * Parses a named node with a prefix. Looks up the prefix in the context and returns the full IRI.\n * [[137]](https://www.w3.org/TR/sparql11-query/#rPrefixedName)\n */\nexport const prefixedName: SparqlRule<'prefixedName', TermIriPrefixed> = <const> {\n  name: 'prefixedName',\n  impl: ({ ACTION, CONSUME, OR }) => (C) => {\n    function verifyPrefix(prefix: string): void {\n      if (!C.skipValidation && C.prefixes[prefix] === undefined) {\n        throw new Error(`Unknown prefix: ${prefix}`);\n      }\n    }\n    return OR([{ ALT: () => {\n      const longName = CONSUME(l.terminals.pNameLn);\n      return ACTION(() => {\n        const [ prefix, localName ] = longName.image.split(':');\n        verifyPrefix(prefix);\n        return C.astFactory.termNamed(C.astFactory.sourceLocation(longName), localName, prefix);\n      });\n    },\n    }, { ALT: () => {\n      const shortName = CONSUME(l.terminals.pNameNs);\n      return ACTION(() => {\n        const prefix = shortName.image.slice(0, -1);\n        verifyPrefix(prefix);\n        return C.astFactory.termNamed(\n          C.astFactory.sourceLocation(shortName),\n          '',\n          prefix,\n        );\n      });\n    },\n    }]);\n  },\n  gImpl: ({ PRINT }) => (ast, { astFactory: F }) => {\n    F.printFilter(ast, () => PRINT(ast.prefix, ':', ast.value));\n  },\n};\n\nexport const canCreateBlankNodes = Symbol('canCreateBlankNodes');\n\n/**\n * Parses blank note and throws an error if 'canCreateBlankNodes' is not in the current parserMode.\n * [[138]](https://www.w3.org/TR/sparql11-query/#rBlankNode)\n */\nexport const blankNode: SparqlRule<'blankNode', TermBlank> = <const> {\n  name: 'blankNode',\n  impl: ({ ACTION, CONSUME, OR }) => (C) => {\n    const result = OR([\n      { ALT: () => {\n        const labelToken = CONSUME(l.terminals.blankNodeLabel);\n        return ACTION(() =>\n          C.astFactory.termBlank(labelToken.image.slice(2), C.astFactory.sourceLocation(labelToken)));\n      } },\n      { ALT: () => {\n        const anonToken = CONSUME(l.terminals.anon);\n        return ACTION(() => C.astFactory.termBlank(undefined, C.astFactory.sourceLocation(anonToken)));\n      } },\n    ]);\n    ACTION(() => {\n      if (!C.parseMode.has('canCreateBlankNodes')) {\n        throw new Error('Blank nodes are not allowed in this context');\n      }\n    });\n    return result;\n  },\n  gImpl: ({ PRINT }) => (ast, { astFactory }) => {\n    astFactory.printFilter(ast, () => PRINT('_:', ast.label.replace(/^e_/u, '')));\n  },\n};\n\nexport const verbA: SparqlGrammarRule<'VerbA', TermIriFull> = <const> {\n  name: 'VerbA',\n  impl: ({ ACTION, CONSUME }) => (C) => {\n    const token = CONSUME(l.a);\n    return ACTION(() => C.astFactory.termNamed(C.astFactory.sourceLocation(token), CommonIRIs.TYPE, undefined));\n  },\n};\n"]}