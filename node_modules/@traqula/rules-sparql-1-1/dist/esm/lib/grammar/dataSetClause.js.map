{"version":3,"file":"dataSetClause.js","sourceRoot":"","sources":["../../../../lib/grammar/dataSetClause.ts"],"names":[],"mappings":"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","sourcesContent":["import type { TokenType } from '@traqula/chevrotain';\nimport type { RuleDefReturn, Wrap } from '@traqula/core';\nimport * as l from '../lexer/index.js';\nimport type { SparqlGrammarRule, SparqlRule } from '../sparql11HelperTypes.js';\nimport type { DatasetClauses, TermIri } from '../Sparql11types.js';\nimport { iri } from './literals.js';\n\nexport function datasetClauseUsing<RuleName extends 'usingClause' | 'datasetClause'>(\n  name: RuleName,\n  token: TokenType,\n): SparqlGrammarRule<RuleName, Wrap<DatasetClauses['clauses'][0]>> {\n  return {\n    name,\n    impl: ({ ACTION, SUBRULE, CONSUME, OR }) => (C) => {\n      const start = CONSUME(token);\n      return OR<RuleDefReturn<typeof datasetClause>>([\n        { ALT: () => {\n          const iri = SUBRULE(defaultGraphClause);\n          return ACTION(() =>\n            C.astFactory.wrap({ clauseType: 'default', value: iri }, C.astFactory.sourceLocation(start, iri)));\n        } },\n        { ALT: () => {\n          const namedClause = SUBRULE(namedGraphClause);\n          return ACTION(() => C.astFactory.wrap({\n            clauseType: 'named',\n            value: namedClause.val,\n          }, C.astFactory.sourceLocation(start, namedClause)));\n        } },\n      ]);\n    },\n  };\n}\n\n/**\n * [[13]](https://www.w3.org/TR/sparql11-query/#rDatasetClause)\n */\nexport const datasetClause = datasetClauseUsing('datasetClause', l.from);\n\n/**\n * [[14]](https://www.w3.org/TR/sparql11-query/#rDefaultGraphClause)\n */\nexport const defaultGraphClause: SparqlGrammarRule<'defaultGraphClause', TermIri> = <const> {\n  name: 'defaultGraphClause',\n  impl: ({ SUBRULE }) => () => SUBRULE(sourceSelector),\n};\n/**\n * [[44]](https://www.w3.org/TR/sparql11-query/#rUsingClause)\n */\nexport const usingClause = datasetClauseUsing('usingClause', l.usingClause);\n\nexport function datasetClauseUsingStar<RuleName extends string>(\n  name: RuleName,\n  subRule: ReturnType<typeof datasetClauseUsing<any>>,\n  fromUsing: 'FROM' | 'USING',\n): SparqlRule<RuleName, DatasetClauses> {\n  return {\n    name,\n    impl: ({ ACTION, MANY, SUBRULE }) => (C) => {\n      const clauses: RuleDefReturn<typeof datasetClause>[] = [];\n\n      MANY(() => {\n        const clause = SUBRULE(subRule);\n        clauses.push(clause);\n      });\n\n      return ACTION(() => C.astFactory.datasetClauses(\n        clauses.map(clause => clause.val),\n        C.astFactory.sourceLocation(...clauses),\n      ));\n    },\n    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {\n      for (const clause of ast.clauses) {\n        F.printFilter(ast, () => PRINT_WORD(fromUsing));\n        if (clause.clauseType === 'named') {\n          F.printFilter(ast, () => PRINT_WORD('NAMED'));\n        }\n        SUBRULE(iri, clause.value);\n      }\n    },\n  };\n}\n\nexport const datasetClauseStar = datasetClauseUsingStar(<const> 'datasetClauses', datasetClause, 'FROM');\nexport const usingClauseStar = datasetClauseUsingStar(<const> 'usingClauses', usingClause, 'USING');\n\n/**\n * [[15]](https://www.w3.org/TR/sparql11-query/#rNamedGraphClause)\n */\nexport const namedGraphClause: SparqlGrammarRule<'namedGraphClause', Wrap<TermIri>> = <const> {\n  name: 'namedGraphClause',\n  impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {\n    const named = CONSUME(l.graph.named);\n    const iri = SUBRULE(sourceSelector);\n    return ACTION(() => C.astFactory.wrap(iri, C.astFactory.sourceLocation(named, iri)));\n  },\n};\n\n/**\n * [[16]](https://www.w3.org/TR/sparql11-query/#rSourceSelector)\n */\nexport const sourceSelector: SparqlGrammarRule<'sourceSelector', TermIri> = <const> {\n  name: 'sourceSelector',\n  impl: ({ SUBRULE }) => () => SUBRULE(iri),\n};\n"]}