{"version":3,"file":"SolutionModifiersFactory.js","sourceRoot":"","sources":["../../../../lib/factoryMixins/SolutionModifiersFactory.ts"],"names":[],"mappings":"AAaA,MAAM,QAAQ,GAAa,kBAAkB,CAAC;AAE9C,4DAA4D;AAC5D,MAAM,UAAU,6BAA6B,CAA4C,IAAW;IAClG,OAAO,MAAM,wBAAyB,SAAQ,IAAI;QACzC,kBAAkB,CAAC,GAAW;YACnC,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;QACtC,CAAC;QAEM,sBAAsB,CAAC,MAAoB,EAAE,GAAmB;YACrE,OAAO;gBACL,IAAI,EAAE,QAAQ;gBACd,OAAO,EAAE,QAAQ;gBACjB,MAAM;gBACN,GAAG;aACJ,CAAC;QACJ,CAAC;QAEM,wBAAwB,CAAC,GAAW;YACzC,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACnD,CAAC;QAEM,qBAAqB,CAAC,SAAqB,EAAE,GAAmB;YACrE,OAAO;gBACL,IAAI,EAAE,QAAQ;gBACd,OAAO,EAAE,OAAO;gBAChB,SAAS;gBACT,GAAG;aACJ,CAAC;QACJ,CAAC;QAEM,uBAAuB,CAAC,GAAW;YACxC,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;QAClD,CAAC;QAEM,2BAA2B,CAChC,KAAyB,EACzB,MAA0B,EAC1B,GAAmB;YAEnB,OAAO;gBACL,IAAI,EAAE,QAAQ;gBACd,OAAO,EAAE,aAAa;gBACtB,KAAK;gBACL,MAAM;gBACN,GAAG;aACJ,CAAC;QACJ,CAAC;QAEM,6BAA6B,CAAC,GAAW;YAC9C,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,QAAQ,EAAE,aAAa,CAAC,CAAC;QACxD,CAAC;QAEM,qBAAqB,CAAC,SAAqD,EAAE,GAAmB;YAErG,OAAO;gBACL,IAAI,EAAE,kBAAkB;gBACxB,OAAO,EAAE,OAAO;gBAChB,SAAS;gBACT,GAAG;aACJ,CAAC;QACJ,CAAC;QAEM,uBAAuB,CAAC,GAAW;YACxC,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;QAClD,CAAC;KACF,CAAC;AACJ,CAAC","sourcesContent":["import type { AstCoreFactory, SourceLocation, Typed, SubTyped } from '@traqula/core';\nimport type {\n  Expression,\n  Ordering,\n  SolutionModifierGroup,\n  SolutionModifierGroupBind,\n  SolutionModifierHaving,\n  SolutionModifierLimitOffset,\n  SolutionModifierOrder,\n} from '../Sparql11types.js';\nimport type { Constructor } from './mixins.js';\n\ntype NodeType = 'solutionModifier';\nconst nodeType: NodeType = 'solutionModifier';\n\n// eslint-disable-next-line ts/explicit-function-return-type\nexport function SolutionModifiersFactoryMixin<TBase extends Constructor<AstCoreFactory>>(Base: TBase) {\n  return class SolutionModifiersFactory extends Base {\n    public isSolutionModifier(obj: object): obj is Typed<NodeType> {\n      return this.isOfType(obj, nodeType);\n    }\n\n    public solutionModifierHaving(having: Expression[], loc: SourceLocation): SolutionModifierHaving {\n      return {\n        type: nodeType,\n        subType: 'having',\n        having,\n        loc,\n      };\n    }\n\n    public isSolutionModifierHaving(obj: object): obj is SubTyped<NodeType, 'having'> {\n      return this.isOfSubType(obj, nodeType, 'having');\n    }\n\n    public solutionModifierOrder(orderDefs: Ordering[], loc: SourceLocation): SolutionModifierOrder {\n      return {\n        type: nodeType,\n        subType: 'order',\n        orderDefs,\n        loc,\n      };\n    }\n\n    public isSolutionModifierOrder(obj: object): obj is SubTyped<NodeType, 'order'> {\n      return this.isOfSubType(obj, nodeType, 'order');\n    }\n\n    public solutionModifierLimitOffset(\n      limit: number | undefined,\n      offset: number | undefined,\n      loc: SourceLocation,\n    ): SolutionModifierLimitOffset {\n      return {\n        type: nodeType,\n        subType: 'limitOffset',\n        limit,\n        offset,\n        loc,\n      };\n    }\n\n    public isSolutionModifierLimitOffset(obj: object): obj is SubTyped<NodeType, 'limitOffset'> {\n      return this.isOfSubType(obj, nodeType, 'limitOffset');\n    }\n\n    public solutionModifierGroup(groupings: (Expression | SolutionModifierGroupBind)[], loc: SourceLocation):\n    SolutionModifierGroup {\n      return {\n        type: 'solutionModifier',\n        subType: 'group',\n        groupings,\n        loc,\n      };\n    }\n\n    public isSolutionModifierGroup(obj: object): obj is SubTyped<NodeType, 'group'> {\n      return this.isOfSubType(obj, nodeType, 'group');\n    }\n  };\n}\n"]}