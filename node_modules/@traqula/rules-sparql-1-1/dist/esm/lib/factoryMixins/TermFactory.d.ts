import type { AstCoreFactory, SourceLocation, Typed, SubTyped } from '@traqula/core';
import type { TermBlank, TermIri, TermIriFull, TermIriPrefixed, TermLiteral, TermLiteralLangStr, TermLiteralStr, TermLiteralTyped, TermVariable } from '../Sparql11types.js';
import type { Constructor } from './mixins.js';
type NodeType = 'term';
export declare function TermFactoryMixin<TBase extends Constructor<AstCoreFactory>>(Base: TBase): {
    new (...args: any[]): {
        __blankNodeCounter: number;
        resetBlankNodeCounter(): void;
        isTerm(x: object): x is Typed<"term">;
        termBlank(label: undefined | string, loc: SourceLocation): TermBlank;
        isTermBlank(obj: object): obj is SubTyped<NodeType, "blankNode">;
        /**
         * String, no lang, no type
         */
        termLiteral(loc: SourceLocation, value: string, lang?: undefined): TermLiteralStr;
        /**
         * String with a language tag
         */
        termLiteral(loc: SourceLocation, value: string, lang: string): TermLiteralLangStr;
        /**
         * Lexical form with a type
         */
        termLiteral(loc: SourceLocation, value: string, iri: TermIri): TermLiteralTyped;
        termLiteral(loc: SourceLocation, value: string, langOrIri?: string | TermIri): TermLiteral;
        isTermLiteral(obj: object): obj is SubTyped<NodeType, "literal">;
        isTermLiteralLangStr(obj: object): obj is SubTyped<NodeType, "literal"> & {
            langOrIri: string;
        };
        isTermLiteralStr(obj: object): obj is SubTyped<NodeType, "literal"> & {
            langOrIri: undefined;
        };
        isTermLiteralTyped(obj: object): obj is SubTyped<NodeType, "literal"> & {
            langOrIri: SubTyped<NodeType, "namedNode">;
        };
        termVariable(value: string, loc: SourceLocation): TermVariable;
        isTermVariable(obj: object): obj is SubTyped<NodeType, "variable">;
        /**
         * A namednode with fully defined with a uri.
         */
        termNamed(loc: SourceLocation, value: string, prefix?: undefined): TermIriFull;
        /**
         * A namednode defined using a prefix
         */
        termNamed(loc: SourceLocation, value: string, prefix: string): TermIriPrefixed;
        isTermNamed(obj: object): obj is SubTyped<NodeType, "namedNode">;
        isTermNamedPrefixed(obj: object): obj is SubTyped<NodeType, "namedNode"> & {
            prefix: string;
        };
        tracksSourceLocation: boolean;
        wrap<T>(val: T, loc: SourceLocation): import("@traqula/core").Wrap<T>;
        isLocalized(obj: unknown): obj is import("@traqula/core").Localized;
        sourceLocation(...elements: (undefined | import("chevrotain").IToken | import("@traqula/core").Localized)[]): SourceLocation;
        sourceLocationNoMaterialize(): SourceLocation;
        dematerialized<T extends import("@traqula/core").Node>(arg: T): T;
        safeObjectTransform(value: unknown, mapper: (some: object) => any): any;
        forcedAutoGenTree<T extends object>(obj: T): T;
        forceMaterialized<T extends import("@traqula/core").Node>(arg: T): T;
        isSourceLocation(loc: object): loc is SourceLocation;
        sourceLocationSource(start: number, end: number): import("@traqula/core").SourceLocationSource;
        sourceLocationInlinedSource(newSource: string, subLoc: SourceLocation, start: number, end: number, startOnNew?: number, endOnNew?: number): SourceLocation;
        isSourceLocationInlinedSource(loc: object): loc is import("@traqula/core").SourceLocationInlinedSource;
        gen(): import("@traqula/core").SourceLocationNodeAutoGenerate;
        isSourceLocationSource(loc: object): loc is import("@traqula/core").SourceLocationSource;
        sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation;
        isSourceLocationStringReplace(loc: object): loc is import("@traqula/core").SourceLocationStringReplace;
        sourceLocationNodeReplaceUnsafe(loc: SourceLocation): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(location: import("@traqula/core").SourceLocationSource): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(start: number, end: number): import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeReplace(loc: object): loc is import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeAutoGenerate(loc: object): loc is import("@traqula/core").SourceLocationNodeAutoGenerate;
        isPrintingLoc(loc: SourceLocation): boolean;
        printFilter(node: import("@traqula/core").Localized, callback: () => void): void;
        isSourceLocationNoMaterialize(loc: object): loc is import("@traqula/core").SourceLocationNoMaterialize;
        isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type>;
        isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType): obj is SubTyped<Type, SubType>;
    };
} & TBase;
export {};
