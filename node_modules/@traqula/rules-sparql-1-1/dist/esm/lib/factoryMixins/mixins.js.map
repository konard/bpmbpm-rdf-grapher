{"version":3,"file":"mixins.js","sourceRoot":"","sources":["../../../../lib/factoryMixins/mixins.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAMH,MAAM,UAAU,KAAK,CAAI,GAAM;IAC7B,OAAO,IAAI,QAAQ,CAAI,GAAG,CAAC,CAAC;AAC9B,CAAC;AAED,MAAM,QAAQ;IACe;IAA3B,YAA2B,KAAY;QAAZ,UAAK,GAAL,KAAK,CAAO;IAAG,CAAC;IACpC,IAAI,CAAM,IAA2B;QAC1C,IAAI,CAAC,KAAK,GAAqB,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAChD,OAAiC,IAAI,CAAC;IACxC,CAAC;IAEM,OAAO;QACZ,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;CACF","sourcesContent":["/**\n * We use mixins as explained by the official TypeScript documentation:\n * https://www.typescriptlang.org/docs/handbook/mixins.html\n * Mixins are used so we can split into many files.\n * Additionally, it allows type guards and generics, which the is not possible using the indirection builder.\n */\n\nexport type Constructor<T = object> = new (...args: any[]) => T;\n\nexport type Mixin<Base = object, U extends Base = Base> = (superclass: Constructor<Base>) => Constructor<U>;\n\nexport function asArg<T>(arg: T): FlatCall<T> {\n  return new FlatCall<T>(arg);\n}\n\nclass FlatCall<Input> {\n  public constructor(private input: Input) {}\n  public call<Out>(func: (input: Input) => Out): FlatCall<Out> {\n    this.input = <Input> <unknown> func(this.input);\n    return <FlatCall<Out>> <unknown> this;\n  }\n\n  public returns(): Input {\n    return this.input;\n  }\n}\n"]}