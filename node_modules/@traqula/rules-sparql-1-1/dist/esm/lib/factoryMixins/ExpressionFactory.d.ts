import type { AstCoreFactory, SourceLocation, Typed, SubTyped } from '@traqula/core';
import type { Expression, ExpressionAggregate, ExpressionAggregateDefault, ExpressionAggregateOnWildcard, ExpressionAggregateSeparator, ExpressionFunctionCall, ExpressionOperation, ExpressionPatternOperation, PatternGroup, TermIri, Wildcard } from '../Sparql11types.js';
import type { Constructor } from './mixins.js';
type NodeType = 'expression';
export declare function ExpressionFactoryMixin<TBase extends Constructor<AstCoreFactory>>(Base: TBase): {
    new (...args: any[]): {
        isExpressionPure(obj: object): obj is Typed<NodeType>;
        formatOperator(operator: string): string;
        expressionOperation<Args extends Expression[]>(operator: string, args: Args, loc: SourceLocation): ExpressionOperation & {
            args: Args;
        };
        isExpressionOperator(obj: object): obj is SubTyped<NodeType, "operation">;
        expressionFunctionCall<Args extends Expression[]>(functionOp: TermIri, args: Args, distinct: boolean, loc: SourceLocation): ExpressionFunctionCall & {
            args: Args;
        };
        isExpressionFunctionCall(obj: object): obj is SubTyped<NodeType, "functionCall">;
        expressionPatternOperation(operator: string, args: PatternGroup, loc: SourceLocation): ExpressionPatternOperation;
        isExpressionPatternOperation(obj: object): obj is SubTyped<NodeType, "patternOperation">;
        aggregate(aggregation: string, distinct: boolean, arg: Expression, separator: undefined, loc: SourceLocation): ExpressionAggregateDefault;
        aggregate(aggregation: string, distinct: boolean, arg: Wildcard, separator: undefined, loc: SourceLocation): ExpressionAggregateOnWildcard;
        aggregate(aggregation: string, distinct: boolean, arg: Expression, separator: string, loc: SourceLocation): ExpressionAggregateSeparator;
        aggregate(aggregation: string, distinct: boolean, arg: Expression | Wildcard, separator: string | undefined, loc: SourceLocation): ExpressionAggregate;
        isExpressionAggregate(obj: object): obj is SubTyped<NodeType, "aggregate">;
        isExpressionAggregateSeparator(obj: object): obj is SubTyped<NodeType, "aggregate"> & {
            separator: string;
        };
        isExpressionAggregateOnWildcard(obj: object): obj is SubTyped<NodeType, "aggregate"> & {
            expression: [Typed<"wildcard">];
        };
        isExpressionAggregateDefault(obj: object): obj is SubTyped<NodeType, "aggregate"> & {
            expression: [Expression];
        };
        tracksSourceLocation: boolean;
        wrap<T>(val: T, loc: SourceLocation): import("@traqula/core").Wrap<T>;
        isLocalized(obj: unknown): obj is import("@traqula/core").Localized;
        sourceLocation(...elements: (undefined | import("chevrotain").IToken | import("@traqula/core").Localized)[]): SourceLocation;
        sourceLocationNoMaterialize(): SourceLocation;
        dematerialized<T extends import("@traqula/core").Node>(arg: T): T;
        safeObjectTransform(value: unknown, mapper: (some: object) => any): any;
        forcedAutoGenTree<T extends object>(obj: T): T;
        forceMaterialized<T extends import("@traqula/core").Node>(arg: T): T;
        isSourceLocation(loc: object): loc is SourceLocation;
        sourceLocationSource(start: number, end: number): import("@traqula/core").SourceLocationSource;
        sourceLocationInlinedSource(newSource: string, subLoc: SourceLocation, start: number, end: number, startOnNew?: number, endOnNew?: number): SourceLocation;
        isSourceLocationInlinedSource(loc: object): loc is import("@traqula/core").SourceLocationInlinedSource;
        gen(): import("@traqula/core").SourceLocationNodeAutoGenerate;
        isSourceLocationSource(loc: object): loc is import("@traqula/core").SourceLocationSource;
        sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation;
        isSourceLocationStringReplace(loc: object): loc is import("@traqula/core").SourceLocationStringReplace;
        sourceLocationNodeReplaceUnsafe(loc: SourceLocation): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(location: import("@traqula/core").SourceLocationSource): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(start: number, end: number): import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeReplace(loc: object): loc is import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeAutoGenerate(loc: object): loc is import("@traqula/core").SourceLocationNodeAutoGenerate;
        isPrintingLoc(loc: SourceLocation): boolean;
        printFilter(node: import("@traqula/core").Localized, callback: () => void): void;
        isSourceLocationNoMaterialize(loc: object): loc is import("@traqula/core").SourceLocationNoMaterialize;
        isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type>;
        isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType): obj is SubTyped<Type, SubType>;
    };
} & TBase;
export {};
