import type { AstCoreFactory, SourceLocation, Typed, SubTyped } from '@traqula/core';
import type { BasicGraphPattern, Expression, Pattern, PatternBgp, PatternBind, PatternFilter, PatternGraph, PatternGroup, PatternMinus, PatternOptional, PatternService, PatternUnion, PatternValues, TermIri, TermVariable, ValuePatternRow } from '../Sparql11types.js';
import type { Constructor } from './mixins.js';
type NodeType = 'pattern';
export declare function PatternFactoryMixin<TBase extends Constructor<AstCoreFactory>>(Base: TBase): {
    new (...args: any[]): {
        isPattern(obj: object): obj is Typed<NodeType>;
        patternBgp(triples: BasicGraphPattern, loc: SourceLocation): PatternBgp;
        isPatternBgp(obj: object): obj is SubTyped<NodeType, "bgp">;
        patternGroup(patterns: Pattern[], loc: SourceLocation): PatternGroup;
        isPatternGroup(obj: object): obj is SubTyped<NodeType, "group">;
        patternGraph(name: TermIri | TermVariable, patterns: Pattern[], loc: SourceLocation): PatternGraph;
        isPatternGraph(obj: object): obj is SubTyped<NodeType, "graph">;
        patternOptional(patterns: Pattern[], loc: SourceLocation): PatternOptional;
        isPatternOptional(obj: object): obj is SubTyped<NodeType, "optional">;
        patternValues(variables: TermVariable[], values: ValuePatternRow[], loc: SourceLocation): PatternValues;
        isPatternValues(obj: object): obj is SubTyped<NodeType, "values">;
        patternFilter(expression: Expression, loc: SourceLocation): PatternFilter;
        isPatternFilter(obj: object): obj is SubTyped<NodeType, "filter">;
        patternBind(expression: Expression, variable: TermVariable, loc: SourceLocation): PatternBind;
        isPatternBind(obj: object): obj is SubTyped<NodeType, "bind">;
        patternUnion(patterns: PatternGroup[], loc: SourceLocation): PatternUnion;
        isPatternUnion(obj: object): obj is SubTyped<NodeType, "union">;
        patternMinus(patterns: Pattern[], loc: SourceLocation): PatternMinus;
        isPatternMinus(obj: object): obj is SubTyped<NodeType, "minus">;
        patternService(name: TermIri | TermVariable, patterns: Pattern[], silent: boolean, loc: SourceLocation): PatternService;
        isPatternService(obj: object): obj is SubTyped<NodeType, "service">;
        tracksSourceLocation: boolean;
        wrap<T>(val: T, loc: SourceLocation): import("@traqula/core").Wrap<T>;
        isLocalized(obj: unknown): obj is import("@traqula/core").Localized;
        sourceLocation(...elements: (undefined | import("chevrotain").IToken | import("@traqula/core").Localized)[]): SourceLocation;
        sourceLocationNoMaterialize(): SourceLocation;
        dematerialized<T extends import("@traqula/core").Node>(arg: T): T;
        safeObjectTransform(value: unknown, mapper: (some: object) => any): any;
        forcedAutoGenTree<T extends object>(obj: T): T;
        forceMaterialized<T extends import("@traqula/core").Node>(arg: T): T;
        isSourceLocation(loc: object): loc is SourceLocation;
        sourceLocationSource(start: number, end: number): import("@traqula/core").SourceLocationSource;
        sourceLocationInlinedSource(newSource: string, subLoc: SourceLocation, start: number, end: number, startOnNew?: number, endOnNew?: number): SourceLocation;
        isSourceLocationInlinedSource(loc: object): loc is import("@traqula/core").SourceLocationInlinedSource;
        gen(): import("@traqula/core").SourceLocationNodeAutoGenerate;
        isSourceLocationSource(loc: object): loc is import("@traqula/core").SourceLocationSource;
        sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation;
        isSourceLocationStringReplace(loc: object): loc is import("@traqula/core").SourceLocationStringReplace;
        sourceLocationNodeReplaceUnsafe(loc: SourceLocation): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(location: import("@traqula/core").SourceLocationSource): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(start: number, end: number): import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeReplace(loc: object): loc is import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeAutoGenerate(loc: object): loc is import("@traqula/core").SourceLocationNodeAutoGenerate;
        isPrintingLoc(loc: SourceLocation): boolean;
        printFilter(node: import("@traqula/core").Localized, callback: () => void): void;
        isSourceLocationNoMaterialize(loc: object): loc is import("@traqula/core").SourceLocationNoMaterialize;
        isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type>;
        isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType): obj is SubTyped<Type, SubType>;
    };
} & TBase;
export {};
