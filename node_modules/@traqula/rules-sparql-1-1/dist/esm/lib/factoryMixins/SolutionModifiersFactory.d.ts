import type { AstCoreFactory, SourceLocation, Typed, SubTyped } from '@traqula/core';
import type { Expression, Ordering, SolutionModifierGroup, SolutionModifierGroupBind, SolutionModifierHaving, SolutionModifierLimitOffset, SolutionModifierOrder } from '../Sparql11types.js';
import type { Constructor } from './mixins.js';
type NodeType = 'solutionModifier';
export declare function SolutionModifiersFactoryMixin<TBase extends Constructor<AstCoreFactory>>(Base: TBase): {
    new (...args: any[]): {
        isSolutionModifier(obj: object): obj is Typed<NodeType>;
        solutionModifierHaving(having: Expression[], loc: SourceLocation): SolutionModifierHaving;
        isSolutionModifierHaving(obj: object): obj is SubTyped<NodeType, "having">;
        solutionModifierOrder(orderDefs: Ordering[], loc: SourceLocation): SolutionModifierOrder;
        isSolutionModifierOrder(obj: object): obj is SubTyped<NodeType, "order">;
        solutionModifierLimitOffset(limit: number | undefined, offset: number | undefined, loc: SourceLocation): SolutionModifierLimitOffset;
        isSolutionModifierLimitOffset(obj: object): obj is SubTyped<NodeType, "limitOffset">;
        solutionModifierGroup(groupings: (Expression | SolutionModifierGroupBind)[], loc: SourceLocation): SolutionModifierGroup;
        isSolutionModifierGroup(obj: object): obj is SubTyped<NodeType, "group">;
        tracksSourceLocation: boolean;
        wrap<T>(val: T, loc: SourceLocation): import("@traqula/core").Wrap<T>;
        isLocalized(obj: unknown): obj is import("@traqula/core").Localized;
        sourceLocation(...elements: (undefined | import("chevrotain").IToken | import("@traqula/core").Localized)[]): SourceLocation;
        sourceLocationNoMaterialize(): SourceLocation;
        dematerialized<T extends import("@traqula/core").Node>(arg: T): T;
        safeObjectTransform(value: unknown, mapper: (some: object) => any): any;
        forcedAutoGenTree<T extends object>(obj: T): T;
        forceMaterialized<T extends import("@traqula/core").Node>(arg: T): T;
        isSourceLocation(loc: object): loc is SourceLocation;
        sourceLocationSource(start: number, end: number): import("@traqula/core").SourceLocationSource;
        sourceLocationInlinedSource(newSource: string, subLoc: SourceLocation, start: number, end: number, startOnNew?: number, endOnNew?: number): SourceLocation;
        isSourceLocationInlinedSource(loc: object): loc is import("@traqula/core").SourceLocationInlinedSource;
        gen(): import("@traqula/core").SourceLocationNodeAutoGenerate;
        isSourceLocationSource(loc: object): loc is import("@traqula/core").SourceLocationSource;
        sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation;
        isSourceLocationStringReplace(loc: object): loc is import("@traqula/core").SourceLocationStringReplace;
        sourceLocationNodeReplaceUnsafe(loc: SourceLocation): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(location: import("@traqula/core").SourceLocationSource): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(start: number, end: number): import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeReplace(loc: object): loc is import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeAutoGenerate(loc: object): loc is import("@traqula/core").SourceLocationNodeAutoGenerate;
        isPrintingLoc(loc: SourceLocation): boolean;
        printFilter(node: import("@traqula/core").Localized, callback: () => void): void;
        isSourceLocationNoMaterialize(loc: object): loc is import("@traqula/core").SourceLocationNoMaterialize;
        isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type>;
        isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType): obj is SubTyped<Type, SubType>;
    };
} & TBase;
export {};
