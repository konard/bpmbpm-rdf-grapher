const nodeType = 'path';
// eslint-disable-next-line ts/explicit-function-return-type
export function PathFactoryMixin(Base) {
    return class PathFactory extends Base {
        isPathPure(obj) {
            return this.isOfType(obj, nodeType);
        }
        path(subType, items, loc) {
            const base = {
                type: nodeType,
                loc,
                items,
            };
            if (subType === '|' || subType === '/') {
                return {
                    ...base,
                    subType,
                };
            }
            if ((subType === '?' || subType === '*' || subType === '+' || subType === '^') && items.length === 1) {
                return {
                    ...base,
                    subType,
                    items: items,
                };
            }
            if (subType === '^' && items.length === 1 && !this.isPathPure(items[0])) {
                return {
                    ...base,
                    subType,
                    items: items,
                };
            }
            if (subType === '!' && items.length === 1 && (this.isPathAlternativeLimited(items[0]) || !this.isPathPure(items[0]) || this.isPathNegatedElt(items[0]))) {
                return {
                    ...base,
                    subType,
                    items: items,
                };
            }
            throw new Error('Invalid path type');
        }
        isPathOfType(obj, subTypes) {
            return this.isOfType(obj, nodeType) && subTypes.includes(obj.subType);
        }
        isPathChain(obj) {
            return this.isOfSubType(obj, nodeType, '/') || this.isOfSubType(obj, nodeType, '|');
        }
        isPathModified(obj) {
            return this.isOfSubType(obj, nodeType, '?') || this.isOfSubType(obj, nodeType, '*') ||
                this.isOfSubType(obj, nodeType, '+') || this.isOfSubType(obj, nodeType, '^');
        }
        isPathNegatedElt(obj) {
            const casted = obj;
            return this.isOfSubType(obj, nodeType, '^') && Array.isArray(casted.items) && casted.items.length === 1 &&
                typeof casted.items[0] === 'object' && (casted.items[0] ?? false) && !this.isPathPure(casted.items[0]);
        }
        isPathNegated(obj) {
            return this.isOfSubType(obj, nodeType, '!');
        }
        isPathAlternativeLimited(obj) {
            const casted = obj;
            return this.isOfSubType(obj, nodeType, '|') && Array.isArray(casted.items) &&
                casted.items.every(item => !this.isPathPure(item) || this.isPathNegatedElt(item));
        }
    };
}
//# sourceMappingURL=PathFactory.js.map