import type { AstCoreFactory, SourceLocation, Typed, SubTyped } from '@traqula/core';
import type { Path, PathAlternativeLimited, PathModified, PathNegated, PathNegatedElt, PropertyPathChain, TermIri } from '../Sparql11types.js';
import type { Constructor } from './mixins.js';
type NodeType = 'path';
type RawNegatedElt = SubTyped<NodeType, '^'> & {
    items: [SubTyped<'term', 'namedNode'>];
};
export declare function PathFactoryMixin<TBase extends Constructor<AstCoreFactory>>(Base: TBase): {
    new (...args: any[]): {
        isPathPure(obj: object): obj is Typed<NodeType>;
        path(subType: "|", items: (TermIri | PathNegatedElt)[], loc: SourceLocation): PathAlternativeLimited;
        path(subType: "!", items: [TermIri | PathNegatedElt | PathAlternativeLimited], loc: SourceLocation): PathNegated;
        path(subType: "^", items: [TermIri], loc: SourceLocation): PathNegatedElt;
        path(subType: PathModified["subType"], item: [Path], loc: SourceLocation): PathModified;
        path(subType: "|" | "/", items: Path[], loc: SourceLocation): PropertyPathChain;
        isPathOfType<T extends U[], U extends string>(obj: object, subTypes: T): obj is SubTyped<NodeType, U>;
        isPathChain(obj: object): obj is SubTyped<NodeType, "|" | "/">;
        isPathModified(obj: object): obj is SubTyped<NodeType, "?" | "*" | "+" | "^">;
        isPathNegatedElt(obj: object): obj is RawNegatedElt;
        isPathNegated(obj: object): obj is SubTyped<NodeType, "!">;
        isPathAlternativeLimited(obj: object): obj is SubTyped<NodeType, "|"> & {
            items: (SubTyped<"term", "namedNode"> | RawNegatedElt)[];
        };
        tracksSourceLocation: boolean;
        wrap<T>(val: T, loc: SourceLocation): import("@traqula/core").Wrap<T>;
        isLocalized(obj: unknown): obj is import("@traqula/core").Localized;
        sourceLocation(...elements: (undefined | import("chevrotain").IToken | import("@traqula/core").Localized)[]): SourceLocation;
        sourceLocationNoMaterialize(): SourceLocation;
        dematerialized<T extends import("@traqula/core").Node>(arg: T): T;
        safeObjectTransform(value: unknown, mapper: (some: object) => any): any;
        forcedAutoGenTree<T extends object>(obj: T): T;
        forceMaterialized<T extends import("@traqula/core").Node>(arg: T): T;
        isSourceLocation(loc: object): loc is SourceLocation;
        sourceLocationSource(start: number, end: number): import("@traqula/core").SourceLocationSource;
        sourceLocationInlinedSource(newSource: string, subLoc: SourceLocation, start: number, end: number, startOnNew?: number, endOnNew?: number): SourceLocation;
        isSourceLocationInlinedSource(loc: object): loc is import("@traqula/core").SourceLocationInlinedSource;
        gen(): import("@traqula/core").SourceLocationNodeAutoGenerate;
        isSourceLocationSource(loc: object): loc is import("@traqula/core").SourceLocationSource;
        sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation;
        isSourceLocationStringReplace(loc: object): loc is import("@traqula/core").SourceLocationStringReplace;
        sourceLocationNodeReplaceUnsafe(loc: SourceLocation): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(location: import("@traqula/core").SourceLocationSource): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(start: number, end: number): import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeReplace(loc: object): loc is import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeAutoGenerate(loc: object): loc is import("@traqula/core").SourceLocationNodeAutoGenerate;
        isPrintingLoc(loc: SourceLocation): boolean;
        printFilter(node: import("@traqula/core").Localized, callback: () => void): void;
        isSourceLocationNoMaterialize(loc: object): loc is import("@traqula/core").SourceLocationNoMaterialize;
        isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type>;
        isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType): obj is SubTyped<Type, SubType>;
    };
} & TBase;
export {};
