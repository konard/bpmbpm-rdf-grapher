import { AstCoreFactory } from '@traqula/core';
import { ContextFactoryMixin } from './factoryMixins/ContextFactory.js';
import { ExpressionFactoryMixin } from './factoryMixins/ExpressionFactory.js';
import { GraphRefFactoryMixin } from './factoryMixins/GraphRefFactory.js';
import { asArg } from './factoryMixins/mixins.js';
import { PathFactoryMixin } from './factoryMixins/PathFactory.js';
import { PatternFactoryMixin } from './factoryMixins/Patternfactory.js';
import { QueryFactoryMixin } from './factoryMixins/QueryFactory.js';
import { SolutionModifiersFactoryMixin } from './factoryMixins/SolutionModifiersFactory.js';
import { TermFactoryMixin } from './factoryMixins/TermFactory.js';
import { UpdateOperationFactoryMixin } from './factoryMixins/UpdateOperationFactory.js';
/**
 * A factory that helps you create, and check types for AST nodes for SPARQL 1.1
 */
export class AstFactory extends asArg(AstCoreFactory)
    .call(ContextFactoryMixin)
    .call(ExpressionFactoryMixin)
    .call(GraphRefFactoryMixin)
    .call(PathFactoryMixin)
    .call(PatternFactoryMixin)
    .call(QueryFactoryMixin)
    .call(SolutionModifiersFactoryMixin)
    .call(TermFactoryMixin)
    .call(UpdateOperationFactoryMixin)
    .returns() {
    alwaysSparql11(obj) {
        return true;
    }
    isPath(obj) {
        return this.isPathPure(obj) || this.isTermNamed(obj);
    }
    isExpression(obj) {
        return this.isExpressionPure(obj) || this.isTermNamed(obj) || this.isTermVariable(obj) || this.isTermLiteral(obj);
    }
    graphNodeIdentifier(graphNode) {
        return graphNode.type === 'tripleCollection' ? graphNode.identifier : graphNode;
    }
    triple(subject, predicate, object, loc) {
        return {
            type: 'triple',
            subject,
            predicate,
            object,
            loc: loc ?? this.sourceLocation(subject, predicate, object),
        };
    }
    isTriple(obj) {
        return this.isOfType(obj, 'triple');
    }
    datasetClauses(clauses, loc) {
        return {
            type: 'datasetClauses',
            clauses,
            loc,
        };
    }
    isDatasetClauses(obj) {
        return this.isOfType(obj, 'datasetClauses');
    }
    wildcard(loc) {
        return { type: 'wildcard', loc };
    }
    isWildcard(obj) {
        return this.isOfType(obj, 'wildcard');
    }
    isTripleCollection(obj) {
        return this.isOfType(obj, 'tripleCollection');
    }
    tripleCollectionBlankNodeProperties(identifier, triples, loc) {
        return {
            type: 'tripleCollection',
            subType: 'blankNodeProperties',
            identifier,
            triples,
            loc,
        };
    }
    isTripleCollectionBlankNodeProperties(obj) {
        return this.isOfSubType(obj, 'tripleCollection', 'blankNodeProperties');
    }
    tripleCollectionList(identifier, triples, loc) {
        return {
            type: 'tripleCollection',
            subType: 'list',
            identifier,
            triples,
            loc,
        };
    }
    isTripleCollectionList(obj) {
        return this.isOfSubType(obj, 'tripleCollection', 'list');
    }
    graphQuads(graph, triples, loc) {
        return {
            type: 'graph',
            graph,
            triples,
            loc,
        };
    }
    isGraphQuads(obj) {
        return super.isOfType(obj, 'graph');
    }
    isUpdate(obj) {
        return super.isOfType(obj, 'update');
    }
}
//# sourceMappingURL=astFactory.js.map