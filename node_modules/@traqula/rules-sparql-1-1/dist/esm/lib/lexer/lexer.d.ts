import { LexerBuilder } from '@traqula/core';
export declare const baseDecl: import("@traqula/core").NamedToken<"BaseDecl">;
export declare const prefixDecl: import("@traqula/core").NamedToken<"PrefixDecl">;
export declare const select: import("@traqula/core").NamedToken<"Select">;
export declare const distinct: import("@traqula/core").NamedToken<"Distinct">;
export declare const reduced: import("@traqula/core").NamedToken<"Reduced">;
export declare const as: import("@traqula/core").NamedToken<"As">;
export declare const construct: import("@traqula/core").NamedToken<"Construct">;
export declare const describe: import("@traqula/core").NamedToken<"Describe">;
export declare const ask: import("@traqula/core").NamedToken<"Ask">;
export declare const from: import("@traqula/core").NamedToken<"From">;
export declare const where: import("@traqula/core").NamedToken<"Where">;
export declare const groupByGroup: import("@traqula/core").NamedToken<"GroupByGroup">;
export declare const by: import("@traqula/core").NamedToken<"By">;
export declare const having: import("@traqula/core").NamedToken<"Having">;
export declare const order: import("@traqula/core").NamedToken<"Order">;
export declare const orderAsc: import("@traqula/core").NamedToken<"OrderAsc">;
export declare const orderDesc: import("@traqula/core").NamedToken<"OrderDesc">;
export declare const limit: import("@traqula/core").NamedToken<"Limit">;
export declare const offset: import("@traqula/core").NamedToken<"Offset">;
export declare const values: import("@traqula/core").NamedToken<"Values">;
export declare const load: import("@traqula/core").NamedToken<"Load">;
export declare const silent: import("@traqula/core").NamedToken<"Silent">;
export declare const loadInto: import("@traqula/core").NamedToken<"LoadInto">;
export declare const clear: import("@traqula/core").NamedToken<"Clear">;
export declare const drop: import("@traqula/core").NamedToken<"Drop">;
export declare const create: import("@traqula/core").NamedToken<"Create">;
export declare const add: import("@traqula/core").NamedToken<"Add">;
export declare const to: import("@traqula/core").NamedToken<"To">;
export declare const move: import("@traqula/core").NamedToken<"Move">;
export declare const copy: import("@traqula/core").NamedToken<"Copy">;
export declare const modifyWith: import("@traqula/core").NamedToken<"ModifyWith">;
export declare const deleteDataClause: import("@traqula/core").NamedToken<"DeleteDataClause">;
export declare const deleteWhereClause: import("@traqula/core").NamedToken<"DeleteWhereClause">;
export declare const deleteClause: import("@traqula/core").NamedToken<"DeleteClause">;
export declare const insertDataClause: import("@traqula/core").NamedToken<"InsertDataClause">;
export declare const insertClause: import("@traqula/core").NamedToken<"InsertClause">;
export declare const usingClause: import("@traqula/core").NamedToken<"UsingClause">;
export declare const optional: import("@traqula/core").NamedToken<"Optional">;
export declare const service: import("@traqula/core").NamedToken<"Service">;
export declare const bind: import("@traqula/core").NamedToken<"Bind">;
export declare const undef: import("@traqula/core").NamedToken<"Undef">;
export declare const minus: import("@traqula/core").NamedToken<"Minus">;
export declare const union: import("@traqula/core").NamedToken<"Union">;
export declare const filter: import("@traqula/core").NamedToken<"Filter">;
export declare const a: import("@traqula/core").NamedToken<"a">;
export declare const true_: import("@traqula/core").NamedToken<"True">;
export declare const false_: import("@traqula/core").NamedToken<"False">;
export declare const in_: import("@traqula/core").NamedToken<"In">;
export declare const notIn: import("@traqula/core").NamedToken<"NotIn">;
export declare const separator: import("@traqula/core").NamedToken<"Separator">;
export declare const allBaseTokens: LexerBuilder<"BaseDecl" | "PrefixDecl" | "Select" | "Distinct" | "Reduced" | "As" | "Construct" | "Describe" | "Ask" | "From" | "Where" | "GroupByGroup" | "By" | "Having" | "Order" | "OrderAsc" | "OrderDesc" | "Limit" | "Offset" | "Values" | "Load" | "Silent" | "LoadInto" | "Clear" | "Drop" | "Create" | "Add" | "To" | "Move" | "Copy" | "ModifyWith" | "DeleteDataClause" | "DeleteWhereClause" | "DeleteClause" | "InsertDataClause" | "InsertClause" | "UsingClause" | "Optional" | "Service" | "Bind" | "Undef" | "Minus" | "Union" | "Filter" | "a" | "True" | "False" | "In" | "NotIn" | "Separator">;
/**
 * [!!!ORDER MATTERS!!!](https://chevrotain.io/docs/tutorial/step1_lexing.html#creating-the-lexer)
 */
export declare const sparql11LexerBuilder: LexerBuilder<"BuiltInStr" | "BuiltInLang" | "BuiltInLangmatches" | "BuiltInDatatype" | "BuiltInBound" | "BuiltInIri" | "BuiltInUri" | "BuiltInBnode" | "BuiltInRand" | "BuiltInAbs" | "BuiltInCeil" | "BuiltInFloor" | "BuiltInRound" | "BuiltInConcat" | "BuiltInStrlen" | "BuiltInUcase" | "BuiltInLcase" | "BuiltInEncode_for_uri" | "BuiltInContains" | "BuiltInStrstarts" | "BuiltInStrends" | "BuiltInStrbefore" | "BuiltInStrafter" | "BuiltInYear" | "BuiltInMonth" | "BuiltInDay" | "BuiltInHours" | "BuiltInMinutes" | "BuiltInSeconds" | "BuiltInTimezone" | "BuiltInTz" | "BuiltInNow" | "BuiltInUuid" | "BuiltInStruuid" | "BuiltInMd5" | "BuiltInSha1" | "BuiltInSha256" | "BuiltInSha384" | "BuiltInSha512" | "BuiltInCoalesce" | "BuiltInIf" | "BuiltInStrlang" | "BuiltInStrdt" | "BuiltInSameterm" | "BuiltInIsiri" | "BuiltInIsuri" | "BuiltInIsblank" | "BuiltInIsliteral" | "BuiltInIsnumeric" | "BuiltInRegex" | "BuiltInSubstr" | "BuiltInReplace" | "BuiltInExists" | "BuiltInNotexists" | "BuiltInCount" | "BuiltInSum" | "BuiltInMin" | "BuiltInMax" | "BuiltInAvg" | "BuiltInSample" | "BuiltInGroup_concat" | "NamedGraph" | "DefaultGraph" | "Graph" | "GraphAll" | "LCurly" | "RCurly" | "Dot" | "Comma" | "Semi" | "LParen" | "RParen" | "LSquare" | "RSquare" | "Pipe" | "Slash" | "Hat" | "Question" | "Star" | "OpPlus" | "OpMinus" | "Exclamation" | "LogicAnd" | "LogicOr" | "Equal" | "NotEqual" | "LessThan" | "GreaterThan" | "LessThanEqual" | "GreaterThanEqual" | "Hathat" | "IriRef" | "PNameLn" | "PNameNs" | "BlankNodeLabel" | "Var1" | "Var2" | "LangTag" | "Integer" | "Decimal" | "Double" | "IntegerPositive" | "DecimalPositive" | "DoublePositive" | "IntegerNegative" | "DecimalNegative" | "DoubleNegative" | "StringLiteral1" | "StringLiteral2" | "StringLiteralLong1" | "StringLiteralLong2" | "Ws" | "Comment" | "Nil" | "Anon" | "BaseDecl" | "PrefixDecl" | "Select" | "Distinct" | "Reduced" | "As" | "Construct" | "Describe" | "Ask" | "From" | "Where" | "GroupByGroup" | "By" | "Having" | "Order" | "OrderAsc" | "OrderDesc" | "Limit" | "Offset" | "Values" | "Load" | "Silent" | "LoadInto" | "Clear" | "Drop" | "Create" | "Add" | "To" | "Move" | "Copy" | "ModifyWith" | "DeleteDataClause" | "DeleteWhereClause" | "DeleteClause" | "InsertDataClause" | "InsertClause" | "UsingClause" | "Optional" | "Service" | "Bind" | "Undef" | "Minus" | "Union" | "Filter" | "a" | "True" | "False" | "In" | "NotIn" | "Separator">;
