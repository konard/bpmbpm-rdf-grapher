{"version":3,"file":"sparql11HelperTypes.js","sourceRoot":"","sources":["../../../lib/sparql11HelperTypes.ts"],"names":[],"mappings":"","sourcesContent":["import type { GeneratorRule, ParserRule, traqulaIndentation, traqulaNewlineAlternative } from '@traqula/core';\nimport type { AstFactory } from './astFactory.js';\n\nexport interface SparqlContext {\n  /**\n   * Data-factoryMixins to be used when constructing rdf primitives.\n   */\n  astFactory: AstFactory;\n  /**\n   * Current scoped prefixes. Used for resolving prefixed names.\n   */\n  prefixes: Record<string, string>;\n  /**\n   * The base IRI for the query. Used for resolving relative IRIs.\n   */\n  baseIRI: string | undefined;\n  /**\n   * Can be used to disable the validation that used variables in a select clause are in scope.\n   */\n  skipValidation: boolean;\n  /**\n   * Set of queryModes. Primarily used for note 8, 14.\n   */\n  parseMode: Set<'canParseVars' | 'canCreateBlankNodes' | 'inAggregate' | 'canParseAggregate' | string>;\n}\n\nexport interface SparqlGeneratorContext {\n  astFactory: AstFactory;\n  indentInc: number;\n  origSource: string;\n  [traqulaIndentation]: number;\n  [traqulaNewlineAlternative]: string;\n}\n\nexport type SparqlRule<\n  /**\n   * Name of grammar rule, should be a strict subtype of string like 'myGrammarRule'.\n   */\n  NameType extends string = string,\n  /**\n   * Type that will be returned after a correct parse of this rule.\n   * This type will be the return type of calling SUBRULE with this grammar rule.\n   */\n  ReturnType = unknown,\n  GenInputType = ReturnType,\n  /**\n   * Function arguments that can be given to convey the state of the current parse operation.\n   */\n  ParamType extends any[] = [],\n> = SparqlGrammarRule<NameType, ReturnType, ParamType>\n  & SparqlGeneratorRule<NameType, GenInputType, ParamType>;\nexport type SparqlGeneratorRule<\n  /**\n   * Name of grammar rule, should be a strict subtype of string like 'myGrammarRule'.\n   */\n  NameType extends string = string,\n  /**\n   * Type that will be returned after a correct parse of this rule.\n   * This type will be the return type of calling SUBRULE with this grammar rule.\n   */\n  ReturnType = unknown,\n  /**\n   * Function arguments that can be given to convey the state of the current parse operation.\n   */\n  ParamType extends any[] = [],\n> = GeneratorRule<SparqlGeneratorContext, NameType, ReturnType, ParamType>;\nexport type SparqlGrammarRule<\n  /**\n   * Name of grammar rule, should be a strict subtype of string like 'myGrammarRule'.\n   */\n  NameType extends string = string,\n  /**\n   * Type that will be returned after a correct parse of this rule.\n   * This type will be the return type of calling SUBRULE with this grammar rule.\n   */\n  ReturnType = unknown,\n  /**\n   * Function arguments that can be given to convey the state of the current parse operation.\n   */\n  ParamType extends any[] = [],\n> = ParserRule<SparqlContext, NameType, ReturnType, ParamType>;\n"]}