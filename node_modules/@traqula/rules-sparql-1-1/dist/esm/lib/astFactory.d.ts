import type { SourceLocation, SubTyped, Typed } from '@traqula/core';
import { AstCoreFactory } from '@traqula/core';
import type { DatasetClauses, GraphNode, GraphQuads, PatternBgp, Sparql11Nodes, Term, TermBlank, TermIri, TermVariable, TripleCollectionBlankNodeProperties, TripleCollectionList, TripleNesting, Update, Wildcard } from './Sparql11types.js';
declare const AstFactory_base: {
    new (...args: any[]): {
        isUpdateOperation(obj: object): obj is Typed<"updateOperation">;
        updateOperationLoad(loc: SourceLocation, source: TermIri, silent: boolean, destination?: import("./Sparql11types.js").GraphRefSpecific | undefined): import("./Sparql11types.js").UpdateOperationLoad;
        isUpdateOperationLoad(obj: object): obj is SubTyped<"updateOperation", "load">;
        updateOperationClearDrop(subType: "clear", silent: boolean, destination: import("./Sparql11types.js").GraphRef, loc: SourceLocation): import("./Sparql11types.js").UpdateOperationClear;
        updateOperationClearDrop(subType: "drop", silent: boolean, destination: import("./Sparql11types.js").GraphRef, loc: SourceLocation): import("./Sparql11types.js").UpdateOperationDrop;
        updateOperationClearDrop(subType: "clear" | "drop", silent: boolean, destination: import("./Sparql11types.js").GraphRef, loc: SourceLocation): import("./Sparql11types.js").UpdateOperationClear | import("./Sparql11types.js").UpdateOperationDrop;
        updateOperationClear(destination: import("./Sparql11types.js").GraphRef, silent: boolean, loc: SourceLocation): import("./Sparql11types.js").UpdateOperationClear;
        isUpdateOperationClear(obj: object): obj is SubTyped<"updateOperation", "clear">;
        updateOperationDrop(destination: import("./Sparql11types.js").GraphRef, silent: boolean, loc: SourceLocation): import("./Sparql11types.js").UpdateOperationDrop;
        isUpdateOperationDrop(obj: object): obj is SubTyped<"updateOperation", "drop">;
        updateOperationCreate(destination: import("./Sparql11types.js").GraphRefSpecific, silent: boolean, loc: SourceLocation): import("./Sparql11types.js").UpdateOperationCreate;
        isUpdateOperationCreate(obj: object): obj is SubTyped<"updateOperation", "create">;
        updateOperationAddMoveCopy(subType: "add", source: import("./Sparql11types.js").GraphRefDefault | import("./Sparql11types.js").GraphRefSpecific, destination: import("./Sparql11types.js").GraphRefDefault | import("./Sparql11types.js").GraphRefSpecific, silent: boolean, loc: SourceLocation): import("./Sparql11types.js").UpdateOperationAdd;
        updateOperationAddMoveCopy(subType: "move", source: import("./Sparql11types.js").GraphRefDefault | import("./Sparql11types.js").GraphRefSpecific, destination: import("./Sparql11types.js").GraphRefDefault | import("./Sparql11types.js").GraphRefSpecific, silent: boolean, loc: SourceLocation): import("./Sparql11types.js").UpdateOperationMove;
        updateOperationAddMoveCopy(subType: "copy", source: import("./Sparql11types.js").GraphRefDefault | import("./Sparql11types.js").GraphRefSpecific, destination: import("./Sparql11types.js").GraphRefDefault | import("./Sparql11types.js").GraphRefSpecific, silent: boolean, loc: SourceLocation): import("./Sparql11types.js").UpdateOperationCopy;
        updateOperationAddMoveCopy(subType: "add" | "move" | "copy", source: import("./Sparql11types.js").GraphRefDefault | import("./Sparql11types.js").GraphRefSpecific, destination: import("./Sparql11types.js").GraphRefDefault | import("./Sparql11types.js").GraphRefSpecific, silent: boolean, loc: SourceLocation): import("./Sparql11types.js").UpdateOperationAdd | import("./Sparql11types.js").UpdateOperationMove | import("./Sparql11types.js").UpdateOperationCopy;
        updateOperationAdd(source: import("./Sparql11types.js").GraphRefDefault | import("./Sparql11types.js").GraphRefSpecific, destination: import("./Sparql11types.js").GraphRefDefault | import("./Sparql11types.js").GraphRefSpecific, silent: boolean, loc: SourceLocation): import("./Sparql11types.js").UpdateOperationAdd;
        isUpdateOperationAdd(obj: object): obj is SubTyped<"updateOperation", "add">;
        updateOperationMove(source: import("./Sparql11types.js").GraphRefDefault | import("./Sparql11types.js").GraphRefSpecific, destination: import("./Sparql11types.js").GraphRefDefault | import("./Sparql11types.js").GraphRefSpecific, silent: boolean, loc: SourceLocation): import("./Sparql11types.js").UpdateOperationMove;
        isUpdateOperationMove(obj: object): obj is SubTyped<"updateOperation", "move">;
        updateOperationCopy(source: import("./Sparql11types.js").GraphRefDefault | import("./Sparql11types.js").GraphRefSpecific, destination: import("./Sparql11types.js").GraphRefDefault | import("./Sparql11types.js").GraphRefSpecific, silent: boolean, loc: SourceLocation): import("./Sparql11types.js").UpdateOperationCopy;
        isUpdateOperationCopy(obj: object): obj is SubTyped<"updateOperation", "copy">;
        updateOperationInsDelDataWhere(subType: "insertdata", data: import("./Sparql11types.js").Quads[], loc: SourceLocation): import("./Sparql11types.js").UpdateOperationInsertData;
        updateOperationInsDelDataWhere(subType: "deletedata", data: import("./Sparql11types.js").Quads[], loc: SourceLocation): import("./Sparql11types.js").UpdateOperationDeleteData;
        updateOperationInsDelDataWhere(subType: "deletewhere", data: import("./Sparql11types.js").Quads[], loc: SourceLocation): import("./Sparql11types.js").UpdateOperationDeleteWhere;
        updateOperationInsDelDataWhere(subType: "insertdata" | "deletedata" | "deletewhere", data: import("./Sparql11types.js").Quads[], loc: SourceLocation): import("./Sparql11types.js").UpdateOperationInsertData | import("./Sparql11types.js").UpdateOperationDeleteData | import("./Sparql11types.js").UpdateOperationDeleteWhere;
        updateOperationInsertData(data: import("./Sparql11types.js").Quads[], loc: SourceLocation): import("./Sparql11types.js").UpdateOperationInsertData;
        isUpdateOperationInsertData(obj: object): obj is SubTyped<"updateOperation", "insertdata">;
        updateOperationDeleteData(data: import("./Sparql11types.js").Quads[], loc: SourceLocation): import("./Sparql11types.js").UpdateOperationDeleteData;
        isUpdateOperationDeleteData(obj: object): obj is SubTyped<"updateOperation", "deletedata">;
        updateOperationDeleteWhere(data: import("./Sparql11types.js").Quads[], loc: SourceLocation): import("./Sparql11types.js").UpdateOperationDeleteWhere;
        isUpdateOperationDeleteWhere(obj: object): obj is SubTyped<"updateOperation", "deletewhere">;
        updateOperationModify(loc: SourceLocation, insert: import("./Sparql11types.js").Quads[] | undefined, del: import("./Sparql11types.js").Quads[] | undefined, where: import("./Sparql11types.js").PatternGroup, from: DatasetClauses, graph?: TermIri | undefined): import("./Sparql11types.js").UpdateOperationModify;
        isUpdateOperationModify(obj: object): obj is SubTyped<"updateOperation", "modify">;
        tracksSourceLocation: boolean;
        wrap<T>(val: T, loc: SourceLocation): import("@traqula/core").Wrap<T>;
        isLocalized(obj: unknown): obj is import("@traqula/core").Localized;
        sourceLocation(...elements: (undefined | import("chevrotain").IToken | import("@traqula/core").Localized)[]): SourceLocation;
        sourceLocationNoMaterialize(): SourceLocation;
        dematerialized<T extends import("@traqula/core").Node>(arg: T): T;
        safeObjectTransform(value: unknown, mapper: (some: object) => any): any;
        forcedAutoGenTree<T extends object>(obj: T): T;
        forceMaterialized<T extends import("@traqula/core").Node>(arg: T): T;
        isSourceLocation(loc: object): loc is SourceLocation;
        sourceLocationSource(start: number, end: number): import("@traqula/core").SourceLocationSource;
        sourceLocationInlinedSource(newSource: string, subLoc: SourceLocation, start: number, end: number, startOnNew?: number, endOnNew?: number): SourceLocation;
        isSourceLocationInlinedSource(loc: object): loc is import("@traqula/core").SourceLocationInlinedSource;
        gen(): import("@traqula/core").SourceLocationNodeAutoGenerate;
        isSourceLocationSource(loc: object): loc is import("@traqula/core").SourceLocationSource;
        sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation;
        isSourceLocationStringReplace(loc: object): loc is import("@traqula/core").SourceLocationStringReplace;
        sourceLocationNodeReplaceUnsafe(loc: SourceLocation): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(location: import("@traqula/core").SourceLocationSource): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(start: number, end: number): import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeReplace(loc: object): loc is import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeAutoGenerate(loc: object): loc is import("@traqula/core").SourceLocationNodeAutoGenerate;
        isPrintingLoc(loc: SourceLocation): boolean;
        printFilter(node: import("@traqula/core").Localized, callback: () => void): void;
        isSourceLocationNoMaterialize(loc: object): loc is import("@traqula/core").SourceLocationNoMaterialize;
        isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type>;
        isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType): obj is SubTyped<Type, SubType>;
    };
} & {
    new (...args: any[]): {
        __blankNodeCounter: number;
        resetBlankNodeCounter(): void;
        isTerm(x: object): x is Typed<"term">;
        termBlank(label: undefined | string, loc: SourceLocation): TermBlank;
        isTermBlank(obj: object): obj is SubTyped<"term", "blankNode">;
        termLiteral(loc: SourceLocation, value: string, lang?: undefined): import("./Sparql11types.js").TermLiteralStr;
        termLiteral(loc: SourceLocation, value: string, lang: string): import("./Sparql11types.js").TermLiteralLangStr;
        termLiteral(loc: SourceLocation, value: string, iri: TermIri): import("./Sparql11types.js").TermLiteralTyped;
        termLiteral(loc: SourceLocation, value: string, langOrIri?: string | TermIri): import("./Sparql11types.js").TermLiteral;
        isTermLiteral(obj: object): obj is SubTyped<"term", "literal">;
        isTermLiteralLangStr(obj: object): obj is SubTyped<"term", "literal"> & {
            langOrIri: string;
        };
        isTermLiteralStr(obj: object): obj is SubTyped<"term", "literal"> & {
            langOrIri: undefined;
        };
        isTermLiteralTyped(obj: object): obj is SubTyped<"term", "literal"> & {
            langOrIri: SubTyped<"term", "namedNode">;
        };
        termVariable(value: string, loc: SourceLocation): TermVariable;
        isTermVariable(obj: object): obj is SubTyped<"term", "variable">;
        termNamed(loc: SourceLocation, value: string, prefix?: undefined): import("./Sparql11types.js").TermIriFull;
        termNamed(loc: SourceLocation, value: string, prefix: string): import("./Sparql11types.js").TermIriPrefixed;
        isTermNamed(obj: object): obj is SubTyped<"term", "namedNode">;
        isTermNamedPrefixed(obj: object): obj is SubTyped<"term", "namedNode"> & {
            prefix: string;
        };
        tracksSourceLocation: boolean;
        wrap<T>(val: T, loc: SourceLocation): import("@traqula/core").Wrap<T>;
        isLocalized(obj: unknown): obj is import("@traqula/core").Localized;
        sourceLocation(...elements: (undefined | import("chevrotain").IToken | import("@traqula/core").Localized)[]): SourceLocation;
        sourceLocationNoMaterialize(): SourceLocation;
        dematerialized<T extends import("@traqula/core").Node>(arg: T): T;
        safeObjectTransform(value: unknown, mapper: (some: object) => any): any;
        forcedAutoGenTree<T extends object>(obj: T): T;
        forceMaterialized<T extends import("@traqula/core").Node>(arg: T): T;
        isSourceLocation(loc: object): loc is SourceLocation;
        sourceLocationSource(start: number, end: number): import("@traqula/core").SourceLocationSource;
        sourceLocationInlinedSource(newSource: string, subLoc: SourceLocation, start: number, end: number, startOnNew?: number, endOnNew?: number): SourceLocation;
        isSourceLocationInlinedSource(loc: object): loc is import("@traqula/core").SourceLocationInlinedSource;
        gen(): import("@traqula/core").SourceLocationNodeAutoGenerate;
        isSourceLocationSource(loc: object): loc is import("@traqula/core").SourceLocationSource;
        sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation;
        isSourceLocationStringReplace(loc: object): loc is import("@traqula/core").SourceLocationStringReplace;
        sourceLocationNodeReplaceUnsafe(loc: SourceLocation): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(location: import("@traqula/core").SourceLocationSource): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(start: number, end: number): import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeReplace(loc: object): loc is import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeAutoGenerate(loc: object): loc is import("@traqula/core").SourceLocationNodeAutoGenerate;
        isPrintingLoc(loc: SourceLocation): boolean;
        printFilter(node: import("@traqula/core").Localized, callback: () => void): void;
        isSourceLocationNoMaterialize(loc: object): loc is import("@traqula/core").SourceLocationNoMaterialize;
        isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type>;
        isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType): obj is SubTyped<Type, SubType>;
    };
} & {
    new (...args: any[]): {
        isSolutionModifier(obj: object): obj is Typed<"solutionModifier">;
        solutionModifierHaving(having: import("./Sparql11types.js").Expression[], loc: SourceLocation): import("./Sparql11types.js").SolutionModifierHaving;
        isSolutionModifierHaving(obj: object): obj is SubTyped<"solutionModifier", "having">;
        solutionModifierOrder(orderDefs: import("./Sparql11types.js").Ordering[], loc: SourceLocation): import("./Sparql11types.js").SolutionModifierOrder;
        isSolutionModifierOrder(obj: object): obj is SubTyped<"solutionModifier", "order">;
        solutionModifierLimitOffset(limit: number | undefined, offset: number | undefined, loc: SourceLocation): import("./Sparql11types.js").SolutionModifierLimitOffset;
        isSolutionModifierLimitOffset(obj: object): obj is SubTyped<"solutionModifier", "limitOffset">;
        solutionModifierGroup(groupings: (import("./Sparql11types.js").Expression | import("./Sparql11types.js").SolutionModifierGroupBind)[], loc: SourceLocation): import("./Sparql11types.js").SolutionModifierGroup;
        isSolutionModifierGroup(obj: object): obj is SubTyped<"solutionModifier", "group">;
        tracksSourceLocation: boolean;
        wrap<T>(val: T, loc: SourceLocation): import("@traqula/core").Wrap<T>;
        isLocalized(obj: unknown): obj is import("@traqula/core").Localized;
        sourceLocation(...elements: (undefined | import("chevrotain").IToken | import("@traqula/core").Localized)[]): SourceLocation;
        sourceLocationNoMaterialize(): SourceLocation;
        dematerialized<T extends import("@traqula/core").Node>(arg: T): T;
        safeObjectTransform(value: unknown, mapper: (some: object) => any): any;
        forcedAutoGenTree<T extends object>(obj: T): T;
        forceMaterialized<T extends import("@traqula/core").Node>(arg: T): T;
        isSourceLocation(loc: object): loc is SourceLocation;
        sourceLocationSource(start: number, end: number): import("@traqula/core").SourceLocationSource;
        sourceLocationInlinedSource(newSource: string, subLoc: SourceLocation, start: number, end: number, startOnNew?: number, endOnNew?: number): SourceLocation;
        isSourceLocationInlinedSource(loc: object): loc is import("@traqula/core").SourceLocationInlinedSource;
        gen(): import("@traqula/core").SourceLocationNodeAutoGenerate;
        isSourceLocationSource(loc: object): loc is import("@traqula/core").SourceLocationSource;
        sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation;
        isSourceLocationStringReplace(loc: object): loc is import("@traqula/core").SourceLocationStringReplace;
        sourceLocationNodeReplaceUnsafe(loc: SourceLocation): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(location: import("@traqula/core").SourceLocationSource): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(start: number, end: number): import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeReplace(loc: object): loc is import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeAutoGenerate(loc: object): loc is import("@traqula/core").SourceLocationNodeAutoGenerate;
        isPrintingLoc(loc: SourceLocation): boolean;
        printFilter(node: import("@traqula/core").Localized, callback: () => void): void;
        isSourceLocationNoMaterialize(loc: object): loc is import("@traqula/core").SourceLocationNoMaterialize;
        isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type>;
        isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType): obj is SubTyped<Type, SubType>;
    };
} & {
    new (...args: any[]): {
        isQuery(obj: object): obj is Typed<"query">;
        isQuerySelect(obj: object): obj is SubTyped<"query", "select">;
        queryConstruct(loc: SourceLocation, context: import("./Sparql11types.js").ContextDefinition[], template: PatternBgp, where: import("./Sparql11types.js").PatternGroup, solutionModifiers: import("./Sparql11types.js").SolutionModifiers, datasets: DatasetClauses, values?: import("./Sparql11types.js").PatternValues): import("./Sparql11types.js").QueryConstruct;
        isQueryConstruct(obj: object): obj is SubTyped<"query", "construct">;
        isQueryDescribe(obj: object): obj is SubTyped<"query", "describe">;
        isQueryAsk(obj: object): obj is SubTyped<"query", "ask">;
        querySelect(arg: Omit<import("./Sparql11types.js").QuerySelect, "type" | "subType" | "loc">, loc: SourceLocation): import("./Sparql11types.js").QuerySelect;
        tracksSourceLocation: boolean;
        wrap<T>(val: T, loc: SourceLocation): import("@traqula/core").Wrap<T>;
        isLocalized(obj: unknown): obj is import("@traqula/core").Localized;
        sourceLocation(...elements: (undefined | import("chevrotain").IToken | import("@traqula/core").Localized)[]): SourceLocation;
        sourceLocationNoMaterialize(): SourceLocation;
        dematerialized<T extends import("@traqula/core").Node>(arg: T): T;
        safeObjectTransform(value: unknown, mapper: (some: object) => any): any;
        forcedAutoGenTree<T extends object>(obj: T): T;
        forceMaterialized<T extends import("@traqula/core").Node>(arg: T): T;
        isSourceLocation(loc: object): loc is SourceLocation;
        sourceLocationSource(start: number, end: number): import("@traqula/core").SourceLocationSource;
        sourceLocationInlinedSource(newSource: string, subLoc: SourceLocation, start: number, end: number, startOnNew?: number, endOnNew?: number): SourceLocation;
        isSourceLocationInlinedSource(loc: object): loc is import("@traqula/core").SourceLocationInlinedSource;
        gen(): import("@traqula/core").SourceLocationNodeAutoGenerate;
        isSourceLocationSource(loc: object): loc is import("@traqula/core").SourceLocationSource;
        sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation;
        isSourceLocationStringReplace(loc: object): loc is import("@traqula/core").SourceLocationStringReplace;
        sourceLocationNodeReplaceUnsafe(loc: SourceLocation): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(location: import("@traqula/core").SourceLocationSource): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(start: number, end: number): import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeReplace(loc: object): loc is import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeAutoGenerate(loc: object): loc is import("@traqula/core").SourceLocationNodeAutoGenerate;
        isPrintingLoc(loc: SourceLocation): boolean;
        printFilter(node: import("@traqula/core").Localized, callback: () => void): void;
        isSourceLocationNoMaterialize(loc: object): loc is import("@traqula/core").SourceLocationNoMaterialize;
        isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type>;
        isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType): obj is SubTyped<Type, SubType>;
    };
} & {
    new (...args: any[]): {
        isPattern(obj: object): obj is Typed<"pattern">;
        patternBgp(triples: import("./Sparql11types.js").BasicGraphPattern, loc: SourceLocation): PatternBgp;
        isPatternBgp(obj: object): obj is SubTyped<"pattern", "bgp">;
        patternGroup(patterns: import("./Sparql11types.js").Pattern[], loc: SourceLocation): import("./Sparql11types.js").PatternGroup;
        isPatternGroup(obj: object): obj is SubTyped<"pattern", "group">;
        patternGraph(name: TermIri | TermVariable, patterns: import("./Sparql11types.js").Pattern[], loc: SourceLocation): import("./Sparql11types.js").PatternGraph;
        isPatternGraph(obj: object): obj is SubTyped<"pattern", "graph">;
        patternOptional(patterns: import("./Sparql11types.js").Pattern[], loc: SourceLocation): import("./Sparql11types.js").PatternOptional;
        isPatternOptional(obj: object): obj is SubTyped<"pattern", "optional">;
        patternValues(variables: TermVariable[], values: import("./Sparql11types.js").ValuePatternRow[], loc: SourceLocation): import("./Sparql11types.js").PatternValues;
        isPatternValues(obj: object): obj is SubTyped<"pattern", "values">;
        patternFilter(expression: import("./Sparql11types.js").Expression, loc: SourceLocation): import("./Sparql11types.js").PatternFilter;
        isPatternFilter(obj: object): obj is SubTyped<"pattern", "filter">;
        patternBind(expression: import("./Sparql11types.js").Expression, variable: TermVariable, loc: SourceLocation): import("./Sparql11types.js").PatternBind;
        isPatternBind(obj: object): obj is SubTyped<"pattern", "bind">;
        patternUnion(patterns: import("./Sparql11types.js").PatternGroup[], loc: SourceLocation): import("./Sparql11types.js").PatternUnion;
        isPatternUnion(obj: object): obj is SubTyped<"pattern", "union">;
        patternMinus(patterns: import("./Sparql11types.js").Pattern[], loc: SourceLocation): import("./Sparql11types.js").PatternMinus;
        isPatternMinus(obj: object): obj is SubTyped<"pattern", "minus">;
        patternService(name: TermIri | TermVariable, patterns: import("./Sparql11types.js").Pattern[], silent: boolean, loc: SourceLocation): import("./Sparql11types.js").PatternService;
        isPatternService(obj: object): obj is SubTyped<"pattern", "service">;
        tracksSourceLocation: boolean;
        wrap<T>(val: T, loc: SourceLocation): import("@traqula/core").Wrap<T>;
        isLocalized(obj: unknown): obj is import("@traqula/core").Localized;
        sourceLocation(...elements: (undefined | import("chevrotain").IToken | import("@traqula/core").Localized)[]): SourceLocation;
        sourceLocationNoMaterialize(): SourceLocation;
        dematerialized<T extends import("@traqula/core").Node>(arg: T): T;
        safeObjectTransform(value: unknown, mapper: (some: object) => any): any;
        forcedAutoGenTree<T extends object>(obj: T): T;
        forceMaterialized<T extends import("@traqula/core").Node>(arg: T): T;
        isSourceLocation(loc: object): loc is SourceLocation;
        sourceLocationSource(start: number, end: number): import("@traqula/core").SourceLocationSource;
        sourceLocationInlinedSource(newSource: string, subLoc: SourceLocation, start: number, end: number, startOnNew?: number, endOnNew?: number): SourceLocation;
        isSourceLocationInlinedSource(loc: object): loc is import("@traqula/core").SourceLocationInlinedSource;
        gen(): import("@traqula/core").SourceLocationNodeAutoGenerate;
        isSourceLocationSource(loc: object): loc is import("@traqula/core").SourceLocationSource;
        sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation;
        isSourceLocationStringReplace(loc: object): loc is import("@traqula/core").SourceLocationStringReplace;
        sourceLocationNodeReplaceUnsafe(loc: SourceLocation): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(location: import("@traqula/core").SourceLocationSource): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(start: number, end: number): import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeReplace(loc: object): loc is import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeAutoGenerate(loc: object): loc is import("@traqula/core").SourceLocationNodeAutoGenerate;
        isPrintingLoc(loc: SourceLocation): boolean;
        printFilter(node: import("@traqula/core").Localized, callback: () => void): void;
        isSourceLocationNoMaterialize(loc: object): loc is import("@traqula/core").SourceLocationNoMaterialize;
        isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type>;
        isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType): obj is SubTyped<Type, SubType>;
    };
} & {
    new (...args: any[]): {
        isPathPure(obj: object): obj is Typed<"path">;
        path(subType: "|", items: (TermIri | import("./Sparql11types.js").PathNegatedElt)[], loc: SourceLocation): import("./Sparql11types.js").PathAlternativeLimited;
        path(subType: "!", items: [TermIri | import("./Sparql11types.js").PathNegatedElt | import("./Sparql11types.js").PathAlternativeLimited], loc: SourceLocation): import("./Sparql11types.js").PathNegated;
        path(subType: "^", items: [TermIri], loc: SourceLocation): import("./Sparql11types.js").PathNegatedElt;
        path(subType: import("./Sparql11types.js").PathModified["subType"], item: [import("./Sparql11types.js").Path], loc: SourceLocation): import("./Sparql11types.js").PathModified;
        path(subType: "|" | "/", items: import("./Sparql11types.js").Path[], loc: SourceLocation): import("./Sparql11types.js").PropertyPathChain;
        isPathOfType<T extends U[], U extends string>(obj: object, subTypes: T): obj is SubTyped<"path", U>;
        isPathChain(obj: object): obj is SubTyped<"path", "|" | "/">;
        isPathModified(obj: object): obj is SubTyped<"path", "?" | "*" | "+" | "^">;
        isPathNegatedElt(obj: object): obj is SubTyped<"path", "^"> & {
            items: [SubTyped<"term", "namedNode">];
        };
        isPathNegated(obj: object): obj is SubTyped<"path", "!">;
        isPathAlternativeLimited(obj: object): obj is SubTyped<"path", "|"> & {
            items: (SubTyped<"term", "namedNode"> | (SubTyped<"path", "^"> & {
                items: [SubTyped<"term", "namedNode">];
            }))[];
        };
        tracksSourceLocation: boolean;
        wrap<T>(val: T, loc: SourceLocation): import("@traqula/core").Wrap<T>;
        isLocalized(obj: unknown): obj is import("@traqula/core").Localized;
        sourceLocation(...elements: (undefined | import("chevrotain").IToken | import("@traqula/core").Localized)[]): SourceLocation;
        sourceLocationNoMaterialize(): SourceLocation;
        dematerialized<T extends import("@traqula/core").Node>(arg: T): T;
        safeObjectTransform(value: unknown, mapper: (some: object) => any): any;
        forcedAutoGenTree<T extends object>(obj: T): T;
        forceMaterialized<T extends import("@traqula/core").Node>(arg: T): T;
        isSourceLocation(loc: object): loc is SourceLocation;
        sourceLocationSource(start: number, end: number): import("@traqula/core").SourceLocationSource;
        sourceLocationInlinedSource(newSource: string, subLoc: SourceLocation, start: number, end: number, startOnNew?: number, endOnNew?: number): SourceLocation;
        isSourceLocationInlinedSource(loc: object): loc is import("@traqula/core").SourceLocationInlinedSource;
        gen(): import("@traqula/core").SourceLocationNodeAutoGenerate;
        isSourceLocationSource(loc: object): loc is import("@traqula/core").SourceLocationSource;
        sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation;
        isSourceLocationStringReplace(loc: object): loc is import("@traqula/core").SourceLocationStringReplace;
        sourceLocationNodeReplaceUnsafe(loc: SourceLocation): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(location: import("@traqula/core").SourceLocationSource): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(start: number, end: number): import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeReplace(loc: object): loc is import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeAutoGenerate(loc: object): loc is import("@traqula/core").SourceLocationNodeAutoGenerate;
        isPrintingLoc(loc: SourceLocation): boolean;
        printFilter(node: import("@traqula/core").Localized, callback: () => void): void;
        isSourceLocationNoMaterialize(loc: object): loc is import("@traqula/core").SourceLocationNoMaterialize;
        isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type>;
        isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType): obj is SubTyped<Type, SubType>;
    };
} & {
    new (...args: any[]): {
        isGraphRef(obj: object): obj is Typed<"graphRef">;
        graphRefDefault(loc: SourceLocation): import("./Sparql11types.js").GraphRefDefault;
        isGraphRefDefault(graphRef: object): graphRef is SubTyped<"graphRef", "default">;
        graphRefNamed(loc: SourceLocation): import("./Sparql11types.js").GraphRefNamed;
        isGraphRefNamed(graphRef: object): graphRef is SubTyped<"graphRef", "named">;
        graphRefAll(loc: SourceLocation): import("./Sparql11types.js").GraphRefAll;
        isGraphRefAll(graphRef: object): graphRef is SubTyped<"graphRef", "all">;
        graphRefSpecific(graph: TermIri, loc: SourceLocation): import("./Sparql11types.js").GraphRefSpecific;
        isGraphRefSpecific(graphRef: object): graphRef is SubTyped<"graphRef", "specific">;
        tracksSourceLocation: boolean;
        wrap<T>(val: T, loc: SourceLocation): import("@traqula/core").Wrap<T>;
        isLocalized(obj: unknown): obj is import("@traqula/core").Localized;
        sourceLocation(...elements: (undefined | import("chevrotain").IToken | import("@traqula/core").Localized)[]): SourceLocation;
        sourceLocationNoMaterialize(): SourceLocation;
        dematerialized<T extends import("@traqula/core").Node>(arg: T): T;
        safeObjectTransform(value: unknown, mapper: (some: object) => any): any;
        forcedAutoGenTree<T extends object>(obj: T): T;
        forceMaterialized<T extends import("@traqula/core").Node>(arg: T): T;
        isSourceLocation(loc: object): loc is SourceLocation;
        sourceLocationSource(start: number, end: number): import("@traqula/core").SourceLocationSource;
        sourceLocationInlinedSource(newSource: string, subLoc: SourceLocation, start: number, end: number, startOnNew?: number, endOnNew?: number): SourceLocation;
        isSourceLocationInlinedSource(loc: object): loc is import("@traqula/core").SourceLocationInlinedSource;
        gen(): import("@traqula/core").SourceLocationNodeAutoGenerate;
        isSourceLocationSource(loc: object): loc is import("@traqula/core").SourceLocationSource;
        sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation;
        isSourceLocationStringReplace(loc: object): loc is import("@traqula/core").SourceLocationStringReplace;
        sourceLocationNodeReplaceUnsafe(loc: SourceLocation): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(location: import("@traqula/core").SourceLocationSource): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(start: number, end: number): import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeReplace(loc: object): loc is import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeAutoGenerate(loc: object): loc is import("@traqula/core").SourceLocationNodeAutoGenerate;
        isPrintingLoc(loc: SourceLocation): boolean;
        printFilter(node: import("@traqula/core").Localized, callback: () => void): void;
        isSourceLocationNoMaterialize(loc: object): loc is import("@traqula/core").SourceLocationNoMaterialize;
        isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type>;
        isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType): obj is SubTyped<Type, SubType>;
    };
} & {
    new (...args: any[]): {
        isExpressionPure(obj: object): obj is Typed<"expression">;
        formatOperator(operator: string): string;
        expressionOperation<Args extends import("./Sparql11types.js").Expression[]>(operator: string, args: Args, loc: SourceLocation): import("@traqula/core").Node & {
            type: "expression";
            subType: string;
        } & {
            subType: "operation";
            operator: string;
            args: import("./Sparql11types.js").Expression[];
        } & {
            args: Args;
        };
        isExpressionOperator(obj: object): obj is SubTyped<"expression", "operation">;
        expressionFunctionCall<Args extends import("./Sparql11types.js").Expression[]>(functionOp: TermIri, args: Args, distinct: boolean, loc: SourceLocation): import("@traqula/core").Node & {
            type: "expression";
            subType: string;
        } & {
            subType: "functionCall";
            function: TermIri;
            distinct: boolean;
            args: import("./Sparql11types.js").Expression[];
        } & {
            args: Args;
        };
        isExpressionFunctionCall(obj: object): obj is SubTyped<"expression", "functionCall">;
        expressionPatternOperation(operator: string, args: import("./Sparql11types.js").PatternGroup, loc: SourceLocation): import("./Sparql11types.js").ExpressionPatternOperation;
        isExpressionPatternOperation(obj: object): obj is SubTyped<"expression", "patternOperation">;
        aggregate(aggregation: string, distinct: boolean, arg: import("./Sparql11types.js").Expression, separator: undefined, loc: SourceLocation): import("./Sparql11types.js").ExpressionAggregateDefault;
        aggregate(aggregation: string, distinct: boolean, arg: Wildcard, separator: undefined, loc: SourceLocation): import("./Sparql11types.js").ExpressionAggregateOnWildcard;
        aggregate(aggregation: string, distinct: boolean, arg: import("./Sparql11types.js").Expression, separator: string, loc: SourceLocation): import("./Sparql11types.js").ExpressionAggregateSeparator;
        aggregate(aggregation: string, distinct: boolean, arg: import("./Sparql11types.js").Expression | Wildcard, separator: string | undefined, loc: SourceLocation): import("./Sparql11types.js").ExpressionAggregate;
        isExpressionAggregate(obj: object): obj is SubTyped<"expression", "aggregate">;
        isExpressionAggregateSeparator(obj: object): obj is SubTyped<"expression", "aggregate"> & {
            separator: string;
        };
        isExpressionAggregateOnWildcard(obj: object): obj is SubTyped<"expression", "aggregate"> & {
            expression: [Typed<"wildcard">];
        };
        isExpressionAggregateDefault(obj: object): obj is SubTyped<"expression", "aggregate"> & {
            expression: [import("./Sparql11types.js").Expression];
        };
        tracksSourceLocation: boolean;
        wrap<T>(val: T, loc: SourceLocation): import("@traqula/core").Wrap<T>;
        isLocalized(obj: unknown): obj is import("@traqula/core").Localized;
        sourceLocation(...elements: (undefined | import("chevrotain").IToken | import("@traqula/core").Localized)[]): SourceLocation;
        sourceLocationNoMaterialize(): SourceLocation;
        dematerialized<T extends import("@traqula/core").Node>(arg: T): T;
        safeObjectTransform(value: unknown, mapper: (some: object) => any): any;
        forcedAutoGenTree<T extends object>(obj: T): T;
        forceMaterialized<T extends import("@traqula/core").Node>(arg: T): T;
        isSourceLocation(loc: object): loc is SourceLocation;
        sourceLocationSource(start: number, end: number): import("@traqula/core").SourceLocationSource;
        sourceLocationInlinedSource(newSource: string, subLoc: SourceLocation, start: number, end: number, startOnNew?: number, endOnNew?: number): SourceLocation;
        isSourceLocationInlinedSource(loc: object): loc is import("@traqula/core").SourceLocationInlinedSource;
        gen(): import("@traqula/core").SourceLocationNodeAutoGenerate;
        isSourceLocationSource(loc: object): loc is import("@traqula/core").SourceLocationSource;
        sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation;
        isSourceLocationStringReplace(loc: object): loc is import("@traqula/core").SourceLocationStringReplace;
        sourceLocationNodeReplaceUnsafe(loc: SourceLocation): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(location: import("@traqula/core").SourceLocationSource): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(start: number, end: number): import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeReplace(loc: object): loc is import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeAutoGenerate(loc: object): loc is import("@traqula/core").SourceLocationNodeAutoGenerate;
        isPrintingLoc(loc: SourceLocation): boolean;
        printFilter(node: import("@traqula/core").Localized, callback: () => void): void;
        isSourceLocationNoMaterialize(loc: object): loc is import("@traqula/core").SourceLocationNoMaterialize;
        isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type>;
        isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType): obj is SubTyped<Type, SubType>;
    };
} & {
    new (...args: any[]): {
        contextDefinitionPrefix(loc: SourceLocation, key: string, value: import("./Sparql11types.js").TermIriFull): import("./Sparql11types.js").ContextDefinitionPrefix;
        isContextDefinitionPrefix(contextDef: object): contextDef is SubTyped<"contextDef", "prefix">;
        contextDefinitionBase(loc: SourceLocation, value: import("./Sparql11types.js").TermIriFull): import("./Sparql11types.js").ContextDefinitionBase;
        isContextDefinitionBase(contextDef: object): contextDef is SubTyped<"contextDef", "base">;
        tracksSourceLocation: boolean;
        wrap<T>(val: T, loc: SourceLocation): import("@traqula/core").Wrap<T>;
        isLocalized(obj: unknown): obj is import("@traqula/core").Localized;
        sourceLocation(...elements: (undefined | import("chevrotain").IToken | import("@traqula/core").Localized)[]): SourceLocation;
        sourceLocationNoMaterialize(): SourceLocation;
        dematerialized<T extends import("@traqula/core").Node>(arg: T): T;
        safeObjectTransform(value: unknown, mapper: (some: object) => any): any;
        forcedAutoGenTree<T extends object>(obj: T): T;
        forceMaterialized<T extends import("@traqula/core").Node>(arg: T): T;
        isSourceLocation(loc: object): loc is SourceLocation;
        sourceLocationSource(start: number, end: number): import("@traqula/core").SourceLocationSource;
        sourceLocationInlinedSource(newSource: string, subLoc: SourceLocation, start: number, end: number, startOnNew?: number, endOnNew?: number): SourceLocation;
        isSourceLocationInlinedSource(loc: object): loc is import("@traqula/core").SourceLocationInlinedSource;
        gen(): import("@traqula/core").SourceLocationNodeAutoGenerate;
        isSourceLocationSource(loc: object): loc is import("@traqula/core").SourceLocationSource;
        sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation;
        isSourceLocationStringReplace(loc: object): loc is import("@traqula/core").SourceLocationStringReplace;
        sourceLocationNodeReplaceUnsafe(loc: SourceLocation): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(location: import("@traqula/core").SourceLocationSource): import("@traqula/core").SourceLocationNodeReplace;
        sourceLocationNodeReplace(start: number, end: number): import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeReplace(loc: object): loc is import("@traqula/core").SourceLocationNodeReplace;
        isSourceLocationNodeAutoGenerate(loc: object): loc is import("@traqula/core").SourceLocationNodeAutoGenerate;
        isPrintingLoc(loc: SourceLocation): boolean;
        printFilter(node: import("@traqula/core").Localized, callback: () => void): void;
        isSourceLocationNoMaterialize(loc: object): loc is import("@traqula/core").SourceLocationNoMaterialize;
        isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type>;
        isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType): obj is SubTyped<Type, SubType>;
    };
} & typeof AstCoreFactory;
/**
 * A factory that helps you create, and check types for AST nodes for SPARQL 1.1
 */
export declare class AstFactory extends AstFactory_base {
    alwaysSparql11(obj: object): obj is Sparql11Nodes;
    isPath(obj: object): obj is SubTyped<'term', 'namedNode'> | Typed<'path'>;
    isExpression(obj: object): obj is SubTyped<'term', 'namedNode' | 'variable' | 'literal'> | Typed<'expression'>;
    graphNodeIdentifier(graphNode: GraphNode): Term;
    triple(subject: TripleNesting['subject'], predicate: TripleNesting['predicate'], object: TripleNesting['object'], loc?: SourceLocation): TripleNesting;
    isTriple(obj: object): obj is Typed<'triple'>;
    datasetClauses(clauses: DatasetClauses['clauses'], loc: SourceLocation): DatasetClauses;
    isDatasetClauses(obj: object): obj is Typed<'datasetClauses'>;
    wildcard(loc: SourceLocation): Wildcard;
    isWildcard(obj: object): obj is Typed<'wildcard'>;
    isTripleCollection(obj: object): obj is Typed<'tripleCollection'>;
    tripleCollectionBlankNodeProperties(identifier: TermBlank, triples: TripleNesting[], loc: SourceLocation): TripleCollectionBlankNodeProperties;
    isTripleCollectionBlankNodeProperties(obj: object): obj is SubTyped<'tripleCollection', 'blankNodeProperties'>;
    tripleCollectionList(identifier: TermBlank, triples: TripleNesting[], loc: SourceLocation): TripleCollectionList;
    isTripleCollectionList(obj: object): obj is SubTyped<'tripleCollection', 'list'>;
    graphQuads(graph: TermIri | TermVariable, triples: PatternBgp, loc: SourceLocation): GraphQuads;
    isGraphQuads(obj: object): obj is GraphQuads;
    isUpdate(obj: object): obj is Update;
}
export {};
