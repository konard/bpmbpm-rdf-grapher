import { ParserBuilder } from '@traqula/core';
import { gram } from '@traqula/rules-sparql-1-1';
export declare const expressionParserBuilder: ParserBuilder<import("@traqula/rules-sparql-1-1").SparqlContext, "string" | "expression" | "aggregate" | "builtInStr" | "builtInLang" | "builtInLangmatches" | "builtInDatatype" | "builtInBound" | "builtInIri" | "builtInUri" | "builtInBnode" | "builtInRand" | "builtInAbs" | "builtInCeil" | "builtInFloor" | "builtInRound" | "builtInConcat" | "builtInStrlen" | "builtInUcase" | "builtInLcase" | "builtInEncode_for_uri" | "builtInContains" | "builtInStrstarts" | "builtInStrends" | "builtInStrbefore" | "builtInStrafter" | "builtInYear" | "builtInMonth" | "builtInDay" | "builtInHours" | "builtInMinutes" | "builtInSeconds" | "builtInTimezone" | "builtInTz" | "builtInNow" | "builtInUuid" | "builtInStruuid" | "builtInMd5" | "builtInSha1" | "builtInSha256" | "builtInSha384" | "builtInSha512" | "builtInCoalesce" | "builtInIf" | "builtInStrlang" | "builtInStrdt" | "builtInSameterm" | "builtInIsiri" | "builtInIsuri" | "builtInIsblank" | "builtInIsliteral" | "builtInIsnumeric" | "builtInCall" | "builtInRegex" | "builtInSubstr" | "builtInReplace" | "builtInCount" | "builtInSum" | "builtInMin" | "builtInMax" | "builtInAvg" | "builtInSample" | "builtInGroup_concat" | "argList" | "expressionList" | "conditionalOrExpression" | "conditionalAndExpression" | "valueLogical" | "relationalExpression" | "numericExpression" | "additiveExpression" | "multiplicativeExpression" | "unaryExpression" | "primaryExpression" | "brackettedExpression" | "iriOrFunction" | "var" | "rdfLiteral" | "numericLiteral" | "numericLiteralUnsigned" | "numericLiteralPositive" | "numericLiteralNegative" | "booleanLiteral" | "iri" | "prefixedName", {
    string: import("@traqula/core").ParserRule<any, "string"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"string", import("@traqula/rules-sparql-1-1").TermLiteralStr>;
    expression: import("@traqula/core").ParserRule<any, "expression"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"expression", import("@traqula/rules-sparql-1-1").Expression, []> & import("@traqula/rules-sparql-1-1").SparqlGeneratorRule<"expression", import("@traqula/rules-sparql-1-1").Expression, []>;
    aggregate: import("@traqula/core").ParserRule<any, "aggregate"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"aggregate", import("@traqula/rules-sparql-1-1").ExpressionAggregate, []> & import("@traqula/rules-sparql-1-1").SparqlGeneratorRule<"aggregate", import("@traqula/rules-sparql-1-1").ExpressionAggregate, []>;
    builtInStr: import("@traqula/core").ParserRule<any, "builtInStr"> & gram.RuleDefExpressionFunctionX<"builtInStr", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInLang: import("@traqula/core").ParserRule<any, "builtInLang"> & gram.RuleDefExpressionFunctionX<"builtInLang", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInLangmatches: import("@traqula/core").ParserRule<any, "builtInLangmatches"> & gram.RuleDefExpressionFunctionX<"builtInLangmatches", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInDatatype: import("@traqula/core").ParserRule<any, "builtInDatatype"> & gram.RuleDefExpressionFunctionX<"builtInDatatype", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInBound: import("@traqula/core").ParserRule<any, "builtInBound"> & gram.RuleDefExpressionFunctionX<"builtInBound", [import("@traqula/rules-sparql-1-1").TermVariable]>;
    builtInIri: import("@traqula/core").ParserRule<any, "builtInIri"> & gram.RuleDefExpressionFunctionX<"builtInIri", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInUri: import("@traqula/core").ParserRule<any, "builtInUri"> & gram.RuleDefExpressionFunctionX<"builtInUri", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInBnode: import("@traqula/core").ParserRule<any, "builtInBnode"> & gram.RuleDefExpressionFunctionX<"builtInBnode", [import("@traqula/rules-sparql-1-1").Expression] | []>;
    builtInRand: import("@traqula/core").ParserRule<any, "builtInRand"> & gram.RuleDefExpressionFunctionX<"builtInRand", []>;
    builtInAbs: import("@traqula/core").ParserRule<any, "builtInAbs"> & gram.RuleDefExpressionFunctionX<"builtInAbs", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInCeil: import("@traqula/core").ParserRule<any, "builtInCeil"> & gram.RuleDefExpressionFunctionX<"builtInCeil", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInFloor: import("@traqula/core").ParserRule<any, "builtInFloor"> & gram.RuleDefExpressionFunctionX<"builtInFloor", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInRound: import("@traqula/core").ParserRule<any, "builtInRound"> & gram.RuleDefExpressionFunctionX<"builtInRound", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInConcat: import("@traqula/core").ParserRule<any, "builtInConcat"> & gram.RuleDefExpressionFunctionX<"builtInConcat", import("@traqula/rules-sparql-1-1").Expression[]>;
    builtInStrlen: import("@traqula/core").ParserRule<any, "builtInStrlen"> & gram.RuleDefExpressionFunctionX<"builtInStrlen", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInUcase: import("@traqula/core").ParserRule<any, "builtInUcase"> & gram.RuleDefExpressionFunctionX<"builtInUcase", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInLcase: import("@traqula/core").ParserRule<any, "builtInLcase"> & gram.RuleDefExpressionFunctionX<"builtInLcase", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInEncode_for_uri: import("@traqula/core").ParserRule<any, "builtInEncode_for_uri"> & gram.RuleDefExpressionFunctionX<"builtInEncode_for_uri", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInContains: import("@traqula/core").ParserRule<any, "builtInContains"> & gram.RuleDefExpressionFunctionX<"builtInContains", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInStrstarts: import("@traqula/core").ParserRule<any, "builtInStrstarts"> & gram.RuleDefExpressionFunctionX<"builtInStrstarts", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInStrends: import("@traqula/core").ParserRule<any, "builtInStrends"> & gram.RuleDefExpressionFunctionX<"builtInStrends", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInStrbefore: import("@traqula/core").ParserRule<any, "builtInStrbefore"> & gram.RuleDefExpressionFunctionX<"builtInStrbefore", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInStrafter: import("@traqula/core").ParserRule<any, "builtInStrafter"> & gram.RuleDefExpressionFunctionX<"builtInStrafter", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInYear: import("@traqula/core").ParserRule<any, "builtInYear"> & gram.RuleDefExpressionFunctionX<"builtInYear", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInMonth: import("@traqula/core").ParserRule<any, "builtInMonth"> & gram.RuleDefExpressionFunctionX<"builtInMonth", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInDay: import("@traqula/core").ParserRule<any, "builtInDay"> & gram.RuleDefExpressionFunctionX<"builtInDay", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInHours: import("@traqula/core").ParserRule<any, "builtInHours"> & gram.RuleDefExpressionFunctionX<"builtInHours", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInMinutes: import("@traqula/core").ParserRule<any, "builtInMinutes"> & gram.RuleDefExpressionFunctionX<"builtInMinutes", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInSeconds: import("@traqula/core").ParserRule<any, "builtInSeconds"> & gram.RuleDefExpressionFunctionX<"builtInSeconds", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInTimezone: import("@traqula/core").ParserRule<any, "builtInTimezone"> & gram.RuleDefExpressionFunctionX<"builtInTimezone", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInTz: import("@traqula/core").ParserRule<any, "builtInTz"> & gram.RuleDefExpressionFunctionX<"builtInTz", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInNow: import("@traqula/core").ParserRule<any, "builtInNow"> & gram.RuleDefExpressionFunctionX<"builtInNow", []>;
    builtInUuid: import("@traqula/core").ParserRule<any, "builtInUuid"> & gram.RuleDefExpressionFunctionX<"builtInUuid", []>;
    builtInStruuid: import("@traqula/core").ParserRule<any, "builtInStruuid"> & gram.RuleDefExpressionFunctionX<"builtInStruuid", []>;
    builtInMd5: import("@traqula/core").ParserRule<any, "builtInMd5"> & gram.RuleDefExpressionFunctionX<"builtInMd5", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInSha1: import("@traqula/core").ParserRule<any, "builtInSha1"> & gram.RuleDefExpressionFunctionX<"builtInSha1", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInSha256: import("@traqula/core").ParserRule<any, "builtInSha256"> & gram.RuleDefExpressionFunctionX<"builtInSha256", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInSha384: import("@traqula/core").ParserRule<any, "builtInSha384"> & gram.RuleDefExpressionFunctionX<"builtInSha384", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInSha512: import("@traqula/core").ParserRule<any, "builtInSha512"> & gram.RuleDefExpressionFunctionX<"builtInSha512", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInCoalesce: import("@traqula/core").ParserRule<any, "builtInCoalesce"> & gram.RuleDefExpressionFunctionX<"builtInCoalesce", import("@traqula/rules-sparql-1-1").Expression[]>;
    builtInIf: import("@traqula/core").ParserRule<any, "builtInIf"> & gram.RuleDefExpressionFunctionX<"builtInIf", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInStrlang: import("@traqula/core").ParserRule<any, "builtInStrlang"> & gram.RuleDefExpressionFunctionX<"builtInStrlang", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInStrdt: import("@traqula/core").ParserRule<any, "builtInStrdt"> & gram.RuleDefExpressionFunctionX<"builtInStrdt", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInSameterm: import("@traqula/core").ParserRule<any, "builtInSameterm"> & gram.RuleDefExpressionFunctionX<"builtInSameterm", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInIsiri: import("@traqula/core").ParserRule<any, "builtInIsiri"> & gram.RuleDefExpressionFunctionX<"builtInIsiri", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInIsuri: import("@traqula/core").ParserRule<any, "builtInIsuri"> & gram.RuleDefExpressionFunctionX<"builtInIsuri", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInIsblank: import("@traqula/core").ParserRule<any, "builtInIsblank"> & gram.RuleDefExpressionFunctionX<"builtInIsblank", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInIsliteral: import("@traqula/core").ParserRule<any, "builtInIsliteral"> & gram.RuleDefExpressionFunctionX<"builtInIsliteral", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInIsnumeric: import("@traqula/core").ParserRule<any, "builtInIsnumeric"> & gram.RuleDefExpressionFunctionX<"builtInIsnumeric", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInCall: import("@traqula/core").ParserRule<import("@traqula/rules-sparql-1-1").SparqlContext, "builtInCall", import("@traqula/rules-sparql-1-1").Expression, []>;
    builtInRegex: import("@traqula/core").ParserRule<any, "builtInRegex"> & gram.RuleDefExpressionFunctionX<"builtInRegex", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression] | [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInSubstr: import("@traqula/core").ParserRule<any, "builtInSubstr"> & gram.RuleDefExpressionFunctionX<"builtInSubstr", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression] | [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInReplace: import("@traqula/core").ParserRule<any, "builtInReplace"> & gram.RuleDefExpressionFunctionX<"builtInReplace", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression] | [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInCount: import("@traqula/core").ParserRule<any, "builtInCount"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"builtInCount", import("@traqula/rules-sparql-1-1").ExpressionAggregateDefault | import("@traqula/rules-sparql-1-1").ExpressionAggregateOnWildcard>;
    builtInSum: import("@traqula/core").ParserRule<any, "builtInSum"> & gram.RuleDefExpressionAggregatorX<"builtInSum">;
    builtInMin: import("@traqula/core").ParserRule<any, "builtInMin"> & gram.RuleDefExpressionAggregatorX<"builtInMin">;
    builtInMax: import("@traqula/core").ParserRule<any, "builtInMax"> & gram.RuleDefExpressionAggregatorX<"builtInMax">;
    builtInAvg: import("@traqula/core").ParserRule<any, "builtInAvg"> & gram.RuleDefExpressionAggregatorX<"builtInAvg">;
    builtInSample: import("@traqula/core").ParserRule<any, "builtInSample"> & gram.RuleDefExpressionAggregatorX<"builtInSample">;
    builtInGroup_concat: import("@traqula/core").ParserRule<any, "builtInGroup_concat"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"builtInGroup_concat", import("@traqula/rules-sparql-1-1").ExpressionAggregateDefault | import("@traqula/rules-sparql-1-1").ExpressionAggregateSeparator>;
    argList: import("@traqula/core").ParserRule<any, "argList"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"argList", import("@traqula/core").Wrap<gram.IArgList>, []> & import("@traqula/rules-sparql-1-1").SparqlGeneratorRule<"argList", import("@traqula/core").Wrap<gram.IArgList>, []>;
    expressionList: import("@traqula/core").ParserRule<any, "expressionList"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"expressionList", import("@traqula/core").Wrap<import("@traqula/rules-sparql-1-1").Expression[]>>;
    conditionalOrExpression: import("@traqula/core").ParserRule<any, "conditionalOrExpression"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"conditionalOrExpression", import("@traqula/rules-sparql-1-1").Expression>;
    conditionalAndExpression: import("@traqula/core").ParserRule<any, "conditionalAndExpression"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"conditionalAndExpression", import("@traqula/rules-sparql-1-1").Expression>;
    valueLogical: import("@traqula/core").ParserRule<any, "valueLogical"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"valueLogical", import("@traqula/rules-sparql-1-1").Expression>;
    relationalExpression: import("@traqula/core").ParserRule<any, "relationalExpression"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"relationalExpression", import("@traqula/rules-sparql-1-1").Expression>;
    numericExpression: import("@traqula/core").ParserRule<any, "numericExpression"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"numericExpression", import("@traqula/rules-sparql-1-1").Expression>;
    additiveExpression: import("@traqula/core").ParserRule<any, "additiveExpression"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"additiveExpression", import("@traqula/rules-sparql-1-1").Expression>;
    multiplicativeExpression: import("@traqula/core").ParserRule<any, "multiplicativeExpression"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"multiplicativeExpression", import("@traqula/rules-sparql-1-1").Expression>;
    unaryExpression: import("@traqula/core").ParserRule<any, "unaryExpression"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"unaryExpression", import("@traqula/rules-sparql-1-1").Expression>;
    primaryExpression: import("@traqula/core").ParserRule<any, "primaryExpression"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"primaryExpression", import("@traqula/rules-sparql-1-1").Expression>;
    brackettedExpression: import("@traqula/core").ParserRule<any, "brackettedExpression"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"brackettedExpression", import("@traqula/rules-sparql-1-1").Expression>;
    iriOrFunction: import("@traqula/core").ParserRule<any, "iriOrFunction"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"iriOrFunction", import("@traqula/rules-sparql-1-1").ExpressionFunctionCall | import("@traqula/rules-sparql-1-1").TermIri, []> & import("@traqula/rules-sparql-1-1").SparqlGeneratorRule<"iriOrFunction", import("@traqula/rules-sparql-1-1").ExpressionFunctionCall | import("@traqula/rules-sparql-1-1").TermIri, []>;
    var: import("@traqula/core").ParserRule<any, "var"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"var", import("@traqula/rules-sparql-1-1").TermVariable, []> & import("@traqula/rules-sparql-1-1").SparqlGeneratorRule<"var", import("@traqula/rules-sparql-1-1").TermVariable, []>;
    rdfLiteral: import("@traqula/core").ParserRule<any, "rdfLiteral"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"rdfLiteral", import("@traqula/rules-sparql-1-1").TermLiteral, []> & import("@traqula/rules-sparql-1-1").SparqlGeneratorRule<"rdfLiteral", import("@traqula/rules-sparql-1-1").TermLiteral, []>;
    numericLiteral: import("@traqula/core").ParserRule<any, "numericLiteral"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"numericLiteral", import("@traqula/rules-sparql-1-1").TermLiteralTyped>;
    numericLiteralUnsigned: import("@traqula/core").ParserRule<any, "numericLiteralUnsigned"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"numericLiteralUnsigned", import("@traqula/rules-sparql-1-1").TermLiteralTyped>;
    numericLiteralPositive: import("@traqula/core").ParserRule<any, "numericLiteralPositive"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"numericLiteralPositive", import("@traqula/rules-sparql-1-1").TermLiteralTyped>;
    numericLiteralNegative: import("@traqula/core").ParserRule<any, "numericLiteralNegative"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"numericLiteralNegative", import("@traqula/rules-sparql-1-1").TermLiteralTyped>;
    booleanLiteral: import("@traqula/core").ParserRule<any, "booleanLiteral"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"booleanLiteral", import("@traqula/rules-sparql-1-1").TermLiteralTyped>;
    iri: import("@traqula/core").ParserRule<any, "iri"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"iri", import("@traqula/rules-sparql-1-1").TermIri, []> & import("@traqula/rules-sparql-1-1").SparqlGeneratorRule<"iri", import("@traqula/rules-sparql-1-1").TermIri, []>;
    prefixedName: import("@traqula/core").ParserRule<any, "prefixedName"> & import("@traqula/rules-sparql-1-1").SparqlGrammarRule<"prefixedName", import("@traqula/rules-sparql-1-1").TermIriPrefixed, []> & import("@traqula/rules-sparql-1-1").SparqlGeneratorRule<"prefixedName", import("@traqula/rules-sparql-1-1").TermIriPrefixed, []>;
}>;
export type ExpressionParser = ReturnType<typeof expressionParserBuilder.build>;
