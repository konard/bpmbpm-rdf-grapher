{"version":3,"file":"Parser.js","sourceRoot":"","sources":["../../../lib/Parser.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,aAAa,EAAE,MAAM,eAAe,CAAC;AAE9C,OAAO,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC,EAAE,mBAAmB,EAAE,qBAAqB,EAAE,MAAM,2BAA2B,CAAC;AACvG,OAAO,EAAE,sBAAsB,EAAE,MAAM,sBAAsB,CAAC;AAC9D,OAAO,EAAE,mBAAmB,EAAE,MAAM,uBAAuB,CAAC;AAE5D,MAAM,CAAC,MAAM,qBAAqB,GAAG,aAAa,CAAC,MAAM,CAAC,sBAAsB,CAAC;KAC9E,KAAK,CAAC,mBAAmB,EAAU,EAAE,CAAC;KACtC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;AAI/B;;GAEG;AACH,MAAM,OAAO,MAAO,SAAQ,mBAAoC;IAC9D,YACE,OAAgH,EAAE;QAElH,MAAM,MAAM,GAAiB,qBAAqB,CAAC,KAAK,CAAC;YACvD,GAAG,IAAI;YACP,eAAe,EAAE,CAAC,CAAC,oBAAoB,CAAC,eAAe;YACvD,iBAAiB,EAAE,qBAAqB;SACzC,CAAC,CAAC;QACH,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;IACrC,CAAC;CACF","sourcesContent":["import type { ParserBuildArgs } from '@traqula/core';\nimport { ParserBuilder } from '@traqula/core';\nimport type * as T11 from '@traqula/rules-sparql-1-1';\nimport { gram, lex as l, MinimalSparqlParser, sparqlCodepointEscape } from '@traqula/rules-sparql-1-1';\nimport { queryUnitParserBuilder } from './queryUnitParser.js';\nimport { updateParserBuilder } from './updateUnitParser.js';\n\nexport const sparql11ParserBuilder = ParserBuilder.create(queryUnitParserBuilder)\n  .merge(updateParserBuilder, <const> [])\n  .addRule(gram.queryOrUpdate);\n\nexport type SparqlParser = ReturnType<typeof sparql11ParserBuilder.build>;\n\n/**\n * Generator that can generate a SPARQL 1.1 AST given a SPARQL 1.1 string.\n */\nexport class Parser extends MinimalSparqlParser<T11.SparqlQuery> {\n  public constructor(\n    args: Pick<ParserBuildArgs, 'parserConfig' | 'lexerConfig'> & { defaultContext?: Partial<T11.SparqlContext> } = {},\n  ) {\n    const parser: SparqlParser = sparql11ParserBuilder.build({\n      ...args,\n      tokenVocabulary: l.sparql11LexerBuilder.tokenVocabulary,\n      queryPreProcessor: sparqlCodepointEscape,\n    });\n    super(parser, args.defaultContext);\n  }\n}\n"]}