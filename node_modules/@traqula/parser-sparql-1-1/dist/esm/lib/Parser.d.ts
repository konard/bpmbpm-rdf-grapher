import type { ParserBuildArgs } from '@traqula/core';
import { ParserBuilder } from '@traqula/core';
import type * as T11 from '@traqula/rules-sparql-1-1';
import { MinimalSparqlParser } from '@traqula/rules-sparql-1-1';
export declare const sparql11ParserBuilder: ParserBuilder<T11.SparqlContext, "string" | "object" | "filter" | "copy" | "graphRef" | "load" | "clear" | "drop" | "create" | "add" | "move" | "modify" | "update" | "query" | "datasetClauses" | "bind" | "solutionModifier" | "expression" | "aggregate" | "functionCall" | "path" | "blankNode" | "queryUnit" | "selectQuery" | "subSelect" | "selectClause" | "constructQuery" | "describeQuery" | "askQuery" | "valuesClause" | "constructTemplate" | "constructTriples" | "updateUnit" | "update1" | "quadPattern" | "quadData" | "insertData" | "deleteData" | "deleteWhere" | "deleteClause" | "insertClause" | "graphOrDefault" | "graphRefAll" | "quads" | "quadsNotTriples" | "builtInStr" | "builtInLang" | "builtInLangmatches" | "builtInDatatype" | "builtInBound" | "builtInIri" | "builtInUri" | "builtInBnode" | "builtInRand" | "builtInAbs" | "builtInCeil" | "builtInFloor" | "builtInRound" | "builtInConcat" | "builtInStrlen" | "builtInUcase" | "builtInLcase" | "builtInEncode_for_uri" | "builtInContains" | "builtInStrstarts" | "builtInStrends" | "builtInStrbefore" | "builtInStrafter" | "builtInYear" | "builtInMonth" | "builtInDay" | "builtInHours" | "builtInMinutes" | "builtInSeconds" | "builtInTimezone" | "builtInTz" | "builtInNow" | "builtInUuid" | "builtInStruuid" | "builtInMd5" | "builtInSha1" | "builtInSha256" | "builtInSha384" | "builtInSha512" | "builtInCoalesce" | "builtInIf" | "builtInStrlang" | "builtInStrdt" | "builtInSameterm" | "builtInIsiri" | "builtInIsuri" | "builtInIsblank" | "builtInIsliteral" | "builtInIsnumeric" | "builtInCall" | "builtInRegex" | "builtInSubstr" | "builtInReplace" | "builtInExists" | "builtInNotexists" | "builtInCount" | "builtInSum" | "builtInMin" | "builtInMax" | "builtInAvg" | "builtInSample" | "builtInGroup_concat" | "usingClause" | "datasetClause" | "defaultGraphClause" | "usingClauses" | "namedGraphClause" | "sourceSelector" | "argList" | "expressionList" | "conditionalOrExpression" | "conditionalAndExpression" | "valueLogical" | "relationalExpression" | "numericExpression" | "additiveExpression" | "multiplicativeExpression" | "unaryExpression" | "primaryExpression" | "brackettedExpression" | "iriOrFunction" | "prologue" | "baseDecl" | "prefixDecl" | "verb" | "varOrTerm" | "varOrIri" | "var" | "graphTerm" | "rdfLiteral" | "numericLiteral" | "numericLiteralUnsigned" | "numericLiteralPositive" | "numericLiteralNegative" | "booleanLiteral" | "iri" | "iriFull" | "prefixedName" | "VerbA" | "pathEltOrInverse" | "pathSequence" | "pathAlternative" | "pathElt" | "pathMod" | "pathPrimary" | "pathNegatedPropertySet" | "pathOneInPropertySet" | "groupClause" | "groupCondition" | "havingClause" | "havingCondition" | "orderClause" | "orderCondition" | "limitOffsetClauses" | "limitClause" | "offsetClause" | "triplesBlock" | "triplesSameSubject" | "triplesSameSubjectPath" | "triplesTemplate" | "propertyList" | "propertyListPath" | "propertyListNotEmpty" | "propertyListPathNotEmpty" | "verbPath" | "verbSimple" | "objectList" | "objectListPath" | "objectPath" | "collection" | "collectionPath" | "triplesNode" | "triplesNodePath" | "blankNodePropertyList" | "blankNodePropertyListPath" | "graphNode" | "graphNodePath" | "whereClause" | "groupGraphPattern" | "groupGraphPatternSub" | "graphPatternNotTriples" | "optionalGraphPattern" | "graphGraphPattern" | "serviceGraphPattern" | "inlineData" | "dataBlock" | "inlineDataOneVar" | "inlineDataFull" | "dataBlockValue" | "minusGraphPattern" | "groupOrUnionGraphPattern" | "constraint" | "queryOrUpdate", {
    string: import("@traqula/core").ParserRule<any, "string"> & T11.SparqlGrammarRule<"string", T11.TermLiteralStr>;
    object: import("@traqula/core").ParserRule<any, "object"> & T11.SparqlGrammarRule<"object", T11.TripleNesting, [T11.GraphNode, T11.TermIriFull | T11.TermIriPrefixed | T11.TermVariable | T11.PropertyPathChain | T11.PathModified | T11.PathNegated]>;
    filter: import("@traqula/core").ParserRule<any, "filter"> & T11.SparqlGrammarRule<"filter", T11.PatternFilter, []> & T11.SparqlGeneratorRule<"filter", T11.PatternFilter, []>;
    copy: import("@traqula/core").ParserRule<any, "copy"> & T11.SparqlGrammarRule<"copy", T11.UpdateOperationAdd | T11.UpdateOperationMove | T11.UpdateOperationCopy, []> & T11.SparqlGeneratorRule<"copy", T11.UpdateOperationAdd | T11.UpdateOperationMove | T11.UpdateOperationCopy, []>;
    graphRef: import("@traqula/core").ParserRule<any, "graphRef"> & T11.SparqlGrammarRule<"graphRef", T11.GraphRefSpecific, []> & T11.SparqlGeneratorRule<"graphRef", T11.GraphRefSpecific, []>;
    load: import("@traqula/core").ParserRule<any, "load"> & T11.SparqlGrammarRule<"load", T11.UpdateOperationLoad, []> & T11.SparqlGeneratorRule<"load", T11.UpdateOperationLoad, []>;
    clear: import("@traqula/core").ParserRule<any, "clear"> & T11.SparqlGrammarRule<"clear", T11.UpdateOperationClear | T11.UpdateOperationDrop, []> & T11.SparqlGeneratorRule<"clear", T11.UpdateOperationClear | T11.UpdateOperationDrop, []>;
    drop: import("@traqula/core").ParserRule<any, "drop"> & T11.SparqlGrammarRule<"drop", T11.UpdateOperationClear | T11.UpdateOperationDrop, []> & T11.SparqlGeneratorRule<"drop", T11.UpdateOperationClear | T11.UpdateOperationDrop, []>;
    create: import("@traqula/core").ParserRule<any, "create"> & T11.SparqlGrammarRule<"create", T11.UpdateOperationCreate, []> & T11.SparqlGeneratorRule<"create", T11.UpdateOperationCreate, []>;
    add: import("@traqula/core").ParserRule<any, "add"> & T11.SparqlGrammarRule<"add", T11.UpdateOperationAdd | T11.UpdateOperationMove | T11.UpdateOperationCopy, []> & T11.SparqlGeneratorRule<"add", T11.UpdateOperationAdd | T11.UpdateOperationMove | T11.UpdateOperationCopy, []>;
    move: import("@traqula/core").ParserRule<any, "move"> & T11.SparqlGrammarRule<"move", T11.UpdateOperationAdd | T11.UpdateOperationMove | T11.UpdateOperationCopy, []> & T11.SparqlGeneratorRule<"move", T11.UpdateOperationAdd | T11.UpdateOperationMove | T11.UpdateOperationCopy, []>;
    modify: import("@traqula/core").ParserRule<any, "modify"> & T11.SparqlGrammarRule<"modify", T11.UpdateOperationModify, []> & T11.SparqlGeneratorRule<"modify", T11.UpdateOperationModify, []>;
    update: import("@traqula/core").ParserRule<any, "update"> & T11.SparqlGrammarRule<"update", T11.Update, []> & T11.SparqlGeneratorRule<"update", T11.Update, []>;
    query: import("@traqula/core").ParserRule<any, "query"> & T11.SparqlGrammarRule<"query", T11.Query, []> & T11.SparqlGeneratorRule<"query", T11.Query, []>;
    datasetClauses: import("@traqula/core").ParserRule<T11.SparqlContext, "datasetClauses", T11.DatasetClauses, []>;
    bind: import("@traqula/core").ParserRule<any, "bind"> & T11.SparqlGrammarRule<"bind", T11.PatternBind, []> & T11.SparqlGeneratorRule<"bind", T11.PatternBind, []>;
    solutionModifier: import("@traqula/core").ParserRule<any, "solutionModifier"> & T11.SparqlGrammarRule<"solutionModifier", T11.SolutionModifiers, []> & T11.SparqlGeneratorRule<"solutionModifier", T11.SolutionModifiers, []>;
    expression: import("@traqula/core").ParserRule<any, "expression"> & T11.SparqlGrammarRule<"expression", T11.Expression, []> & T11.SparqlGeneratorRule<"expression", T11.Expression, []>;
    aggregate: import("@traqula/core").ParserRule<any, "aggregate"> & T11.SparqlGrammarRule<"aggregate", T11.ExpressionAggregate, []> & T11.SparqlGeneratorRule<"aggregate", T11.ExpressionAggregate, []>;
    functionCall: import("@traqula/core").ParserRule<any, "functionCall"> & T11.SparqlGrammarRule<"functionCall", T11.ExpressionFunctionCall>;
    path: import("@traqula/core").ParserRule<any, "path"> & T11.SparqlGrammarRule<"path", T11.Path>;
    blankNode: import("@traqula/core").ParserRule<any, "blankNode"> & T11.SparqlGrammarRule<"blankNode", T11.TermBlank, []> & T11.SparqlGeneratorRule<"blankNode", T11.TermBlank, []>;
    queryUnit: import("@traqula/core").ParserRule<any, "queryUnit"> & T11.SparqlGrammarRule<"queryUnit", T11.Query>;
    selectQuery: import("@traqula/core").ParserRule<any, "selectQuery"> & T11.SparqlGrammarRule<"selectQuery", Omit<T11.QuerySelect, T11.gram.HandledByBase>, []> & T11.SparqlGeneratorRule<"selectQuery", Omit<T11.QuerySelect, T11.gram.HandledByBase>, []>;
    subSelect: import("@traqula/core").ParserRule<any, "subSelect"> & T11.SparqlGrammarRule<"subSelect", T11.QuerySelect>;
    selectClause: import("@traqula/core").ParserRule<any, "selectClause"> & T11.SparqlGrammarRule<"selectClause", import("@traqula/core").Wrap<Pick<T11.QuerySelect, "variables" | "distinct" | "reduced">>, []> & T11.SparqlGeneratorRule<"selectClause", import("@traqula/core").Wrap<Pick<T11.QuerySelect, "variables" | "distinct" | "reduced">>, []>;
    constructQuery: import("@traqula/core").ParserRule<any, "constructQuery"> & T11.SparqlGrammarRule<"constructQuery", Omit<T11.QueryConstruct, T11.gram.HandledByBase>, []> & T11.SparqlGeneratorRule<"constructQuery", Omit<T11.QueryConstruct, T11.gram.HandledByBase>, []>;
    describeQuery: import("@traqula/core").ParserRule<any, "describeQuery"> & T11.SparqlGrammarRule<"describeQuery", Omit<T11.QueryDescribe, T11.gram.HandledByBase>, []> & T11.SparqlGeneratorRule<"describeQuery", Omit<T11.QueryDescribe, T11.gram.HandledByBase>, []>;
    askQuery: import("@traqula/core").ParserRule<any, "askQuery"> & T11.SparqlGrammarRule<"askQuery", Omit<T11.QueryAsk, T11.gram.HandledByBase>, []> & T11.SparqlGeneratorRule<"askQuery", Omit<T11.QueryAsk, T11.gram.HandledByBase>, []>;
    valuesClause: import("@traqula/core").ParserRule<any, "valuesClause"> & T11.SparqlGrammarRule<"valuesClause", T11.PatternValues | undefined>;
    constructTemplate: import("@traqula/core").ParserRule<T11.SparqlContext, "constructTemplate", import("@traqula/core").Wrap<T11.PatternBgp>, []>;
    constructTriples: import("@traqula/core").ParserRule<T11.SparqlContext, "constructTriples", T11.PatternBgp, []>;
    updateUnit: import("@traqula/core").ParserRule<any, "updateUnit"> & T11.SparqlGrammarRule<"updateUnit", T11.Update>;
    update1: import("@traqula/core").ParserRule<T11.SparqlContext, "update1", T11.UpdateOperation, []>;
    quadPattern: import("@traqula/core").ParserRule<T11.SparqlContext, "quadPattern", import("@traqula/core").Wrap<T11.Quads[]>, []>;
    quadData: import("@traqula/core").ParserRule<any, "quadData"> & T11.SparqlGrammarRule<"quadData", import("@traqula/core").Wrap<T11.Quads[]>>;
    insertData: import("@traqula/core").ParserRule<any, "insertData"> & T11.SparqlGrammarRule<"insertData", T11.UpdateOperationInsertData | T11.UpdateOperationDeleteData | T11.UpdateOperationDeleteWhere, []> & T11.SparqlGeneratorRule<"insertData", T11.UpdateOperationInsertData | T11.UpdateOperationDeleteData | T11.UpdateOperationDeleteWhere, []>;
    deleteData: import("@traqula/core").ParserRule<any, "deleteData"> & T11.SparqlGrammarRule<"deleteData", T11.UpdateOperationInsertData | T11.UpdateOperationDeleteData | T11.UpdateOperationDeleteWhere, []> & T11.SparqlGeneratorRule<"deleteData", T11.UpdateOperationInsertData | T11.UpdateOperationDeleteData | T11.UpdateOperationDeleteWhere, []>;
    deleteWhere: import("@traqula/core").ParserRule<any, "deleteWhere"> & T11.SparqlGrammarRule<"deleteWhere", T11.UpdateOperationInsertData | T11.UpdateOperationDeleteData | T11.UpdateOperationDeleteWhere, []> & T11.SparqlGeneratorRule<"deleteWhere", T11.UpdateOperationInsertData | T11.UpdateOperationDeleteData | T11.UpdateOperationDeleteWhere, []>;
    deleteClause: import("@traqula/core").ParserRule<any, "deleteClause"> & T11.SparqlGrammarRule<"deleteClause", import("@traqula/core").Wrap<T11.Quads[]>>;
    insertClause: import("@traqula/core").ParserRule<any, "insertClause"> & T11.SparqlGrammarRule<"insertClause", import("@traqula/core").Wrap<T11.Quads[]>>;
    graphOrDefault: import("@traqula/core").ParserRule<any, "graphOrDefault"> & T11.SparqlGrammarRule<"graphOrDefault", T11.GraphRefDefault | T11.GraphRefSpecific>;
    graphRefAll: import("@traqula/core").ParserRule<any, "graphRefAll"> & T11.SparqlGrammarRule<"graphRefAll", T11.GraphRef, []> & T11.SparqlGeneratorRule<"graphRefAll", T11.GraphRef, []>;
    quads: import("@traqula/core").ParserRule<any, "quads"> & T11.SparqlGrammarRule<"quads", import("@traqula/core").Wrap<T11.Quads[]>, []> & T11.SparqlGeneratorRule<"quads", import("@traqula/core").Wrap<T11.Quads[]>, []>;
    quadsNotTriples: import("@traqula/core").ParserRule<T11.SparqlContext, "quadsNotTriples", T11.GraphQuads, []>;
    builtInStr: import("@traqula/core").ParserRule<any, "builtInStr"> & T11.RuleDefExpressionFunctionX<"builtInStr", [T11.Expression]>;
    builtInLang: import("@traqula/core").ParserRule<any, "builtInLang"> & T11.RuleDefExpressionFunctionX<"builtInLang", [T11.Expression]>;
    builtInLangmatches: import("@traqula/core").ParserRule<any, "builtInLangmatches"> & T11.RuleDefExpressionFunctionX<"builtInLangmatches", [T11.Expression, T11.Expression]>;
    builtInDatatype: import("@traqula/core").ParserRule<any, "builtInDatatype"> & T11.RuleDefExpressionFunctionX<"builtInDatatype", [T11.Expression]>;
    builtInBound: import("@traqula/core").ParserRule<any, "builtInBound"> & T11.RuleDefExpressionFunctionX<"builtInBound", [T11.TermVariable]>;
    builtInIri: import("@traqula/core").ParserRule<any, "builtInIri"> & T11.RuleDefExpressionFunctionX<"builtInIri", [T11.Expression]>;
    builtInUri: import("@traqula/core").ParserRule<any, "builtInUri"> & T11.RuleDefExpressionFunctionX<"builtInUri", [T11.Expression]>;
    builtInBnode: import("@traqula/core").ParserRule<any, "builtInBnode"> & T11.RuleDefExpressionFunctionX<"builtInBnode", [T11.Expression] | []>;
    builtInRand: import("@traqula/core").ParserRule<any, "builtInRand"> & T11.RuleDefExpressionFunctionX<"builtInRand", []>;
    builtInAbs: import("@traqula/core").ParserRule<any, "builtInAbs"> & T11.RuleDefExpressionFunctionX<"builtInAbs", [T11.Expression]>;
    builtInCeil: import("@traqula/core").ParserRule<any, "builtInCeil"> & T11.RuleDefExpressionFunctionX<"builtInCeil", [T11.Expression]>;
    builtInFloor: import("@traqula/core").ParserRule<any, "builtInFloor"> & T11.RuleDefExpressionFunctionX<"builtInFloor", [T11.Expression]>;
    builtInRound: import("@traqula/core").ParserRule<any, "builtInRound"> & T11.RuleDefExpressionFunctionX<"builtInRound", [T11.Expression]>;
    builtInConcat: import("@traqula/core").ParserRule<any, "builtInConcat"> & T11.RuleDefExpressionFunctionX<"builtInConcat", T11.Expression[]>;
    builtInStrlen: import("@traqula/core").ParserRule<any, "builtInStrlen"> & T11.RuleDefExpressionFunctionX<"builtInStrlen", [T11.Expression]>;
    builtInUcase: import("@traqula/core").ParserRule<any, "builtInUcase"> & T11.RuleDefExpressionFunctionX<"builtInUcase", [T11.Expression]>;
    builtInLcase: import("@traqula/core").ParserRule<any, "builtInLcase"> & T11.RuleDefExpressionFunctionX<"builtInLcase", [T11.Expression]>;
    builtInEncode_for_uri: import("@traqula/core").ParserRule<any, "builtInEncode_for_uri"> & T11.RuleDefExpressionFunctionX<"builtInEncode_for_uri", [T11.Expression]>;
    builtInContains: import("@traqula/core").ParserRule<any, "builtInContains"> & T11.RuleDefExpressionFunctionX<"builtInContains", [T11.Expression, T11.Expression]>;
    builtInStrstarts: import("@traqula/core").ParserRule<any, "builtInStrstarts"> & T11.RuleDefExpressionFunctionX<"builtInStrstarts", [T11.Expression, T11.Expression]>;
    builtInStrends: import("@traqula/core").ParserRule<any, "builtInStrends"> & T11.RuleDefExpressionFunctionX<"builtInStrends", [T11.Expression, T11.Expression]>;
    builtInStrbefore: import("@traqula/core").ParserRule<any, "builtInStrbefore"> & T11.RuleDefExpressionFunctionX<"builtInStrbefore", [T11.Expression, T11.Expression]>;
    builtInStrafter: import("@traqula/core").ParserRule<any, "builtInStrafter"> & T11.RuleDefExpressionFunctionX<"builtInStrafter", [T11.Expression, T11.Expression]>;
    builtInYear: import("@traqula/core").ParserRule<any, "builtInYear"> & T11.RuleDefExpressionFunctionX<"builtInYear", [T11.Expression]>;
    builtInMonth: import("@traqula/core").ParserRule<any, "builtInMonth"> & T11.RuleDefExpressionFunctionX<"builtInMonth", [T11.Expression]>;
    builtInDay: import("@traqula/core").ParserRule<any, "builtInDay"> & T11.RuleDefExpressionFunctionX<"builtInDay", [T11.Expression]>;
    builtInHours: import("@traqula/core").ParserRule<any, "builtInHours"> & T11.RuleDefExpressionFunctionX<"builtInHours", [T11.Expression]>;
    builtInMinutes: import("@traqula/core").ParserRule<any, "builtInMinutes"> & T11.RuleDefExpressionFunctionX<"builtInMinutes", [T11.Expression]>;
    builtInSeconds: import("@traqula/core").ParserRule<any, "builtInSeconds"> & T11.RuleDefExpressionFunctionX<"builtInSeconds", [T11.Expression]>;
    builtInTimezone: import("@traqula/core").ParserRule<any, "builtInTimezone"> & T11.RuleDefExpressionFunctionX<"builtInTimezone", [T11.Expression]>;
    builtInTz: import("@traqula/core").ParserRule<any, "builtInTz"> & T11.RuleDefExpressionFunctionX<"builtInTz", [T11.Expression]>;
    builtInNow: import("@traqula/core").ParserRule<any, "builtInNow"> & T11.RuleDefExpressionFunctionX<"builtInNow", []>;
    builtInUuid: import("@traqula/core").ParserRule<any, "builtInUuid"> & T11.RuleDefExpressionFunctionX<"builtInUuid", []>;
    builtInStruuid: import("@traqula/core").ParserRule<any, "builtInStruuid"> & T11.RuleDefExpressionFunctionX<"builtInStruuid", []>;
    builtInMd5: import("@traqula/core").ParserRule<any, "builtInMd5"> & T11.RuleDefExpressionFunctionX<"builtInMd5", [T11.Expression]>;
    builtInSha1: import("@traqula/core").ParserRule<any, "builtInSha1"> & T11.RuleDefExpressionFunctionX<"builtInSha1", [T11.Expression]>;
    builtInSha256: import("@traqula/core").ParserRule<any, "builtInSha256"> & T11.RuleDefExpressionFunctionX<"builtInSha256", [T11.Expression]>;
    builtInSha384: import("@traqula/core").ParserRule<any, "builtInSha384"> & T11.RuleDefExpressionFunctionX<"builtInSha384", [T11.Expression]>;
    builtInSha512: import("@traqula/core").ParserRule<any, "builtInSha512"> & T11.RuleDefExpressionFunctionX<"builtInSha512", [T11.Expression]>;
    builtInCoalesce: import("@traqula/core").ParserRule<any, "builtInCoalesce"> & T11.RuleDefExpressionFunctionX<"builtInCoalesce", T11.Expression[]>;
    builtInIf: import("@traqula/core").ParserRule<any, "builtInIf"> & T11.RuleDefExpressionFunctionX<"builtInIf", [T11.Expression, T11.Expression, T11.Expression]>;
    builtInStrlang: import("@traqula/core").ParserRule<any, "builtInStrlang"> & T11.RuleDefExpressionFunctionX<"builtInStrlang", [T11.Expression, T11.Expression]>;
    builtInStrdt: import("@traqula/core").ParserRule<any, "builtInStrdt"> & T11.RuleDefExpressionFunctionX<"builtInStrdt", [T11.Expression, T11.Expression]>;
    builtInSameterm: import("@traqula/core").ParserRule<any, "builtInSameterm"> & T11.RuleDefExpressionFunctionX<"builtInSameterm", [T11.Expression, T11.Expression]>;
    builtInIsiri: import("@traqula/core").ParserRule<any, "builtInIsiri"> & T11.RuleDefExpressionFunctionX<"builtInIsiri", [T11.Expression]>;
    builtInIsuri: import("@traqula/core").ParserRule<any, "builtInIsuri"> & T11.RuleDefExpressionFunctionX<"builtInIsuri", [T11.Expression]>;
    builtInIsblank: import("@traqula/core").ParserRule<any, "builtInIsblank"> & T11.RuleDefExpressionFunctionX<"builtInIsblank", [T11.Expression]>;
    builtInIsliteral: import("@traqula/core").ParserRule<any, "builtInIsliteral"> & T11.RuleDefExpressionFunctionX<"builtInIsliteral", [T11.Expression]>;
    builtInIsnumeric: import("@traqula/core").ParserRule<any, "builtInIsnumeric"> & T11.RuleDefExpressionFunctionX<"builtInIsnumeric", [T11.Expression]>;
    builtInCall: import("@traqula/core").ParserRule<T11.SparqlContext, "builtInCall", T11.Expression, []>;
    builtInRegex: import("@traqula/core").ParserRule<any, "builtInRegex"> & T11.RuleDefExpressionFunctionX<"builtInRegex", [T11.Expression, T11.Expression] | [T11.Expression, T11.Expression, T11.Expression]>;
    builtInSubstr: import("@traqula/core").ParserRule<any, "builtInSubstr"> & T11.RuleDefExpressionFunctionX<"builtInSubstr", [T11.Expression, T11.Expression] | [T11.Expression, T11.Expression, T11.Expression]>;
    builtInReplace: import("@traqula/core").ParserRule<any, "builtInReplace"> & T11.RuleDefExpressionFunctionX<"builtInReplace", [T11.Expression, T11.Expression, T11.Expression] | [T11.Expression, T11.Expression, T11.Expression, T11.Expression]>;
    builtInExists: import("@traqula/core").ParserRule<any, "builtInExists"> & T11.SparqlGrammarRule<"builtInExists", T11.ExpressionPatternOperation>;
    builtInNotexists: import("@traqula/core").ParserRule<any, "builtInNotexists"> & T11.SparqlGrammarRule<"builtInNotexists", T11.ExpressionPatternOperation>;
    builtInCount: import("@traqula/core").ParserRule<any, "builtInCount"> & T11.SparqlGrammarRule<"builtInCount", T11.ExpressionAggregateDefault | T11.ExpressionAggregateOnWildcard>;
    builtInSum: import("@traqula/core").ParserRule<any, "builtInSum"> & T11.RuleDefExpressionAggregatorX<"builtInSum">;
    builtInMin: import("@traqula/core").ParserRule<any, "builtInMin"> & T11.RuleDefExpressionAggregatorX<"builtInMin">;
    builtInMax: import("@traqula/core").ParserRule<any, "builtInMax"> & T11.RuleDefExpressionAggregatorX<"builtInMax">;
    builtInAvg: import("@traqula/core").ParserRule<any, "builtInAvg"> & T11.RuleDefExpressionAggregatorX<"builtInAvg">;
    builtInSample: import("@traqula/core").ParserRule<any, "builtInSample"> & T11.RuleDefExpressionAggregatorX<"builtInSample">;
    builtInGroup_concat: import("@traqula/core").ParserRule<any, "builtInGroup_concat"> & T11.SparqlGrammarRule<"builtInGroup_concat", T11.ExpressionAggregateDefault | T11.ExpressionAggregateSeparator>;
    usingClause: import("@traqula/core").ParserRule<any, "usingClause"> & T11.SparqlGrammarRule<"usingClause", import("@traqula/core").Wrap<{
        clauseType: "default" | "named";
        value: T11.TermIri;
    }>>;
    datasetClause: import("@traqula/core").ParserRule<T11.SparqlContext, "datasetClause", import("@traqula/core").Wrap<{
        clauseType: "default" | "named";
        value: T11.TermIri;
    }>, []>;
    defaultGraphClause: import("@traqula/core").ParserRule<T11.SparqlContext, "defaultGraphClause", T11.TermIri, []>;
    usingClauses: import("@traqula/core").ParserRule<any, "usingClauses"> & T11.SparqlGrammarRule<"usingClauses", T11.DatasetClauses, []> & T11.SparqlGeneratorRule<"usingClauses", T11.DatasetClauses, []>;
    namedGraphClause: import("@traqula/core").ParserRule<T11.SparqlContext, "namedGraphClause", import("@traqula/core").Wrap<T11.TermIri>, []>;
    sourceSelector: import("@traqula/core").ParserRule<T11.SparqlContext, "sourceSelector", T11.TermIri, []>;
    argList: import("@traqula/core").ParserRule<any, "argList"> & T11.SparqlGrammarRule<"argList", import("@traqula/core").Wrap<T11.gram.IArgList>, []> & T11.SparqlGeneratorRule<"argList", import("@traqula/core").Wrap<T11.gram.IArgList>, []>;
    expressionList: import("@traqula/core").ParserRule<any, "expressionList"> & T11.SparqlGrammarRule<"expressionList", import("@traqula/core").Wrap<T11.Expression[]>>;
    conditionalOrExpression: import("@traqula/core").ParserRule<any, "conditionalOrExpression"> & T11.SparqlGrammarRule<"conditionalOrExpression", T11.Expression>;
    conditionalAndExpression: import("@traqula/core").ParserRule<any, "conditionalAndExpression"> & T11.SparqlGrammarRule<"conditionalAndExpression", T11.Expression>;
    valueLogical: import("@traqula/core").ParserRule<any, "valueLogical"> & T11.SparqlGrammarRule<"valueLogical", T11.Expression>;
    relationalExpression: import("@traqula/core").ParserRule<any, "relationalExpression"> & T11.SparqlGrammarRule<"relationalExpression", T11.Expression>;
    numericExpression: import("@traqula/core").ParserRule<any, "numericExpression"> & T11.SparqlGrammarRule<"numericExpression", T11.Expression>;
    additiveExpression: import("@traqula/core").ParserRule<any, "additiveExpression"> & T11.SparqlGrammarRule<"additiveExpression", T11.Expression>;
    multiplicativeExpression: import("@traqula/core").ParserRule<any, "multiplicativeExpression"> & T11.SparqlGrammarRule<"multiplicativeExpression", T11.Expression>;
    unaryExpression: import("@traqula/core").ParserRule<any, "unaryExpression"> & T11.SparqlGrammarRule<"unaryExpression", T11.Expression>;
    primaryExpression: import("@traqula/core").ParserRule<any, "primaryExpression"> & T11.SparqlGrammarRule<"primaryExpression", T11.Expression>;
    brackettedExpression: import("@traqula/core").ParserRule<any, "brackettedExpression"> & T11.SparqlGrammarRule<"brackettedExpression", T11.Expression>;
    iriOrFunction: import("@traqula/core").ParserRule<any, "iriOrFunction"> & T11.SparqlGrammarRule<"iriOrFunction", T11.ExpressionFunctionCall | T11.TermIri, []> & T11.SparqlGeneratorRule<"iriOrFunction", T11.ExpressionFunctionCall | T11.TermIri, []>;
    prologue: import("@traqula/core").ParserRule<any, "prologue"> & T11.SparqlGrammarRule<"prologue", T11.ContextDefinition[], []> & T11.SparqlGeneratorRule<"prologue", T11.ContextDefinition[], []>;
    baseDecl: import("@traqula/core").ParserRule<any, "baseDecl"> & T11.SparqlGrammarRule<"baseDecl", T11.ContextDefinitionBase, []> & T11.SparqlGeneratorRule<"baseDecl", T11.ContextDefinitionBase, []>;
    prefixDecl: import("@traqula/core").ParserRule<any, "prefixDecl"> & T11.SparqlGrammarRule<"prefixDecl", T11.ContextDefinitionPrefix, []> & T11.SparqlGeneratorRule<"prefixDecl", T11.ContextDefinitionPrefix, []>;
    verb: import("@traqula/core").ParserRule<any, "verb"> & T11.SparqlGrammarRule<"verb", T11.TermIri | T11.TermVariable>;
    varOrTerm: import("@traqula/core").ParserRule<any, "varOrTerm"> & T11.SparqlGrammarRule<"varOrTerm", T11.Term, []> & T11.SparqlGeneratorRule<"varOrTerm", T11.Term, []>;
    varOrIri: import("@traqula/core").ParserRule<any, "varOrIri"> & T11.SparqlGrammarRule<"varOrIri", T11.TermIri | T11.TermVariable>;
    var: import("@traqula/core").ParserRule<any, "var"> & T11.SparqlGrammarRule<"var", T11.TermVariable, []> & T11.SparqlGeneratorRule<"var", T11.TermVariable, []>;
    graphTerm: import("@traqula/core").ParserRule<any, "graphTerm"> & T11.SparqlGrammarRule<"graphTerm", T11.GraphTerm, []> & T11.SparqlGeneratorRule<"graphTerm", T11.GraphTerm, []>;
    rdfLiteral: import("@traqula/core").ParserRule<any, "rdfLiteral"> & T11.SparqlGrammarRule<"rdfLiteral", T11.TermLiteral, []> & T11.SparqlGeneratorRule<"rdfLiteral", T11.TermLiteral, []>;
    numericLiteral: import("@traqula/core").ParserRule<any, "numericLiteral"> & T11.SparqlGrammarRule<"numericLiteral", T11.TermLiteralTyped>;
    numericLiteralUnsigned: import("@traqula/core").ParserRule<any, "numericLiteralUnsigned"> & T11.SparqlGrammarRule<"numericLiteralUnsigned", T11.TermLiteralTyped>;
    numericLiteralPositive: import("@traqula/core").ParserRule<any, "numericLiteralPositive"> & T11.SparqlGrammarRule<"numericLiteralPositive", T11.TermLiteralTyped>;
    numericLiteralNegative: import("@traqula/core").ParserRule<any, "numericLiteralNegative"> & T11.SparqlGrammarRule<"numericLiteralNegative", T11.TermLiteralTyped>;
    booleanLiteral: import("@traqula/core").ParserRule<any, "booleanLiteral"> & T11.SparqlGrammarRule<"booleanLiteral", T11.TermLiteralTyped>;
    iri: import("@traqula/core").ParserRule<any, "iri"> & T11.SparqlGrammarRule<"iri", T11.TermIri, []> & T11.SparqlGeneratorRule<"iri", T11.TermIri, []>;
    iriFull: import("@traqula/core").ParserRule<any, "iriFull"> & T11.SparqlGrammarRule<"iriFull", T11.TermIriFull, []> & T11.SparqlGeneratorRule<"iriFull", T11.TermIriFull, []>;
    prefixedName: import("@traqula/core").ParserRule<any, "prefixedName"> & T11.SparqlGrammarRule<"prefixedName", T11.TermIriPrefixed, []> & T11.SparqlGeneratorRule<"prefixedName", T11.TermIriPrefixed, []>;
    VerbA: import("@traqula/core").ParserRule<any, "VerbA"> & T11.SparqlGrammarRule<"VerbA", T11.TermIriFull>;
    pathEltOrInverse: import("@traqula/core").ParserRule<any, "pathEltOrInverse"> & T11.SparqlGrammarRule<"pathEltOrInverse", T11.Path>;
    pathSequence: import("@traqula/core").ParserRule<any, "pathSequence"> & T11.SparqlGrammarRule<"pathSequence", T11.TermIriFull | T11.TermIriPrefixed | T11.PropertyPathChain | T11.PathModified | T11.PathNegated>;
    pathAlternative: import("@traqula/core").ParserRule<any, "pathAlternative"> & T11.SparqlGrammarRule<"pathAlternative", T11.TermIriFull | T11.TermIriPrefixed | T11.PropertyPathChain | T11.PathModified | T11.PathNegated>;
    pathElt: import("@traqula/core").ParserRule<any, "pathElt"> & T11.SparqlGrammarRule<"pathElt", T11.Path>;
    pathMod: import("@traqula/core").ParserRule<any, "pathMod"> & T11.SparqlGrammarRule<"pathMod", import("chevrotain").IToken & {
        image: "*" | "+" | "?";
    }>;
    pathPrimary: import("@traqula/core").ParserRule<any, "pathPrimary"> & T11.SparqlGrammarRule<"pathPrimary", T11.Path>;
    pathNegatedPropertySet: import("@traqula/core").ParserRule<any, "pathNegatedPropertySet"> & T11.SparqlGrammarRule<"pathNegatedPropertySet", T11.PathNegated>;
    pathOneInPropertySet: import("@traqula/core").ParserRule<any, "pathOneInPropertySet"> & T11.SparqlGrammarRule<"pathOneInPropertySet", T11.TermIri | T11.PathNegatedElt>;
    groupClause: import("@traqula/core").ParserRule<any, "groupClause"> & T11.SparqlGrammarRule<"groupClause", T11.SolutionModifierGroup, []> & T11.SparqlGeneratorRule<"groupClause", T11.SolutionModifierGroup, []>;
    groupCondition: import("@traqula/core").ParserRule<any, "groupCondition"> & T11.SparqlGrammarRule<"groupCondition", T11.Expression | T11.SolutionModifierGroupBind>;
    havingClause: import("@traqula/core").ParserRule<any, "havingClause"> & T11.SparqlGrammarRule<"havingClause", T11.SolutionModifierHaving, []> & T11.SparqlGeneratorRule<"havingClause", T11.SolutionModifierHaving, []>;
    havingCondition: import("@traqula/core").ParserRule<any, "havingCondition"> & T11.SparqlGrammarRule<"havingCondition", T11.Expression>;
    orderClause: import("@traqula/core").ParserRule<any, "orderClause"> & T11.SparqlGrammarRule<"orderClause", T11.SolutionModifierOrder, []> & T11.SparqlGeneratorRule<"orderClause", T11.SolutionModifierOrder, []>;
    orderCondition: import("@traqula/core").ParserRule<any, "orderCondition"> & T11.SparqlGrammarRule<"orderCondition", T11.Ordering>;
    limitOffsetClauses: import("@traqula/core").ParserRule<any, "limitOffsetClauses"> & T11.SparqlGrammarRule<"limitOffsetClauses", T11.SolutionModifierLimitOffset, []> & T11.SparqlGeneratorRule<"limitOffsetClauses", T11.SolutionModifierLimitOffset, []>;
    limitClause: import("@traqula/core").ParserRule<any, "limitClause"> & T11.SparqlGrammarRule<"limitClause", import("@traqula/core").Wrap<number>>;
    offsetClause: import("@traqula/core").ParserRule<any, "offsetClause"> & T11.SparqlGrammarRule<"offsetClause", import("@traqula/core").Wrap<number>>;
    triplesBlock: import("@traqula/core").ParserRule<any, "triplesBlock"> & T11.SparqlGrammarRule<"triplesBlock", T11.PatternBgp, []> & T11.SparqlGeneratorRule<"triplesBlock", T11.PatternBgp, []>;
    triplesSameSubject: import("@traqula/core").ParserRule<any, "triplesSameSubject"> & T11.SparqlGrammarRule<"triplesSameSubject", T11.BasicGraphPattern>;
    triplesSameSubjectPath: import("@traqula/core").ParserRule<any, "triplesSameSubjectPath"> & T11.SparqlGrammarRule<"triplesSameSubjectPath", T11.BasicGraphPattern>;
    triplesTemplate: import("@traqula/core").ParserRule<any, "triplesTemplate"> & T11.SparqlGrammarRule<"triplesTemplate", T11.PatternBgp>;
    propertyList: import("@traqula/core").ParserRule<any, "propertyList"> & T11.SparqlGrammarRule<"propertyList", T11.TripleNesting[], [T11.GraphNode]>;
    propertyListPath: import("@traqula/core").ParserRule<any, "propertyListPath"> & T11.SparqlGrammarRule<"propertyListPath", T11.TripleNesting[], [T11.GraphNode]>;
    propertyListNotEmpty: import("@traqula/core").ParserRule<any, "propertyListNotEmpty"> & T11.SparqlGrammarRule<"propertyListNotEmpty", T11.TripleNesting[], [T11.GraphNode]>;
    propertyListPathNotEmpty: import("@traqula/core").ParserRule<any, "propertyListPathNotEmpty"> & T11.SparqlGrammarRule<"propertyListPathNotEmpty", T11.TripleNesting[], [T11.GraphNode]>;
    verbPath: import("@traqula/core").ParserRule<any, "verbPath"> & T11.SparqlGrammarRule<"verbPath", T11.Path>;
    verbSimple: import("@traqula/core").ParserRule<any, "verbSimple"> & T11.SparqlGrammarRule<"verbSimple", T11.TermVariable>;
    objectList: import("@traqula/core").ParserRule<any, "objectList"> & T11.SparqlGrammarRule<"objectList", T11.TripleNesting[], [T11.GraphNode, T11.TermIriFull | T11.TermIriPrefixed | T11.TermVariable | T11.PropertyPathChain | T11.PathModified | T11.PathNegated]>;
    objectListPath: import("@traqula/core").ParserRule<any, "objectListPath"> & T11.SparqlGrammarRule<"objectListPath", T11.TripleNesting[], [T11.GraphNode, T11.TermIriFull | T11.TermIriPrefixed | T11.TermVariable | T11.PropertyPathChain | T11.PathModified | T11.PathNegated]>;
    objectPath: import("@traqula/core").ParserRule<any, "objectPath"> & T11.SparqlGrammarRule<"objectPath", T11.TripleNesting, [T11.GraphNode, T11.TermIriFull | T11.TermIriPrefixed | T11.TermVariable | T11.PropertyPathChain | T11.PathModified | T11.PathNegated]>;
    collection: import("@traqula/core").ParserRule<any, "collection"> & T11.SparqlGrammarRule<"collection", T11.TripleCollectionList, []> & T11.SparqlGeneratorRule<"collection", T11.TripleCollectionList, []>;
    collectionPath: import("@traqula/core").ParserRule<any, "collectionPath"> & T11.SparqlGrammarRule<"collectionPath", T11.TripleCollectionList, []> & T11.SparqlGeneratorRule<"collectionPath", T11.TripleCollectionList, []>;
    triplesNode: import("@traqula/core").ParserRule<any, "triplesNode"> & T11.SparqlGrammarRule<"triplesNode", T11.TripleCollection, []> & T11.SparqlGeneratorRule<"triplesNode", T11.TripleCollection, []>;
    triplesNodePath: import("@traqula/core").ParserRule<any, "triplesNodePath"> & T11.SparqlGrammarRule<"triplesNodePath", T11.TripleCollection, []> & T11.SparqlGeneratorRule<"triplesNodePath", T11.TripleCollection, []>;
    blankNodePropertyList: import("@traqula/core").ParserRule<any, "blankNodePropertyList"> & T11.SparqlGrammarRule<"blankNodePropertyList", T11.TripleCollectionBlankNodeProperties, []> & T11.SparqlGeneratorRule<"blankNodePropertyList", T11.TripleCollectionBlankNodeProperties, []>;
    blankNodePropertyListPath: import("@traqula/core").ParserRule<any, "blankNodePropertyListPath"> & T11.SparqlGrammarRule<"blankNodePropertyListPath", T11.TripleCollectionBlankNodeProperties, []> & T11.SparqlGeneratorRule<"blankNodePropertyListPath", T11.TripleCollectionBlankNodeProperties, []>;
    graphNode: import("@traqula/core").ParserRule<any, "graphNode"> & T11.SparqlGrammarRule<"graphNode", T11.TripleCollection | T11.Term, []> & T11.SparqlGeneratorRule<"graphNode", T11.TripleCollection | T11.Term, []>;
    graphNodePath: import("@traqula/core").ParserRule<any, "graphNodePath"> & T11.SparqlGrammarRule<"graphNodePath", T11.TripleCollection | T11.Term, []> & T11.SparqlGeneratorRule<"graphNodePath", T11.TripleCollection | T11.Term, []>;
    whereClause: import("@traqula/core").ParserRule<any, "whereClause"> & T11.SparqlGrammarRule<"whereClause", import("@traqula/core").Wrap<T11.PatternGroup>, []> & T11.SparqlGeneratorRule<"whereClause", import("@traqula/core").Wrap<T11.PatternGroup>, []>;
    groupGraphPattern: import("@traqula/core").ParserRule<any, "groupGraphPattern"> & T11.SparqlGrammarRule<"groupGraphPattern", T11.PatternGroup, []> & T11.SparqlGeneratorRule<"groupGraphPattern", T11.PatternGroup, []>;
    groupGraphPatternSub: import("@traqula/core").ParserRule<any, "groupGraphPatternSub"> & T11.SparqlGrammarRule<"groupGraphPatternSub", T11.Pattern[]>;
    graphPatternNotTriples: import("@traqula/core").ParserRule<any, "graphPatternNotTriples"> & T11.SparqlGrammarRule<"graphPatternNotTriples", T11.PatternGroup | T11.PatternUnion | T11.PatternOptional | T11.PatternMinus | T11.PatternGraph | T11.PatternService | T11.PatternFilter | T11.PatternBind | T11.PatternValues, []> & T11.SparqlGeneratorRule<"graphPatternNotTriples", T11.PatternGroup | T11.PatternUnion | T11.PatternOptional | T11.PatternMinus | T11.PatternGraph | T11.PatternService | T11.PatternFilter | T11.PatternBind | T11.PatternValues, []>;
    optionalGraphPattern: import("@traqula/core").ParserRule<any, "optionalGraphPattern"> & T11.SparqlGrammarRule<"optionalGraphPattern", T11.PatternOptional, []> & T11.SparqlGeneratorRule<"optionalGraphPattern", T11.PatternOptional, []>;
    graphGraphPattern: import("@traqula/core").ParserRule<any, "graphGraphPattern"> & T11.SparqlGrammarRule<"graphGraphPattern", T11.PatternGraph, []> & T11.SparqlGeneratorRule<"graphGraphPattern", T11.PatternGraph, []>;
    serviceGraphPattern: import("@traqula/core").ParserRule<any, "serviceGraphPattern"> & T11.SparqlGrammarRule<"serviceGraphPattern", T11.PatternService, []> & T11.SparqlGeneratorRule<"serviceGraphPattern", T11.PatternService, []>;
    inlineData: import("@traqula/core").ParserRule<any, "inlineData"> & T11.SparqlGrammarRule<"inlineData", T11.PatternValues, []> & T11.SparqlGeneratorRule<"inlineData", T11.PatternValues, []>;
    dataBlock: import("@traqula/core").ParserRule<any, "dataBlock"> & T11.SparqlGrammarRule<"dataBlock", T11.PatternValues>;
    inlineDataOneVar: import("@traqula/core").ParserRule<any, "inlineDataOneVar"> & T11.SparqlGrammarRule<"inlineDataOneVar", T11.PatternValues>;
    inlineDataFull: import("@traqula/core").ParserRule<any, "inlineDataFull"> & T11.SparqlGrammarRule<"inlineDataFull", T11.PatternValues>;
    dataBlockValue: import("@traqula/core").ParserRule<any, "dataBlockValue"> & T11.SparqlGrammarRule<"dataBlockValue", T11.TermIri | T11.TermLiteral | undefined>;
    minusGraphPattern: import("@traqula/core").ParserRule<any, "minusGraphPattern"> & T11.SparqlGrammarRule<"minusGraphPattern", T11.PatternMinus, []> & T11.SparqlGeneratorRule<"minusGraphPattern", T11.PatternMinus, []>;
    groupOrUnionGraphPattern: import("@traqula/core").ParserRule<any, "groupOrUnionGraphPattern"> & T11.SparqlGrammarRule<"groupOrUnionGraphPattern", T11.PatternGroup | T11.PatternUnion, []> & T11.SparqlGeneratorRule<"groupOrUnionGraphPattern", T11.PatternGroup | T11.PatternUnion, []>;
    constraint: import("@traqula/core").ParserRule<any, "constraint"> & T11.SparqlGrammarRule<"constraint", T11.Expression>;
    queryOrUpdate: import("@traqula/core").ParserRule<T11.SparqlContext, "queryOrUpdate", T11.SparqlQuery, []>;
}>;
export type SparqlParser = ReturnType<typeof sparql11ParserBuilder.build>;
/**
 * Generator that can generate a SPARQL 1.1 AST given a SPARQL 1.1 string.
 */
export declare class Parser extends MinimalSparqlParser<T11.SparqlQuery> {
    constructor(args?: Pick<ParserBuildArgs, 'parserConfig' | 'lexerConfig'> & {
        defaultContext?: Partial<T11.SparqlContext>;
    });
}
