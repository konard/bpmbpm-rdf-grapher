{"version":3,"file":"Parser.js","sourceRoot":"","sources":["../../../lib/Parser.ts"],"names":[],"mappings":";;;AACA,wCAA8C;AAE9C,gEAAuG;AACvG,6DAA8D;AAC9D,+DAA4D;AAE/C,QAAA,qBAAqB,GAAG,oBAAa,CAAC,MAAM,CAAC,2CAAsB,CAAC;KAC9E,KAAK,CAAC,yCAAmB,EAAU,EAAE,CAAC;KACtC,OAAO,CAAC,uBAAI,CAAC,aAAa,CAAC,CAAC;AAI/B;;GAEG;AACH,MAAa,MAAO,SAAQ,sCAAoC;IAC9D,YACE,OAAgH,EAAE;QAElH,MAAM,MAAM,GAAiB,6BAAqB,CAAC,KAAK,CAAC;YACvD,GAAG,IAAI;YACP,eAAe,EAAE,sBAAC,CAAC,oBAAoB,CAAC,eAAe;YACvD,iBAAiB,EAAE,wCAAqB;SACzC,CAAC,CAAC;QACH,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;IACrC,CAAC;CACF;AAXD,wBAWC","sourcesContent":["import type { ParserBuildArgs } from '@traqula/core';\nimport { ParserBuilder } from '@traqula/core';\nimport type * as T11 from '@traqula/rules-sparql-1-1';\nimport { gram, lex as l, MinimalSparqlParser, sparqlCodepointEscape } from '@traqula/rules-sparql-1-1';\nimport { queryUnitParserBuilder } from './queryUnitParser.js';\nimport { updateParserBuilder } from './updateUnitParser.js';\n\nexport const sparql11ParserBuilder = ParserBuilder.create(queryUnitParserBuilder)\n  .merge(updateParserBuilder, <const> [])\n  .addRule(gram.queryOrUpdate);\n\nexport type SparqlParser = ReturnType<typeof sparql11ParserBuilder.build>;\n\n/**\n * Generator that can generate a SPARQL 1.1 AST given a SPARQL 1.1 string.\n */\nexport class Parser extends MinimalSparqlParser<T11.SparqlQuery> {\n  public constructor(\n    args: Pick<ParserBuildArgs, 'parserConfig' | 'lexerConfig'> & { defaultContext?: Partial<T11.SparqlContext> } = {},\n  ) {\n    const parser: SparqlParser = sparql11ParserBuilder.build({\n      ...args,\n      tokenVocabulary: l.sparql11LexerBuilder.tokenVocabulary,\n      queryPreProcessor: sparqlCodepointEscape,\n    });\n    super(parser, args.defaultContext);\n  }\n}\n"]}