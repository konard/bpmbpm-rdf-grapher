"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgebraFactory = void 0;
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_string_1 = require("rdf-string");
const A = __importStar(require("./algebra.js"));
function known(x) {
    return x;
}
class AlgebraFactory {
    dataFactory;
    stringType;
    constructor(dataFactory) {
        this.dataFactory = dataFactory ?? new rdf_data_factory_1.DataFactory();
        this.stringType = this.createTerm('http://www.w3.org/2001/XMLSchema#string');
    }
    createAlt(input, flatten = true) {
        return this.flattenMulti({
            type: A.Types.ALT,
            input: input,
        }, flatten);
    }
    createAsk(input) {
        return { type: A.Types.ASK, input: known(input) };
    }
    createBoundAggregate(variable, aggregate, expression, distinct, separator) {
        const result = this.createAggregateExpression(aggregate, known(expression), distinct, separator);
        result.variable = variable;
        return result;
    }
    createBgp(patterns) {
        return { type: A.Types.BGP, patterns };
    }
    createConstruct(input, template) {
        return { type: A.Types.CONSTRUCT, input: known(input), template };
    }
    createDescribe(input, terms) {
        return { type: A.Types.DESCRIBE, input: known(input), terms };
    }
    createDistinct(input) {
        return { type: A.Types.DISTINCT, input: known(input) };
    }
    createExtend(input, variable, expression) {
        return { type: A.Types.EXTEND, input: known(input), variable, expression: known(expression) };
    }
    createFrom(input, def, named) {
        return { type: A.Types.FROM, input: known(input), default: def, named };
    }
    createFilter(input, expression) {
        return { type: A.Types.FILTER, input: known(input), expression: known(expression) };
    }
    createGraph(input, name) {
        return { type: A.Types.GRAPH, input: known(input), name };
    }
    createGroup(input, variables, aggregates) {
        return { type: A.Types.GROUP, input: known(input), variables, aggregates: known(aggregates) };
    }
    createInv(path) {
        return { type: A.Types.INV, path: path };
    }
    createJoin(input, flatten = true) {
        return this.flattenMulti({ type: A.Types.JOIN, input: known(input) }, flatten);
    }
    createLeftJoin(left, right, expression) {
        if (expression) {
            return {
                type: A.Types.LEFT_JOIN,
                input: [known(left), known(right)],
                expression: known(expression),
            };
        }
        return { type: A.Types.LEFT_JOIN, input: [known(left), known(right)] };
    }
    createLink(iri) {
        return { type: A.Types.LINK, iri };
    }
    createMinus(left, right) {
        return { type: A.Types.MINUS, input: [known(left), known(right)] };
    }
    createNop() {
        return { type: A.Types.NOP };
    }
    createNps(iris) {
        return { type: A.Types.NPS, iris };
    }
    createOneOrMorePath(path) {
        return { type: A.Types.ONE_OR_MORE_PATH, path: path };
    }
    createOrderBy(input, expressions) {
        return { type: A.Types.ORDER_BY, input: known(input), expressions: known(expressions) };
    }
    createPath(subject, predicate, object, graph) {
        if (graph) {
            return { type: A.Types.PATH, subject, predicate: predicate, object, graph };
        }
        return {
            type: A.Types.PATH,
            subject,
            predicate: predicate,
            object,
            graph: this.dataFactory.defaultGraph(),
        };
    }
    createPattern(subject, predicate, object, graph) {
        const pattern = this.dataFactory.quad(subject, predicate, object, graph);
        pattern.type = A.Types.PATTERN;
        return pattern;
    }
    createProject(input, variables) {
        return { type: A.Types.PROJECT, input: known(input), variables };
    }
    createReduced(input) {
        return { type: A.Types.REDUCED, input: known(input) };
    }
    createSeq(input, flatten = true) {
        return this.flattenMulti({
            type: A.Types.SEQ,
            input: input,
        }, flatten);
    }
    createService(input, name, silent) {
        return { type: A.Types.SERVICE, input: known(input), name, silent: Boolean(silent) };
    }
    createSlice(input, start, length) {
        start = start || 0;
        if (length !== undefined) {
            return { type: A.Types.SLICE, input: known(input), start, length };
        }
        return { type: A.Types.SLICE, input: known(input), start };
    }
    createUnion(input, flatten = true) {
        return this.flattenMulti({ type: A.Types.UNION, input: known(input) }, flatten);
    }
    createValues(variables, bindings) {
        return { type: A.Types.VALUES, variables, bindings };
    }
    createZeroOrMorePath(path) {
        return {
            type: A.Types.ZERO_OR_MORE_PATH,
            path: path,
        };
    }
    createZeroOrOnePath(path) {
        return {
            type: A.Types.ZERO_OR_ONE_PATH,
            path: path,
        };
    }
    createAggregateExpression(aggregator, expression, distinct, separator) {
        if (separator !== undefined) {
            return {
                type: A.Types.EXPRESSION,
                subType: A.ExpressionTypes.AGGREGATE,
                aggregator: aggregator,
                expression: known(expression),
                separator,
                distinct,
            };
        }
        return {
            type: A.Types.EXPRESSION,
            subType: A.ExpressionTypes.AGGREGATE,
            aggregator: aggregator,
            expression: known(expression),
            distinct,
        };
    }
    createExistenceExpression(not, input) {
        return { type: A.Types.EXPRESSION, subType: A.ExpressionTypes.EXISTENCE, not, input: known(input) };
    }
    createNamedExpression(name, args) {
        return { type: A.Types.EXPRESSION, subType: A.ExpressionTypes.NAMED, name, args: known(args) };
    }
    createOperatorExpression(operator, args) {
        return { type: A.Types.EXPRESSION, subType: A.ExpressionTypes.OPERATOR, operator, args: known(args) };
    }
    createTermExpression(term) {
        return { type: A.Types.EXPRESSION, subType: A.ExpressionTypes.TERM, term };
    }
    createWildcardExpression() {
        return { type: A.Types.EXPRESSION, subType: A.ExpressionTypes.WILDCARD, wildcard: { type: 'wildcard' } };
    }
    createTerm(str) {
        if (str.startsWith('$')) {
            str = str.replace('$', '?');
        }
        return (0, rdf_string_1.stringToTerm)(str, this.dataFactory);
    }
    // Update functions
    createCompositeUpdate(updates) {
        return { type: A.Types.COMPOSITE_UPDATE, updates: updates };
    }
    createDeleteInsert(deleteQuads, insertQuads, where) {
        const result = { type: A.Types.DELETE_INSERT };
        if (deleteQuads) {
            result.delete = deleteQuads;
        }
        if (insertQuads) {
            result.insert = insertQuads;
        }
        if (where) {
            result.where = known(where);
        }
        return result;
    }
    createLoad(source, destination, silent) {
        const result = { type: A.Types.LOAD, source };
        if (destination) {
            result.destination = destination;
        }
        return this.addSilent(result, Boolean(silent));
    }
    createClear(source, silent) {
        return this.addSilent({ type: A.Types.CLEAR, source }, Boolean(silent));
    }
    createCreate(source, silent) {
        return this.addSilent({ type: A.Types.CREATE, source }, Boolean(silent));
    }
    createDrop(source, silent) {
        return this.addSilent({ type: A.Types.DROP, source }, Boolean(silent));
    }
    createAdd(source, destination, silent) {
        return this.addSilent({
            type: A.Types.ADD,
            source,
            destination,
        }, Boolean(silent));
    }
    createMove(source, destination, silent) {
        return this.addSilent({
            type: A.Types.MOVE,
            source,
            destination,
        }, Boolean(silent));
    }
    createCopy(source, destination, silent) {
        return this.addSilent({
            type: A.Types.COPY,
            source,
            destination,
        }, Boolean(silent));
    }
    addSilent(input, silent) {
        if (silent) {
            input.silent = silent;
        }
        return input;
    }
    flattenMulti(input, flatten) {
        if (!flatten) {
            return input;
        }
        const type = input.type;
        const subType = input.subType;
        const children = input.input;
        const newChildren = [];
        for (const child of children) {
            if (child.type === type && (!subType || subType === child.subType)) {
                newChildren.push(...child.input);
            }
            else {
                newChildren.push(child);
            }
        }
        input.input = newChildren;
        return input;
    }
}
exports.AlgebraFactory = AlgebraFactory;
//# sourceMappingURL=algebraFactory.js.map