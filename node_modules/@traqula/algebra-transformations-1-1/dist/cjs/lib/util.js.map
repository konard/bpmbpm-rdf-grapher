{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../lib/util.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { TransformContext, VisitContext } from '@traqula/core';\nimport { TransformerSubTyped } from '@traqula/core';\nimport type * as A from './algebra.js';\nimport { ExpressionTypes, Types } from './algebra.js';\n\nconst transformer = new TransformerSubTyped<A.Operation>({}, {\n  // Optimization that causes search tree pruning\n  [Types.PATTERN]: { ignoreKeys: new Set([ 'subject', 'predicate', 'object', 'graph' ]) } satisfies TransformContext,\n  [Types.EXPRESSION]: { ignoreKeys: new Set([ 'name', 'term', 'wildcard', 'variable' ]) } satisfies VisitContext,\n  [Types.DESCRIBE]: { ignoreKeys: new Set([ 'terms' ]) },\n  [Types.EXTEND]: { ignoreKeys: new Set([ 'variable' ]) },\n  [Types.FROM]: { ignoreKeys: new Set([ 'default', 'named' ]) },\n  [Types.GRAPH]: { ignoreKeys: new Set([ 'name' ]) },\n  [Types.GROUP]: { ignoreKeys: new Set([ 'variables' ]) },\n  [Types.LINK]: { ignoreKeys: new Set([ 'iri' ]) },\n  [Types.NPS]: { ignoreKeys: new Set([ 'iris' ]) },\n  [Types.PATH]: { ignoreKeys: new Set([ 'subject', 'object', 'graph' ]) },\n  [Types.PROJECT]: { ignoreKeys: new Set([ 'variables' ]) },\n  [Types.SERVICE]: { ignoreKeys: new Set([ 'name' ]) },\n  [Types.VALUES]: { ignoreKeys: new Set([ 'variables', 'bindings' ]) },\n  [Types.LOAD]: { ignoreKeys: new Set([ 'source', 'destination' ]) },\n  [Types.CLEAR]: { ignoreKeys: new Set([ 'source' ]) },\n  [Types.CREATE]: { ignoreKeys: new Set([ 'source' ]) },\n  [Types.DROP]: { ignoreKeys: new Set([ 'source' ]) },\n  [Types.ADD]: { ignoreKeys: new Set([ 'source', 'destination' ]) },\n  [Types.MOVE]: { ignoreKeys: new Set([ 'source', 'destination' ]) },\n  [Types.COPY]: { ignoreKeys: new Set([ 'source', 'destination' ]) },\n});\n\n/**\n * Transform a single operation.\n * e.g. wrapping a distinct around the outermost project:\n * ```ts\n * mapOperation({\n *   type: Algebra.Types.SLICE,\n *   input: {\n *     type: Algebra.Types.PROJECT,\n *     input: {\n *       type: Algebra.Types.JOIN,\n *       input: [{ type: Algebra.Types.PROJECT }, { type: Algebra.Types.BGP }],\n *     },\n *   },\n * }, {\n *   [Algebra.Types.PROJECT]: {\n *     preVisitor: () => ({ continue: false }),\n *     transform: projection => algebraFactory.createDistinct(projection),\n *   },\n * });\n * const returns = {\n *   type: Algebra.Types.SLICE,\n *   input: {\n *     type: Algebra.Types.DISTINCT,\n *     input: {\n *       type: Algebra.Types.PROJECT,\n *       input: {\n *         type: Algebra.Types.JOIN,\n *         input: [{ type: Algebra.Types.PROJECT }, { type: Algebra.Types.BGP }],\n *       },\n *     },\n *   },\n * };\n * ```\n * @param startObject the object from which we will start the transformation,\n *   potentially visiting and transforming its descendants along the way.\n * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally\n *    containing preVisitor and transformer.\n *    The preVisitor allows you to provide {@link TransformContext} for the current object,\n *    altering how it will be transformed.\n *    The transformer allows you to manipulate the copy of the current object,\n *    and expects you to return the value that should take the current objects place.\n * @return the result of transforming the requested descendant operations (based on the preVisitor)\n * using a transformer that works its way back up from the descendant to the startObject.\n */\nexport const mapOperation = transformer.transformNode.bind(transformer);\n\n/**\n * Transform a single operation, similar to {@link mapOperation}, but also allowing you to target subTypes.\n * e.g. wrapping a distinct around the all project operations not contained in an aggregate expression\n * (invalid algebra anyway):\n * ```ts\n * mapOperationSub({\n *   type: Algebra.Types.SLICE,\n *   input: {\n *     type: Algebra.Types.PROJECT,\n *     input: {\n *       type: Algebra.Types.JOIN,\n *       input: [{\n *         type: Algebra.Types.EXPRESSION,\n *         subType: Algebra.ExpressionTypes.AGGREGATE,\n *         input: { type: Algebra.Types.PROJECT },\n *       }, { type: Algebra.Types.BGP }],\n *     },\n *   },\n * }, { [Algebra.Types.PROJECT]: {\n *   transform: projection => algebraFactory.createDistinct(projection),\n * }}, { [Algebra.Types.EXPRESSION]: { [Algebra.ExpressionTypes.AGGREGATE]: {\n *   preVisitor: () => ({ continue: false }),\n * }}});\n * const returns = {\n *   type: Algebra.Types.SLICE,\n *   input: {\n *     type: Algebra.Types.DISTINCT,\n *     input: {\n *       type: Algebra.Types.PROJECT,\n *       input: {\n *         type: Algebra.Types.JOIN,\n *         input: [{\n *           type: Algebra.Types.EXPRESSION,\n *           subType: Algebra.ExpressionTypes.AGGREGATE,\n *           input: { type: Algebra.Types.PROJECT },\n *         }, { type: Algebra.Types.BGP }],\n *       },\n *     },\n *   },\n * };\n * ```\n * @param startObject the object from which we will start the transformation,\n *   potentially visiting and transforming its descendants along the way.\n * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally\n *    containing preVisitor and transformer.\n *    The preVisitor allows you to provide {@link TransformContext} for the current object,\n *    altering how it will be transformed.\n *    The transformer allows you to manipulate the copy of the current object,\n *    and expects you to return the value that should take the current objects place.\n * @param nodeSpecificCallBacks Same as nodeCallBacks but using an additional level of indirection to\n *     indicate the subType.\n * @return the result of transforming the requested descendant operations (based on the preVisitor)\n * using a transformer that works its way back up from the descendant to the startObject.\n */\nexport const mapOperationSub = transformer.transformNodeSpecific.bind(transformer);\n\n/**\n * Similar to {@link mapOperation}, but only visiting instead of copying and transforming explicitly.\n * e.g.:\n * ```ts\n * visitOperation({\n *   type: Algebra.Types.DISTINCT,\n *   input: {\n *     type: Algebra.Types.PROJECT,\n *     input: { type: Algebra.Types.DISTINCT },\n *   },\n * }, {\n *   [Algebra.Types.DISTINCT]: { visitor: () => console.log('1') },\n *   [Algebra.Types.PROJECT]: {\n *     preVisitor: () => ({ continue: false }),\n *     visitor: () => console.log('2'),\n *   },\n * });\n * ```\n * Will first call the preVisitor on the project and notice it should not iterate on its descendants.\n * It then visits the project, and the outermost distinct, printing '21'.\n * The pre-visitor visits starting from the root, going deeper, while the actual visitor goes in reverse.\n * @param startObject the object from which we will start visiting,\n *   potentially visiting its descendants along the way.\n * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally\n *    containing preVisitor and visitor.\n *    The preVisitor allows you to provide {@link VisitContext} for the current object,\n *    altering how it will be visited.\n *    The visitor allows you to visit the object from deepest to the outermost object.\n *    This is useful if you for example want to manipulate the objects you visit during your visits,\n *    similar to {@link mapOperation}.\n */\nexport const visitOperation = transformer.visitNode.bind(transformer);\n\n/**\n * Visits an object and it's descendants, similar to {@link visitOperation},\n * but also allowing you to target subTypes. e.g.:\n * e.g.:\n * ```ts\n * visitOperationSub({\n *   type: Algebra.Types.DISTINCT,\n *   input: {\n *     type: Algebra.Types.DISTINCT,\n *     subType: 'special',\n *   },\n * }, {\n *   [Algebra.Types.DISTINCT]: {\n *     visitor: () => console.log('1'),\n *     preVisitor: () => {\n *       console.log('2');\n *       return {};\n *     },\n *   },\n * }, {\n *   [Algebra.Types.DISTINCT]: { special: {\n *     visitor: () => console.log('3'),\n *   }},\n * });\n * ```\n * Will call the preVisitor on the outer distinct, then the visitor of the special distinct,\n * followed by the visiting the outer distinct, printing '231'.\n * The pre-visitor visits starting from the root, going deeper, while the actual visitor goes in reverse.\n * @param startObject the object from which we will start visiting,\n *   potentially visiting its descendants along the way.\n * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally\n *    containing preVisitor and visitor.\n *    The preVisitor allows you to provide {@link VisitContext} for the current object,\n *    altering how it will be visited.\n *    The visitor allows you to visit the object from deepest to the outermost object.\n *    This is useful if you for example want to manipulate the objects you visit during your visits,\n *    similar to {@link mapOperation}.\n * @param nodeSpecificCallBacks Same as nodeCallBacks but using an additional level of indirection to\n *     indicate the subType.\n */\nexport const visitOperationSub = transformer.visitNodeSpecific.bind(transformer);\n\n/**\n * Resolves an IRI against a base path in accordance to the [Syntax for IRIs](https://www.w3.org/TR/sparql11-query/#QSynIRI)\n */\nexport function resolveIRI(iri: string, base: string | undefined): string {\n  // Return absolute IRIs unmodified\n  if (/^[a-z][\\d+.a-z-]*:/iu.test(iri)) {\n    return iri;\n  }\n  if (!base) {\n    throw new Error(`Cannot resolve relative IRI ${iri} because no base IRI was set.`);\n  }\n  switch (iri[0]) {\n    // An empty relative IRI indicates the base IRI\n    case undefined:\n      return base;\n      // Resolve relative fragment IRIs against the base IRI\n    case '#':\n      return base + iri;\n      // Resolve relative query string IRIs by replacing the query string\n    case '?':\n      return base.replace(/(?:\\?.*)?$/u, iri);\n      // Resolve root relative IRIs at the root of the base IRI\n    case '/': {\n      const baseMatch = /^(?:[a-z]+:\\/*)?[^/]*/u.exec(base);\n      if (!baseMatch) {\n        throw new Error(`Could not determine relative IRI using base: ${base}`);\n      }\n      const baseRoot = baseMatch[0];\n      return baseRoot + iri;\n    }\n    // Resolve all other IRIs at the base IRI's path\n    default: {\n      // Const lastSemi = base.lastIndexOf(':');\n      // const lastSlash = base.lastIndexOf('/');\n      // let basePath;\n      // if (lastSlash === -1 && lastSemi === -1) {\n      //   basePath = '';\n      // } else if (lastSlash > lastSemi) {\n      //   basePath = base.slice(0, lastSlash);\n      // } else {\n      //   basePath = base.slice(0, lastSemi);\n      // }\n      const basePath = base.replace(/[^/:]*$/u, '');\n      return basePath + iri;\n    }\n  }\n}\n\n/**\n * Outputs a JSON object corresponding to the input algebra-like.\n */\nexport function objectify(algebra: any): any {\n  if (algebra.termType) {\n    if (algebra.termType === 'Quad') {\n      return {\n        type: 'pattern',\n        termType: 'Quad',\n        subject: objectify(algebra.subject),\n        predicate: objectify(algebra.predicate),\n        object: objectify(algebra.object),\n        graph: objectify(algebra.graph),\n      };\n    }\n    const result: any = { termType: algebra.termType, value: algebra.value };\n    if (algebra.language) {\n      result.language = algebra.language;\n    }\n    if (algebra.datatype) {\n      result.datatype = objectify(algebra.datatype);\n    }\n    return result;\n  }\n  if (Array.isArray(algebra)) {\n    return algebra.map(e => objectify(e));\n  }\n  if (algebra === Object(algebra)) {\n    const result: any = {};\n    for (const key of Object.keys(algebra)) {\n      result[key] = objectify(algebra[key]);\n    }\n    return result;\n  }\n  return algebra;\n}\n\n/**\n * Detects all in-scope variables.\n * In practice this means iterating through the entire algebra tree, finding all variables,\n * and stopping when a project function is found.\n * @param {Operation} op - Input algebra tree.\n * @param visitor the visitor to be used to traverse the various nodes.\n * Allows you to provide a visitor with different default preVisitor cotexts.\n * @returns {RDF.Variable[]} - List of unique in-scope variables.\n */\nexport function inScopeVariables(\n  op: A.BaseOperation,\n  visitor: typeof visitOperation = visitOperation,\n): RDF.Variable[] {\n  const variables: Record<string, RDF.Variable> = {};\n\n  function addVariable(v: RDF.Variable): void {\n    variables[v.value] = v;\n  }\n\n  function recurseTerm(quad: RDF.BaseQuad): void {\n    // Subject\n    if (quad.subject.termType === 'Variable') {\n      addVariable(quad.subject);\n    } else if (quad.subject.termType === 'Quad') {\n      recurseTerm(quad.subject);\n    }\n    // Predicate\n    if (quad.predicate.termType === 'Variable') {\n      addVariable(quad.predicate);\n    } else if (quad.predicate.termType === 'Quad') {\n      recurseTerm(quad.predicate);\n    }\n    // Object\n    if (quad.object.termType === 'Variable') {\n      addVariable(quad.object);\n    } else if (quad.object.termType === 'Quad') {\n      recurseTerm(quad.object);\n    }\n\n    // Graph\n    if (quad.graph.termType === 'Variable') {\n      addVariable(quad.graph);\n    }\n    if (quad.graph.termType === 'Quad') {\n      recurseTerm(quad.graph);\n    }\n  }\n\n  function visitingRecursion(curOp: A.BaseOperation): void {\n    // https://www.w3.org/TR/sparql11-query/#variableScope\n    visitor(curOp, {\n      [Types.EXPRESSION]: { visitor: (op: A.Expression & { variable?: RDF.Variable }) => {\n        if (op.subType === ExpressionTypes.AGGREGATE && (op).variable) {\n          addVariable((op).variable);\n        }\n      } },\n      [Types.EXTEND]: { visitor: op =>\n        addVariable(op.variable),\n      },\n      [Types.GRAPH]: { visitor: (op) => {\n        if (op.name.termType === 'Variable') {\n          addVariable(op.name);\n        }\n      } },\n      [Types.GROUP]: { visitor: (op) => {\n        for (const v of op.variables) {\n          addVariable(v);\n        }\n      } },\n      [Types.PATH]: { visitor: (op) => {\n        // Subject\n        if (op.subject.termType === 'Variable') {\n          addVariable(op.subject);\n        } else if (op.subject.termType === 'Quad') {\n          recurseTerm(op.subject);\n        }\n        // Predicate\n        if (op.object.termType === 'Variable') {\n          addVariable(op.object);\n        } else if (op.object.termType === 'Quad') {\n          recurseTerm(op.object);\n        }\n        // Object\n        if (op.graph.termType === 'Variable') {\n          addVariable(op.graph);\n        } else if (op.graph.termType === 'Quad') {\n          recurseTerm(op.graph);\n        }\n      } },\n      [Types.PATTERN]: { visitor: op => recurseTerm(op) },\n      [Types.PROJECT]: {\n        preVisitor: () => ({ continue: false }),\n        visitor: (op) => {\n          for (const v of op.variables) {\n            addVariable(v);\n          }\n        },\n      },\n      [Types.SERVICE]: { visitor: (op) => {\n        if (op.name.termType === 'Variable') {\n          addVariable(op.name);\n        }\n      } },\n      [Types.VALUES]: { visitor: (op) => {\n        for (const v of op.variables) {\n          addVariable(v);\n        }\n      } },\n      [Types.MINUS]: {\n        preVisitor: () => ({ continue: false }),\n        visitor: (op) => {\n          // Cannot fully visit, only the left hand side is scoped\n          visitingRecursion(op.input[0]);\n        },\n      },\n    });\n  }\n  visitingRecursion(op);\n\n  return Object.values(variables);\n}\n"]}