{"version":3,"file":"quads.js","sourceRoot":"","sources":["../../../../lib/toAst/quads.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra } from '../index.js';\nimport { types } from '../toAlgebra/index.js';\nimport type { AstIndir } from './core.js';\n\n/**\n * Removes quad component of triple and ...\n */\nexport const removeAlgQuads: AstIndir<'removeQuads', Algebra.Operation, [Algebra.Operation]> = {\n  name: 'removeQuads',\n  fun: ({ SUBRULE }) => (_, op) =>\n    <typeof op>SUBRULE(removeAlgQuadsRecursive, op, []),\n};\n\n/**\n * Removes quad component of triples and wrap found bgps in Algebra.GraphOperations\n * Mainly returns same type as first arg\n */\nexport const removeAlgQuadsRecursive: AstIndir<\n  'removeQuadsRecursive',\nunknown,\n[unknown, (RDF.NamedNode | RDF.DefaultGraph)[]]\n> = {\n  name: 'removeQuadsRecursive',\n  fun: ({ SUBRULE }) => ({ algebraFactory: AF }, unknownVal, graphs) => {\n    if (Array.isArray(unknownVal)) {\n      return unknownVal.map(sub => SUBRULE(removeAlgQuadsRecursive, sub, graphs));\n    }\n\n    if (typeof unknownVal !== 'object' || unknownVal === null || !('type' in unknownVal) || !unknownVal.type) {\n      return unknownVal;\n    }\n    const knownOp = <Algebra.Operation> unknownVal;\n\n    // UPDATE operations with Patterns handle graphs a bit differently - do not traverse\n    if (knownOp.type === types.DELETE_INSERT) {\n      return unknownVal;\n    }\n\n    // If triple or path register graph and return - graphs will be populated by in order graph occurrence\n    if ((knownOp.type === types.PATTERN || knownOp.type === types.PATH) && knownOp.graph) {\n      const graph = <RDF.NamedNode | RDF.DefaultGraph> knownOp.graph;\n      // We create a list that tracks, for each pattern the original graph and remove the graph\n      graphs.push(graph);\n      // Remove non-default graphs\n      if (graph.value !== '') {\n        return knownOp.type === types.PATTERN ?\n          AF.createPattern(knownOp.subject, knownOp.predicate, knownOp.object) :\n          AF.createPath(knownOp.subject, knownOp.predicate, knownOp.object);\n      }\n      return knownOp;\n    }\n\n    // We build our `op` again.\n    const result: any = {};\n    // Unique graphs per key (keyof T)\n    const keyGraphs: Record<string, (RDF.NamedNode | RDF.DefaultGraph)[]> = {};\n    // Track all the unique graph names for the entire Operation\n    const operationGraphNames: Record<string, RDF.NamedNode | RDF.DefaultGraph> = {};\n    for (const [ key, value ] of Object.entries(knownOp)) {\n      const newGraphs: (RDF.NamedNode | RDF.DefaultGraph)[] = [];\n      result[key] = SUBRULE(removeAlgQuadsRecursive, value, newGraphs);\n\n      // If a graph was registered, we register the discovery we did at this key of the object\n      //  and create graph identifier map\n      if (newGraphs.length > 0) {\n        keyGraphs[key] = newGraphs;\n        for (const graph of newGraphs) {\n          operationGraphNames[graph.value] = graph;\n        }\n      }\n    }\n\n    const graphNameSet = Object.keys(operationGraphNames);\n    // Finally, if we found graphs at some keys, wrap those keys in Algebra.graphOperations\n    if (graphNameSet.length > 0) {\n      // We also need to create graph statement if we are at the edge of certain operations\n      if (graphNameSet.length === 1 && ![ types.PROJECT, types.SERVICE ].includes(knownOp.type)) {\n        graphs.push(operationGraphNames[graphNameSet[0]]);\n      } else if (knownOp.type === types.BGP) {\n        // This is the specific case that `op` got changed because of using quads. -\n        return SUBRULE(splitAlgBgpToGraphs, knownOp, keyGraphs.patterns);\n      } else {\n        // Multiple graphs (or project), need to create graph objects for them\n        for (const key of Object.keys(keyGraphs)) {\n          const value = result[key];\n          if (Array.isArray(value)) {\n            result[key] = value.map((child, idx) =>\n              // If DefaultGraph, do nothing, else wrap in plainly in Graph\n              keyGraphs[key][idx].termType === 'DefaultGraph' ?\n                child :\n                AF.createGraph(child, keyGraphs[key][idx]));\n          } else if (keyGraphs[key][0].termType !== 'DefaultGraph') {\n            result[key] = AF.createGraph(value, keyGraphs[key][0]);\n          }\n        }\n      }\n    }\n\n    return result;\n  },\n};\n\n/**\n * Graphs should be an array of length identical to `op.patterns`,\n * containing the corresponding graph for each triple.\n *\n * returns Join if more than 1 pattern present, otherwise if only default graph present returns Bgp, otherwise Graph.\n */\nexport const splitAlgBgpToGraphs: AstIndir<\n  'splitBgpToGraphs',\nAlgebra.Join | Algebra.Graph | Algebra.Bgp,\n[Algebra.Bgp, (RDF.NamedNode | RDF.DefaultGraph)[]]\n> = {\n  name: 'splitBgpToGraphs',\n  fun: () => ({ algebraFactory: AF }, op, graphs) => {\n    // Split patterns per graph\n    const graphPatterns: Record<string, { patterns: Algebra.Pattern[]; graph: RDF.NamedNode }> = {};\n    for (const [ index, pattern ] of op.patterns.entries()) {\n      const graph = graphs[index];\n      graphPatterns[graph.value] = graphPatterns[graph.value] ?? { patterns: [], graph };\n      graphPatterns[graph.value].patterns.push(pattern);\n    }\n\n    // Create graph objects for every cluster\n    const children: (Algebra.Graph | Algebra.Bgp)[] = [];\n    for (const [ graphName, { patterns, graph }] of Object.entries(graphPatterns)) {\n      const bgp = AF.createBgp(patterns);\n      // No name means DefaultGraph, otherwise wrap in graph\n      children.push(graphName === '' ? bgp : AF.createGraph(bgp, graph));\n    }\n\n    // Join the graph objects\n    let join: Algebra.Join | Algebra.Graph | Algebra.Bgp = children[0];\n    for (const child of children.slice(1)) {\n      join = AF.createJoin([ join, child ]);\n    }\n\n    return join;\n  },\n};\n"]}