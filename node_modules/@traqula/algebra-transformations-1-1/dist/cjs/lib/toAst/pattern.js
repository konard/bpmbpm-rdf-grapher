"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateAlgValues = exports.translateAlgUnion = exports.algWrapInPatternGroup = exports.translateAlgSlice = exports.operationAlgInputAsPatternList = exports.translateAlgService = exports.translateAlgMinus = exports.translateAlgLeftJoin = exports.translateAlgJoin = exports.translateAlgGroup = exports.translateAlgGraph = exports.translateAlgFilter = exports.translateAlgFrom = exports.translateAlgPath = exports.translateAlgBgp = exports.translateAlgBoundAggregate = exports.translateAlgPatternNew = exports.translateAlgSinglePattern = exports.translateAlgPatternIntoGroup = void 0;
const index_js_1 = require("../toAlgebra/index.js");
const core_js_1 = require("./core.js");
const expression_js_1 = require("./expression.js");
const general_js_1 = require("./general.js");
const path_js_1 = require("./path.js");
const queryUnit_js_1 = require("./queryUnit.js");
exports.translateAlgPatternIntoGroup = {
    name: 'translatePatternIntoGroup',
    fun: ({ SUBRULE }) => (_, op) => {
        switch (op.type) {
            case index_js_1.types.ASK: return SUBRULE(queryUnit_js_1.translateAlgProject, op, index_js_1.types.ASK);
            case index_js_1.types.PROJECT: return SUBRULE(queryUnit_js_1.translateAlgProject, op, index_js_1.types.PROJECT);
            case index_js_1.types.CONSTRUCT: return SUBRULE(queryUnit_js_1.translateAlgConstruct, op);
            case index_js_1.types.DESCRIBE: return SUBRULE(queryUnit_js_1.translateAlgProject, op, index_js_1.types.DESCRIBE);
            case index_js_1.types.DISTINCT: return SUBRULE(general_js_1.translateAlgDistinct, op);
            case index_js_1.types.FROM: return SUBRULE(exports.translateAlgFrom, op);
            case index_js_1.types.FILTER: return SUBRULE(exports.translateAlgFilter, op);
            case index_js_1.types.REDUCED: return SUBRULE(general_js_1.translateAlgReduced, op);
            case index_js_1.types.SLICE: return SUBRULE(exports.translateAlgSlice, op);
            default:
                throw new Error(`Unknown Operation type ${op.type}`);
        }
    },
};
exports.translateAlgSinglePattern = {
    name: 'translateSinglePattern',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => {
        SUBRULE(core_js_1.registerProjection, op);
        switch (op.type) {
            case index_js_1.types.PATH: return SUBRULE(exports.translateAlgPath, op);
            case index_js_1.types.BGP: return SUBRULE(exports.translateAlgBgp, op);
            case index_js_1.types.GRAPH: return SUBRULE(exports.translateAlgGraph, op);
            case index_js_1.types.SERVICE: return SUBRULE(exports.translateAlgService, op);
            case index_js_1.types.UNION: return SUBRULE(exports.translateAlgUnion, op);
            case index_js_1.types.VALUES: return SUBRULE(exports.translateAlgValues, op);
            case index_js_1.types.PATTERN: return F.patternBgp([SUBRULE(general_js_1.translateAlgPattern, op)], F.gen());
            default:
                return SUBRULE(exports.translateAlgPatternIntoGroup, op);
        }
    },
};
exports.translateAlgPatternNew = {
    name: 'translatePatternNew',
    fun: ({ SUBRULE }) => (_, op) => {
        SUBRULE(core_js_1.registerProjection, op);
        switch (op.type) {
            case index_js_1.types.ORDER_BY: return SUBRULE(general_js_1.translateAlgOrderBy, op);
            case index_js_1.types.GROUP: return SUBRULE(exports.translateAlgGroup, op);
            case index_js_1.types.EXTEND: return SUBRULE(general_js_1.translateAlgExtend, op);
            case index_js_1.types.JOIN: return SUBRULE(exports.translateAlgJoin, op);
            case index_js_1.types.LEFT_JOIN: return SUBRULE(exports.translateAlgLeftJoin, op);
            case index_js_1.types.MINUS: return SUBRULE(exports.translateAlgMinus, op);
            default:
                return SUBRULE(exports.translateAlgSinglePattern, op);
        }
    },
};
/**
 * These get translated in the project function
 */
exports.translateAlgBoundAggregate = {
    name: 'translateBoundAggregate',
    fun: () => (_, op) => op,
};
exports.translateAlgBgp = {
    name: 'translateBgp',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => {
        const patterns = op.patterns.map(triple => SUBRULE(general_js_1.translateAlgPattern, triple));
        return F.patternBgp(patterns, F.gen());
    },
};
exports.translateAlgPath = {
    name: 'translatePath',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.patternBgp([
        F.triple(SUBRULE(general_js_1.translateAlgTerm, op.subject), SUBRULE(path_js_1.translateAlgPathComponent, op.predicate), SUBRULE(general_js_1.translateAlgTerm, op.object)),
    ], F.gen()),
};
/**
 * A from needs to be registered to the solutionModifiers.
 * Similar to {@link translateAlgDistinct}
 */
exports.translateAlgFrom = {
    name: 'translateFrom',
    fun: ({ SUBRULE }) => (_, op) => {
        const result = SUBRULE(exports.translateAlgPatternIntoGroup, op.input);
        const query = result.patterns[0];
        query.datasets = SUBRULE(general_js_1.translateAlgDatasetClauses, op.default, op.named);
        return result;
    },
};
/**
 * A patternFilter closes the group
 */
exports.translateAlgFilter = {
    name: 'translateFilter',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.patternGroup([
        SUBRULE(exports.translateAlgPatternNew, op.input),
        F.patternFilter(SUBRULE(expression_js_1.translateAlgPureExpression, op.expression), F.gen()),
    ].flat(), F.gen()),
};
exports.translateAlgGraph = {
    name: 'translateGraph',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.patternGraph(SUBRULE(general_js_1.translateAlgTerm, op.name), [SUBRULE(exports.translateAlgPatternNew, op.input)].flat(), F.gen()),
};
/**
 * A group needs to be handled by {@link translateAlgProject}
 */
exports.translateAlgGroup = {
    name: 'translateGroup',
    fun: ({ SUBRULE }) => ({ aggregates, group }, op) => {
        const input = SUBRULE(exports.translateAlgPatternNew, op.input);
        const aggs = op.aggregates.map(x => SUBRULE(exports.translateAlgBoundAggregate, x));
        aggregates.push(...aggs);
        // TODO: apply possible extends
        group.push(...op.variables);
        return input;
    },
};
exports.translateAlgJoin = {
    name: 'translateJoin',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => {
        const arr = op.input.flatMap(x => SUBRULE(exports.translateAlgPatternNew, x));
        // Merge bgps
        // This is possible if one side was a path and the other a bgp for example
        const result = [];
        for (const val of arr) {
            const lastResult = result.at(-1);
            if (!F.isPatternBgp(val) || result.length === 0 || !F.isPatternBgp(lastResult)) {
                result.push(val);
            }
            else {
                lastResult.triples.push(...val.triples);
            }
        }
        return result;
    },
};
exports.translateAlgLeftJoin = {
    name: 'translateLeftJoin',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => {
        const leftJoin = F.patternOptional(SUBRULE(exports.operationAlgInputAsPatternList, op.input[1]), F.gen());
        if (op.expression) {
            leftJoin.patterns.push(F.patternFilter(SUBRULE(expression_js_1.translateAlgPureExpression, op.expression), F.gen()));
        }
        leftJoin.patterns = leftJoin.patterns.filter(Boolean);
        return [
            SUBRULE(exports.translateAlgPatternNew, op.input[0]),
            leftJoin,
        ].flat();
    },
};
exports.translateAlgMinus = {
    name: 'translateMinus',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => [
        SUBRULE(exports.translateAlgPatternNew, op.input[0]),
        F.patternMinus(SUBRULE(exports.operationAlgInputAsPatternList, op.input[1]), F.gen()),
    ].flat(),
};
exports.translateAlgService = {
    name: 'translateService',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.patternService(SUBRULE(general_js_1.translateAlgTerm, op.name), SUBRULE(exports.operationAlgInputAsPatternList, op.input), op.silent, F.gen()),
};
/**
 * Unwrap single group patterns, create array if it was not yet.
 */
exports.operationAlgInputAsPatternList = {
    name: 'operationInputAsPatternList',
    fun: ({ SUBRULE }) => (_, input) => {
        const result = SUBRULE(exports.translateAlgPatternNew, input);
        // If (result && F.isPatternGroup(result)) {
        //   return result.patterns;
        // }
        return result ? (Array.isArray(result) ? result : [result]) : [];
    },
};
/**
 * A limit offset needs to be registered to the solutionModifiers.
 * Similar to {@link translateAlgDistinct}
 */
exports.translateAlgSlice = {
    name: 'translateSlice',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => {
        const result = SUBRULE(exports.translateAlgPatternIntoGroup, op.input);
        const query = result.patterns[0];
        if (op.start !== 0) {
            query.solutionModifiers.limitOffset = query.solutionModifiers.limitOffset ??
                F.solutionModifierLimitOffset(undefined, op.start, F.gen());
            query.solutionModifiers.limitOffset.offset = op.start;
        }
        if (op.length !== undefined) {
            query.solutionModifiers.limitOffset = query.solutionModifiers.limitOffset ??
                F.solutionModifierLimitOffset(op.length, undefined, F.gen());
            query.solutionModifiers.limitOffset.limit = op.length;
        }
        return result;
    },
};
exports.algWrapInPatternGroup = {
    name: 'wrapInPatternGroup',
    fun: () => ({ astFactory: F }, input) => {
        if (Array.isArray(input)) {
            return F.patternGroup(input, F.gen());
        }
        if (F.isPatternGroup(input)) {
            return input;
        }
        return F.patternGroup([input], F.gen());
    },
};
exports.translateAlgUnion = {
    name: 'translateUnion',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.patternUnion(op.input.map(operation => SUBRULE(exports.algWrapInPatternGroup, SUBRULE(exports.translateAlgPatternNew, operation))), F.gen()),
};
exports.translateAlgValues = {
    name: 'translateValues',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.patternValues(op.variables.map(variable => F.termVariable(variable.value, F.gen())), op.bindings.map((binding) => {
        const result = {};
        for (const v of op.variables) {
            const s = v.value;
            if (binding[s]) {
                result[s] = SUBRULE(general_js_1.translateAlgTerm, binding[s]);
            }
            else {
                result[s] = undefined;
            }
        }
        return result;
    }), F.gen()),
};
//# sourceMappingURL=pattern.js.map