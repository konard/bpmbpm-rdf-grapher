"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateAlgWildcardExpression = exports.translateAlgOperatorExpression = exports.translateAlgPureOperatorExpression = exports.translateAlgNamedExpression = exports.translateAlgExistenceExpression = exports.translateAlgAggregateExpression = exports.translateAlgAnyExpression = exports.translateAlgExpressionOrOrdering = exports.translateAlgExpressionOrWild = exports.translateAlgPureExpression = void 0;
const core_js_1 = require("./core.js");
const general_js_1 = require("./general.js");
const pattern_js_1 = require("./pattern.js");
exports.translateAlgPureExpression = {
    name: 'translatePureExpression',
    fun: ({ SUBRULE }) => (_, expr) => {
        switch (expr.subType) {
            case core_js_1.eTypes.AGGREGATE:
                return SUBRULE(exports.translateAlgAggregateExpression, expr);
            case core_js_1.eTypes.EXISTENCE:
                return SUBRULE(exports.translateAlgExistenceExpression, expr);
            case core_js_1.eTypes.NAMED:
                return SUBRULE(exports.translateAlgNamedExpression, expr);
            case core_js_1.eTypes.OPERATOR:
                return SUBRULE(exports.translateAlgPureOperatorExpression, expr);
            case core_js_1.eTypes.TERM:
                return SUBRULE(general_js_1.translateAlgTerm, expr.term);
            default:
                throw new Error(`Unknown Expression Operation type ${expr.subType}`);
        }
    },
};
exports.translateAlgExpressionOrWild = {
    name: 'translateExpressionOrWild',
    fun: ({ SUBRULE }) => (_, expr) => expr.subType === core_js_1.eTypes.WILDCARD ?
        SUBRULE(exports.translateAlgWildcardExpression, expr) :
        SUBRULE(exports.translateAlgPureExpression, expr),
};
exports.translateAlgExpressionOrOrdering = {
    name: 'translateExpressionOrOrdering',
    fun: ({ SUBRULE }) => (_, expr) => expr.subType === core_js_1.eTypes.OPERATOR ?
        SUBRULE(exports.translateAlgOperatorExpression, expr) :
        SUBRULE(exports.translateAlgPureExpression, expr),
};
exports.translateAlgAnyExpression = {
    name: 'translateAnyExpression',
    fun: ({ SUBRULE }) => (_, expr) => expr.subType === core_js_1.eTypes.OPERATOR ?
        SUBRULE(exports.translateAlgOperatorExpression, expr) :
        SUBRULE(exports.translateAlgExpressionOrWild, expr),
};
exports.translateAlgAggregateExpression = {
    name: 'translateAggregateExpression',
    fun: ({ SUBRULE }) => ({ astFactory: F }, expr) => F.aggregate(expr.aggregator, expr.distinct, SUBRULE(exports.translateAlgExpressionOrWild, expr.expression), expr.separator, F.gen()),
};
exports.translateAlgExistenceExpression = {
    name: 'translateExistenceExpression',
    fun: ({ SUBRULE }) => ({ astFactory: F }, expr) => F.expressionPatternOperation(expr.not ? 'notexists' : 'exists', 
    // TranslateOperation can give an array
    F.patternGroup([SUBRULE(pattern_js_1.translateAlgPatternNew, expr.input)].flat(), F.gen()), F.gen()),
};
exports.translateAlgNamedExpression = {
    name: 'translateNamedExpression',
    fun: ({ SUBRULE }) => ({ astFactory: F }, expr) => F.expressionFunctionCall(SUBRULE(general_js_1.translateAlgTerm, expr.name), expr.args.map(x => SUBRULE(exports.translateAlgPureExpression, x)), false, F.gen()),
};
exports.translateAlgPureOperatorExpression = {
    name: 'translatePureOperatorExpression',
    fun: ({ SUBRULE }) => ({ astFactory: F }, expr) => F.expressionOperation(expr.operator, expr.args.map(x => SUBRULE(exports.translateAlgPureExpression, x)), F.gen()),
};
exports.translateAlgOperatorExpression = {
    name: 'translateOperatorExpression',
    fun: ({ SUBRULE }) => ({ astFactory: F }, expr) => {
        if (expr.operator === 'desc') {
            return { expression: SUBRULE(exports.translateAlgPureExpression, expr.args[0]), descending: true, loc: F.gen() };
        }
        return SUBRULE(exports.translateAlgPureOperatorExpression, expr);
    },
};
exports.translateAlgWildcardExpression = {
    name: 'translateWildcardExpression',
    fun: () => ({ astFactory: F }, _) => F.wildcard(F.gen()),
};
//# sourceMappingURL=expression.js.map