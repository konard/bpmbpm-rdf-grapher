{"version":3,"file":"pattern.js","sourceRoot":"","sources":["../../../../lib/toAst/pattern.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  Pattern,\n  PatternBgp,\n  PatternGraph,\n  PatternGroup,\n  PatternService,\n  PatternUnion,\n  PatternValues,\n  QueryBase,\n  ValuePatternRow,\n} from '@traqula/rules-sparql-1-1';\nimport type * as Algebra from '../algebra.js';\nimport { types } from '../toAlgebra/index.js';\nimport type { AstIndir } from './core.js';\nimport { registerProjection } from './core.js';\nimport { translateAlgPureExpression } from './expression.js';\nimport type {\n  RdfTermToAst,\n} from './general.js';\nimport {\n  translateAlgDatasetClauses,\n  translateAlgDistinct,\n  translateAlgExtend,\n  translateAlgOrderBy,\n  translateAlgPattern,\n  translateAlgReduced,\n  translateAlgTerm,\n} from './general.js';\nimport { translateAlgPathComponent } from './path.js';\nimport { translateAlgConstruct, translateAlgProject } from './queryUnit.js';\n\nexport const translateAlgPatternIntoGroup: AstIndir<'translatePatternIntoGroup', PatternGroup, [Algebra.Operation]> = {\n  name: 'translatePatternIntoGroup',\n  fun: ({ SUBRULE }) => (_, op) => {\n    switch (op.type) {\n      case types.ASK: return SUBRULE(translateAlgProject, op, types.ASK);\n      case types.PROJECT: return SUBRULE(translateAlgProject, op, types.PROJECT);\n      case types.CONSTRUCT: return SUBRULE(translateAlgConstruct, op);\n      case types.DESCRIBE: return SUBRULE(translateAlgProject, op, types.DESCRIBE);\n      case types.DISTINCT: return SUBRULE(translateAlgDistinct, op);\n      case types.FROM: return SUBRULE(translateAlgFrom, op);\n      case types.FILTER: return SUBRULE(translateAlgFilter, op);\n      case types.REDUCED: return SUBRULE(translateAlgReduced, op);\n      case types.SLICE: return SUBRULE(translateAlgSlice, op);\n      default:\n        throw new Error(`Unknown Operation type ${op.type}`);\n    }\n  },\n};\n\nexport const translateAlgSinglePattern: AstIndir<'translateSinglePattern', Pattern, [Algebra.Operation]> = {\n  name: 'translateSinglePattern',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) => {\n    SUBRULE(registerProjection, op);\n    switch (op.type) {\n      case types.PATH: return SUBRULE(translateAlgPath, op);\n      case types.BGP: return SUBRULE(translateAlgBgp, op);\n      case types.GRAPH: return SUBRULE(translateAlgGraph, op);\n      case types.SERVICE: return SUBRULE(translateAlgService, op);\n      case types.UNION: return SUBRULE(translateAlgUnion, op);\n      case types.VALUES: return SUBRULE(translateAlgValues, op);\n      case types.PATTERN: return F.patternBgp([ SUBRULE(translateAlgPattern, op) ], F.gen());\n      default:\n        return SUBRULE(translateAlgPatternIntoGroup, op);\n    }\n  },\n};\n\nexport const translateAlgPatternNew: AstIndir<'translatePatternNew', Pattern | Pattern[], [Algebra.Operation]> = {\n  name: 'translatePatternNew',\n  fun: ({ SUBRULE }) => (_, op) => {\n    SUBRULE(registerProjection, op);\n    switch (op.type) {\n      case types.ORDER_BY: return SUBRULE(translateAlgOrderBy, op);\n      case types.GROUP: return SUBRULE(translateAlgGroup, op);\n      case types.EXTEND: return SUBRULE(translateAlgExtend, op);\n      case types.JOIN: return SUBRULE(translateAlgJoin, op);\n      case types.LEFT_JOIN: return SUBRULE(translateAlgLeftJoin, op);\n      case types.MINUS: return SUBRULE(translateAlgMinus, op);\n      default:\n        return SUBRULE(translateAlgSinglePattern, op);\n    }\n  },\n};\n\n/**\n * These get translated in the project function\n */\nexport const translateAlgBoundAggregate:\nAstIndir<'translateBoundAggregate', Algebra.BoundAggregate, [Algebra.BoundAggregate]> = {\n  name: 'translateBoundAggregate',\n  fun: () => (_, op) => op,\n};\n\nexport const translateAlgBgp: AstIndir<'translateBgp', PatternBgp, [Algebra.Bgp]> = {\n  name: 'translateBgp',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) => {\n    const patterns = op.patterns.map(triple => SUBRULE(translateAlgPattern, triple));\n    return F.patternBgp(patterns, F.gen());\n  },\n};\n\nexport const translateAlgPath: AstIndir<'translatePath', PatternBgp, [Algebra.Path]> = {\n  name: 'translatePath',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.patternBgp([\n    F.triple(\n      SUBRULE(translateAlgTerm, op.subject),\n      SUBRULE(translateAlgPathComponent, op.predicate),\n      SUBRULE(translateAlgTerm, op.object),\n    ),\n  ], F.gen()),\n};\n\n/**\n * A from needs to be registered to the solutionModifiers.\n * Similar to {@link translateAlgDistinct}\n */\nexport const translateAlgFrom: AstIndir<'translateFrom', PatternGroup, [Algebra.From]> = {\n  name: 'translateFrom',\n  fun: ({ SUBRULE }) => (_, op) => {\n    const result = SUBRULE(translateAlgPatternIntoGroup, op.input);\n    const query = <QueryBase> result.patterns[0];\n    query.datasets = SUBRULE(translateAlgDatasetClauses, op.default, op.named);\n    return result;\n  },\n};\n\n/**\n * A patternFilter closes the group\n */\nexport const translateAlgFilter: AstIndir<'translateFilter', PatternGroup, [Algebra.Filter]> = {\n  name: 'translateFilter',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) =>\n    F.patternGroup(\n      [\n        SUBRULE(translateAlgPatternNew, op.input),\n        F.patternFilter(SUBRULE(translateAlgPureExpression, op.expression), F.gen()),\n      ].flat(),\n      F.gen(),\n    ),\n};\n\nexport const translateAlgGraph: AstIndir<'translateGraph', PatternGraph, [Algebra.Graph]> = {\n  name: 'translateGraph',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) =>\n    F.patternGraph(\n      <RdfTermToAst<typeof op.name>>SUBRULE(translateAlgTerm, op.name),\n      [ SUBRULE(translateAlgPatternNew, op.input) ].flat(),\n      F.gen(),\n    ),\n};\n\n/**\n * A group needs to be handled by {@link translateAlgProject}\n */\nexport const translateAlgGroup: AstIndir<'translateGroup', Pattern | Pattern[], [Algebra.Group]> = {\n  name: 'translateGroup',\n  fun: ({ SUBRULE }) => ({ aggregates, group }, op) => {\n    const input = SUBRULE(translateAlgPatternNew, op.input);\n    const aggs = op.aggregates.map(x => SUBRULE(translateAlgBoundAggregate, x));\n    aggregates.push(...aggs);\n    // TODO: apply possible extends\n    group.push(...op.variables);\n    return input;\n  },\n};\n\nexport const translateAlgJoin: AstIndir<'translateJoin', Pattern[], [Algebra.Join]> = {\n  name: 'translateJoin',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) => {\n    const arr = op.input.flatMap(x => SUBRULE(translateAlgPatternNew, x));\n\n    // Merge bgps\n    // This is possible if one side was a path and the other a bgp for example\n    const result: Pattern[] = [];\n    for (const val of arr) {\n      const lastResult = result.at(-1);\n      if (!F.isPatternBgp(val) || result.length === 0 || !F.isPatternBgp(lastResult!)) {\n        result.push(val);\n      } else {\n        lastResult.triples.push(...val.triples);\n      }\n    }\n    return result;\n  },\n};\n\nexport const translateAlgLeftJoin: AstIndir<'translateLeftJoin', Pattern[], [Algebra.LeftJoin]> = {\n  name: 'translateLeftJoin',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) => {\n    const leftJoin = F.patternOptional(\n      SUBRULE(operationAlgInputAsPatternList, op.input[1]),\n      F.gen(),\n    );\n\n    if (op.expression) {\n      leftJoin.patterns.push(\n        F.patternFilter(SUBRULE(translateAlgPureExpression, op.expression), F.gen()),\n      );\n    }\n    leftJoin.patterns = leftJoin.patterns.filter(Boolean);\n\n    return [\n      SUBRULE(translateAlgPatternNew, op.input[0]),\n      leftJoin,\n    ].flat();\n  },\n};\n\nexport const translateAlgMinus: AstIndir<'translateMinus', Pattern[], [Algebra.Minus]> = {\n  name: 'translateMinus',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) =>\n    [\n      SUBRULE(translateAlgPatternNew, op.input[0]),\n      F.patternMinus(SUBRULE(operationAlgInputAsPatternList, op.input[1]), F.gen()),\n    ].flat(),\n};\n\nexport const translateAlgService: AstIndir<'translateService', PatternService, [Algebra.Service]> = {\n  name: 'translateService',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) =>\n    F.patternService(\n      <RdfTermToAst<typeof op.name>> SUBRULE(translateAlgTerm, op.name),\n      SUBRULE(operationAlgInputAsPatternList, op.input),\n      op.silent,\n      F.gen(),\n    ),\n};\n\n/**\n * Unwrap single group patterns, create array if it was not yet.\n */\nexport const operationAlgInputAsPatternList: AstIndir<'operationInputAsPatternList', Pattern[], [Algebra.Operation]> = {\n  name: 'operationInputAsPatternList',\n  fun: ({ SUBRULE }) => (_, input) => {\n    const result = SUBRULE(translateAlgPatternNew, input);\n    // If (result && F.isPatternGroup(result)) {\n    //   return result.patterns;\n    // }\n    return result ? (Array.isArray(result) ? result : [ result ]) : [];\n  },\n};\n\n/**\n * A limit offset needs to be registered to the solutionModifiers.\n * Similar to {@link translateAlgDistinct}\n */\nexport const translateAlgSlice: AstIndir<'translateSlice', PatternGroup, [Algebra.Slice]> = {\n  name: 'translateSlice',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) => {\n    const result = SUBRULE(translateAlgPatternIntoGroup, op.input);\n    const query = <QueryBase>result.patterns[0];\n    if (op.start !== 0) {\n      query.solutionModifiers.limitOffset = query.solutionModifiers.limitOffset ??\n        F.solutionModifierLimitOffset(undefined, op.start, F.gen());\n      query.solutionModifiers.limitOffset.offset = op.start;\n    }\n    if (op.length !== undefined) {\n      query.solutionModifiers.limitOffset = query.solutionModifiers.limitOffset ??\n        F.solutionModifierLimitOffset(op.length, undefined, F.gen());\n      query.solutionModifiers.limitOffset.limit = op.length;\n    }\n    return result;\n  },\n};\n\nexport const algWrapInPatternGroup: AstIndir<'wrapInPatternGroup', PatternGroup, [Pattern[] | Pattern]> = {\n  name: 'wrapInPatternGroup',\n  fun: () => ({ astFactory: F }, input) => {\n    if (Array.isArray(input)) {\n      return F.patternGroup(input, F.gen());\n    }\n    if (F.isPatternGroup(input)) {\n      return input;\n    }\n    return F.patternGroup([ input ], F.gen());\n  },\n};\n\nexport const translateAlgUnion: AstIndir<'translateUnion', PatternUnion, [Algebra.Union]> = {\n  name: 'translateUnion',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) =>\n    F.patternUnion(\n      op.input.map(operation => SUBRULE(algWrapInPatternGroup, SUBRULE(translateAlgPatternNew, operation))),\n      F.gen(),\n    ),\n};\n\nexport const translateAlgValues: AstIndir<'translateValues', PatternValues, [Algebra.Values]> = {\n  name: 'translateValues',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) =>\n    F.patternValues(\n      op.variables.map(variable => F.termVariable(variable.value, F.gen())),\n      op.bindings.map((binding) => {\n        const result: ValuePatternRow = {};\n        for (const v of op.variables) {\n          const s = v.value;\n          if (binding[s]) {\n            result[s] = <RdfTermToAst<typeof binding[typeof s]>> SUBRULE(translateAlgTerm, binding[s]);\n          } else {\n            result[s] = undefined;\n          }\n        }\n        return result;\n      }),\n      F.gen(),\n    ),\n};\n"]}