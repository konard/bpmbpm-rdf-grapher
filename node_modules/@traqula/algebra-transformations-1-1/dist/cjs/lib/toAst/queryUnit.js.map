{"version":3,"file":"queryUnit.js","sourceRoot":"","sources":["../../../../lib/toAst/queryUnit.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type {\n  BasicGraphPattern,\n  Expression,\n  Ordering,\n  Pattern,\n  PatternBind,\n  PatternGroup,\n  QueryBase,\n  QuerySelect,\n  SolutionModifierGroupBind,\n  Sparql11Nodes,\n  TermVariable,\n} from '@traqula/rules-sparql-1-1';\nimport type { Algebra } from '../index.js';\nimport { types } from '../toAlgebra/index.js';\nimport type { AstIndir } from './core.js';\nimport { resetContext } from './core.js';\nimport { translateAlgExpressionOrOrdering, translateAlgPureExpression } from './expression.js';\nimport type { RdfTermToAst } from './general.js';\nimport { translateAlgPattern, translateAlgTerm } from './general.js';\nimport { translateAlgPatternNew } from './pattern.js';\n\nexport const translateAlgConstruct: AstIndir<'translateConstruct', PatternGroup, [Algebra.Construct]> = {\n  name: 'translateConstruct',\n  fun: ({ SUBRULE }) => ({ astFactory: F, order }, op) => {\n    const queryConstruct = F.queryConstruct(\n      F.gen(),\n      [],\n      F.patternBgp(<BasicGraphPattern> op.template.map(x => SUBRULE(translateAlgPattern, x)), F.gen()),\n      F.patternGroup([ SUBRULE(translateAlgPatternNew, op.input) ].flat(), F.gen()),\n      {},\n      F.datasetClauses([], F.gen()),\n    );\n    SUBRULE(registerOrderBy, queryConstruct);\n    order.length = 0;\n    // Subqueries need to be in a group! Top level grouping is removed at toAst function\n    //  - for consistency with the other operators, we also wrap here.\n    return F.patternGroup([ <Pattern> <unknown> queryConstruct ], F.gen());\n  },\n};\n\n// Separate terms from wildcard since we handle them differently\nfunction isSimpleTerm(term: any): term is RDF.Term {\n  return term.termType !== undefined && term.termType !== 'Quad' && term.termType !== 'wildcard' &&\n    term.termType !== 'Wildcard';\n}\n\n/**\n * Will mostly return the same type as what you give in second arg.\n */\nexport const replaceAlgAggregatorVariables:\nAstIndir<'replaceAggregatorVariables', unknown, [unknown, Record<string, Expression>]> = {\n  name: 'replaceAggregatorVariables',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, s, map) => {\n    const st: Sparql11Nodes = isSimpleTerm(s) ? SUBRULE(translateAlgTerm, s) : <Sparql11Nodes> s;\n\n    // Look for TermVariable, if we find, replace it by the aggregator.\n    if (F.isTermVariable(st)) {\n      if (map[st.value]) {\n        // Returns the ExpressionAggregate\n        return map[st.value];\n      }\n    } else if (Array.isArray(s)) {\n      s = s.map(e => SUBRULE(replaceAlgAggregatorVariables, e, map));\n    } else if (typeof s === 'object') {\n      const obj = <Record<string, any>> s;\n      for (const key of Object.keys(obj)) {\n        obj[key] = SUBRULE(replaceAlgAggregatorVariables, obj[key], map);\n      }\n    }\n    return s;\n  },\n};\n\nexport const translateAlgProject:\nAstIndir<'translateProject', PatternGroup, [Algebra.Project | Algebra.Ask | Algebra.Describe, string]> = {\n  name: 'translateProject',\n  fun: ({ SUBRULE }) => (c, op, type) => {\n    const F = c.astFactory;\n    const result: QueryBase = <any> {\n      type: 'query',\n      solutionModifiers: {},\n      loc: F.gen(),\n      datasets: F.datasetClauses([], F.gen()),\n      context: [],\n    } satisfies Partial<QueryBase>;\n\n    // Makes typing easier in some places\n    const select = <QuerySelect> result;\n    let variables: RDF.Variable[] | undefined;\n\n    if (type === types.PROJECT) {\n      result.subType = 'select';\n      variables = (<Algebra.Project>op).variables;\n    } else if (type === types.ASK) {\n      result.subType = 'ask';\n    } else if (type === types.DESCRIBE) {\n      result.subType = 'describe';\n      variables = <RDF.Variable[]>(<Algebra.Describe>op).terms;\n    }\n\n    // Backup values in case of nested queries\n    // everything in extend, group, etc. is irrelevant for this project call\n    const extend = c.extend;\n    const group = c.group;\n    const aggregates = c.aggregates;\n    const order = c.order;\n    SUBRULE(resetContext);\n    c.project = true;\n\n    // TranslateOperation could give an array.\n    let input = [ SUBRULE(translateAlgPatternNew, op.input) ].flat();\n    if (input.length === 1 && F.isPatternGroup(input[0])) {\n      input = (input[0]).patterns;\n    }\n    result.where = F.patternGroup(input, F.gen());\n\n    // Map from variable to what agg it represents\n    const aggregators: Record<string, Expression> = {};\n    // These can not reference each other\n    for (const agg of c.aggregates) {\n      aggregators[(<RdfTermToAst<typeof agg.variable>>SUBRULE(translateAlgTerm, agg.variable)).value] =\n        SUBRULE(translateAlgPureExpression, agg);\n    }\n\n    // Do these in reverse order since variables in one extend might apply to an expression in another extend\n    const extensions: Record<string, Expression> = {};\n    for (const e of c.extend.reverse()) {\n      const expr = SUBRULE(translateAlgPureExpression, e.expression);\n      extensions[(<RdfTermToAst<typeof e.variable>>SUBRULE(translateAlgTerm, e.variable)).value] =\n        <typeof expr>SUBRULE(replaceAlgAggregatorVariables, expr, aggregators);\n    }\n    SUBRULE(registerAlgGroupBy, result, extensions);\n    SUBRULE(registerOrderBy, result);\n    SUBRULE(registerVariables, select, variables, extensions);\n    SUBRULE(putExtensionsInGroup, result, extensions);\n\n    // Convert all filters to 'having' if it contains an aggregator variable\n    // could always convert, but is nicer to keep as filter when possible\n    const havings: Expression[] = [];\n    result.where = <PatternGroup> SUBRULE(filterReplace, result.where, aggregators, havings);\n    if (havings.length > 0) {\n      select.solutionModifiers.having = F.solutionModifierHaving(havings, F.gen());\n    }\n\n    // Recover state\n    c.extend = extend;\n    c.group = group;\n    c.aggregates = aggregates;\n    c.order = order;\n\n    // Subqueries need to be in a group! Top level grouping is removed at toAst function\n    return F.patternGroup([ select ], F.gen());\n  },\n};\n\nexport const registerAlgGroupBy: AstIndir<'registerGroupBy', void, [QueryBase, Record<string, Expression>]> = {\n  name: 'registerGroupBy',\n  fun: ({ SUBRULE }) => ({ astFactory: F, group }, result, extensions) => {\n    if (group.length > 0) {\n      result.solutionModifiers.group = F.solutionModifierGroup(\n        group.map((variable) => {\n          const v = <RdfTermToAst<typeof variable>>SUBRULE(translateAlgTerm, variable);\n          if (extensions[v.value]) {\n            const result = extensions[v.value];\n            // Make sure there is only 1 'AS' statement\n            delete extensions[v.value];\n            return {\n              variable: v,\n              value: result,\n              loc: F.gen(),\n            } satisfies SolutionModifierGroupBind;\n          }\n          return v;\n        }),\n        F.gen(),\n      );\n    }\n  },\n};\n\nexport const registerOrderBy: AstIndir<'registerOrderBy', void, [QueryBase]> = {\n  name: 'registerOrderBy',\n  fun: ({ SUBRULE }) => ({ astFactory: F, order }, result) => {\n    if (order.length > 0) {\n      result.solutionModifiers.order = F.solutionModifierOrder(\n        order\n          .map(x => SUBRULE(translateAlgExpressionOrOrdering, x))\n          .map((o: Ordering | Expression) =>\n            F.isExpression(o) ?\n                ({\n                  expression: o,\n                  descending: false,\n                  loc: F.gen(),\n                } satisfies Ordering) :\n              o),\n        F.gen(),\n      );\n    }\n  },\n};\n\nexport const registerVariables:\nAstIndir<'registerVariables', void, [QuerySelect, RDF.Variable[] | undefined, Record<string, Expression>]> = {\n  name: 'registerVariables',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, select, variables, extensions) => {\n    if (variables) {\n      select.variables = variables.map((term): TermVariable | PatternBind => {\n        const v = <RdfTermToAst<typeof term>>SUBRULE(translateAlgTerm, term);\n        if (extensions[v.value]) {\n          const result: Expression = extensions[v.value];\n          // Remove used extensions so only unused ones remain\n          delete extensions[v.value];\n          return F.patternBind(result, v, F.gen());\n        }\n        return v;\n      });\n      // If the * didn't match any variables this would be empty\n      if (select.variables.length === 0) {\n        select.variables = [ F.wildcard(F.gen()) ];\n      }\n    }\n  },\n};\n\n/**\n * It is possible that at this point some extensions have not yet been resolved.\n * These would be bind operations that are not used in a GROUP BY or SELECT body.\n * We still need to add them though, as they could be relevant to the other extensions.\n */\nexport const putExtensionsInGroup: AstIndir<'putExtensionsInGroup', void, [QueryBase, Record<string, Expression>]> = {\n  name: 'putExtensionsInGroup',\n  fun: () => ({ astFactory: F }, result, extensions) => {\n    const extensionEntries = Object.entries(extensions);\n    if (extensionEntries.length > 0) {\n      result.where = result.where ?? F.patternGroup([], F.gen());\n      for (const [ key, value ] of extensionEntries) {\n        result.where.patterns.push(\n          F.patternBind(\n            value,\n            F.termVariable(key, F.gen()),\n            F.gen(),\n          ),\n        );\n      }\n    }\n  },\n};\n\n/**\n * If second arg is a Group, we will return a group.\n */\nexport const filterReplace: AstIndir<\n  'filterReplace',\nPatternGroup | Pattern,\n[PatternGroup | Pattern, Record<string, Expression>, Expression[]]\n> = {\n  name: 'filterReplace',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, group, aggregators, havings) => {\n    if (!F.isPatternGroup(group)) {\n      return group;\n    }\n    const patterns = group.patterns\n      .map(x => SUBRULE(filterReplace, x, aggregators, havings))\n      .flatMap((pattern) => {\n        if (F.isPatternFilter(pattern) && SUBRULE(objectContainsVariable, pattern, Object.keys(aggregators))) {\n          havings.push(\n            <typeof pattern.expression>SUBRULE(replaceAlgAggregatorVariables, pattern.expression, aggregators),\n          );\n          return [];\n        }\n        return [ pattern ];\n      });\n    return F.patternGroup(patterns, F.gen());\n  },\n};\n\nexport const objectContainsVariable: AstIndir<'objectContainsVariable', boolean, [any, string[]]> = {\n  name: 'objectContainsVariable',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, o, vals) => {\n    const casted = <Sparql11Nodes> o;\n    if (F.isTermVariable(casted)) {\n      return vals.includes(casted.value);\n    }\n    if (Array.isArray(o)) {\n      return o.some(e => SUBRULE(objectContainsVariable, e, vals));\n    }\n    if (o === Object(o)) {\n      return Object.keys(o).some(key => SUBRULE(objectContainsVariable, o[key], vals));\n    }\n    return false;\n  },\n};\n"]}