"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertAlgUpdatePatterns = exports.translateAlgCopy = exports.translateAlgMove = exports.translateAlgAdd = exports.translateAlgDrop = exports.translateAlgCreate = exports.translateAlgClear = exports.translateAlgGraphRef = exports.translateAlgLoad = exports.cleanupAlgUpdateOperationModify = exports.translateAlgDeleteInsert = exports.translateAlgCompositeUpdate = exports.toUpdate = exports.translateAlgUpdateOperation = void 0;
const rdf_isomorphic_1 = require("rdf-isomorphic");
const algebra_js_1 = require("../algebra.js");
const index_js_1 = require("../toAlgebra/index.js");
const general_js_1 = require("./general.js");
const pattern_js_1 = require("./pattern.js");
const quads_js_1 = require("./quads.js");
exports.translateAlgUpdateOperation = {
    name: 'translateUpdateOperation',
    fun: ({ SUBRULE }) => (_, op) => {
        switch (op.type) {
            case algebra_js_1.Types.DELETE_INSERT:
                return SUBRULE(exports.translateAlgDeleteInsert, op);
            case algebra_js_1.Types.LOAD:
                return SUBRULE(exports.translateAlgLoad, op);
            case algebra_js_1.Types.CLEAR:
                return SUBRULE(exports.translateAlgClear, op);
            case algebra_js_1.Types.CREATE:
                return SUBRULE(exports.translateAlgCreate, op);
            case algebra_js_1.Types.DROP:
                return SUBRULE(exports.translateAlgDrop, op);
            case algebra_js_1.Types.ADD:
                return SUBRULE(exports.translateAlgAdd, op);
            case algebra_js_1.Types.MOVE:
                return SUBRULE(exports.translateAlgMove, op);
            case algebra_js_1.Types.COPY:
                return SUBRULE(exports.translateAlgCopy, op);
            default:
                throw new Error(`Unknown Operation type ${op.type}`);
        }
    },
};
exports.toUpdate = {
    name: 'toUpdate',
    fun: () => ({ astFactory: F }, ops) => ({
        type: 'update',
        updates: ops.map(op => ({ context: [], operation: op })),
        loc: F.gen(),
    }),
};
exports.translateAlgCompositeUpdate = {
    name: 'translateCompositeUpdate',
    fun: ({ SUBRULE }) => (_, op) => SUBRULE(exports.toUpdate, op.updates.map(update => update.type === algebra_js_1.Types.NOP ? undefined : SUBRULE(exports.translateAlgUpdateOperation, update))),
};
exports.translateAlgDeleteInsert = {
    name: 'translateDeleteInsert',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => {
        let where = op.where;
        let use;
        if (where && where.type === index_js_1.types.FROM) {
            const from = where;
            where = from.input;
            use = SUBRULE(general_js_1.translateAlgDatasetClauses, from.default, from.named);
        }
        const update = {
            type: 'updateOperation',
            subType: 'modify',
            delete: SUBRULE(exports.convertAlgUpdatePatterns, op.delete ?? []),
            insert: SUBRULE(exports.convertAlgUpdatePatterns, op.insert ?? []),
            where: F.patternGroup([], F.gen()),
            from: use ?? F.datasetClauses([], F.gen()),
            loc: F.gen(),
            graph: undefined,
        };
        // If not an empty where pattern, handle quads
        if (where && (where.type !== index_js_1.types.BGP || where.patterns.length > 0)) {
            const graphs = [];
            const result = SUBRULE(pattern_js_1.translateAlgPatternNew, SUBRULE(quads_js_1.removeAlgQuadsRecursive, where, graphs));
            update.where = SUBRULE(pattern_js_1.algWrapInPatternGroup, result);
            // Graph might not be applied yet since there was no project
            // this can only happen if there was a single graph
            if (graphs.length > 0) {
                if (graphs.length === 1) {
                    // Ignore if default graph
                    if (graphs.at(0)?.value !== '') {
                        update.where.patterns = [
                            F.patternGraph(SUBRULE(general_js_1.translateAlgTerm, graphs[0]), update.where.patterns, F.gen()),
                        ];
                    }
                }
                else {
                    throw new Error('This is unexpected and might indicate an error in graph handling for updates.');
                }
            }
        }
        return SUBRULE(exports.cleanupAlgUpdateOperationModify, update, op);
    },
};
/**
 * Return the minimal version of the UpdateOperationModify.
 * Not really necessary but can give cleaner looking queries
 */
exports.cleanupAlgUpdateOperationModify = {
    name: 'cleanUpUpdateOperationModify',
    fun: () => (_, update, op) => {
        const copy = { ...update };
        // Check Insert Data
        if (!op.delete && !op.where) {
            const asInsert = copy;
            asInsert.subType = 'insertdata';
            asInsert.data = copy.insert;
            delete asInsert.delete;
            delete asInsert.where;
            return asInsert;
        }
        // Check DeleteWhere or DeleteData
        if (!op.insert && !op.where) {
            const asCasted = copy;
            asCasted.data = copy.delete;
            delete asCasted.insert;
            delete asCasted.where;
            if (op.delete.some(pattern => (0, index_js_1.isVariable)(pattern.subject) || (0, index_js_1.isVariable)(pattern.predicate) || (0, index_js_1.isVariable)(pattern.object))) {
                asCasted.subType = 'deletewhere';
            }
            else {
                asCasted.subType = 'deletedata';
            }
            return asCasted;
        }
        // Check if deleteWhere when modify but isomorphic.
        if (!op.insert && op.where && op.where.type === 'bgp' && (0, rdf_isomorphic_1.isomorphic)(op.delete, op.where.patterns)) {
            const asCasted = copy;
            asCasted.data = copy.delete;
            delete asCasted.where;
            delete asCasted.delete;
            asCasted.subType = 'deletewhere';
            return asCasted;
        }
        return update;
    },
};
exports.translateAlgLoad = {
    name: 'translateLoad',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.updateOperationLoad(F.gen(), SUBRULE(general_js_1.translateAlgTerm, op.source), Boolean(op.silent), op.destination ?
        F.graphRefSpecific(SUBRULE(general_js_1.translateAlgTerm, op.destination), F.gen()) :
        undefined),
};
exports.translateAlgGraphRef = {
    name: 'translateGraphRef',
    fun: ({ SUBRULE }) => ({ astFactory: F }, graphRef) => {
        if (graphRef === 'DEFAULT') {
            return F.graphRefDefault(F.gen());
        }
        if (graphRef === 'NAMED') {
            return F.graphRefNamed(F.gen());
        }
        if (graphRef === 'ALL') {
            return F.graphRefAll(F.gen());
        }
        return F.graphRefSpecific(SUBRULE(general_js_1.translateAlgTerm, graphRef), F.gen());
    },
};
exports.translateAlgClear = {
    name: 'translateClear',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.updateOperationClear(SUBRULE(exports.translateAlgGraphRef, op.source), op.silent ?? false, F.gen()),
};
exports.translateAlgCreate = {
    name: 'translateCreate',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.updateOperationCreate(SUBRULE(exports.translateAlgGraphRef, op.source), op.silent ?? false, F.gen()),
};
exports.translateAlgDrop = {
    name: 'translateDrop',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.updateOperationDrop(SUBRULE(exports.translateAlgGraphRef, op.source), op.silent ?? false, F.gen()),
};
exports.translateAlgAdd = {
    name: 'translateAdd',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.updateOperationAdd(SUBRULE(exports.translateAlgGraphRef, op.source), SUBRULE(exports.translateAlgGraphRef, op.destination), op.silent ?? false, F.gen()),
};
exports.translateAlgMove = {
    name: 'translateMove',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.updateOperationMove(SUBRULE(exports.translateAlgGraphRef, op.source), SUBRULE(exports.translateAlgGraphRef, op.destination), op.silent ?? false, F.gen()),
};
exports.translateAlgCopy = {
    name: 'translateCopy',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.updateOperationCopy(SUBRULE(exports.translateAlgGraphRef, op.source), SUBRULE(exports.translateAlgGraphRef, op.destination), op.silent ?? false, F.gen()),
};
/**
 * Similar to removeQuads but more simplified for UPDATES
 */
exports.convertAlgUpdatePatterns = {
    name: 'convertUpdatePatterns',
    fun: ({ SUBRULE }) => ({ astFactory: F }, patterns) => {
        if (!patterns) {
            return [];
        }
        const graphs = {};
        for (const pattern of patterns) {
            const graph = pattern.graph.value;
            if (!graphs[graph]) {
                graphs[graph] = [];
            }
            graphs[graph].push(pattern);
        }
        return Object.keys(graphs).map((graph) => {
            const patternBgp = F.patternBgp(graphs[graph].map(x => SUBRULE(general_js_1.translateAlgPattern, x)), F.gen());
            // If DefaultGraph, de not wrap
            if (graph === '') {
                return patternBgp;
            }
            return F.graphQuads(SUBRULE(general_js_1.translateAlgTerm, graphs[graph][0].graph), patternBgp, F.gen());
        });
    },
};
//# sourceMappingURL=updateUnit.js.map