{"version":3,"file":"core.js","sourceRoot":"","sources":["../../../../lib/toAst/core.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA,4CAWC;AA3CD,gEAAuE;AACvE,uDAAyC;AACzC,4DAAsD;AACtD,oDAA8C;AA6B9C,SAAgB,gBAAgB;IAC9B,OAAO;QACL,OAAO,EAAE,KAAK;QACd,MAAM,EAAE,EAAE;QACV,KAAK,EAAE,EAAE;QACT,UAAU,EAAE,EAAE;QACd,KAAK,EAAE,EAAE;QACT,cAAc,EAAE,IAAI,kCAAc,EAAE;QACpC,UAAU,EAAE,IAAI,6BAAU,EAAE;QAC5B,WAAW,EAAE,IAAI,iCAAc,EAAE;KAClC,CAAC;AACJ,CAAC;AAGY,QAAA,MAAM,GAAG,OAAO,CAAC,eAAe,CAAC;AAEjC,QAAA,YAAY,GAAuC;IAC9D,IAAI,EAAE,cAAc;IACpB,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE;QACf,CAAC,CAAC,OAAO,GAAG,KAAK,CAAC;QAClB,CAAC,CAAC,MAAM,GAAG,EAAE,CAAC;QACd,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;QACb,CAAC,CAAC,UAAU,GAAG,EAAE,CAAC;QAClB,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;IACf,CAAC;CACF,CAAC;AAEW,QAAA,kBAAkB,GAA8D;IAC3F,IAAI,EAAE,oBAAoB;IAC1B,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE;QACnB,iHAAiH;QACjH,mFAAmF;QACnF,IAAI,EAAE,CAAC,IAAI,KAAK,gBAAK,CAAC,MAAM,IAAI,EAAE,CAAC,IAAI,KAAK,gBAAK,CAAC,QAAQ,IAAI,EAAE,CAAC,IAAI,KAAK,gBAAK,CAAC,KAAK,EAAE,CAAC;YACtF,CAAC,CAAC,OAAO,GAAG,KAAK,CAAC;QACpB,CAAC;IACH,CAAC;CACF,CAAC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { IndirDef } from '@traqula/core';\nimport { AstFactory, AstTransformer } from '@traqula/rules-sparql-1-1';\nimport * as Algebra from '../algebra.js';\nimport { AlgebraFactory } from '../algebraFactory.js';\nimport { types } from '../toAlgebra/index.js';\n\nexport interface AstContext {\n  /**\n   * Whether we are contained in a projection.\n   * This allows us to differentiate between BIND and SELECT when translating EXTEND\n   */\n  project: boolean;\n  /**\n   * All extends found in our suboperations\n   */\n  extend: Algebra.Extend[];\n  /**\n   * All groups found in our suboperations\n   */\n  group: RDF.Variable[];\n  /**\n   * All aggregates found in our suboperations\n   */\n  aggregates: Algebra.BoundAggregate[];\n  /**\n   * All orderings found in our suboperations\n   */\n  order: Algebra.Expression[];\n  algebraFactory: AlgebraFactory;\n  astFactory: AstFactory;\n  transformer: AstTransformer;\n}\n\nexport function createAstContext(): AstContext {\n  return {\n    project: false,\n    extend: [],\n    group: [],\n    aggregates: [],\n    order: [],\n    algebraFactory: new AlgebraFactory(),\n    astFactory: new AstFactory(),\n    transformer: new AstTransformer(),\n  };\n}\n\nexport type AstIndir<Name extends string, Ret, Arg extends any[]> = IndirDef<AstContext, Name, Ret, Arg>;\nexport const eTypes = Algebra.ExpressionTypes;\n\nexport const resetContext: AstIndir<'resetContext', void, []> = {\n  name: 'resetContext',\n  fun: () => (c) => {\n    c.project = false;\n    c.extend = [];\n    c.group = [];\n    c.aggregates = [];\n    c.order = [];\n  },\n};\n\nexport const registerProjection: AstIndir<'registerProjection', void, [Algebra.Operation]> = {\n  name: 'registerProjection',\n  fun: () => (c, op) => {\n    // GRAPH was added because the way graphs get added back here is not the same as how they get added in the future\n    // ^ seems fine but might have to be changed if problems get detected in the future\n    if (op.type !== types.EXTEND && op.type !== types.ORDER_BY && op.type !== types.GRAPH) {\n      c.project = false;\n    }\n  },\n};\n"]}