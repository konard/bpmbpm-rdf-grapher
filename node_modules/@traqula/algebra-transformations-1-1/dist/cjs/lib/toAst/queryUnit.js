"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.objectContainsVariable = exports.filterReplace = exports.putExtensionsInGroup = exports.registerVariables = exports.registerOrderBy = exports.registerAlgGroupBy = exports.translateAlgProject = exports.replaceAlgAggregatorVariables = exports.translateAlgConstruct = void 0;
const index_js_1 = require("../toAlgebra/index.js");
const core_js_1 = require("./core.js");
const expression_js_1 = require("./expression.js");
const general_js_1 = require("./general.js");
const pattern_js_1 = require("./pattern.js");
exports.translateAlgConstruct = {
    name: 'translateConstruct',
    fun: ({ SUBRULE }) => ({ astFactory: F, order }, op) => {
        const queryConstruct = F.queryConstruct(F.gen(), [], F.patternBgp(op.template.map(x => SUBRULE(general_js_1.translateAlgPattern, x)), F.gen()), F.patternGroup([SUBRULE(pattern_js_1.translateAlgPatternNew, op.input)].flat(), F.gen()), {}, F.datasetClauses([], F.gen()));
        SUBRULE(exports.registerOrderBy, queryConstruct);
        order.length = 0;
        // Subqueries need to be in a group! Top level grouping is removed at toAst function
        //  - for consistency with the other operators, we also wrap here.
        return F.patternGroup([queryConstruct], F.gen());
    },
};
// Separate terms from wildcard since we handle them differently
function isSimpleTerm(term) {
    return term.termType !== undefined && term.termType !== 'Quad' && term.termType !== 'wildcard' &&
        term.termType !== 'Wildcard';
}
/**
 * Will mostly return the same type as what you give in second arg.
 */
exports.replaceAlgAggregatorVariables = {
    name: 'replaceAggregatorVariables',
    fun: ({ SUBRULE }) => ({ astFactory: F }, s, map) => {
        const st = isSimpleTerm(s) ? SUBRULE(general_js_1.translateAlgTerm, s) : s;
        // Look for TermVariable, if we find, replace it by the aggregator.
        if (F.isTermVariable(st)) {
            if (map[st.value]) {
                // Returns the ExpressionAggregate
                return map[st.value];
            }
        }
        else if (Array.isArray(s)) {
            s = s.map(e => SUBRULE(exports.replaceAlgAggregatorVariables, e, map));
        }
        else if (typeof s === 'object') {
            const obj = s;
            for (const key of Object.keys(obj)) {
                obj[key] = SUBRULE(exports.replaceAlgAggregatorVariables, obj[key], map);
            }
        }
        return s;
    },
};
exports.translateAlgProject = {
    name: 'translateProject',
    fun: ({ SUBRULE }) => (c, op, type) => {
        const F = c.astFactory;
        const result = {
            type: 'query',
            solutionModifiers: {},
            loc: F.gen(),
            datasets: F.datasetClauses([], F.gen()),
            context: [],
        };
        // Makes typing easier in some places
        const select = result;
        let variables;
        if (type === index_js_1.types.PROJECT) {
            result.subType = 'select';
            variables = op.variables;
        }
        else if (type === index_js_1.types.ASK) {
            result.subType = 'ask';
        }
        else if (type === index_js_1.types.DESCRIBE) {
            result.subType = 'describe';
            variables = op.terms;
        }
        // Backup values in case of nested queries
        // everything in extend, group, etc. is irrelevant for this project call
        const extend = c.extend;
        const group = c.group;
        const aggregates = c.aggregates;
        const order = c.order;
        SUBRULE(core_js_1.resetContext);
        c.project = true;
        // TranslateOperation could give an array.
        let input = [SUBRULE(pattern_js_1.translateAlgPatternNew, op.input)].flat();
        if (input.length === 1 && F.isPatternGroup(input[0])) {
            input = (input[0]).patterns;
        }
        result.where = F.patternGroup(input, F.gen());
        // Map from variable to what agg it represents
        const aggregators = {};
        // These can not reference each other
        for (const agg of c.aggregates) {
            aggregators[SUBRULE(general_js_1.translateAlgTerm, agg.variable).value] =
                SUBRULE(expression_js_1.translateAlgPureExpression, agg);
        }
        // Do these in reverse order since variables in one extend might apply to an expression in another extend
        const extensions = {};
        for (const e of c.extend.reverse()) {
            const expr = SUBRULE(expression_js_1.translateAlgPureExpression, e.expression);
            extensions[SUBRULE(general_js_1.translateAlgTerm, e.variable).value] =
                SUBRULE(exports.replaceAlgAggregatorVariables, expr, aggregators);
        }
        SUBRULE(exports.registerAlgGroupBy, result, extensions);
        SUBRULE(exports.registerOrderBy, result);
        SUBRULE(exports.registerVariables, select, variables, extensions);
        SUBRULE(exports.putExtensionsInGroup, result, extensions);
        // Convert all filters to 'having' if it contains an aggregator variable
        // could always convert, but is nicer to keep as filter when possible
        const havings = [];
        result.where = SUBRULE(exports.filterReplace, result.where, aggregators, havings);
        if (havings.length > 0) {
            select.solutionModifiers.having = F.solutionModifierHaving(havings, F.gen());
        }
        // Recover state
        c.extend = extend;
        c.group = group;
        c.aggregates = aggregates;
        c.order = order;
        // Subqueries need to be in a group! Top level grouping is removed at toAst function
        return F.patternGroup([select], F.gen());
    },
};
exports.registerAlgGroupBy = {
    name: 'registerGroupBy',
    fun: ({ SUBRULE }) => ({ astFactory: F, group }, result, extensions) => {
        if (group.length > 0) {
            result.solutionModifiers.group = F.solutionModifierGroup(group.map((variable) => {
                const v = SUBRULE(general_js_1.translateAlgTerm, variable);
                if (extensions[v.value]) {
                    const result = extensions[v.value];
                    // Make sure there is only 1 'AS' statement
                    delete extensions[v.value];
                    return {
                        variable: v,
                        value: result,
                        loc: F.gen(),
                    };
                }
                return v;
            }), F.gen());
        }
    },
};
exports.registerOrderBy = {
    name: 'registerOrderBy',
    fun: ({ SUBRULE }) => ({ astFactory: F, order }, result) => {
        if (order.length > 0) {
            result.solutionModifiers.order = F.solutionModifierOrder(order
                .map(x => SUBRULE(expression_js_1.translateAlgExpressionOrOrdering, x))
                .map((o) => F.isExpression(o) ?
                {
                    expression: o,
                    descending: false,
                    loc: F.gen(),
                } :
                o), F.gen());
        }
    },
};
exports.registerVariables = {
    name: 'registerVariables',
    fun: ({ SUBRULE }) => ({ astFactory: F }, select, variables, extensions) => {
        if (variables) {
            select.variables = variables.map((term) => {
                const v = SUBRULE(general_js_1.translateAlgTerm, term);
                if (extensions[v.value]) {
                    const result = extensions[v.value];
                    // Remove used extensions so only unused ones remain
                    delete extensions[v.value];
                    return F.patternBind(result, v, F.gen());
                }
                return v;
            });
            // If the * didn't match any variables this would be empty
            if (select.variables.length === 0) {
                select.variables = [F.wildcard(F.gen())];
            }
        }
    },
};
/**
 * It is possible that at this point some extensions have not yet been resolved.
 * These would be bind operations that are not used in a GROUP BY or SELECT body.
 * We still need to add them though, as they could be relevant to the other extensions.
 */
exports.putExtensionsInGroup = {
    name: 'putExtensionsInGroup',
    fun: () => ({ astFactory: F }, result, extensions) => {
        const extensionEntries = Object.entries(extensions);
        if (extensionEntries.length > 0) {
            result.where = result.where ?? F.patternGroup([], F.gen());
            for (const [key, value] of extensionEntries) {
                result.where.patterns.push(F.patternBind(value, F.termVariable(key, F.gen()), F.gen()));
            }
        }
    },
};
/**
 * If second arg is a Group, we will return a group.
 */
exports.filterReplace = {
    name: 'filterReplace',
    fun: ({ SUBRULE }) => ({ astFactory: F }, group, aggregators, havings) => {
        if (!F.isPatternGroup(group)) {
            return group;
        }
        const patterns = group.patterns
            .map(x => SUBRULE(exports.filterReplace, x, aggregators, havings))
            .flatMap((pattern) => {
            if (F.isPatternFilter(pattern) && SUBRULE(exports.objectContainsVariable, pattern, Object.keys(aggregators))) {
                havings.push(SUBRULE(exports.replaceAlgAggregatorVariables, pattern.expression, aggregators));
                return [];
            }
            return [pattern];
        });
        return F.patternGroup(patterns, F.gen());
    },
};
exports.objectContainsVariable = {
    name: 'objectContainsVariable',
    fun: ({ SUBRULE }) => ({ astFactory: F }, o, vals) => {
        const casted = o;
        if (F.isTermVariable(casted)) {
            return vals.includes(casted.value);
        }
        if (Array.isArray(o)) {
            return o.some(e => SUBRULE(exports.objectContainsVariable, e, vals));
        }
        if (o === Object(o)) {
            return Object.keys(o).some(key => SUBRULE(exports.objectContainsVariable, o[key], vals));
        }
        return false;
    },
};
//# sourceMappingURL=queryUnit.js.map