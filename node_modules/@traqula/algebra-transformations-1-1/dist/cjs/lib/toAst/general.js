"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateAlgDistinct = exports.translateAlgReduced = exports.translateAlgPattern = exports.translateAlgOrderBy = exports.translateAlgDatasetClauses = exports.translateAlgExtend = exports.translateAlgTerm = void 0;
const index_js_1 = require("../index.js");
const expression_js_1 = require("./expression.js");
const pattern_js_1 = require("./pattern.js");
exports.translateAlgTerm = {
    name: 'translateTerm',
    fun: ({ SUBRULE }) => ({ astFactory: F }, term) => {
        if (term.termType === 'NamedNode') {
            return F.termNamed(F.gen(), term.value);
        }
        if (term.termType === 'BlankNode') {
            return F.termBlank(term.value, F.gen());
        }
        if (term.termType === 'Variable') {
            return F.termVariable(term.value, F.gen());
        }
        if (term.termType === 'Literal') {
            return F.termLiteral(F.gen(), term.value, term.language ? term.language : SUBRULE(exports.translateAlgTerm, term.datatype));
        }
        throw new Error(`invalid term type: ${term.termType}`);
    },
};
/**
 * Extend is for example a bind, or an aggregator.
 * The result is thus registered to be tackled at the project level,
 *  or if we are not in project scope, we give it as a patternBind
 *  - of course, the pattern bind is scoped with the other operations at this level
 */
exports.translateAlgExtend = {
    name: 'translateExtend',
    fun: ({ SUBRULE }) => ({ astFactory: F, project, extend }, op) => {
        if (project) {
            extend.push(op);
            return SUBRULE(pattern_js_1.translateAlgPatternNew, op.input);
        }
        // Many extends can be put in a single group
        const extendsOperations = [];
        function collectExtends(op) {
            if (op.type === index_js_1.Algebra.Types.EXTEND) {
                extendsOperations.push(op);
                return collectExtends(op.input);
            }
            return op;
        }
        const input = collectExtends(op);
        return F.patternGroup([
            SUBRULE(pattern_js_1.translateAlgPatternNew, input),
            ...extendsOperations.reverse().map(extend => F.patternBind(SUBRULE(expression_js_1.translateAlgPureExpression, extend.expression), SUBRULE(exports.translateAlgTerm, extend.variable), F.gen())),
        ].flat(), F.gen());
    },
};
exports.translateAlgDatasetClauses = {
    name: 'translateDatasetClauses',
    fun: ({ SUBRULE }) => ({ astFactory: F }, _default, named) => F.datasetClauses([
        ..._default.map(x => ({
            clauseType: 'default',
            value: SUBRULE(exports.translateAlgTerm, x),
        })),
        ...named.map(x => ({
            clauseType: 'named',
            value: SUBRULE(exports.translateAlgTerm, x),
        })),
    ], F.gen()),
};
/**
 * An order by is just registered to be handled in the creation of your QueryBase
 */
exports.translateAlgOrderBy = {
    name: 'translateOrderBy',
    fun: ({ SUBRULE }) => ({ order }, op) => {
        order.push(...op.expressions);
        return SUBRULE(pattern_js_1.translateAlgPatternNew, op.input);
    },
};
exports.translateAlgPattern = {
    name: 'translatePattern',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.triple(SUBRULE(exports.translateAlgTerm, op.subject), SUBRULE(exports.translateAlgTerm, op.predicate), SUBRULE(exports.translateAlgTerm, op.object)),
};
/**
 * Reduced is wrapped around a project, set the query contained to be distinct
 */
exports.translateAlgReduced = {
    name: 'translateReduced',
    fun: ({ SUBRULE }) => (_, op) => {
        const result = SUBRULE(pattern_js_1.translateAlgPatternIntoGroup, op.input);
        const select = result.patterns[0];
        select.reduced = true;
        return result;
    },
};
/**
 * District is wrapped around a project, set the query contained to be distinct
 */
exports.translateAlgDistinct = {
    name: 'translateDistinct',
    fun: ({ SUBRULE }) => (_, op) => {
        const result = SUBRULE(pattern_js_1.translateAlgPatternIntoGroup, op.input);
        const select = result.patterns[0];
        select.distinct = true;
        return result;
    },
};
//# sourceMappingURL=general.js.map