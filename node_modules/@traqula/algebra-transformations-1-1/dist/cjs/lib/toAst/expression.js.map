{"version":3,"file":"expression.js","sourceRoot":"","sources":["../../../../lib/toAst/expression.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  Expression,\n  ExpressionAggregate,\n  ExpressionFunctionCall,\n  ExpressionOperation,\n  ExpressionPatternOperation,\n  Ordering,\n  Wildcard,\n} from '@traqula/rules-sparql-1-1';\nimport type { Algebra } from '../index.js';\nimport type { AstIndir } from './core.js';\nimport { eTypes } from './core.js';\nimport { type RdfTermToAst, translateAlgTerm } from './general.js';\nimport { translateAlgPatternNew } from './pattern.js';\n\nexport const translateAlgPureExpression: AstIndir<'translatePureExpression', Expression, [Algebra.Expression]> = {\n  name: 'translatePureExpression',\n  fun: ({ SUBRULE }) => (_, expr) => {\n    switch (expr.subType) {\n      case eTypes.AGGREGATE:\n        return SUBRULE(translateAlgAggregateExpression, expr);\n      case eTypes.EXISTENCE:\n        return SUBRULE(translateAlgExistenceExpression, expr);\n      case eTypes.NAMED:\n        return SUBRULE(translateAlgNamedExpression, expr);\n      case eTypes.OPERATOR:\n        return SUBRULE(translateAlgPureOperatorExpression, expr);\n      case eTypes.TERM:\n        return <Expression> SUBRULE(translateAlgTerm, expr.term);\n      default:\n        throw new Error(`Unknown Expression Operation type ${expr.subType}`);\n    }\n  },\n};\n\nexport const translateAlgExpressionOrWild:\nAstIndir<'translateExpressionOrWild', Expression | Wildcard, [Algebra.Expression]> = {\n  name: 'translateExpressionOrWild',\n  fun: ({ SUBRULE }) => (_, expr) => expr.subType === eTypes.WILDCARD ?\n    SUBRULE(translateAlgWildcardExpression, expr) :\n    SUBRULE(translateAlgPureExpression, expr),\n};\n\nexport const translateAlgExpressionOrOrdering:\nAstIndir<'translateExpressionOrOrdering', Expression | Ordering, [Algebra.Expression]> = {\n  name: 'translateExpressionOrOrdering',\n  fun: ({ SUBRULE }) => (_, expr) =>\n    expr.subType === eTypes.OPERATOR ?\n      SUBRULE(translateAlgOperatorExpression, expr) :\n      SUBRULE(translateAlgPureExpression, expr),\n};\n\nexport const translateAlgAnyExpression:\nAstIndir<'translateAnyExpression', Expression | Ordering | Wildcard, [Algebra.Expression]> = {\n  name: 'translateAnyExpression',\n  fun: ({ SUBRULE }) => (_, expr) => expr.subType === eTypes.OPERATOR ?\n    SUBRULE(translateAlgOperatorExpression, expr) :\n    SUBRULE(translateAlgExpressionOrWild, expr),\n};\n\nexport const translateAlgAggregateExpression:\nAstIndir<'translateAggregateExpression', ExpressionAggregate, [Algebra.AggregateExpression]> = {\n  name: 'translateAggregateExpression',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, expr) =>\n    F.aggregate(\n      expr.aggregator,\n      expr.distinct,\n      SUBRULE(translateAlgExpressionOrWild, expr.expression),\n      expr.separator,\n      F.gen(),\n    ),\n};\n\nexport const translateAlgExistenceExpression:\nAstIndir<'translateExistenceExpression', ExpressionPatternOperation, [Algebra.ExistenceExpression]> = {\n  name: 'translateExistenceExpression',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, expr) =>\n    F.expressionPatternOperation(\n      expr.not ? 'notexists' : 'exists',\n      // TranslateOperation can give an array\n      F.patternGroup([ SUBRULE(translateAlgPatternNew, expr.input) ].flat(), F.gen()),\n      F.gen(),\n    ),\n};\n\nexport const translateAlgNamedExpression:\nAstIndir<'translateNamedExpression', ExpressionFunctionCall, [Algebra.NamedExpression]> = {\n  name: 'translateNamedExpression',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, expr) =>\n    F.expressionFunctionCall(\n      <RdfTermToAst<typeof expr.name>> SUBRULE(translateAlgTerm, expr.name),\n      expr.args.map(x => SUBRULE(translateAlgPureExpression, x)),\n      false,\n      F.gen(),\n    ),\n};\n\nexport const translateAlgPureOperatorExpression:\nAstIndir<'translatePureOperatorExpression', ExpressionOperation, [Algebra.OperatorExpression]> = {\n  name: 'translatePureOperatorExpression',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, expr) =>\n    F.expressionOperation(\n      expr.operator,\n      expr.args.map(x => SUBRULE(translateAlgPureExpression, x)),\n      F.gen(),\n    ),\n};\n\nexport const translateAlgOperatorExpression:\nAstIndir<'translateOperatorExpression', Ordering | ExpressionOperation, [Algebra.OperatorExpression]> = {\n  name: 'translateOperatorExpression',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, expr) => {\n    if (expr.operator === 'desc') {\n      return { expression: SUBRULE(translateAlgPureExpression, expr.args[0]), descending: true, loc: F.gen() };\n    }\n    return SUBRULE(translateAlgPureOperatorExpression, expr);\n  },\n};\n\nexport const translateAlgWildcardExpression:\nAstIndir<'translateWildcardExpression', Wildcard, [ Algebra.WildcardExpression ]> = {\n  name: 'translateWildcardExpression',\n  fun: () => ({ astFactory: F }, _) =>\n    F.wildcard(F.gen()),\n};\n"]}