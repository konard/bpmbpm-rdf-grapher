"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateUpdateGraphLoad = exports.translateGraphRef = exports.translateGraphRefDefSpec = exports.translateGraphRefSpecific = exports.translateUpdateTriplesBlock = exports.translateInsertDelete = exports.translateSingleUpdate = exports.translateUpdate = void 0;
const general_js_1 = require("./general.js");
const patterns_js_1 = require("./patterns.js");
const tripleAndQuad_js_1 = require("./tripleAndQuad.js");
exports.translateUpdate = {
    name: 'translateUpdate',
    fun: ({ SUBRULE }) => ({ algebraFactory: AF }, thingy) => {
        const updates = thingy.updates.flatMap((update) => {
            SUBRULE(general_js_1.registerContextDefinitions, update.context);
            return update.operation ? [SUBRULE(exports.translateSingleUpdate, update.operation)] : [];
        });
        if (updates.length === 0) {
            return AF.createNop();
        }
        if (updates.length === 1) {
            return updates[0];
        }
        return AF.createCompositeUpdate(updates);
    },
};
exports.translateSingleUpdate = {
    name: 'translateSingleUpdate',
    fun: ({ SUBRULE }) => ({ astFactory: F, algebraFactory: AF }, op) => {
        if (F.isUpdateOperationLoad(op)) {
            return SUBRULE(exports.translateUpdateGraphLoad, op);
        }
        if (F.isUpdateOperationClear(op)) {
            return AF.createClear(SUBRULE(exports.translateGraphRef, op.destination), op.silent);
        }
        if (F.isUpdateOperationCreate(op)) {
            return AF.createCreate(SUBRULE(exports.translateGraphRef, op.destination), op.silent);
        }
        if (F.isUpdateOperationDrop(op)) {
            return AF.createDrop(SUBRULE(exports.translateGraphRef, op.destination), op.silent);
        }
        if (F.isUpdateOperationAdd(op)) {
            return AF.createAdd(SUBRULE(exports.translateGraphRefDefSpec, op.source), SUBRULE(exports.translateGraphRefDefSpec, op.destination), op.silent);
        }
        if (F.isUpdateOperationCopy(op)) {
            return AF.createCopy(SUBRULE(exports.translateGraphRefDefSpec, op.source), SUBRULE(exports.translateGraphRefDefSpec, op.destination), op.silent);
        }
        if (F.isUpdateOperationMove(op)) {
            return AF.createMove(SUBRULE(exports.translateGraphRefDefSpec, op.source), SUBRULE(exports.translateGraphRefDefSpec, op.destination), op.silent);
        }
        if (F.isUpdateOperationInsertData(op) || F.isUpdateOperationDeleteData(op) || F.isUpdateOperationDeleteWhere(op) ||
            F.isUpdateOperationModify(op)) {
            return SUBRULE(exports.translateInsertDelete, op);
        }
        throw new Error(`Unknown update type ${JSON.stringify(op)}`);
    },
};
exports.translateInsertDelete = {
    name: 'translateInsertDelete',
    fun: ({ SUBRULE }) => ({ useQuads, algebraFactory: AF, astFactory: F }, op) => {
        if (!useQuads) {
            throw new Error('INSERT/DELETE operations are only supported with quads option enabled');
        }
        const deleteTriples = [];
        const insertTriples = [];
        let where;
        if (F.isUpdateOperationDeleteData(op) || F.isUpdateOperationDeleteWhere(op)) {
            deleteTriples.push(...op.data.flatMap(quad => SUBRULE(exports.translateUpdateTriplesBlock, quad, undefined)));
            if (F.isUpdateOperationDeleteWhere(op)) {
                where = AF.createBgp(deleteTriples);
            }
        }
        else if (F.isUpdateOperationInsertData(op)) {
            insertTriples.push(...op.data.flatMap(quad => SUBRULE(exports.translateUpdateTriplesBlock, quad, undefined)));
        }
        else {
            deleteTriples.push(...op.delete.flatMap(quad => SUBRULE(exports.translateUpdateTriplesBlock, quad, op.graph ? SUBRULE(general_js_1.translateNamed, op.graph) : op.graph)));
            insertTriples.push(...op.insert.flatMap(quad => SUBRULE(exports.translateUpdateTriplesBlock, quad, op.graph ? SUBRULE(general_js_1.translateNamed, op.graph) : op.graph)));
            if (op.where.patterns.length > 0) {
                where = SUBRULE(patterns_js_1.translateGraphPattern, op.where);
                const use = SUBRULE(general_js_1.translateDatasetClause, op.from);
                if (use.default.length > 0 || use.named.length > 0) {
                    where = AF.createFrom(where, use.default, use.named);
                }
                else if (F.isUpdateOperationModify(op) && op.graph) {
                    // This is equivalent
                    where = SUBRULE(tripleAndQuad_js_1.recurseGraph, where, SUBRULE(general_js_1.translateNamed, op.graph), undefined);
                }
            }
        }
        return AF.createDeleteInsert(deleteTriples.length > 0 ? deleteTriples : undefined, insertTriples.length > 0 ? insertTriples : undefined, where);
    },
};
// UPDATE parsing will always return quads and have no GRAPH elements
exports.translateUpdateTriplesBlock = {
    name: 'translateUpdateTriplesBlock',
    fun: ({ SUBRULE }) => (c, thingy, graph) => {
        const F = c.astFactory;
        let currentGraph = graph;
        let patternBgp;
        if (F.isGraphQuads(thingy)) {
            currentGraph = SUBRULE(general_js_1.translateTerm, thingy.graph);
            patternBgp = thingy.triples;
        }
        else {
            patternBgp = thingy;
        }
        let triples = [];
        SUBRULE(tripleAndQuad_js_1.translateBasicGraphPattern, patternBgp.triples, triples);
        if (currentGraph) {
            triples = triples.map(triple => Object.assign(triple, { graph: currentGraph }));
        }
        return triples.map(triple => SUBRULE(tripleAndQuad_js_1.translateQuad, triple));
    },
};
exports.translateGraphRefSpecific = {
    name: 'translateGraphRefSpecific',
    fun: ({ SUBRULE }) => (_, graph) => SUBRULE(general_js_1.translateNamed, graph.graph),
};
exports.translateGraphRefDefSpec = {
    name: 'translateGraphRefDefSpec',
    fun: ({ SUBRULE }) => ({ astFactory: F }, graph) => F.isGraphRefDefault(graph) ? 'DEFAULT' : SUBRULE(exports.translateGraphRefSpecific, graph),
};
exports.translateGraphRef = {
    name: 'translateGraphRef',
    fun: ({ SUBRULE }) => (c, graph) => {
        const F = c.astFactory;
        if (F.isGraphRefAll(graph)) {
            return 'ALL';
        }
        if (F.isGraphRefNamed(graph)) {
            return 'NAMED';
        }
        return SUBRULE(exports.translateGraphRefDefSpec, graph);
    },
};
exports.translateUpdateGraphLoad = {
    name: 'translateUpdateGraphLoad',
    fun: ({ SUBRULE }) => ({ algebraFactory: AF }, op) => AF.createLoad(SUBRULE(general_js_1.translateNamed, op.source), op.destination ? SUBRULE(general_js_1.translateNamed, op.destination.graph) : undefined, op.silent),
};
//# sourceMappingURL=updates.js.map