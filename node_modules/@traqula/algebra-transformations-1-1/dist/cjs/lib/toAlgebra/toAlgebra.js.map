{"version":3,"file":"toAlgebra.js","sourceRoot":"","sources":["../../../../lib/toAlgebra/toAlgebra.ts"],"names":[],"mappings":";;;AAEA,iDAAqD;AAErD,6CAIsB;AACtB,+CAEuB;AACvB,6CAEsB;AAET,QAAA,cAAc,GACkF;IAC3G,IAAI,EAAE,gBAAgB;IACtB,GAAG,EAAE,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,eAAe,EAAE,EAAE;QAC1D,MAAM,CAAC,GAAG,CAAC,CAAC,UAAU,CAAC;QACvB,CAAC,CAAC,SAAS,GAAG,IAAI,GAAG,EAAE,CAAC;QACxB,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC;QACf,CAAC,CAAC,QAAQ,GAAG,KAAK,IAAI,KAAK,CAAC;QAE5B,IAAI,MAAyB,CAAC;QAE9B,uFAAuF;QACvF,OAAO,CAAC,6BAAgB,EAAE,MAAM,CAAC,CAAC;QAElC,IAAI,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC;YACtB,OAAO,CAAC,uCAA0B,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;YACpD,kGAAkG;YAClG,MAAM,KAAK,GAAiB,MAAM,CAAC,KAAK,IAAI,CAAC,CAAC,YAAY,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;YACxE,MAAM,GAAG,OAAO,CAAC,mCAAqB,EAAE,KAAK,CAAC,CAAC;YAC/C,2FAA2F;YAC3F,MAAM,GAAG,OAAO,CAAC,kCAAmB,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;QACxD,CAAC;aAAM,CAAC;YACN,MAAM,GAAG,OAAO,CAAC,4BAAe,EAAE,MAAM,CAAC,CAAC;QAC5C,CAAC;QACD,IAAI,eAAe,EAAE,CAAC;YACpB,MAAM,GAAG,OAAO,CAAC,2CAA8B,EAAE,MAAM,CAAC,CAAC;QAC3D,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;CACF,CAAC","sourcesContent":["import type { PatternGroup, SparqlQuery } from '@traqula/rules-sparql-1-1';\nimport type { Algebra } from '../index.js';\nimport { translateAggregates } from './aggregate.js';\nimport type { AlgebraIndir } from './core.js';\nimport {\n  findAllVariables,\n  registerContextDefinitions,\n  translateBlankNodesToVariables,\n} from './general.js';\nimport {\n  translateGraphPattern,\n} from './patterns.js';\nimport {\n  translateUpdate,\n} from './updates.js';\n\nexport const translateQuery:\nAlgebraIndir<'translateQuery', Algebra.Operation, [SparqlQuery, boolean | undefined, boolean | undefined]> = {\n  name: 'translateQuery',\n  fun: ({ SUBRULE }) => (c, sparql, quads, blankToVariable) => {\n    const F = c.astFactory;\n    c.variables = new Set();\n    c.varCount = 0;\n    c.useQuads = quads ?? false;\n\n    let result: Algebra.Operation;\n\n    // Find ALL variables here to fill `variables` array - needed to create fresh variables\n    SUBRULE(findAllVariables, sparql);\n\n    if (F.isQuery(sparql)) {\n      SUBRULE(registerContextDefinitions, sparql.context);\n      // Group and where are identical, having only 1 makes parsing easier, can be undefined in DESCRIBE\n      const group: PatternGroup = sparql.where ?? F.patternGroup([], F.gen());\n      result = SUBRULE(translateGraphPattern, group);\n      // 18.2.4 Converting Groups, Aggregates, HAVING, final VALUES clause and SELECT Expressions\n      result = SUBRULE(translateAggregates, sparql, result);\n    } else {\n      result = SUBRULE(translateUpdate, sparql);\n    }\n    if (blankToVariable) {\n      result = SUBRULE(translateBlankNodesToVariables, result);\n    }\n\n    return result;\n  },\n};\n"]}