{"version":3,"file":"core.js","sourceRoot":"","sources":["../../../../lib/toAlgebra/core.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,oDAaC;AAaD,wBAEC;AAGD,4BAEC;AAED,gCAEC;AA7DD,gEAAuE;AACvE,uDAA+C;AAC/C,uDAAyC;AACzC,4DAAsD;AAqBtD,SAAgB,oBAAoB,CAAC,MAAsB;IACzD,MAAM,WAAW,GAAG,MAAM,CAAC,WAAW,IAAI,IAAI,8BAAW,EAAgB,CAAC;IAC1E,OAAO;QACL,SAAS,EAAE,IAAI,GAAG,EAAU;QAC5B,QAAQ,EAAE,CAAC;QACX,QAAQ,EAAE,KAAK;QACf,WAAW,EAAE,IAAI,iCAAc,EAAE;QACjC,UAAU,EAAE,IAAI,6BAAU,EAAE;QAC5B,WAAW;QACX,cAAc,EAAE,IAAI,kCAAc,CAAC,WAAW,CAAC;QAC/C,WAAW,EAAE,MAAM,CAAC,OAAO;QAC3B,eAAe,EAAE,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE;KAC/D,CAAC;AACJ,CAAC;AAUY,QAAA,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;AACtB,QAAA,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,aAAK,CAAC,CAAC;AAE7C,SAAgB,MAAM,CAAC,IAAS;IAC9B,OAAO,OAAO,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AACjC,CAAC;AAED,8EAA8E;AAC9E,SAAgB,QAAQ,CAAC,MAAW;IAClC,OAAO,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,SAAS,IAAI,MAAM,CAAC,MAAM,CAAC;AAC7D,CAAC;AAED,SAAgB,UAAU,CAAC,IAAc;IACvC,OAAO,IAAI,EAAE,QAAQ,KAAK,UAAU,CAAC;AACvC,CAAC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { IndirDef } from '@traqula/core';\nimport type { PathPure } from '@traqula/rules-sparql-1-1';\nimport { AstFactory, AstTransformer } from '@traqula/rules-sparql-1-1';\nimport { DataFactory } from 'rdf-data-factory';\nimport * as Algebra from '../algebra.js';\nimport { AlgebraFactory } from '../algebraFactory.js';\n\nexport interface AlgebraContext {\n  variables: Set<string>;\n  varCount: number;\n  useQuads: boolean;\n  algebraFactory: AlgebraFactory;\n  transformer: AstTransformer;\n  astFactory: AstFactory;\n  dataFactory: RDF.DataFactory<RDF.BaseQuad> & { variable: Function };\n  currentBase: string | undefined;\n  currentPrefixes: Record<string, string>;\n}\n\nexport interface ContextConfigs {\n  dataFactory?: RDF.DataFactory<RDF.BaseQuad> & { variable: Function };\n  quads?: boolean;\n  prefixes?: Record<string, string>;\n  baseIRI?: string;\n  blankToVariable?: boolean;\n}\nexport function createAlgebraContext(config: ContextConfigs): AlgebraContext {\n  const dataFactory = config.dataFactory ?? new DataFactory<RDF.BaseQuad>();\n  return {\n    variables: new Set<string>(),\n    varCount: 0,\n    useQuads: false,\n    transformer: new AstTransformer(),\n    astFactory: new AstFactory(),\n    dataFactory,\n    algebraFactory: new AlgebraFactory(dataFactory),\n    currentBase: config.baseIRI,\n    currentPrefixes: config.prefixes ? { ...config.prefixes } : {},\n  };\n}\n\nexport type AlgebraIndir<Name extends string, Ret, Arg extends any[]> = IndirDef<AlgebraContext, Name, Ret, Arg>;\n\nexport interface FlattenedTriple {\n  subject: RDF.Term;\n  predicate: RDF.Term | PathPure;\n  object: RDF.Term;\n}\n\nexport const types = Algebra.Types;\nexport const typeVals = Object.values(types);\n\nexport function isTerm(term: any): term is RDF.Term {\n  return Boolean(term?.termType);\n}\n\n// This is not completely correct but this way we also catch SPARQL.js triples\nexport function isTriple(triple: any): triple is RDF.Quad {\n  return triple.subject && triple.predicate && triple.object;\n}\n\nexport function isVariable(term: RDF.Term): term is RDF.Variable {\n  return term?.termType === 'Variable';\n}\n"]}