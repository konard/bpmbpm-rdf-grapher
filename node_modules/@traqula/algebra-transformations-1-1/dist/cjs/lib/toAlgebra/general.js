"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateFreshVar = exports.inScopeVariables = exports.findAllVariables = exports.translateBlankNodesToVariables = exports.translateDatasetClause = exports.translateInlineData = exports.registerContextDefinitions = exports.translateTerm = exports.translateNamed = void 0;
const rules_sparql_1_1_1 = require("@traqula/rules-sparql-1-1");
const Algebra = __importStar(require("../algebra.js"));
const util = __importStar(require("../util.js"));
exports.translateNamed = {
    name: 'translateNamed',
    fun: () => ({ astFactory: F, currentPrefixes, currentBase, dataFactory }, term) => {
        let fullIri = term.value;
        if (F.isTermNamedPrefixed(term)) {
            const expanded = currentPrefixes[term.prefix];
            if (!expanded) {
                throw new Error(`Unknown prefix: ${term.prefix}`);
            }
            fullIri = expanded + term.value;
        }
        return dataFactory.namedNode(util.resolveIRI(fullIri, currentBase));
    },
};
exports.translateTerm = {
    name: 'translateTerm',
    fun: ({ SUBRULE }) => ({ astFactory: F, dataFactory }, term) => {
        if (F.isTermNamed(term)) {
            return SUBRULE(exports.translateNamed, term);
        }
        if (F.isTermBlank(term)) {
            return dataFactory.blankNode(term.label);
        }
        if (F.isTermVariable(term)) {
            return dataFactory.variable(term.value);
        }
        if (F.isTermLiteral(term)) {
            const langOrIri = typeof term.langOrIri === 'object' ?
                SUBRULE(exports.translateNamed, term.langOrIri) :
                term.langOrIri;
            return dataFactory.literal(term.value, langOrIri);
        }
        throw new Error(`Unexpected term: ${JSON.stringify(term)}`);
    },
};
exports.registerContextDefinitions = {
    name: 'registerContextDefinitions',
    fun: ({ SUBRULE }) => (c, definitions) => {
        const { astFactory: F, currentPrefixes } = c;
        for (const def of definitions) {
            if (F.isContextDefinitionPrefix(def)) {
                currentPrefixes[def.key] = SUBRULE(exports.translateTerm, def.value).value;
            }
            if (F.isContextDefinitionBase(def)) {
                c.currentBase = SUBRULE(exports.translateTerm, def.value).value;
            }
        }
    },
};
exports.translateInlineData = {
    name: 'translateInlineData',
    fun: ({ SUBRULE }) => ({ algebraFactory: AF }, values) => {
        const variables = values.variables.map(x => SUBRULE(exports.translateTerm, x));
        const bindings = values.values.map((binding) => {
            const map = {};
            for (const [key, value] of Object.entries(binding)) {
                if (value !== undefined) {
                    map[key] = SUBRULE(exports.translateTerm, value);
                }
            }
            return map;
        });
        return AF.createValues(variables, bindings);
    },
};
exports.translateDatasetClause = {
    name: 'translateDatasetClause',
    fun: ({ SUBRULE }) => (_, dataset) => ({
        default: dataset.clauses.filter(x => x.clauseType === 'default')
            .map(x => SUBRULE(exports.translateNamed, x.value)),
        named: dataset.clauses.filter(x => x.clauseType === 'named')
            .map(x => SUBRULE(exports.translateNamed, x.value)),
    }),
};
exports.translateBlankNodesToVariables = {
    name: 'translateBlankNodesToVariables',
    fun: ({ SUBRULE }) => ({ algebraFactory: AF, variables }, res) => {
        const blankToVariableMapping = {};
        const variablesRaw = new Set(variables);
        function uniqueVar(label) {
            let counter = 0;
            let labelLoop = label;
            while (variables.has(labelLoop)) {
                labelLoop = `${label}${counter++}`;
            }
            return AF.dataFactory.variable(labelLoop);
        }
        ;
        function blankToVariable(term) {
            if (term.termType === 'BlankNode') {
                let variable = blankToVariableMapping[term.value];
                if (!variable) {
                    variable = uniqueVar(term.value);
                    variablesRaw.add(variable.value);
                    blankToVariableMapping[term.value] = variable;
                }
                return variable;
            }
            if (term.termType === 'Quad') {
                return AF.dataFactory.quad(blankToVariable(term.subject), blankToVariable(term.predicate), blankToVariable(term.object), blankToVariable(term.graph));
            }
            return term;
        }
        return util.mapOperation(res, {
            [Algebra.Types.PATH]: {
                preVisitor: () => ({ continue: false }),
                transform: pathOp => AF.createPath(blankToVariable(pathOp.subject), pathOp.predicate, blankToVariable(pathOp.object), blankToVariable(pathOp.graph)),
            },
            [Algebra.Types.PATTERN]: {
                preVisitor: () => ({ continue: false }),
                transform: patternOp => AF.createPattern(blankToVariable(patternOp.subject), blankToVariable(patternOp.predicate), blankToVariable(patternOp.object), blankToVariable(patternOp.graph)),
            },
            [Algebra.Types.CONSTRUCT]: {
                preVisitor: () => ({ continue: false }),
                // Blank nodes in CONSTRUCT templates must be maintained
                transform: constructOp => AF.createConstruct(SUBRULE(exports.translateBlankNodesToVariables, constructOp.input), constructOp.template),
            },
            [Algebra.Types.DELETE_INSERT]: {
                preVisitor: () => ({ continue: false }),
                transform: delInsOp => 
                // Make sure blank nodes remain in the INSERT block, but do update the WHERE block
                AF.createDeleteInsert(delInsOp.delete, delInsOp.insert, delInsOp.where && SUBRULE(exports.translateBlankNodesToVariables, delInsOp.where)),
            },
        });
    },
};
/**
 * Will be used to make sure new variables don't overlap
 */
exports.findAllVariables = {
    name: 'findAllVariables',
    fun: () => ({ transformer, variables }, thingy) => {
        transformer.visitNodeSpecific(thingy, {}, { term: { variable: { visitor: (_var) => {
                        variables.add(_var.value);
                    } } } });
    },
};
/**
 * 18.2.1
 */
exports.inScopeVariables = {
    name: 'inScopeVariables',
    fun: () => (_, thingy) => {
        const vars = new Set();
        (0, rules_sparql_1_1_1.findPatternBoundedVars)(thingy, vars);
        return vars;
    },
};
exports.generateFreshVar = {
    name: 'generateFreshVar',
    fun: () => (c) => {
        let newVar = `var${c.varCount++}`;
        while (c.variables.has(newVar)) {
            newVar = `var${c.varCount++}`;
        }
        c.variables.add(newVar);
        return c.dataFactory.variable(newVar);
    },
};
//# sourceMappingURL=general.js.map