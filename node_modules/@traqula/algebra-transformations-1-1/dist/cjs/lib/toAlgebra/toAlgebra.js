"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateQuery = void 0;
const aggregate_js_1 = require("./aggregate.js");
const general_js_1 = require("./general.js");
const patterns_js_1 = require("./patterns.js");
const updates_js_1 = require("./updates.js");
exports.translateQuery = {
    name: 'translateQuery',
    fun: ({ SUBRULE }) => (c, sparql, quads, blankToVariable) => {
        const F = c.astFactory;
        c.variables = new Set();
        c.varCount = 0;
        c.useQuads = quads ?? false;
        let result;
        // Find ALL variables here to fill `variables` array - needed to create fresh variables
        SUBRULE(general_js_1.findAllVariables, sparql);
        if (F.isQuery(sparql)) {
            SUBRULE(general_js_1.registerContextDefinitions, sparql.context);
            // Group and where are identical, having only 1 makes parsing easier, can be undefined in DESCRIBE
            const group = sparql.where ?? F.patternGroup([], F.gen());
            result = SUBRULE(patterns_js_1.translateGraphPattern, group);
            // 18.2.4 Converting Groups, Aggregates, HAVING, final VALUES clause and SELECT Expressions
            result = SUBRULE(aggregate_js_1.translateAggregates, sparql, result);
        }
        else {
            result = SUBRULE(updates_js_1.translateUpdate, sparql);
        }
        if (blankToVariable) {
            result = SUBRULE(general_js_1.translateBlankNodesToVariables, result);
        }
        return result;
    },
};
//# sourceMappingURL=toAlgebra.js.map