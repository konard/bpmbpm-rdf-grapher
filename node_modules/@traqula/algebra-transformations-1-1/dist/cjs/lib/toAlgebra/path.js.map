{"version":3,"file":"path.js","sourceRoot":"","sources":["../../../../lib/toAlgebra/path.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Path, PathNegatedElt, PathPure, TermIri } from '@traqula/rules-sparql-1-1';\nimport { Types } from '../algebra.js';\nimport type { Algebra } from '../index.js';\nimport type { AlgebraIndir, FlattenedTriple } from './core.js';\nimport { isTerm } from './core.js';\nimport { generateFreshVar, translateNamed } from './general.js';\n\n/**\n * 18.2.2.3 Translate Property Path Expressions\n * 18.2.2.4 Translate Property Path Patterns\n */\nexport const translatePath:\nAlgebraIndir<'translatePath', (Algebra.Path | Algebra.Pattern)[], [FlattenedTriple & { predicate: PathPure }]> = {\n  name: 'translatePath',\n  fun: ({ SUBRULE }) => (_, triple) => {\n    const sub = triple.subject;\n    const pred = SUBRULE(translatePathPredicate, triple.predicate);\n    const obj = triple.object;\n\n    return SUBRULE(simplifyPath, sub, pred, obj);\n  },\n};\n\n/**\n * 18.2.2.3 Translate Property Path Expressions\n */\nexport const translatePathPredicate:\nAlgebraIndir<'translatePathPredicate', Algebra.PropertyPathSymbol, [RDF.NamedNode | Path]> = {\n  name: 'translatePathPredicate',\n  fun: ({ SUBRULE }) => ({ astFactory: F, algebraFactory: AF }, predicate) => {\n    if (F.isTerm(predicate)) {\n      return SUBRULE(translatePathPredicate, SUBRULE(translateNamed, predicate));\n    }\n    // Iri -> link(iri)\n    if (isTerm(predicate)) {\n      return AF.createLink(predicate);\n    }\n\n    // ^path -> inv(path)\n    if (predicate.subType === '^') {\n      return AF.createInv(SUBRULE(translatePathPredicate, predicate.items[0]));\n    }\n\n    if (predicate.subType === '!') {\n      // Negation is either over a single predicate or a list of disjuncted properties - that can only have modifier '^'\n      const normals: TermIri[] = [];\n      const inverted: TermIri[] = [];\n      // Either the item of this one is an `|`, `^` or `iri`\n      const contained = predicate.items[0];\n      let items: (TermIri | PathNegatedElt)[];\n      if (F.isPathPure(contained) && contained.subType === '|') {\n        items = contained.items;\n      } else {\n        items = [ contained ];\n      }\n\n      for (const item of items) {\n        if (F.isTerm(item)) {\n          normals.push(item);\n        } else if (item.subType === '^') {\n          inverted.push(item.items[0]);\n        } else {\n          throw new Error(`Unexpected item: ${JSON.stringify(item)}`);\n        }\n      }\n\n      // NPS elements do not have the LINK function\n      const normalElement = AF.createNps(normals.map(x => SUBRULE(translateNamed, x)));\n      const invertedElement = AF.createInv(AF.createNps(inverted.map(x => SUBRULE(translateNamed, x))));\n\n      // !(:iri1|...|:irin) -> NPS({:iri1 ... :irin})\n      if (inverted.length === 0) {\n        return normalElement;\n      }\n      // !(^:iri1|...|^:irin) -> inv(NPS({:iri1 ... :irin}))\n      if (normals.length === 0) {\n        return invertedElement;\n      }\n      // !(:iri1|...|:irii|^:irii+1|...|^:irim -> alt(NPS({:iri1 ...:irii}), inv(NPS({:irii+1, ..., :irim})) )\n      return AF.createAlt([ normalElement, invertedElement ]);\n    }\n\n    // Path1 / path -> seq(path1, path2)\n    if (predicate.subType === '/') {\n      return AF.createSeq(predicate.items.map(item => SUBRULE(translatePathPredicate, <PathPure> item)));\n    }\n    // Path1 | path2 -> alt(path1, path2)\n    if (predicate.subType === '|') {\n      return AF.createAlt(predicate.items.map(item => SUBRULE(translatePathPredicate, <PathPure> item)));\n    }\n    // Path* -> ZeroOrMorePath(path)\n    if (predicate.subType === '*') {\n      return AF.createZeroOrMorePath(SUBRULE(translatePathPredicate, <PathPure> predicate.items[0]));\n    }\n    // Path+ -> OneOrMorePath(path)\n    if (predicate.subType === '+') {\n      return AF.createOneOrMorePath(SUBRULE(translatePathPredicate, <PathPure> predicate.items[0]));\n    }\n    // Path? -> ZeroOrOnePath(path)\n    if (predicate.subType === '?') {\n      return AF.createZeroOrOnePath(SUBRULE(translatePathPredicate, <PathPure> predicate.items[0]));\n    }\n\n    throw new Error(`Unable to translate path expression ${JSON.stringify(predicate)}`);\n  },\n};\n\n/**\n * 18.2.2.4 Translate Property Path Patterns\n */\nexport const simplifyPath:\nAlgebraIndir<'simplifyPath', (Algebra.Pattern | Algebra.Path)[], [RDF.Term, Algebra.PropertyPathSymbol, RDF.Term]> = {\n  name: 'simplifyPath',\n  fun: ({ SUBRULE }) => ({ algebraFactory: AF }, subject, predicate, object) => {\n    // X link(iri) Y -> X iri Y\n    if (predicate.type === Types.LINK) {\n      return [ AF.createPattern(subject, predicate.iri, object) ];\n    }\n\n    // X inv(iri) Y -> Y iri X\n    if (predicate.type === Types.INV) {\n      return SUBRULE(simplifyPath, <RDF.Quad_Subject> object, predicate.path, subject);\n    }\n\n    // X seq(P, Q) Y -> X P ?V . ?V Q P\n    if (predicate.type === Types.SEQ) {\n      let iter = subject;\n      const result: (Algebra.Pattern | Algebra.Path)[] = [];\n      for (const pathOfSeq of predicate.input.slice(0, -1)) {\n        const joinVar = SUBRULE(generateFreshVar);\n        result.push(...SUBRULE(simplifyPath, iter, pathOfSeq, joinVar));\n        iter = joinVar;\n      }\n      result.push(...SUBRULE(simplifyPath, iter, predicate.input.at(-1)!, object));\n      return result;\n    }\n\n    // X P Y -> Path(X, P, Y)\n    return [ AF.createPath(subject, predicate, object) ];\n  },\n};\n"]}