{"version":3,"file":"aggregate.js","sourceRoot":"","sources":["../../../../lib/toAlgebra/aggregate.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type {\n  Expression,\n  ExpressionAggregate,\n  Ordering,\n  PatternBind,\n  Query,\n  TermIri,\n  TermVariable,\n  Wildcard,\n} from '@traqula/rules-sparql-1-1';\nimport equal from 'fast-deep-equal';\nimport type { Algebra } from '../index.js';\nimport type { AlgebraIndir, FlattenedTriple } from './core.js';\nimport {\n  type AstToRdfTerm,\n  generateFreshVar,\n  inScopeVariables,\n  translateDatasetClause,\n  translateInlineData,\n  translateTerm,\n} from './general.js';\nimport { translateExpression } from './patterns.js';\nimport { translateBasicGraphPattern, translateQuad } from './tripleAndQuad.js';\n\n/**\n * 18.2.4\n */\nexport const translateAggregates: AlgebraIndir<'translateAggregates', Algebra.Operation, [Query, Algebra.Operation]> = {\n  name: 'translateAggregates',\n  fun: ({ SUBRULE }) => ({ astFactory: F, algebraFactory: AF, dataFactory: DF }, query, res) => {\n    const bindPatterns: PatternBind[] = [];\n\n    const varAggrMap: Record<string, ExpressionAggregate> = {};\n    const variables = F.isQuerySelect(query) || F.isQueryDescribe(query) ?\n      query.variables.map(x => SUBRULE(mapAggregate, x, varAggrMap)) :\n      undefined;\n    const having = query.solutionModifiers.having ?\n      query.solutionModifiers.having.having.map(x => <typeof x>SUBRULE(mapAggregate, x, varAggrMap)) :\n      undefined;\n    const order = query.solutionModifiers.order ?\n      query.solutionModifiers.order.orderDefs.map(x => <typeof x>SUBRULE(mapAggregate, x, varAggrMap)) :\n      undefined;\n\n    // Step: GROUP BY - If we found an aggregate, in group by or implicitly, do Group function.\n    // 18.2.4.1 Grouping and Aggregation\n    if (query.solutionModifiers.group ?? Object.keys(varAggrMap).length > 0) {\n      const aggregates = Object.keys(varAggrMap).map(var_ =>\n        SUBRULE(translateBoundAggregate, varAggrMap[var_], DF.variable(var_)));\n      const vars: RDF.Variable[] = [];\n      if (query.solutionModifiers.group) {\n        for (const expression of query.solutionModifiers.group.groupings) {\n          // https://www.w3.org/TR/sparql11-query/#rGroupCondition\n          if (F.isTerm(expression)) {\n            // This will always be a var, otherwise sparql would be invalid\n            vars.push(<RDF.Variable>SUBRULE(translateTerm, expression));\n          } else {\n            let var_: RDF.Variable;\n            let expr: Expression;\n            if ('variable' in expression) {\n              var_ = <AstToRdfTerm<typeof expression.variable>>SUBRULE(translateTerm, expression.variable);\n              expr = expression.value;\n            } else {\n              var_ = SUBRULE(generateFreshVar);\n              expr = expression;\n            }\n            res = AF.createExtend(res, var_, SUBRULE(translateExpression, expr));\n            vars.push(var_);\n          }\n        }\n      }\n      res = AF.createGroup(res, vars, aggregates);\n    }\n\n    // 18.2.4.2\n    if (having) {\n      for (const filter of having) {\n        res = AF.createFilter(res, SUBRULE(translateExpression, filter));\n      }\n    }\n\n    // 18.2.4.3\n    if (query.values) {\n      res = AF.createJoin([ res, SUBRULE(translateInlineData, query.values) ]);\n    }\n\n    // 18.2.4.4\n    let PatternValues: (RDF.Variable | RDF.NamedNode)[] = [];\n\n    if (variables) {\n      // Sort variables for consistent output\n      if (variables.some(wild => F.isWildcard(wild))) {\n        PatternValues = [ ...SUBRULE(inScopeVariables, query).values() ].map(x => DF.variable(x))\n          .sort((left, right) => left.value.localeCompare(right.value));\n      } else {\n        // Wildcard has been filtered out above\n        for (const var_ of <(TermVariable | TermIri | PatternBind)[]> variables) {\n          // Can have non-variables with DESCRIBE\n          if (F.isTerm(var_)) {\n            PatternValues.push(<AstToRdfTerm<typeof var_>>SUBRULE(translateTerm, var_));\n          } else {\n            // ... AS ?x\n            PatternValues.push(<AstToRdfTerm<typeof var_.variable>>SUBRULE(translateTerm, var_.variable));\n            bindPatterns.push(var_);\n          }\n        }\n      }\n    }\n\n    // TODO: Jena simplifies by having a list of extends\n    for (const bind of bindPatterns) {\n      res = AF.createExtend(\n        res,\n        <AstToRdfTerm<typeof bind.variable>>SUBRULE(translateTerm, bind.variable),\n        SUBRULE(translateExpression, bind.expression),\n      );\n    }\n\n    // 18.2.5\n    // not using toList and toMultiset\n\n    // 18.2.5.1\n    if (order) {\n      res = AF.createOrderBy(res, order.map((expr) => {\n        let result = SUBRULE(translateExpression, expr.expression);\n        if (expr.descending) {\n          result = AF.createOperatorExpression('desc', [ result ]);\n        }\n        return result;\n      }));\n    }\n\n    // 18.2.5.2\n    // construct does not need a project (select, ask and describe do)\n    if (F.isQuerySelect(query)) {\n      // Named nodes are only possible in a DESCRIBE so this cast is safe\n      res = AF.createProject(res, <RDF.Variable[]> PatternValues);\n    }\n\n    // 18.2.5.3\n    if ((<{ distinct?: unknown }>query).distinct) {\n      res = AF.createDistinct(res);\n    }\n\n    // 18.2.5.4\n    if ((<{ reduced?: unknown }>query).reduced) {\n      res = AF.createReduced(res);\n    }\n\n    if (F.isQueryConstruct(query)) {\n      const triples: FlattenedTriple[] = [];\n      SUBRULE(translateBasicGraphPattern, query.template.triples, triples);\n      res = AF.createConstruct(res, triples.map(quad => SUBRULE(translateQuad, quad)));\n    } else if (F.isQueryAsk(query)) {\n      res = AF.createAsk(res);\n    } else if (F.isQueryDescribe(query)) {\n      res = AF.createDescribe(res, PatternValues);\n    }\n\n    // Slicing needs to happen after construct/describe\n    // 18.2.5.5\n    const limitOffset = query.solutionModifiers.limitOffset;\n    if (limitOffset?.limit ?? limitOffset?.offset) {\n      res = AF.createSlice(res, limitOffset.offset ?? 0, limitOffset.limit);\n    }\n\n    if (query.datasets.clauses.length > 0) {\n      const clauses = SUBRULE(translateDatasetClause, query.datasets);\n      res = AF.createFrom(res, clauses.default, clauses.named);\n    }\n\n    return res;\n  },\n};\n\nexport type MapAggregateType = Wildcard | Expression | Ordering | PatternBind;\n\n/**\n * Rewrites some of the input sparql object to make use of aggregate variables\n * It thus replaces aggregates by their representative variable and registers the mapping.\n */\nexport const mapAggregate:\nAlgebraIndir<'mapAggregate', MapAggregateType, [MapAggregateType, Record<string, ExpressionAggregate>]> = {\n  name: 'mapAggregate',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, thingy, aggregates): MapAggregateType => {\n    if (F.isExpressionAggregate(thingy)) {\n      // Needed to take away the difference in the various `loc` descriptions\n      const canonicalAggregate = F.forcedAutoGenTree<ExpressionAggregate>(thingy);\n      let val: TermVariable | undefined;\n      // Look for the matching aggregate\n      for (const [ key, aggregate ] of Object.entries(aggregates)) {\n        if (equal(aggregate, canonicalAggregate)) {\n          val = F.termVariable(key, F.sourceLocation());\n          break;\n        }\n      }\n      if (val !== undefined) {\n        return val;\n      }\n      const freshVar = SUBRULE(generateFreshVar);\n      aggregates[freshVar.value] = canonicalAggregate;\n      return F.termVariable(freshVar.value, F.sourceLocation());\n    }\n\n    if (F.isExpressionPure(thingy) && !F.isExpressionPatternOperation(thingy)) {\n      return { ...thingy, args: thingy.args.map(x => <typeof x>SUBRULE(mapAggregate, x, aggregates)) };\n    }\n    // Non-aggregate expression\n    if ('expression' in thingy && thingy.expression) {\n      return { ...thingy, expression: <typeof thingy.expression>SUBRULE(mapAggregate, thingy.expression, aggregates) };\n    }\n    return thingy;\n  },\n};\n\nexport const translateBoundAggregate:\nAlgebraIndir<'translateBoundAggregate', Algebra.BoundAggregate, [ExpressionAggregate, RDF.Variable]> = {\n  name: 'translateBoundAggregate',\n  fun: ({ SUBRULE }) => (_, thingy, variable) => {\n    const A = <Algebra.AggregateExpression> SUBRULE(translateExpression, thingy);\n    return { ...A, variable };\n  },\n};\n"]}