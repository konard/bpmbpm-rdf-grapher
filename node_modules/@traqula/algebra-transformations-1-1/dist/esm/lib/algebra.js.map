{"version":3,"file":"algebra.js","sourceRoot":"","sources":["../../../lib/algebra.ts"],"names":[],"mappings":"AAGA,MAAM,CAAN,IAAY,KA8CX;AA9CD,WAAY,KAAK;IACf,oBAAW,CAAA;IACX,oBAAW,CAAA;IACX,gCAAuB,CAAA;IACvB,8BAAqB,CAAA;IACrB,8BAAqB,CAAA;IACrB,kCAAyB,CAAA;IACzB,0BAAiB,CAAA;IACjB,0BAAiB,CAAA;IACjB,sBAAa,CAAA;IACb,wBAAe,CAAA;IACf,wBAAe,CAAA;IACf,sBAAa,CAAA;IACb,+BAAsB,CAAA;IACtB,wBAAe,CAAA;IACf,oBAAW,CAAA;IACX,6BAAoB,CAAA;IACpB,4BAAmB,CAAA;IACnB,4BAAmB,CAAA;IACnB,4BAAmB,CAAA;IACnB,4BAAmB,CAAA;IACnB,wBAAe,CAAA;IACf,wBAAe,CAAA;IACf,0BAAiB,CAAA;IAEjB,SAAS;IACT,6CAAoC,CAAA;IACpC,uCAA8B,CAAA;IAC9B,sBAAa,CAAA;IACb,wBAAe,CAAA;IACf,0BAAiB,CAAA;IACjB,sBAAa,CAAA;IACb,oBAAW,CAAA;IACX,sBAAa,CAAA;IACb,sBAAa,CAAA;IAEb,QAAQ;IACR,sBAAa,CAAA;IACb,oBAAW,CAAA;IACX,oBAAW,CAAA;IACX,sBAAa,CAAA;IACb,2CAAkC,CAAA;IAClC,oBAAW,CAAA;IACX,oBAAW,CAAA;IACX,6CAAoC,CAAA;IACpC,2CAAkC,CAAA;AACpC,CAAC,EA9CW,KAAK,KAAL,KAAK,QA8ChB;AAED,MAAM,CAAN,IAAY,eAOX;AAPD,WAAY,eAAe;IACzB,0CAAuB,CAAA;IACvB,0CAAuB,CAAA;IACvB,kCAAe,CAAA;IACf,wCAAqB,CAAA;IACrB,gCAAa,CAAA;IACb,wCAAqB,CAAA;AACvB,CAAC,EAPW,eAAe,KAAf,eAAe,QAO1B","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Typed, SubTyped } from '@traqula/core';\n\nexport enum Types {\n  ASK = 'ask',\n  BGP = 'bgp',\n  CONSTRUCT = 'construct',\n  DESCRIBE = 'describe',\n  DISTINCT = 'distinct',\n  EXPRESSION = 'expression',\n  EXTEND = 'extend',\n  FILTER = 'filter',\n  FROM = 'from',\n  GRAPH = 'graph',\n  GROUP = 'group',\n  JOIN = 'join',\n  LEFT_JOIN = 'leftjoin',\n  MINUS = 'minus',\n  NOP = 'nop',\n  ORDER_BY = 'orderby',\n  PATTERN = 'pattern',\n  PROJECT = 'project',\n  REDUCED = 'reduced',\n  SERVICE = 'service',\n  SLICE = 'slice',\n  UNION = 'union',\n  VALUES = 'values',\n\n  // Update\n  COMPOSITE_UPDATE = 'compositeupdate',\n  DELETE_INSERT = 'deleteinsert',\n  LOAD = 'load',\n  CLEAR = 'clear',\n  CREATE = 'create',\n  DROP = 'drop',\n  ADD = 'add',\n  MOVE = 'move',\n  COPY = 'copy',\n\n  // Paths\n  PATH = 'path',\n  ALT = 'alt',\n  INV = 'inv',\n  LINK = 'link',\n  ONE_OR_MORE_PATH = 'OneOrMorePath',\n  SEQ = 'seq',\n  NPS = 'nps',\n  ZERO_OR_MORE_PATH = 'ZeroOrMorePath',\n  ZERO_OR_ONE_PATH = 'ZeroOrOnePath',\n}\n\nexport enum ExpressionTypes {\n  AGGREGATE = 'aggregate',\n  EXISTENCE = 'existence',\n  NAMED = 'named',\n  OPERATOR = 'operator',\n  TERM = 'term',\n  WILDCARD = 'wildcard',\n}\n\n// ----------------------- OPERATIONS -----------------------\nexport type Operation = Ask | Expression | Bgp | Construct | Describe | Distinct | Extend | From | Filter\n  | Graph | Group | Join | LeftJoin | Minus | Nop | OrderBy | Path | Pattern | Project | PropertyPathSymbol\n  | Reduced | Service | Slice | Union | Values | Update | CompositeUpdate;\n\nexport type Expression = AggregateExpression | GroupConcatExpression | ExistenceExpression | NamedExpression |\n  OperatorExpression | TermExpression | WildcardExpression | BoundAggregate;\n\nexport type PropertyPathSymbol = Alt | Inv | Link | Nps | OneOrMorePath | Seq | ZeroOrMorePath | ZeroOrOnePath;\n\nexport type Update = DeleteInsert | Load | Clear | Create | Drop | Add | Move | Copy;\n\n// Returns the correct type based on the type enum\nexport type TypedOperation<T extends Types> = Extract<Operation, { type: T }>;\nexport type TypedExpression<T extends ExpressionTypes> = Extract<Expression, { subType: T }>;\n\n// ----------------------- ABSTRACTS -----------------------\nexport interface BaseOperation extends Typed { }\n\n/**\n * Open interface describing an expression\n */\nexport interface BaseExpression extends BaseOperation, SubTyped<Types.EXPRESSION> {\n  type: Types.EXPRESSION;\n  subType: string;\n}\n\n// ----------------------- ABSTRACTS -----------------------\n\n/**\n * Algebra operation taking a single operation as input.\n */\nexport interface Single extends BaseOperation {\n  input: Operation;\n}\n\n/**\n * Algebra operation taking multiple operations as input.\n */\nexport interface Multi extends BaseOperation {\n  input: Operation[];\n}\n\n/**\n * Algebra operation taking exactly two input operations.\n */\nexport interface Double extends Multi {\n  input: [Operation, Operation];\n}\n\nexport interface AggregateExpression extends BaseExpression {\n  subType: ExpressionTypes.AGGREGATE;\n  aggregator: 'avg' | 'count' | 'group_concat' | 'max' | 'min' | 'sample' | 'sum';\n  distinct: boolean;\n  expression: Expression;\n  separator?: string;\n}\n\nexport interface GroupConcatExpression extends AggregateExpression {\n  aggregator: 'group_concat';\n  separator?: string;\n}\n\nexport interface ExistenceExpression extends BaseExpression {\n  subType: ExpressionTypes.EXISTENCE;\n  not: boolean;\n  input: Operation;\n}\n\nexport interface NamedExpression extends BaseExpression {\n  subType: ExpressionTypes.NAMED;\n  name: RDF.NamedNode;\n  args: Expression[];\n}\n\nexport interface OperatorExpression extends BaseExpression {\n  subType: ExpressionTypes.OPERATOR;\n  operator: string;\n  args: Expression[];\n}\n\nexport interface TermExpression extends BaseExpression {\n  subType: ExpressionTypes.TERM;\n  term: RDF.Term;\n}\n\nexport interface WildcardExpression extends BaseExpression {\n  subType: ExpressionTypes.WILDCARD;\n  wildcard: {\n    type: 'wildcard';\n  };\n}\n\n// TODO: currently not differentiating between lists and multisets\n\n// ----------------------- ACTUAL FUNCTIONS -----------------------\n\n/**\n * Algebra operation representing the [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths) alternative (`|`).\n * Property paths have a specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n */\nexport interface Alt extends Multi {\n  type: Types.ALT;\n  input: PropertyPathSymbol[];\n}\n\nexport interface Ask extends Single {\n  type: Types.ASK;\n}\n\nexport interface Bgp extends BaseOperation {\n  type: Types.BGP;\n  patterns: Pattern[];\n}\n\nexport interface Construct extends Single {\n  type: Types.CONSTRUCT;\n  template: Pattern[];\n}\n\nexport interface Describe extends Single {\n  type: Types.DESCRIBE;\n  terms: (RDF.Variable | RDF.NamedNode)[];\n}\n\nexport interface Distinct extends Single {\n  type: Types.DISTINCT;\n}\n\nexport interface Extend extends Single {\n  type: Types.EXTEND;\n  variable: RDF.Variable;\n  expression: Expression;\n}\n\nexport interface From extends Single {\n  type: Types.FROM;\n  default: RDF.NamedNode[];\n  named: RDF.NamedNode[];\n}\n\nexport interface Filter extends Single {\n  type: Types.FILTER;\n  expression: Expression;\n}\n\nexport interface Graph extends Single {\n  type: Types.GRAPH;\n  name: RDF.Variable | RDF.NamedNode;\n}\n\n// Also an expression\nexport interface BoundAggregate extends AggregateExpression {\n  variable: RDF.Variable;\n}\n\nexport interface Group extends Single {\n  type: Types.GROUP;\n  variables: RDF.Variable[];\n  aggregates: BoundAggregate[];\n}\n\n/**\n * Algebra operation representing the [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths) inverse (`^`).\n * Having a specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n * This operation, besides basic mode is the reason SPARQL can contain literals in the subject position.\n */\nexport interface Inv extends BaseOperation {\n  type: Types.INV;\n  path: PropertyPathSymbol;\n}\n\nexport interface Join extends Multi {\n  type: Types.JOIN;\n}\n\nexport interface LeftJoin extends Double {\n  type: Types.LEFT_JOIN;\n  expression?: Expression;\n}\n\n/**\n * Algebra operation representing the property of a [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths).\n * Property paths have a specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n * This operation, is just a way of saying to a Propery Path operation that nothing fancy is going on,\n * and it should just match this property.\n */\nexport interface Link extends BaseOperation {\n  type: Types.LINK;\n  iri: RDF.NamedNode;\n}\n\nexport interface Minus extends Double {\n  type: Types.MINUS;\n  /**\n   * Since our graph translation is not really part of the spec,\n   * there is a MINUS edge case we need to consider with GRAPH ?g.\n   * If left and right of MINUS have disjoint variables, the whole left solution sequence must be kept.\n   * If GRAPH is defined outside of an operator (e.g. MINUS), then the spec says that evaluation of the operators\n   * must be done as union over the evaluation of that operator within each graph separately,\n   * and that the variable of ?g must only be bound **after** that evaluation.\n   * As such, MINUS will not be aware of this variable ?g, and the disjoint case will apply.\n   * The code below adds metadata to the operation so that engines can special-case this.\n   */\n  graphScopeVar?: RDF.Variable;\n}\n\n/**\n * An empty operation.\n * For example used for the algebra representation of a query string that does not contain any operation.\n */\nexport interface Nop extends BaseOperation {\n  type: Types.NOP;\n}\n\n/**\n * Algebra operation representing the [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths) negated property set (`!`).\n * Property paths have a specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n */\nexport interface Nps extends BaseOperation {\n  type: Types.NPS;\n  iris: RDF.NamedNode[];\n}\n\n/**\n * Algebra operation representing the [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths) one or more (`+`).\n * Property paths have a specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n */\nexport interface OneOrMorePath extends BaseOperation {\n  type: Types.ONE_OR_MORE_PATH;\n  path: PropertyPathSymbol;\n}\n\nexport interface OrderBy extends Single {\n  type: Types.ORDER_BY;\n  expressions: Expression[];\n}\n\nexport interface Path extends BaseOperation {\n  type: Types.PATH;\n  subject: RDF.Term;\n  predicate: PropertyPathSymbol;\n  object: RDF.Term;\n  graph: RDF.Term;\n}\n\n/**\n * Simple BGP entry (triple)\n */\nexport interface Pattern extends BaseOperation, RDF.BaseQuad {\n  type: Types.PATTERN;\n}\n\nexport interface Project extends Single {\n  type: Types.PROJECT;\n  variables: RDF.Variable[];\n}\n\nexport interface Reduced extends Single {\n  type: Types.REDUCED;\n}\n\n/**\n * Algebra operation representing the [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths) sequence (`/`).\n * Property paths have a specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n */\nexport interface Seq extends Multi {\n  type: Types.SEQ;\n  input: PropertyPathSymbol[];\n}\n\nexport interface Service extends Single {\n  type: Types.SERVICE;\n  name: RDF.Variable | RDF.NamedNode;\n  silent: boolean;\n}\n\nexport interface Slice extends Single {\n  type: Types.SLICE;\n  start: number;\n  length?: number;\n}\n\nexport interface Union extends Multi {\n  type: Types.UNION;\n}\n\n/**\n * Algebra operation representing the [VALUES pattern](https://www.w3.org/TR/sparql11-query/#inline-data)\n * Has a list of variables that will be assigned.\n * The assignments are represented as a list of object containing bindings.\n * Each binging links the variable value to the appropriate Term for this binding.\n * Does not take any input.\n */\nexport interface Values extends BaseOperation {\n  type: Types.VALUES;\n  variables: RDF.Variable[];\n  bindings: Record<string, RDF.Literal | RDF.NamedNode>[];\n}\n\n/**\n * Algebra operation representing the [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths) zero or more (`*`).\n * The having specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n */\nexport interface ZeroOrMorePath extends BaseOperation {\n  type: Types.ZERO_OR_MORE_PATH;\n  path: PropertyPathSymbol;\n}\n\n/**\n * Algebra operation representing the [Property path](https://www.w3.org/TR/sparql11-query/#propertypaths) zero or one (`?`).\n * The having specific [SPARQL definition](https://www.w3.org/TR/sparql11-query/#sparqlPropertyPaths)\n */\nexport interface ZeroOrOnePath extends BaseOperation {\n  type: Types.ZERO_OR_ONE_PATH;\n  path: PropertyPathSymbol;\n}\n\n// ----------------------- UPDATE FUNCTIONS -----------------------\nexport interface CompositeUpdate extends BaseOperation {\n  type: Types.COMPOSITE_UPDATE;\n  updates: (Update | Nop)[];\n}\n\nexport interface DeleteInsert extends BaseOperation {\n  type: Types.DELETE_INSERT;\n  delete?: Pattern[];\n  insert?: Pattern[];\n  where?: Operation;\n}\n\nexport interface UpdateGraph extends BaseOperation {\n  silent?: boolean;\n}\n\nexport interface Load extends UpdateGraph {\n  type: Types.LOAD;\n  source: RDF.NamedNode;\n  destination?: RDF.NamedNode;\n}\n\nexport interface Clear extends UpdateGraph {\n  type: Types.CLEAR;\n  source: 'DEFAULT' | 'NAMED' | 'ALL' | RDF.NamedNode;\n}\n\nexport interface Create extends UpdateGraph {\n  type: Types.CREATE;\n  source: RDF.NamedNode;\n}\n\nexport interface Drop extends UpdateGraph {\n  type: Types.DROP;\n  source: 'DEFAULT' | 'NAMED' | 'ALL' | RDF.NamedNode;\n}\n\nexport interface UpdateGraphShortcut extends UpdateGraph {\n  source: 'DEFAULT' | RDF.NamedNode;\n  destination: 'DEFAULT' | RDF.NamedNode;\n}\n\nexport interface Add extends UpdateGraphShortcut {\n  type: Types.ADD;\n}\n\nexport interface Move extends UpdateGraphShortcut {\n  type: Types.MOVE;\n}\n\nexport interface Copy extends UpdateGraphShortcut {\n  type: Types.COPY;\n}\n"]}