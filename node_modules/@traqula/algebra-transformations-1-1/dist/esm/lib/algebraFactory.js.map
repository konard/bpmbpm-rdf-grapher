{"version":3,"file":"algebraFactory.js","sourceRoot":"","sources":["../../../lib/algebraFactory.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport { stringToTerm } from 'rdf-string';\nimport * as A from './algebra.js';\nimport type { PropertyPathSymbol, Update } from './algebra.js';\n\nfunction known<T extends A.Operation = A.Operation>(x: A.BaseOperation): T;\nfunction known<T extends A.Operation = A.Operation>(x: A.BaseOperation[]): T[];\nfunction known<T extends A.Operation = A.Operation>(\n  x: A.BaseOperation | A.BaseOperation[],\n): typeof x extends any[] ? T[] : T {\n  return <any> x;\n}\n\nexport class AlgebraFactory {\n  public dataFactory: RDF.DataFactory<RDF.BaseQuad, RDF.BaseQuad>;\n  public stringType: RDF.NamedNode;\n\n  public constructor(dataFactory?: RDF.DataFactory<RDF.BaseQuad>) {\n    this.dataFactory = dataFactory ?? new DataFactory();\n    this.stringType = <RDF.NamedNode> this.createTerm('http://www.w3.org/2001/XMLSchema#string');\n  }\n\n  public createAlt(input: A.BaseOperation[], flatten = true): A.Alt {\n    return this.flattenMulti({\n      type: A.Types.ALT,\n      input: <PropertyPathSymbol[]> input,\n    }, flatten);\n  }\n\n  public createAsk(input: A.BaseOperation): A.Ask {\n    return { type: A.Types.ASK, input: known(input) };\n  }\n\n  public createBoundAggregate(\n    variable: RDF.Variable,\n    aggregate: string,\n    expression: A.BaseExpression,\n    distinct: boolean,\n    separator?: string,\n  ): A.BoundAggregate {\n    const result = <A.BoundAggregate> this.createAggregateExpression(\n      aggregate,\n      known<A.Expression>(expression),\n      distinct,\n      separator,\n    );\n    result.variable = variable;\n    return result;\n  }\n\n  public createBgp(patterns: A.Pattern[]): A.Bgp {\n    return { type: A.Types.BGP, patterns };\n  }\n\n  public createConstruct(input: A.BaseOperation, template: A.Pattern[]): A.Construct {\n    return { type: A.Types.CONSTRUCT, input: known(input), template };\n  }\n\n  public createDescribe(input: A.BaseOperation, terms: (RDF.Variable | RDF.NamedNode)[]): A.Describe {\n    return { type: A.Types.DESCRIBE, input: known(input), terms };\n  }\n\n  public createDistinct(input: A.BaseOperation): A.Distinct {\n    return { type: A.Types.DISTINCT, input: known(input) };\n  }\n\n  public createExtend(\n    input: A.BaseOperation,\n    variable: RDF.Variable,\n    expression: A.BaseExpression,\n  ): A.Extend {\n    return { type: A.Types.EXTEND, input: known(input), variable, expression: known(expression) };\n  }\n\n  public createFrom(input: A.BaseOperation, def: RDF.NamedNode[], named: RDF.NamedNode[]): A.From {\n    return { type: A.Types.FROM, input: known(input), default: def, named };\n  }\n\n  public createFilter(input: A.BaseOperation, expression: A.BaseExpression): A.Filter {\n    return { type: A.Types.FILTER, input: known(input), expression: known(expression) };\n  }\n\n  public createGraph(input: A.BaseOperation, name: RDF.Variable | RDF.NamedNode): A.Graph {\n    return { type: A.Types.GRAPH, input: known(input), name };\n  }\n\n  public createGroup(\n    input: A.BaseOperation,\n    variables: RDF.Variable[],\n    aggregates: A.BaseOperation[],\n  ): A.Group {\n    return { type: A.Types.GROUP, input: known(input), variables, aggregates: known(aggregates) };\n  }\n\n  public createInv(path: A.BaseOperation): A.Inv {\n    return { type: A.Types.INV, path: <PropertyPathSymbol> path };\n  }\n\n  public createJoin(input: A.BaseOperation[], flatten = true): A.Join {\n    return this.flattenMulti({ type: A.Types.JOIN, input: known(input) }, flatten);\n  }\n\n  public createLeftJoin(\n    left: A.BaseOperation,\n    right: A.BaseOperation,\n    expression?: A.BaseExpression,\n  ): A.LeftJoin {\n    if (expression) {\n      return {\n        type: A.Types.LEFT_JOIN,\n        input: [ known(left), known(right) ],\n        expression: known<A.Expression>(expression),\n      };\n    }\n    return { type: A.Types.LEFT_JOIN, input: [ known(left), known(right) ]};\n  }\n\n  public createLink(iri: RDF.NamedNode): A.Link {\n    return { type: A.Types.LINK, iri };\n  }\n\n  public createMinus(left: A.BaseOperation, right: A.BaseOperation): A.Minus {\n    return { type: A.Types.MINUS, input: [ known(left), known(right) ]};\n  }\n\n  public createNop(): A.Nop {\n    return { type: A.Types.NOP };\n  }\n\n  public createNps(iris: RDF.NamedNode[]): A.Nps {\n    return { type: A.Types.NPS, iris };\n  }\n\n  public createOneOrMorePath(path: A.BaseOperation): A.OneOrMorePath {\n    return { type: A.Types.ONE_OR_MORE_PATH, path: <PropertyPathSymbol> path };\n  }\n\n  public createOrderBy(input: A.BaseOperation, expressions: A.BaseExpression[]): A.OrderBy {\n    return { type: A.Types.ORDER_BY, input: known(input), expressions: known(expressions) };\n  }\n\n  public createPath(\n    subject: RDF.Term,\n    predicate: A.BaseOperation,\n    object: RDF.Term,\n    graph?: RDF.Term,\n  ): A.Path {\n    if (graph) {\n      return { type: A.Types.PATH, subject, predicate: <PropertyPathSymbol> predicate, object, graph };\n    }\n    return {\n      type: A.Types.PATH,\n      subject,\n      predicate: <PropertyPathSymbol> predicate,\n      object,\n      graph: this.dataFactory.defaultGraph(),\n    };\n  }\n\n  public createPattern(subject: RDF.Term, predicate: RDF.Term, object: RDF.Term, graph?: RDF.Term): A.Pattern {\n    const pattern = <A.Pattern> this.dataFactory.quad(subject, predicate, object, graph);\n    pattern.type = A.Types.PATTERN;\n    return pattern;\n  }\n\n  public createProject(input: A.BaseOperation, variables: RDF.Variable[]): A.Project {\n    return { type: A.Types.PROJECT, input: known(input), variables };\n  }\n\n  public createReduced(input: A.BaseOperation): A.Reduced {\n    return { type: A.Types.REDUCED, input: known(input) };\n  }\n\n  public createSeq(input: A.BaseOperation[], flatten = true): A.Seq {\n    return this.flattenMulti({\n      type: A.Types.SEQ,\n      input: <PropertyPathSymbol[]> input,\n    }, flatten);\n  }\n\n  public createService(input: A.BaseOperation, name: RDF.NamedNode | RDF.Variable, silent?: boolean): A.Service {\n    return { type: A.Types.SERVICE, input: known(input), name, silent: Boolean(silent) };\n  }\n\n  public createSlice(input: A.BaseOperation, start: number, length?: number): A.Slice {\n    start = start || 0;\n    if (length !== undefined) {\n      return { type: A.Types.SLICE, input: known(input), start, length };\n    }\n    return { type: A.Types.SLICE, input: known(input), start };\n  }\n\n  public createUnion(input: A.BaseOperation[], flatten = true): A.Union {\n    return this.flattenMulti({ type: A.Types.UNION, input: known(input) }, flatten);\n  }\n\n  public createValues(variables: RDF.Variable[], bindings: Record<string, RDF.Literal | RDF.NamedNode>[]): A.Values {\n    return { type: A.Types.VALUES, variables, bindings };\n  }\n\n  public createZeroOrMorePath(path: A.BaseOperation): A.ZeroOrMorePath {\n    return {\n      type: A.Types.ZERO_OR_MORE_PATH,\n      path: <PropertyPathSymbol> path,\n    };\n  }\n\n  public createZeroOrOnePath(path: A.BaseOperation): A.ZeroOrOnePath {\n    return {\n      type: A.Types.ZERO_OR_ONE_PATH,\n      path: <PropertyPathSymbol> path,\n    };\n  }\n\n  public createAggregateExpression(\n    aggregator: string,\n    expression: A.BaseExpression,\n    distinct: boolean,\n    separator?: string,\n  ): A.AggregateExpression {\n    if (separator !== undefined) {\n      return {\n        type: A.Types.EXPRESSION,\n        subType: A.ExpressionTypes.AGGREGATE,\n        aggregator: <any> aggregator,\n        expression: known(expression),\n        separator,\n        distinct,\n      };\n    }\n    return {\n      type: A.Types.EXPRESSION,\n      subType: A.ExpressionTypes.AGGREGATE,\n      aggregator: <any> aggregator,\n      expression: known(expression),\n      distinct,\n    };\n  }\n\n  public createExistenceExpression(not: boolean, input: A.BaseOperation): A.ExistenceExpression {\n    return { type: A.Types.EXPRESSION, subType: A.ExpressionTypes.EXISTENCE, not, input: known(input) };\n  }\n\n  public createNamedExpression(name: RDF.NamedNode, args: A.BaseExpression[]): A.NamedExpression {\n    return { type: A.Types.EXPRESSION, subType: A.ExpressionTypes.NAMED, name, args: known(args) };\n  }\n\n  public createOperatorExpression(operator: string, args: A.BaseExpression[]): A.OperatorExpression {\n    return { type: A.Types.EXPRESSION, subType: A.ExpressionTypes.OPERATOR, operator, args: known(args) };\n  }\n\n  public createTermExpression(term: RDF.Term): A.TermExpression {\n    return { type: A.Types.EXPRESSION, subType: A.ExpressionTypes.TERM, term };\n  }\n\n  public createWildcardExpression(): A.WildcardExpression {\n    return { type: A.Types.EXPRESSION, subType: A.ExpressionTypes.WILDCARD, wildcard: { type: 'wildcard' }};\n  }\n\n  public createTerm(str: string): RDF.Term {\n    if (str.startsWith('$')) {\n      str = str.replace('$', '?');\n    }\n    return stringToTerm(str, this.dataFactory);\n  }\n\n  // Update functions\n  public createCompositeUpdate(updates: A.BaseOperation[]): A.CompositeUpdate {\n    return { type: A.Types.COMPOSITE_UPDATE, updates: <Update[]> updates };\n  }\n\n  public createDeleteInsert(\n    deleteQuads?: A.Pattern[],\n    insertQuads?: A.Pattern[],\n    where?: A.BaseOperation,\n  ): A.DeleteInsert {\n    const result: A.DeleteInsert = { type: A.Types.DELETE_INSERT };\n    if (deleteQuads) {\n      result.delete = deleteQuads;\n    }\n    if (insertQuads) {\n      result.insert = insertQuads;\n    }\n    if (where) {\n      result.where = known(where);\n    }\n    return result;\n  }\n\n  public createLoad(source: RDF.NamedNode, destination?: RDF.NamedNode, silent?: boolean): A.Load {\n    const result: A.Load = { type: A.Types.LOAD, source };\n    if (destination) {\n      result.destination = destination;\n    }\n    return this.addSilent(result, Boolean(silent));\n  }\n\n  public createClear(source: 'DEFAULT' | 'NAMED' | 'ALL' | RDF.NamedNode, silent?: boolean): A.Clear {\n    return this.addSilent({ type: A.Types.CLEAR, source }, Boolean(silent));\n  }\n\n  public createCreate(source: RDF.NamedNode, silent?: boolean): A.Create {\n    return this.addSilent({ type: A.Types.CREATE, source }, Boolean(silent));\n  }\n\n  public createDrop(source: 'DEFAULT' | 'NAMED' | 'ALL' | RDF.NamedNode, silent?: boolean): A.Drop {\n    return this.addSilent({ type: A.Types.DROP, source }, Boolean(silent));\n  }\n\n  public createAdd(source: 'DEFAULT' | RDF.NamedNode, destination: 'DEFAULT' | RDF.NamedNode, silent?: boolean): A.Add {\n    return this.addSilent({\n      type: A.Types.ADD,\n      source,\n      destination,\n    }, Boolean(silent));\n  }\n\n  public createMove(\n    source: 'DEFAULT' | RDF.NamedNode,\n    destination: 'DEFAULT' | RDF.NamedNode,\n    silent?: boolean,\n  ): A.Move {\n    return this.addSilent({\n      type: A.Types.MOVE,\n      source,\n      destination,\n    }, Boolean(silent));\n  }\n\n  public createCopy(\n    source: 'DEFAULT' | RDF.NamedNode,\n    destination: 'DEFAULT' | RDF.NamedNode,\n    silent?: boolean,\n  ): A.Copy {\n    return this.addSilent({\n      type: A.Types.COPY,\n      source,\n      destination,\n    }, Boolean(silent));\n  }\n\n  private addSilent<T extends A.UpdateGraph>(input: T, silent: boolean): T {\n    if (silent) {\n      input.silent = silent;\n    }\n    return input;\n  }\n\n  private flattenMulti<T extends A.Multi>(input: T, flatten: boolean): T {\n    if (!flatten) {\n      return input;\n    }\n    const type = input.type;\n    const subType = input.subType;\n    const children = input.input;\n    const newChildren: A.Operation[] = [];\n    for (const child of children) {\n      if (child.type === type && (!subType || subType === child.subType)) {\n        newChildren.push(...(<A.Multi> child).input);\n      } else {\n        newChildren.push(child);\n      }\n    }\n    input.input = newChildren;\n    return input;\n  }\n}\n"]}