import { isomorphic } from 'rdf-isomorphic';
import { Types } from '../algebra.js';
import { isVariable, types } from '../toAlgebra/index.js';
import { translateAlgDatasetClauses, translateAlgPattern, translateAlgTerm } from './general.js';
import { algWrapInPatternGroup, translateAlgPatternNew } from './pattern.js';
import { removeAlgQuadsRecursive } from './quads.js';
export const translateAlgUpdateOperation = {
    name: 'translateUpdateOperation',
    fun: ({ SUBRULE }) => (_, op) => {
        switch (op.type) {
            case Types.DELETE_INSERT:
                return SUBRULE(translateAlgDeleteInsert, op);
            case Types.LOAD:
                return SUBRULE(translateAlgLoad, op);
            case Types.CLEAR:
                return SUBRULE(translateAlgClear, op);
            case Types.CREATE:
                return SUBRULE(translateAlgCreate, op);
            case Types.DROP:
                return SUBRULE(translateAlgDrop, op);
            case Types.ADD:
                return SUBRULE(translateAlgAdd, op);
            case Types.MOVE:
                return SUBRULE(translateAlgMove, op);
            case Types.COPY:
                return SUBRULE(translateAlgCopy, op);
            default:
                throw new Error(`Unknown Operation type ${op.type}`);
        }
    },
};
export const toUpdate = {
    name: 'toUpdate',
    fun: () => ({ astFactory: F }, ops) => ({
        type: 'update',
        updates: ops.map(op => ({ context: [], operation: op })),
        loc: F.gen(),
    }),
};
export const translateAlgCompositeUpdate = {
    name: 'translateCompositeUpdate',
    fun: ({ SUBRULE }) => (_, op) => SUBRULE(toUpdate, op.updates.map(update => update.type === Types.NOP ? undefined : SUBRULE(translateAlgUpdateOperation, update))),
};
export const translateAlgDeleteInsert = {
    name: 'translateDeleteInsert',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => {
        let where = op.where;
        let use;
        if (where && where.type === types.FROM) {
            const from = where;
            where = from.input;
            use = SUBRULE(translateAlgDatasetClauses, from.default, from.named);
        }
        const update = {
            type: 'updateOperation',
            subType: 'modify',
            delete: SUBRULE(convertAlgUpdatePatterns, op.delete ?? []),
            insert: SUBRULE(convertAlgUpdatePatterns, op.insert ?? []),
            where: F.patternGroup([], F.gen()),
            from: use ?? F.datasetClauses([], F.gen()),
            loc: F.gen(),
            graph: undefined,
        };
        // If not an empty where pattern, handle quads
        if (where && (where.type !== types.BGP || where.patterns.length > 0)) {
            const graphs = [];
            const result = SUBRULE(translateAlgPatternNew, SUBRULE(removeAlgQuadsRecursive, where, graphs));
            update.where = SUBRULE(algWrapInPatternGroup, result);
            // Graph might not be applied yet since there was no project
            // this can only happen if there was a single graph
            if (graphs.length > 0) {
                if (graphs.length === 1) {
                    // Ignore if default graph
                    if (graphs.at(0)?.value !== '') {
                        update.where.patterns = [
                            F.patternGraph(SUBRULE(translateAlgTerm, graphs[0]), update.where.patterns, F.gen()),
                        ];
                    }
                }
                else {
                    throw new Error('This is unexpected and might indicate an error in graph handling for updates.');
                }
            }
        }
        return SUBRULE(cleanupAlgUpdateOperationModify, update, op);
    },
};
/**
 * Return the minimal version of the UpdateOperationModify.
 * Not really necessary but can give cleaner looking queries
 */
export const cleanupAlgUpdateOperationModify = {
    name: 'cleanUpUpdateOperationModify',
    fun: () => (_, update, op) => {
        const copy = { ...update };
        // Check Insert Data
        if (!op.delete && !op.where) {
            const asInsert = copy;
            asInsert.subType = 'insertdata';
            asInsert.data = copy.insert;
            delete asInsert.delete;
            delete asInsert.where;
            return asInsert;
        }
        // Check DeleteWhere or DeleteData
        if (!op.insert && !op.where) {
            const asCasted = copy;
            asCasted.data = copy.delete;
            delete asCasted.insert;
            delete asCasted.where;
            if (op.delete.some(pattern => isVariable(pattern.subject) || isVariable(pattern.predicate) || isVariable(pattern.object))) {
                asCasted.subType = 'deletewhere';
            }
            else {
                asCasted.subType = 'deletedata';
            }
            return asCasted;
        }
        // Check if deleteWhere when modify but isomorphic.
        if (!op.insert && op.where && op.where.type === 'bgp' && isomorphic(op.delete, op.where.patterns)) {
            const asCasted = copy;
            asCasted.data = copy.delete;
            delete asCasted.where;
            delete asCasted.delete;
            asCasted.subType = 'deletewhere';
            return asCasted;
        }
        return update;
    },
};
export const translateAlgLoad = {
    name: 'translateLoad',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.updateOperationLoad(F.gen(), SUBRULE(translateAlgTerm, op.source), Boolean(op.silent), op.destination ?
        F.graphRefSpecific(SUBRULE(translateAlgTerm, op.destination), F.gen()) :
        undefined),
};
export const translateAlgGraphRef = {
    name: 'translateGraphRef',
    fun: ({ SUBRULE }) => ({ astFactory: F }, graphRef) => {
        if (graphRef === 'DEFAULT') {
            return F.graphRefDefault(F.gen());
        }
        if (graphRef === 'NAMED') {
            return F.graphRefNamed(F.gen());
        }
        if (graphRef === 'ALL') {
            return F.graphRefAll(F.gen());
        }
        return F.graphRefSpecific(SUBRULE(translateAlgTerm, graphRef), F.gen());
    },
};
export const translateAlgClear = {
    name: 'translateClear',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.updateOperationClear(SUBRULE(translateAlgGraphRef, op.source), op.silent ?? false, F.gen()),
};
export const translateAlgCreate = {
    name: 'translateCreate',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.updateOperationCreate(SUBRULE(translateAlgGraphRef, op.source), op.silent ?? false, F.gen()),
};
export const translateAlgDrop = {
    name: 'translateDrop',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.updateOperationDrop(SUBRULE(translateAlgGraphRef, op.source), op.silent ?? false, F.gen()),
};
export const translateAlgAdd = {
    name: 'translateAdd',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.updateOperationAdd(SUBRULE(translateAlgGraphRef, op.source), SUBRULE(translateAlgGraphRef, op.destination), op.silent ?? false, F.gen()),
};
export const translateAlgMove = {
    name: 'translateMove',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.updateOperationMove(SUBRULE(translateAlgGraphRef, op.source), SUBRULE(translateAlgGraphRef, op.destination), op.silent ?? false, F.gen()),
};
export const translateAlgCopy = {
    name: 'translateCopy',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.updateOperationCopy(SUBRULE(translateAlgGraphRef, op.source), SUBRULE(translateAlgGraphRef, op.destination), op.silent ?? false, F.gen()),
};
/**
 * Similar to removeQuads but more simplified for UPDATES
 */
export const convertAlgUpdatePatterns = {
    name: 'convertUpdatePatterns',
    fun: ({ SUBRULE }) => ({ astFactory: F }, patterns) => {
        if (!patterns) {
            return [];
        }
        const graphs = {};
        for (const pattern of patterns) {
            const graph = pattern.graph.value;
            if (!graphs[graph]) {
                graphs[graph] = [];
            }
            graphs[graph].push(pattern);
        }
        return Object.keys(graphs).map((graph) => {
            const patternBgp = F.patternBgp(graphs[graph].map(x => SUBRULE(translateAlgPattern, x)), F.gen());
            // If DefaultGraph, de not wrap
            if (graph === '') {
                return patternBgp;
            }
            return F.graphQuads(SUBRULE(translateAlgTerm, graphs[graph][0].graph), patternBgp, F.gen());
        });
    },
};
//# sourceMappingURL=updateUnit.js.map