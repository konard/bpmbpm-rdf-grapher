import { types } from '../toAlgebra/core.js';
import { translateAlgTerm } from './general.js';
export const translateAlgPathComponent = {
    name: 'translatePathComponent',
    fun: ({ SUBRULE }) => (_, path) => {
        switch (path.type) {
            case types.ALT: return SUBRULE(translateAlgAlt, path);
            case types.INV: return SUBRULE(translateAlgInv, path);
            case types.LINK: return SUBRULE(translateAlgLink, path);
            case types.NPS: return SUBRULE(translateAlgNps, path);
            case types.ONE_OR_MORE_PATH: return SUBRULE(translateAlgOneOrMorePath, path);
            case types.SEQ: return SUBRULE(translateAlgSeq, path);
            case types.ZERO_OR_MORE_PATH: return SUBRULE(translateAlgZeroOrMorePath, path);
            case types.ZERO_OR_ONE_PATH: return SUBRULE(translateAlgZeroOrOnePath, path);
            default:
                throw new Error(`Unknown Path type ${path.type}`);
        }
    },
};
export const translateAlgAlt = {
    name: 'translateAlt',
    fun: ({ SUBRULE }) => ({ astFactory: F }, path) => {
        const mapped = path.input.map(x => SUBRULE(translateAlgPathComponent, x));
        if (mapped.every(entry => F.isPathOfType(entry, ['!']))) {
            return F.path('!', [F.path('|', mapped.flatMap(entry => entry.items), F.gen())], F.gen());
        }
        return F.path('|', mapped, F.gen());
    },
};
export const translateAlgInv = {
    name: 'translateInv',
    fun: ({ SUBRULE }) => ({ astFactory: F }, path) => {
        if (path.path.type === types.NPS) {
            const inv = path.path.iris.map((iri) => F.path('^', [SUBRULE(translateAlgTerm, iri)], F.gen()));
            if (inv.length <= 1) {
                return F.path('!', inv, F.gen());
            }
            return F.path('!', [F.path('|', inv, F.gen())], F.gen());
        }
        return F.path('^', [SUBRULE(translateAlgPathComponent, path.path)], F.gen());
    },
};
export const translateAlgLink = {
    name: 'translateLink',
    fun: ({ SUBRULE }) => (_, path) => SUBRULE(translateAlgTerm, path.iri),
};
export const translateAlgNps = {
    name: 'translateNps',
    fun: ({ SUBRULE }) => ({ astFactory: F }, path) => {
        if (path.iris.length === 1) {
            return F.path('!', [SUBRULE(translateAlgTerm, path.iris[0])], F.gen());
        }
        return F.path('!', [
            F.path('|', path.iris.map(x => SUBRULE(translateAlgTerm, x)), F.gen()),
        ], F.gen());
    },
};
export const translateAlgOneOrMorePath = {
    name: 'translateOneOrMorePath',
    fun: ({ SUBRULE }) => ({ astFactory: F }, path) => F.path('+', [SUBRULE(translateAlgPathComponent, path.path)], F.gen()),
};
export const translateAlgSeq = {
    name: 'translateSeq',
    fun: ({ SUBRULE }) => ({ astFactory: F }, path) => F.path('/', path.input.map(x => SUBRULE(translateAlgPathComponent, x)), F.gen()),
};
export const translateAlgZeroOrMorePath = {
    name: 'translateZeroOrMorePath',
    fun: ({ SUBRULE }) => ({ astFactory: F }, path) => F.path('*', [SUBRULE(translateAlgPathComponent, path.path)], F.gen()),
};
export const translateAlgZeroOrOnePath = {
    name: 'translateZeroOrOnePath',
    fun: ({ SUBRULE }) => ({ astFactory: F }, path) => F.path('?', [SUBRULE(translateAlgPathComponent, path.path)], F.gen()),
};
//# sourceMappingURL=path.js.map