import { eTypes } from './core.js';
import { translateAlgTerm } from './general.js';
import { translateAlgPatternNew } from './pattern.js';
export const translateAlgPureExpression = {
    name: 'translatePureExpression',
    fun: ({ SUBRULE }) => (_, expr) => {
        switch (expr.subType) {
            case eTypes.AGGREGATE:
                return SUBRULE(translateAlgAggregateExpression, expr);
            case eTypes.EXISTENCE:
                return SUBRULE(translateAlgExistenceExpression, expr);
            case eTypes.NAMED:
                return SUBRULE(translateAlgNamedExpression, expr);
            case eTypes.OPERATOR:
                return SUBRULE(translateAlgPureOperatorExpression, expr);
            case eTypes.TERM:
                return SUBRULE(translateAlgTerm, expr.term);
            default:
                throw new Error(`Unknown Expression Operation type ${expr.subType}`);
        }
    },
};
export const translateAlgExpressionOrWild = {
    name: 'translateExpressionOrWild',
    fun: ({ SUBRULE }) => (_, expr) => expr.subType === eTypes.WILDCARD ?
        SUBRULE(translateAlgWildcardExpression, expr) :
        SUBRULE(translateAlgPureExpression, expr),
};
export const translateAlgExpressionOrOrdering = {
    name: 'translateExpressionOrOrdering',
    fun: ({ SUBRULE }) => (_, expr) => expr.subType === eTypes.OPERATOR ?
        SUBRULE(translateAlgOperatorExpression, expr) :
        SUBRULE(translateAlgPureExpression, expr),
};
export const translateAlgAnyExpression = {
    name: 'translateAnyExpression',
    fun: ({ SUBRULE }) => (_, expr) => expr.subType === eTypes.OPERATOR ?
        SUBRULE(translateAlgOperatorExpression, expr) :
        SUBRULE(translateAlgExpressionOrWild, expr),
};
export const translateAlgAggregateExpression = {
    name: 'translateAggregateExpression',
    fun: ({ SUBRULE }) => ({ astFactory: F }, expr) => F.aggregate(expr.aggregator, expr.distinct, SUBRULE(translateAlgExpressionOrWild, expr.expression), expr.separator, F.gen()),
};
export const translateAlgExistenceExpression = {
    name: 'translateExistenceExpression',
    fun: ({ SUBRULE }) => ({ astFactory: F }, expr) => F.expressionPatternOperation(expr.not ? 'notexists' : 'exists', 
    // TranslateOperation can give an array
    F.patternGroup([SUBRULE(translateAlgPatternNew, expr.input)].flat(), F.gen()), F.gen()),
};
export const translateAlgNamedExpression = {
    name: 'translateNamedExpression',
    fun: ({ SUBRULE }) => ({ astFactory: F }, expr) => F.expressionFunctionCall(SUBRULE(translateAlgTerm, expr.name), expr.args.map(x => SUBRULE(translateAlgPureExpression, x)), false, F.gen()),
};
export const translateAlgPureOperatorExpression = {
    name: 'translatePureOperatorExpression',
    fun: ({ SUBRULE }) => ({ astFactory: F }, expr) => F.expressionOperation(expr.operator, expr.args.map(x => SUBRULE(translateAlgPureExpression, x)), F.gen()),
};
export const translateAlgOperatorExpression = {
    name: 'translateOperatorExpression',
    fun: ({ SUBRULE }) => ({ astFactory: F }, expr) => {
        if (expr.operator === 'desc') {
            return { expression: SUBRULE(translateAlgPureExpression, expr.args[0]), descending: true, loc: F.gen() };
        }
        return SUBRULE(translateAlgPureOperatorExpression, expr);
    },
};
export const translateAlgWildcardExpression = {
    name: 'translateWildcardExpression',
    fun: () => ({ astFactory: F }, _) => F.wildcard(F.gen()),
};
//# sourceMappingURL=expression.js.map