{"version":3,"file":"general.js","sourceRoot":"","sources":["../../../../lib/toAst/general.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type {\n  DatasetClauses,\n  Pattern,\n  PatternGroup,\n  QuerySelect,\n  Term,\n  TermBlank,\n  TermIri,\n  TermLiteral,\n  TermVariable,\n  TripleNesting,\n} from '@traqula/rules-sparql-1-1';\nimport { Algebra } from '../index.js';\nimport type { AstIndir } from './core.js';\nimport { translateAlgPureExpression } from './expression.js';\nimport { translateAlgPatternIntoGroup, translateAlgPatternNew } from './pattern.js';\n\nexport type RdfTermToAst<T extends RDF.Term> = T extends RDF.Variable ? TermVariable :\n  T extends RDF.BlankNode ? TermBlank :\n    T extends RDF.Literal ? TermLiteral :\n      T extends RDF.NamedNode ? TermIri : never;\n\nexport const translateAlgTerm: AstIndir<'translateTerm', Term, [RDF.Term]> = {\n  name: 'translateTerm',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, term) => {\n    if (term.termType === 'NamedNode') {\n      return F.termNamed(F.gen(), term.value);\n    }\n    if (term.termType === 'BlankNode') {\n      return F.termBlank(term.value, F.gen());\n    }\n    if (term.termType === 'Variable') {\n      return F.termVariable(term.value, F.gen());\n    }\n    if (term.termType === 'Literal') {\n      return F.termLiteral(\n        F.gen(),\n        term.value,\n        term.language ? term.language : <RdfTermToAst<typeof term.datatype>>SUBRULE(translateAlgTerm, term.datatype),\n      );\n    }\n    throw new Error(`invalid term type: ${term.termType}`);\n  },\n};\n\n/**\n * Extend is for example a bind, or an aggregator.\n * The result is thus registered to be tackled at the project level,\n *  or if we are not in project scope, we give it as a patternBind\n *  - of course, the pattern bind is scoped with the other operations at this level\n */\nexport const translateAlgExtend: AstIndir<'translateExtend', Pattern | Pattern[], [Algebra.Extend]> = {\n  name: 'translateExtend',\n  fun: ({ SUBRULE }) => ({ astFactory: F, project, extend }, op) => {\n    if (project) {\n      extend.push(op);\n      return SUBRULE(translateAlgPatternNew, op.input);\n    }\n    // Many extends can be put in a single group\n    const extendsOperations: Algebra.Extend[] = [];\n    function collectExtends(op: Algebra.Operation): Algebra.Operation {\n      if (op.type === Algebra.Types.EXTEND) {\n        extendsOperations.push(op);\n        return collectExtends(op.input);\n      }\n      return op;\n    }\n    const input = collectExtends(op);\n    return F.patternGroup([\n      SUBRULE(translateAlgPatternNew, input),\n      ...extendsOperations.reverse().map(extend => F.patternBind(\n        SUBRULE(translateAlgPureExpression, extend.expression),\n        <RdfTermToAst<typeof extend.variable>> SUBRULE(translateAlgTerm, extend.variable),\n        F.gen(),\n      )),\n    ].flat(), F.gen());\n  },\n};\n\nexport const translateAlgDatasetClauses:\nAstIndir<'translateDatasetClauses', DatasetClauses, [RDF.NamedNode[], RDF.NamedNode[]]> = {\n  name: 'translateDatasetClauses',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, _default, named) =>\n    F.datasetClauses([\n      ..._default.map(x => (<const>{\n        clauseType: 'default',\n        value: <RdfTermToAst<typeof x>> SUBRULE(translateAlgTerm, x),\n      })),\n      ...named.map(x => (<const>{\n        clauseType: 'named',\n        value: <RdfTermToAst<typeof x>>SUBRULE(translateAlgTerm, x),\n      })),\n    ], F.gen()),\n};\n\n/**\n * An order by is just registered to be handled in the creation of your QueryBase\n */\nexport const translateAlgOrderBy: AstIndir<'translateOrderBy', Pattern | Pattern[], [Algebra.OrderBy]> = {\n  name: 'translateOrderBy',\n  fun: ({ SUBRULE }) => ({ order }, op) => {\n    order.push(...op.expressions);\n    return SUBRULE(translateAlgPatternNew, op.input);\n  },\n};\n\nexport const translateAlgPattern: AstIndir<'translatePattern', TripleNesting, [Algebra.Pattern]> = {\n  name: 'translatePattern',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) =>\n    F.triple(\n      SUBRULE(translateAlgTerm, op.subject),\n      <TripleNesting['predicate']> SUBRULE(translateAlgTerm, op.predicate),\n      SUBRULE(translateAlgTerm, op.object),\n    ),\n};\n\n/**\n * Reduced is wrapped around a project, set the query contained to be distinct\n */\nexport const translateAlgReduced: AstIndir<'translateReduced', PatternGroup, [Algebra.Reduced]> = {\n  name: 'translateReduced',\n  fun: ({ SUBRULE }) => (_, op) => {\n    const result = SUBRULE(translateAlgPatternIntoGroup, op.input);\n    const select = <QuerySelect>result.patterns[0];\n    select.reduced = true;\n    return result;\n  },\n};\n\n/**\n * District is wrapped around a project, set the query contained to be distinct\n */\nexport const translateAlgDistinct: AstIndir<'translateDistinct', PatternGroup, [Algebra.Distinct]> = {\n  name: 'translateDistinct',\n  fun: ({ SUBRULE }) => (_, op) => {\n    const result = SUBRULE(translateAlgPatternIntoGroup, op.input);\n    const select = <QuerySelect>result.patterns[0];\n    select.distinct = true;\n    return result;\n  },\n};\n"]}