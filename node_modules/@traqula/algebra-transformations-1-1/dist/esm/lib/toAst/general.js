import { Algebra } from '../index.js';
import { translateAlgPureExpression } from './expression.js';
import { translateAlgPatternIntoGroup, translateAlgPatternNew } from './pattern.js';
export const translateAlgTerm = {
    name: 'translateTerm',
    fun: ({ SUBRULE }) => ({ astFactory: F }, term) => {
        if (term.termType === 'NamedNode') {
            return F.termNamed(F.gen(), term.value);
        }
        if (term.termType === 'BlankNode') {
            return F.termBlank(term.value, F.gen());
        }
        if (term.termType === 'Variable') {
            return F.termVariable(term.value, F.gen());
        }
        if (term.termType === 'Literal') {
            return F.termLiteral(F.gen(), term.value, term.language ? term.language : SUBRULE(translateAlgTerm, term.datatype));
        }
        throw new Error(`invalid term type: ${term.termType}`);
    },
};
/**
 * Extend is for example a bind, or an aggregator.
 * The result is thus registered to be tackled at the project level,
 *  or if we are not in project scope, we give it as a patternBind
 *  - of course, the pattern bind is scoped with the other operations at this level
 */
export const translateAlgExtend = {
    name: 'translateExtend',
    fun: ({ SUBRULE }) => ({ astFactory: F, project, extend }, op) => {
        if (project) {
            extend.push(op);
            return SUBRULE(translateAlgPatternNew, op.input);
        }
        // Many extends can be put in a single group
        const extendsOperations = [];
        function collectExtends(op) {
            if (op.type === Algebra.Types.EXTEND) {
                extendsOperations.push(op);
                return collectExtends(op.input);
            }
            return op;
        }
        const input = collectExtends(op);
        return F.patternGroup([
            SUBRULE(translateAlgPatternNew, input),
            ...extendsOperations.reverse().map(extend => F.patternBind(SUBRULE(translateAlgPureExpression, extend.expression), SUBRULE(translateAlgTerm, extend.variable), F.gen())),
        ].flat(), F.gen());
    },
};
export const translateAlgDatasetClauses = {
    name: 'translateDatasetClauses',
    fun: ({ SUBRULE }) => ({ astFactory: F }, _default, named) => F.datasetClauses([
        ..._default.map(x => ({
            clauseType: 'default',
            value: SUBRULE(translateAlgTerm, x),
        })),
        ...named.map(x => ({
            clauseType: 'named',
            value: SUBRULE(translateAlgTerm, x),
        })),
    ], F.gen()),
};
/**
 * An order by is just registered to be handled in the creation of your QueryBase
 */
export const translateAlgOrderBy = {
    name: 'translateOrderBy',
    fun: ({ SUBRULE }) => ({ order }, op) => {
        order.push(...op.expressions);
        return SUBRULE(translateAlgPatternNew, op.input);
    },
};
export const translateAlgPattern = {
    name: 'translatePattern',
    fun: ({ SUBRULE }) => ({ astFactory: F }, op) => F.triple(SUBRULE(translateAlgTerm, op.subject), SUBRULE(translateAlgTerm, op.predicate), SUBRULE(translateAlgTerm, op.object)),
};
/**
 * Reduced is wrapped around a project, set the query contained to be distinct
 */
export const translateAlgReduced = {
    name: 'translateReduced',
    fun: ({ SUBRULE }) => (_, op) => {
        const result = SUBRULE(translateAlgPatternIntoGroup, op.input);
        const select = result.patterns[0];
        select.reduced = true;
        return result;
    },
};
/**
 * District is wrapped around a project, set the query contained to be distinct
 */
export const translateAlgDistinct = {
    name: 'translateDistinct',
    fun: ({ SUBRULE }) => (_, op) => {
        const result = SUBRULE(translateAlgPatternIntoGroup, op.input);
        const select = result.patterns[0];
        select.distinct = true;
        return result;
    },
};
//# sourceMappingURL=general.js.map