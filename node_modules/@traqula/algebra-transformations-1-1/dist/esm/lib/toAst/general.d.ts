import type * as RDF from '@rdfjs/types';
import type { DatasetClauses, Pattern, PatternGroup, Term, TermBlank, TermIri, TermLiteral, TermVariable, TripleNesting } from '@traqula/rules-sparql-1-1';
import { Algebra } from '../index.js';
import type { AstIndir } from './core.js';
export type RdfTermToAst<T extends RDF.Term> = T extends RDF.Variable ? TermVariable : T extends RDF.BlankNode ? TermBlank : T extends RDF.Literal ? TermLiteral : T extends RDF.NamedNode ? TermIri : never;
export declare const translateAlgTerm: AstIndir<'translateTerm', Term, [RDF.Term]>;
/**
 * Extend is for example a bind, or an aggregator.
 * The result is thus registered to be tackled at the project level,
 *  or if we are not in project scope, we give it as a patternBind
 *  - of course, the pattern bind is scoped with the other operations at this level
 */
export declare const translateAlgExtend: AstIndir<'translateExtend', Pattern | Pattern[], [Algebra.Extend]>;
export declare const translateAlgDatasetClauses: AstIndir<'translateDatasetClauses', DatasetClauses, [RDF.NamedNode[], RDF.NamedNode[]]>;
/**
 * An order by is just registered to be handled in the creation of your QueryBase
 */
export declare const translateAlgOrderBy: AstIndir<'translateOrderBy', Pattern | Pattern[], [Algebra.OrderBy]>;
export declare const translateAlgPattern: AstIndir<'translatePattern', TripleNesting, [Algebra.Pattern]>;
/**
 * Reduced is wrapped around a project, set the query contained to be distinct
 */
export declare const translateAlgReduced: AstIndir<'translateReduced', PatternGroup, [Algebra.Reduced]>;
/**
 * District is wrapped around a project, set the query contained to be distinct
 */
export declare const translateAlgDistinct: AstIndir<'translateDistinct', PatternGroup, [Algebra.Distinct]>;
