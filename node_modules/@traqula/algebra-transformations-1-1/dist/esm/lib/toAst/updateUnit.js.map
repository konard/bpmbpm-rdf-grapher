{"version":3,"file":"updateUnit.js","sourceRoot":"","sources":["../../../../lib/toAst/updateUnit.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type {\n  DatasetClauses,\n  GraphRef,\n  GraphRefAll,\n  GraphRefDefault,\n  GraphRefNamed,\n  GraphRefSpecific,\n  Quads,\n  TermIri,\n  TermVariable,\n  Update,\n  UpdateOperation,\n  UpdateOperationAdd,\n  UpdateOperationClear,\n  UpdateOperationCopy,\n  UpdateOperationCreate,\n  UpdateOperationDeleteData,\n  UpdateOperationDeleteWhere,\n  UpdateOperationDrop,\n  UpdateOperationInsertData,\n  UpdateOperationLoad,\n  UpdateOperationModify,\n  UpdateOperationMove,\n} from '@traqula/rules-sparql-1-1';\nimport { isomorphic } from 'rdf-isomorphic';\nimport type * as Algebra from '../algebra.js';\nimport { Types } from '../algebra.js';\nimport { isVariable, types } from '../toAlgebra/index.js';\nimport type { AstIndir } from './core.js';\nimport type { RdfTermToAst } from './general.js';\nimport { translateAlgDatasetClauses, translateAlgPattern, translateAlgTerm } from './general.js';\nimport { algWrapInPatternGroup, translateAlgPatternNew } from './pattern.js';\nimport { removeAlgQuadsRecursive } from './quads.js';\n\nexport const translateAlgUpdateOperation: AstIndir<'translateUpdateOperation', UpdateOperation, [Algebra.Update]> = {\n  name: 'translateUpdateOperation',\n  fun: ({ SUBRULE }) => (_, op) => {\n    switch (op.type) {\n      case Types.DELETE_INSERT:\n        return SUBRULE(translateAlgDeleteInsert, op);\n      case Types.LOAD:\n        return SUBRULE(translateAlgLoad, op);\n      case Types.CLEAR:\n        return SUBRULE(translateAlgClear, op);\n      case Types.CREATE:\n        return SUBRULE(translateAlgCreate, op);\n      case Types.DROP:\n        return SUBRULE(translateAlgDrop, op);\n      case Types.ADD:\n        return SUBRULE(translateAlgAdd, op);\n      case Types.MOVE:\n        return SUBRULE(translateAlgMove, op);\n      case Types.COPY:\n        return SUBRULE(translateAlgCopy, op);\n      default:\n        throw new Error(`Unknown Operation type ${(<Algebra.Operation> op).type}`);\n    }\n  },\n};\n\nexport const toUpdate: AstIndir<'toUpdate', Update, [(UpdateOperation | undefined)[]]> = {\n  name: 'toUpdate',\n  fun: () => ({ astFactory: F }, ops) => ({\n    type: 'update',\n    updates: ops.map(op => ({ context: [], operation: op })),\n    loc: F.gen(),\n  } satisfies Update),\n};\n\nexport const translateAlgCompositeUpdate: AstIndir<'translateCompositeUpdate', Update, [Algebra.CompositeUpdate]> = {\n  name: 'translateCompositeUpdate',\n  fun: ({ SUBRULE }) => (_, op) => SUBRULE(\n    toUpdate,\n    op.updates.map(update => update.type === Types.NOP ? undefined : SUBRULE(translateAlgUpdateOperation, update)),\n  ),\n};\n\ntype LikeModify = UpdateOperationModify\n  | UpdateOperationDeleteData\n  | UpdateOperationDeleteWhere\n  | UpdateOperationInsertData;\n\nexport const translateAlgDeleteInsert: AstIndir<'translateDeleteInsert', LikeModify, [Algebra.DeleteInsert]> = {\n  name: 'translateDeleteInsert',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) => {\n    let where: Algebra.Operation | undefined = op.where;\n    let use: DatasetClauses | undefined;\n    if (where && where.type === types.FROM) {\n      const from = where;\n      where = from.input;\n      use = SUBRULE(translateAlgDatasetClauses, from.default, from.named);\n    }\n\n    const update: UpdateOperationModify = {\n      type: 'updateOperation',\n      subType: 'modify',\n      delete: SUBRULE(convertAlgUpdatePatterns, op.delete ?? []),\n      insert: SUBRULE(convertAlgUpdatePatterns, op.insert ?? []),\n      where: F.patternGroup([], F.gen()),\n      from: use ?? F.datasetClauses([], F.gen()),\n      loc: F.gen(),\n      graph: undefined,\n    };\n\n    // If not an empty where pattern, handle quads\n    if (where && (where.type !== types.BGP || where.patterns.length > 0)) {\n      const graphs: (RDF.NamedNode | RDF.DefaultGraph)[] = [];\n      const result = SUBRULE(translateAlgPatternNew, <typeof where> SUBRULE(removeAlgQuadsRecursive, where, graphs));\n      update.where = SUBRULE(algWrapInPatternGroup, result);\n      // Graph might not be applied yet since there was no project\n      // this can only happen if there was a single graph\n      if (graphs.length > 0) {\n        if (graphs.length === 1) {\n          // Ignore if default graph\n          if (graphs.at(0)?.value !== '') {\n            update.where.patterns = [\n              F.patternGraph(<RdfTermToAst<typeof graphs[0]>>\n                SUBRULE(translateAlgTerm, graphs[0]), update.where.patterns, F.gen()),\n            ];\n          }\n        } else {\n          throw new Error('This is unexpected and might indicate an error in graph handling for updates.');\n        }\n      }\n    }\n\n    return SUBRULE(cleanupAlgUpdateOperationModify, update, op);\n  },\n};\n\n/**\n * Return the minimal version of the UpdateOperationModify.\n * Not really necessary but can give cleaner looking queries\n */\nexport const cleanupAlgUpdateOperationModify:\nAstIndir<'cleanUpUpdateOperationModify', LikeModify, [UpdateOperationModify, Algebra.DeleteInsert]> = {\n  name: 'cleanUpUpdateOperationModify',\n  fun: () => (_, update, op) => {\n    const copy = { ...update };\n    // Check Insert Data\n    if (!op.delete && !op.where) {\n      const asInsert = <UpdateOperationInsertData & { delete?: unknown; where?: unknown }> <unknown> copy;\n      asInsert.subType = 'insertdata';\n      asInsert.data = copy.insert;\n      delete asInsert.delete;\n      delete asInsert.where;\n      return asInsert;\n    }\n    // Check DeleteWhere or DeleteData\n    if (!op.insert && !op.where) {\n      const asCasted =\n        <(UpdateOperationDeleteData | UpdateOperationDeleteWhere) & { insert?: unknown; where?: unknown }>\n          <unknown> copy;\n      asCasted.data = copy.delete;\n      delete asCasted.insert;\n      delete asCasted.where;\n      if (op.delete!.some(pattern =>\n        isVariable(pattern.subject) || isVariable(pattern.predicate) || isVariable(pattern.object))) {\n        asCasted.subType = 'deletewhere';\n      } else {\n        asCasted.subType = 'deletedata';\n      }\n      return asCasted;\n    }\n    // Check if deleteWhere when modify but isomorphic.\n    if (!op.insert && op.where && op.where.type === 'bgp' && isomorphic(op.delete!, op.where.patterns)) {\n      const asCasted = <UpdateOperationDeleteWhere & { where?: unknown; delete?: unknown }> <unknown> copy;\n      asCasted.data = copy.delete;\n      delete asCasted.where;\n      delete asCasted.delete;\n      asCasted.subType = 'deletewhere';\n      return asCasted;\n    }\n    return update;\n  },\n};\n\nexport const translateAlgLoad: AstIndir<'translateLoad', UpdateOperationLoad, [Algebra.Load]> = {\n  name: 'translateLoad',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) =>\n    F.updateOperationLoad(\n      F.gen(),\n      <RdfTermToAst<typeof op.source>>SUBRULE(translateAlgTerm, op.source),\n      Boolean(op.silent),\n      op.destination ?\n        F.graphRefSpecific(<RdfTermToAst<typeof op.destination>>SUBRULE(translateAlgTerm, op.destination), F.gen()) :\n        undefined,\n    ),\n};\n\ntype GraphToGraphRef<T extends 'DEFAULT' | 'NAMED' | 'ALL' | RDF.NamedNode> = T extends 'DEFAULT' ? GraphRefDefault :\n  T extends 'NAMED' ? GraphRefNamed : T extends 'ALL' ? GraphRefAll : GraphRefSpecific;\n\nexport const translateAlgGraphRef:\nAstIndir<'translateGraphRef', GraphRef, ['DEFAULT' | 'NAMED' | 'ALL' | RDF.NamedNode]> = {\n  name: 'translateGraphRef',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, graphRef) => {\n    if (graphRef === 'DEFAULT') {\n      return F.graphRefDefault(F.gen());\n    }\n    if (graphRef === 'NAMED') {\n      return F.graphRefNamed(F.gen());\n    }\n    if (graphRef === 'ALL') {\n      return F.graphRefAll(F.gen());\n    }\n    return F.graphRefSpecific(<TermIri> SUBRULE(translateAlgTerm, graphRef), F.gen());\n  },\n};\n\nexport const translateAlgClear: AstIndir<'translateClear', UpdateOperationClear, [Algebra.Clear]> = {\n  name: 'translateClear',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) =>\n    F.updateOperationClear(SUBRULE(translateAlgGraphRef, op.source), op.silent ?? false, F.gen()),\n};\n\nexport const translateAlgCreate: AstIndir<'translateCreate', UpdateOperationCreate, [Algebra.Create]> = {\n  name: 'translateCreate',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) =>\n    F.updateOperationCreate(\n      <GraphToGraphRef<typeof op.source>>SUBRULE(translateAlgGraphRef, op.source),\n      op.silent ?? false,\n      F.gen(),\n    ),\n};\n\nexport const translateAlgDrop: AstIndir<'translateDrop', UpdateOperationDrop, [Algebra.Drop]> = {\n  name: 'translateDrop',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) =>\n    F.updateOperationDrop(SUBRULE(translateAlgGraphRef, op.source), op.silent ?? false, F.gen()),\n};\n\nexport const translateAlgAdd: AstIndir<'translateAdd', UpdateOperationAdd, [Algebra.Add]> = {\n  name: 'translateAdd',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) =>\n    F.updateOperationAdd(\n      <GraphToGraphRef<typeof op.source>> SUBRULE(translateAlgGraphRef, op.source),\n      <GraphToGraphRef<typeof op.destination>> SUBRULE(translateAlgGraphRef, op.destination),\n      op.silent ?? false,\n      F.gen(),\n    ),\n};\n\nexport const translateAlgMove: AstIndir<'translateMove', UpdateOperationMove, [Algebra.Move]> = {\n  name: 'translateMove',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) =>\n    F.updateOperationMove(\n      <GraphToGraphRef<typeof op.source>> SUBRULE(translateAlgGraphRef, op.source),\n      <GraphToGraphRef<typeof op.destination>> SUBRULE(translateAlgGraphRef, op.destination),\n      op.silent ?? false,\n      F.gen(),\n    ),\n};\n\nexport const translateAlgCopy: AstIndir<'translateCopy', UpdateOperationCopy, [Algebra.Copy]> = {\n  name: 'translateCopy',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, op) =>\n    F.updateOperationCopy(\n      <GraphToGraphRef<typeof op.source>> SUBRULE(translateAlgGraphRef, op.source),\n      <GraphToGraphRef<typeof op.destination>> SUBRULE(translateAlgGraphRef, op.destination),\n      op.silent ?? false,\n      F.gen(),\n    ),\n};\n\n/**\n * Similar to removeQuads but more simplified for UPDATES\n */\nexport const convertAlgUpdatePatterns: AstIndir<'convertUpdatePatterns', Quads[], [Algebra.Pattern[]]> = {\n  name: 'convertUpdatePatterns',\n  fun: ({ SUBRULE }) => ({ astFactory: F }, patterns) => {\n    if (!patterns) {\n      return [];\n    }\n    const graphs: Record<string, Algebra.Pattern[]> = {};\n    for (const pattern of patterns) {\n      const graph = pattern.graph.value;\n      if (!graphs[graph]) {\n        graphs[graph] = [];\n      }\n      graphs[graph].push(pattern);\n    }\n    return Object.keys(graphs).map((graph) => {\n      const patternBgp = F.patternBgp(graphs[graph].map(x => SUBRULE(translateAlgPattern, x)), F.gen());\n      // If DefaultGraph, de not wrap\n      if (graph === '') {\n        return patternBgp;\n      }\n      return F.graphQuads(\n        <TermIri | TermVariable> SUBRULE(translateAlgTerm, graphs[graph][0].graph),\n        patternBgp,\n        F.gen(),\n      );\n    });\n  },\n};\n"]}