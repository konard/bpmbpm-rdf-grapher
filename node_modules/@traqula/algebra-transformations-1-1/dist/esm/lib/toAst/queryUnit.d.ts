import type * as RDF from '@rdfjs/types';
import type { Expression, Pattern, PatternGroup, QueryBase, QuerySelect } from '@traqula/rules-sparql-1-1';
import type { Algebra } from '../index.js';
import type { AstIndir } from './core.js';
export declare const translateAlgConstruct: AstIndir<'translateConstruct', PatternGroup, [Algebra.Construct]>;
/**
 * Will mostly return the same type as what you give in second arg.
 */
export declare const replaceAlgAggregatorVariables: AstIndir<'replaceAggregatorVariables', unknown, [unknown, Record<string, Expression>]>;
export declare const translateAlgProject: AstIndir<'translateProject', PatternGroup, [Algebra.Project | Algebra.Ask | Algebra.Describe, string]>;
export declare const registerAlgGroupBy: AstIndir<'registerGroupBy', void, [QueryBase, Record<string, Expression>]>;
export declare const registerOrderBy: AstIndir<'registerOrderBy', void, [QueryBase]>;
export declare const registerVariables: AstIndir<'registerVariables', void, [QuerySelect, RDF.Variable[] | undefined, Record<string, Expression>]>;
/**
 * It is possible that at this point some extensions have not yet been resolved.
 * These would be bind operations that are not used in a GROUP BY or SELECT body.
 * We still need to add them though, as they could be relevant to the other extensions.
 */
export declare const putExtensionsInGroup: AstIndir<'putExtensionsInGroup', void, [QueryBase, Record<string, Expression>]>;
/**
 * If second arg is a Group, we will return a group.
 */
export declare const filterReplace: AstIndir<'filterReplace', PatternGroup | Pattern, [
    PatternGroup | Pattern,
    Record<string, Expression>,
    Expression[]
]>;
export declare const objectContainsVariable: AstIndir<'objectContainsVariable', boolean, [any, string[]]>;
