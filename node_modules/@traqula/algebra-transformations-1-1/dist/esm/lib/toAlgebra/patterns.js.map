{"version":3,"file":"patterns.js","sourceRoot":"","sources":["../../../../lib/toAlgebra/patterns.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type {\n  Expression,\n  PathPure,\n  Pattern,\n  PatternBgp,\n  PatternFilter,\n  PatternGroup,\n  Wildcard,\n} from '@traqula/rules-sparql-1-1';\nimport type { Algebra } from '../index.js';\nimport type { AlgebraIndir, FlattenedTriple } from './core.js';\nimport { types } from './core.js';\nimport type { AstToRdfTerm } from './general.js';\nimport { translateInlineData, translateNamed, translateTerm } from './general.js';\nimport { translatePath } from './path.js';\nimport { translateQuery } from './toAlgebra.js';\nimport { recurseGraph, translateBasicGraphPattern, translateQuad } from './tripleAndQuad.js';\n\n/**\n * Handles part of: 18.2.2.2 Collect FILTER Elements\n */\nexport const translateExpression: AlgebraIndir<'translateExpression', Algebra.Expression, [Expression | Wildcard]> = {\n  name: 'translateExpression',\n  fun: ({ SUBRULE }) => ({ astFactory: F, algebraFactory: AF }, expr) => {\n    if (F.isTerm(expr)) {\n      return AF.createTermExpression(SUBRULE(translateTerm, expr));\n    }\n\n    if (F.isWildcard(expr)) {\n      return AF.createWildcardExpression();\n    }\n\n    if (F.isExpressionAggregate(expr)) {\n      return AF.createAggregateExpression(\n        expr.aggregation,\n        SUBRULE(translateExpression, expr.expression[0]),\n        expr.distinct,\n        F.isExpressionAggregateSeparator(expr) ? expr.separator : undefined,\n      );\n    }\n\n    if (F.isExpressionFunctionCall(expr)) {\n      // Outdated typings\n      return AF.createNamedExpression(\n        SUBRULE(translateNamed, expr.function),\n        expr.args.map(subExpr => SUBRULE(translateExpression, subExpr)),\n      );\n    }\n\n    if (F.isExpressionOperator(expr)) {\n      return AF.createOperatorExpression(\n        expr.operator,\n        expr.args.map(subExpr => SUBRULE(translateExpression, subExpr)),\n      );\n    }\n\n    if (F.isExpressionPatternOperation(expr)) {\n      return AF.createExistenceExpression(\n        expr.operator === 'notexists',\n        SUBRULE(translateGraphPattern, expr.args),\n      );\n    }\n\n    throw new Error(`Unknown expression: ${JSON.stringify(expr)}`);\n  },\n};\n\nexport const translateGraphPattern: AlgebraIndir<'translateGraphPattern', Algebra.Operation, [Pattern]> = {\n  name: 'translateGraphPattern',\n  fun: ({ SUBRULE }) => ({ astFactory: F, algebraFactory: AF, useQuads }, pattern) => {\n    // 18.2.2.1: Expand Syntax Forms -\n    //    partly done by sparql parser, partly in this.translateTerm, and partly in BGP\n    // https://www.w3.org/TR/sparql11-query/#sparqlExpandForms\n    // https://www.w3.org/TR/sparql11-query/#QSynIRI\n    if (F.isPatternBgp(pattern)) {\n      return SUBRULE(translateBgp, pattern);\n    }\n\n    // 18.2.2.6: Translate Graph Patterns - GroupOrUnionGraphPattern\n    if (F.isPatternUnion(pattern)) {\n      return AF.createUnion(\n        pattern.patterns.map((group: PatternGroup) => SUBRULE(translateGraphPattern, group)),\n      );\n    }\n\n    // 18.2.2.6: Translate Graph Patterns - GraphGraphPattern\n    if (F.isPatternGraph(pattern)) {\n      // Sparql.js combines the group graph pattern and the graph itself in the same object.\n      // We split here so the group graph pattern can be interpreted correctly.\n      const group = F.patternGroup(pattern.patterns, pattern.loc);\n      let result = SUBRULE(translateGraphPattern, group);\n\n      // Output depends on if we use quads or not\n      if (useQuads) {\n        result = SUBRULE(recurseGraph, result, SUBRULE(translateTerm, pattern.name), undefined);\n      } else {\n        result = AF.createGraph(result, <RDF.NamedNode | RDF.Variable> SUBRULE(translateTerm, pattern.name));\n      }\n\n      return result;\n    }\n\n    // 18.2.2.6: Translate Graph Patterns - InlineData\n    if (F.isPatternValues(pattern)) {\n      return SUBRULE(translateInlineData, pattern);\n    }\n\n    // 18.2.2.6: Translate Graph Patterns - SubSelect\n    if (F.isQuerySelect(pattern)) {\n      return SUBRULE(translateQuery, pattern, useQuads, false);\n    }\n\n    // 18.2.2.6: Translate Graph Patterns - GroupGraphPattern\n    if (F.isPatternGroup(pattern)) {\n      // 18.2.2.2 - Collect FILTER Elements\n      const filters: PatternFilter[] = [];\n      const nonfilters: Pattern[] = [];\n      for (const subPattern of pattern.patterns) {\n        if (F.isPatternFilter(subPattern)) {\n          filters.push(subPattern);\n        } else {\n          nonfilters.push(subPattern);\n        }\n      }\n\n      // 18.2.2.6 - GroupGraphPattern\n      let result: Algebra.Operation = AF.createBgp([]);\n      for (const pattern of nonfilters) {\n        result = SUBRULE(accumulateGroupGraphPattern, result, pattern);\n      }\n\n      // 18.2.2.7 - Filters of Group - translateExpression handles notExists negation.\n      const expressions: Algebra.Expression[] = filters.map(filter => SUBRULE(translateExpression, filter.expression));\n      if (expressions.length > 0) {\n        let conjunction = expressions[0];\n        for (const expression of expressions.slice(1)) {\n          conjunction = AF.createOperatorExpression('&&', [ conjunction, expression ]);\n        }\n        // One big filter applied on the group\n        result = AF.createFilter(result, conjunction);\n      }\n\n      return result;\n    }\n\n    throw new Error(`Unexpected pattern: ${pattern.subType}`);\n  },\n};\n\n/**\n * 18.2.2.1: Expand Syntax Forms: Flatten TripleCollection\n * 18.2.2.3: Translate Property Path Expressions\n * 18.2.2.4: Translate Property Path Patterns\n * 18.2.2.5: Translate Basic Graph Patterns\n */\nexport const translateBgp: AlgebraIndir<'translateBgp', Algebra.Operation, [PatternBgp]> = {\n  name: 'translateBgp',\n  fun: ({ SUBRULE }) => ({ astFactory: F, algebraFactory: AF }, bgp) => {\n    let patterns: Algebra.Pattern[] = [];\n    const joins: Algebra.Operation[] = [];\n    const flattenedTriples: FlattenedTriple[] = [];\n    SUBRULE(translateBasicGraphPattern, bgp.triples, flattenedTriples);\n    for (const triple of flattenedTriples) {\n      if (F.isPathPure(triple.predicate)) {\n        const smartType = <FlattenedTriple & { predicate: PathPure }> triple;\n        // TranslatePath returns a mix of Quads and Paths\n        const path = SUBRULE(translatePath, smartType);\n        for (const p of path) {\n          if (p.type === types.PATH) {\n            if (patterns.length > 0) {\n              joins.push(AF.createBgp(patterns));\n            }\n            patterns = [];\n            joins.push(p);\n          } else {\n            patterns.push(p);\n          }\n        }\n      } else {\n        patterns.push(SUBRULE(translateQuad, triple));\n      }\n    }\n    if (patterns.length > 0) {\n      joins.push(AF.createBgp(patterns));\n    }\n    if (joins.length === 1) {\n      return joins[0];\n    }\n    return AF.createJoin(joins);\n  },\n};\n\n/**\n * 18.2.2.6 Translate Graph Patterns - GroupGraphPattern\n */\nexport const accumulateGroupGraphPattern:\nAlgebraIndir<'accumulateGroupGraphPattern', Algebra.Operation, [Algebra.Operation, Pattern]> = {\n  name: 'accumulateGroupGraphPattern',\n  fun: ({ SUBRULE }) => ({ astFactory: F, algebraFactory: AF }, algebraOp, pattern) => {\n    if (F.isPatternOptional(pattern)) {\n      // Optional input needs to be interpreted as a group\n      const groupAsAlgebra = SUBRULE(translateGraphPattern, F.patternGroup(pattern.patterns, pattern.loc));\n      if (groupAsAlgebra.type === types.FILTER) {\n        return AF.createLeftJoin(algebraOp, groupAsAlgebra.input, groupAsAlgebra.expression);\n      }\n      return AF.createLeftJoin(algebraOp, groupAsAlgebra);\n    }\n\n    if (F.isPatternMinus(pattern)) {\n      // Minus input needs to be interpreted as a group\n      const groupAsAlgebra = SUBRULE(translateGraphPattern, F.patternGroup(pattern.patterns, pattern.loc));\n      return AF.createMinus(algebraOp, groupAsAlgebra);\n    }\n\n    if (F.isPatternBind(pattern)) {\n      return AF.createExtend(\n        algebraOp,\n        <AstToRdfTerm<typeof pattern.variable>> SUBRULE(translateTerm, pattern.variable),\n        SUBRULE(translateExpression, pattern.expression),\n      );\n    }\n\n    if (F.isPatternService(pattern)) {\n      // Transform to group so child-nodes get parsed correctly\n      const group = F.patternGroup(pattern.patterns, pattern.loc);\n      const A = AF.createService(\n        SUBRULE(translateGraphPattern, group),\n        <AstToRdfTerm<typeof pattern.name>> SUBRULE(translateTerm, pattern.name),\n        pattern.silent,\n      );\n      return SUBRULE(simplifiedJoin, algebraOp, A);\n    }\n\n    const A = SUBRULE(translateGraphPattern, pattern);\n    return SUBRULE(simplifiedJoin, algebraOp, A);\n  },\n};\n\nexport const simplifiedJoin:\nAlgebraIndir<'simplifiedJoin', Algebra.Operation, [Algebra.Operation, Algebra.Operation]> = {\n  name: 'simplifiedJoin',\n  fun: () => ({ algebraFactory: AF }, G, A) => {\n    // Note: this is more simplification than requested in 18.2.2.8, but no reason not to do it.\n    if (G.type === types.BGP && A.type === types.BGP) {\n      G = AF.createBgp([ ...G.patterns, ...A.patterns ]);\n    } else if (G.type === types.BGP && G.patterns.length === 0) {\n      // 18.2.2.8 (simplification)\n      G = A;\n    } else if (A.type === types.BGP && A.patterns.length === 0) {\n      // Do nothing\n    } else {\n      G = AF.createJoin([ G, A ]);\n    }\n    return G;\n  },\n};\n"]}