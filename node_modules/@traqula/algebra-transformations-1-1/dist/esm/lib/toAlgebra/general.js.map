{"version":3,"file":"general.js","sourceRoot":"","sources":["../../../../lib/toAlgebra/general.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport {\n  findPatternBoundedVars,\n} from '@traqula/rules-sparql-1-1';\nimport type {\n  ContextDefinition,\n  DatasetClauses,\n  Path,\n  PatternValues,\n  SparqlQuery,\n  Term,\n  TripleCollection,\n  TripleNesting,\n  TermIri,\n  TermBlank,\n  TermLiteral,\n  TermVariable,\n} from '@traqula/rules-sparql-1-1';\nimport * as Algebra from '../algebra.js';\nimport * as util from '../util.js';\nimport type { AlgebraIndir } from './core.js';\n\nexport const translateNamed: AlgebraIndir<'translateNamed', RDF.NamedNode, [TermIri]> = {\n  name: 'translateNamed',\n  fun: () => ({ astFactory: F, currentPrefixes, currentBase, dataFactory }, term) => {\n    let fullIri: string = term.value;\n    if (F.isTermNamedPrefixed(term)) {\n      const expanded = currentPrefixes[term.prefix];\n      if (!expanded) {\n        throw new Error(`Unknown prefix: ${term.prefix}`);\n      }\n      fullIri = expanded + term.value;\n    }\n    return dataFactory.namedNode(util.resolveIRI(fullIri, currentBase));\n  },\n};\n\nexport type AstToRdfTerm<T extends Term> = T extends TermVariable ? RDF.Variable :\n  T extends TermBlank ? RDF.BlankNode :\n    T extends TermLiteral ? RDF.Literal :\n      T extends TermIri ? RDF.NamedNode : never;\n\nexport const translateTerm: AlgebraIndir<'translateTerm', RDF.Term, [Term]> = {\n  name: 'translateTerm',\n  fun: ({ SUBRULE }) => ({ astFactory: F, dataFactory }, term) => {\n    if (F.isTermNamed(term)) {\n      return SUBRULE(translateNamed, term);\n    }\n    if (F.isTermBlank(term)) {\n      return dataFactory.blankNode(term.label);\n    }\n    if (F.isTermVariable(term)) {\n      return dataFactory.variable(term.value);\n    }\n    if (F.isTermLiteral(term)) {\n      const langOrIri = typeof term.langOrIri === 'object' ?\n        SUBRULE(translateNamed, term.langOrIri) :\n        term.langOrIri;\n      return dataFactory.literal(term.value, langOrIri);\n    }\n    throw new Error(`Unexpected term: ${JSON.stringify(term)}`);\n  },\n};\n\nexport const registerContextDefinitions: AlgebraIndir<'registerContextDefinitions', void, [ContextDefinition[]]> = {\n  name: 'registerContextDefinitions',\n  fun: ({ SUBRULE }) => (c, definitions) => {\n    const { astFactory: F, currentPrefixes } = c;\n    for (const def of definitions) {\n      if (F.isContextDefinitionPrefix(def)) {\n        currentPrefixes[def.key] = SUBRULE(translateTerm, def.value).value;\n      }\n      if (F.isContextDefinitionBase(def)) {\n        c.currentBase = SUBRULE(translateTerm, def.value).value;\n      }\n    }\n  },\n};\n\nexport const translateInlineData: AlgebraIndir<'translateInlineData', Algebra.Values, [PatternValues]> = {\n  name: 'translateInlineData',\n  fun: ({ SUBRULE }) => ({ algebraFactory: AF }, values) => {\n    const variables = values.variables.map(x => <AstToRdfTerm<typeof x>> SUBRULE(translateTerm, x));\n    const bindings = values.values.map((binding) => {\n      const map: Record<string, RDF.NamedNode | RDF.Literal> = {};\n      for (const [ key, value ] of Object.entries(binding)) {\n        if (value !== undefined) {\n          map[key] = <RDF.NamedNode | RDF.Literal> SUBRULE(translateTerm, value);\n        }\n      }\n      return map;\n    });\n    return AF.createValues(variables, bindings);\n  },\n};\n\nexport const translateDatasetClause:\nAlgebraIndir<'translateDatasetClause', { default: RDF.NamedNode[]; named: RDF.NamedNode[] }, [DatasetClauses]> = {\n  name: 'translateDatasetClause',\n  fun: ({ SUBRULE }) => (_, dataset) => ({\n    default: dataset.clauses.filter(x => x.clauseType === 'default')\n      .map(x => SUBRULE(translateNamed, x.value)),\n    named: dataset.clauses.filter(x => x.clauseType === 'named')\n      .map(x => SUBRULE(translateNamed, x.value)),\n  }),\n};\n\nexport const translateBlankNodesToVariables:\nAlgebraIndir<'translateBlankNodesToVariables', Algebra.Operation, [Algebra.Operation]> = {\n  name: 'translateBlankNodesToVariables',\n  fun: ({ SUBRULE }) => ({ algebraFactory: AF, variables }, res) => {\n    const blankToVariableMapping: Record<string, RDF.Variable> = {};\n    const variablesRaw: Set<string> = new Set(variables);\n\n    function uniqueVar(label: string): RDF.Variable {\n      let counter = 0;\n      let labelLoop = label;\n      while (variables.has(labelLoop)) {\n        labelLoop = `${label}${counter++}`;\n      }\n      return AF.dataFactory.variable!(labelLoop);\n    };\n\n    function blankToVariable(term: RDF.Term): RDF.Term {\n      if (term.termType === 'BlankNode') {\n        let variable = blankToVariableMapping[term.value];\n        if (!variable) {\n          variable = uniqueVar(term.value);\n          variablesRaw.add(variable.value);\n          blankToVariableMapping[term.value] = variable;\n        }\n        return variable;\n      }\n      if (term.termType === 'Quad') {\n        return AF.dataFactory.quad(\n          blankToVariable(term.subject),\n          blankToVariable(term.predicate),\n          blankToVariable(term.object),\n          blankToVariable(term.graph),\n        );\n      }\n      return term;\n    }\n\n    return util.mapOperation<'unsafe', typeof res>(res, {\n      [Algebra.Types.PATH]: {\n        preVisitor: () => ({ continue: false }),\n        transform: pathOp => AF.createPath(\n          blankToVariable(pathOp.subject),\n          pathOp.predicate,\n          blankToVariable(pathOp.object),\n          blankToVariable(pathOp.graph),\n        ),\n      },\n      [Algebra.Types.PATTERN]: {\n        preVisitor: () => ({ continue: false }),\n        transform: patternOp => AF.createPattern(\n          blankToVariable(patternOp.subject),\n          blankToVariable(patternOp.predicate),\n          blankToVariable(patternOp.object),\n          blankToVariable(patternOp.graph),\n        ),\n      },\n      [Algebra.Types.CONSTRUCT]: {\n        preVisitor: () => ({ continue: false }),\n        // Blank nodes in CONSTRUCT templates must be maintained\n        transform: constructOp =>\n          AF.createConstruct(SUBRULE(translateBlankNodesToVariables, constructOp.input), constructOp.template),\n      },\n      [Algebra.Types.DELETE_INSERT]: {\n        preVisitor: () => ({ continue: false }),\n        transform: delInsOp =>\n          // Make sure blank nodes remain in the INSERT block, but do update the WHERE block\n          AF.createDeleteInsert(\n            delInsOp.delete,\n            delInsOp.insert,\n            delInsOp.where && SUBRULE(translateBlankNodesToVariables, delInsOp.where),\n          )\n        ,\n      },\n    });\n  },\n};\n\n/**\n * Will be used to make sure new variables don't overlap\n */\nexport const findAllVariables: AlgebraIndir<'findAllVariables', void, [object]> = {\n  name: 'findAllVariables',\n  fun: () => ({ transformer, variables }, thingy) => {\n    transformer.visitNodeSpecific(thingy, {}, { term: { variable: { visitor: (_var) => {\n      variables.add(_var.value);\n    } }}});\n  },\n};\n\n/**\n * 18.2.1\n */\nexport const inScopeVariables:\nAlgebraIndir<'inScopeVariables', Set<string>, [SparqlQuery | TripleNesting | TripleCollection | Path | Term]> = {\n  name: 'inScopeVariables',\n  fun: () => (_, thingy) => {\n    const vars = new Set<string>();\n    findPatternBoundedVars(thingy, vars);\n    return vars;\n  },\n};\n\nexport const generateFreshVar: AlgebraIndir<'generateFreshVar', RDF.Variable, []> = {\n  name: 'generateFreshVar',\n  fun: () => (c) => {\n    let newVar = `var${c.varCount++}`;\n    while (c.variables.has(newVar)) {\n      newVar = `var${c.varCount++}`;\n    }\n    c.variables.add(newVar);\n    return c.dataFactory.variable(newVar);\n  },\n};\n"]}