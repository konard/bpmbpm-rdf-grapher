{"version":3,"file":"toAlgebra12.js","sourceRoot":"","sources":["../../../lib/toAlgebra12.ts"],"names":[],"mappings":";;;AACA,sFAK8C;AAc9C,gEAEmC;AACnC,2CAA0C;AAG1C,MAAM,cAAc,GAAG,oDAAoD,CAAC;AAI/D,QAAA,eAAe,GAAmE;IAC7F,IAAI,EAAE,eAAe;IACrB,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE;QACpB,IAAI,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC;YACpC,OAAO,CAAC,CAAC,WAAW,CAAC,IAAI,CACvB,CAAC,CAAC,OAAO,CAAC,uBAAe,EAAE,IAAI,CAAC,OAAO,CAAC,EACxC,CAAC,CAAC,OAAO,CAAC,uBAAe,EAAE,IAAI,CAAC,SAAS,CAAC,EAC1C,CAAC,CAAC,OAAO,CAAC,uBAAe,EAAE,IAAI,CAAC,MAAM,CAAC,CACxC,CAAC;QACJ,CAAC;QACD,IAAI,CAAC,CAAC,UAAU,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,CAAC;YACrC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;gBACpB,OAAO,CAAC,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC3C,CAAC;YACD,IAAI,OAAO,IAAI,CAAC,SAAS,KAAK,QAAQ,EAAE,CAAC;gBACvC,MAAM,GAAG,GAAG,CAAC,CAAC,OAAO,CAAC,4CAAc,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;gBACtD,OAAO,CAAC,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;YAChD,CAAC;YACD,MAAM,CAAE,IAAI,EAAE,OAAO,CAAE,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACrD,IAAI,OAAO,IAAI,CAAC,OAAO,KAAK,EAAE,IAAI,OAAO,KAAK,KAAK,IAAI,OAAO,KAAK,KAAK,CAAC,EAAE,CAAC;gBAC1E,OAAO,CAAC,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE;oBACvC,QAAQ,EAAE,IAAI;oBACd,SAAS,EAAE,OAAO;iBACnB,CAAC,CAAC;YACL,CAAC;YACD,OAAO,CAAC,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;QAC3D,CAAC;QACD,OAAO,2CAAa,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;IACvC,CAAC;CACF,CAAC;AAEW,QAAA,2BAA2B,GAIpC;IACF,IAAI,EAAE,2BAA2B;IACjC,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,UAAU,EAAE,MAAM,EAAE,EAAE;QAClC,IAAI,CAAC,CAAC,UAAU,CAAC,+BAA+B,CAAC,UAAU,CAAC,EAAE,CAAC;YAC7D,MAAM,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC;YACtB,MAAM,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC;YAC1B,MAAM,UAAU,GAAG,OAAO,CAAC,uBAAe,EAAE,UAAU,CAAC,UAAU,CAAC,CAAC;YACnE,OAAO,CAAC,gCAAwB,EAAE,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;YACjE,gFAAgF;YAChF,4EAA4E;YAC5E,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,GAAG,MAAM,CAAC,GAAG,EAAG,CAAC;YACrD,MAAM,MAAM,GAAG,WAAW,CAAC,IAAI,CAAC,OAAO,EAA4C,SAAS,EAAE,MAAM,CAAC,CAAC;YACtG,MAAM,CAAC,IAAI,CAAC;gBACV,OAAO,EAAE,UAAU;gBACnB,SAAS,EAAE,WAAW,CAAC,SAAS,CAAC,cAAc,CAAC;gBAChD,MAAM,EAAE,MAAM;aACf,CAAC,CAAC;QACL,CAAC;aAAM,CAAC;YACN,uDAAyB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAyB,UAAU,EAAE,MAAM,CAAC,CAAC;QACjF,CAAC;IACH,CAAC;CACF,CAAC;AAEF;;;GAGG;AACU,QAAA,wBAAwB,GAIjC;IACF,IAAI,EAAE,wBAAwB;IAC9B,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE,MAAM,EAAE,EAAE;QAC9B,oDAAsB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAqB,MAAM,EAAE,MAAM,CAAC,CAAC;QACpE,MAAM,OAAO,GAAG,CAAC,CAAC,OAAO,CAAC;QAC1B,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAE,CAAC;QACtD,MAAM,EAAE,UAAU,EAAE,CAAC,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC;QACzC,IAAI,MAAM,CAAC,WAAW,IAAI,MAAM,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACxD,yEAAyE;YACzE,8GAA8G;YAC9G,yDAAyD;YACzD,2DAA2D;YAC3D,MAAM,MAAM,GAAG,WAAW,CAAC,IAAI,CAAC,OAAO,EAA4C,SAAS,EAAE,MAAM,CAAC,CAAC;YACtG,MAAM,UAAU,GAAG,IAAI,GAAG,EAAU,CAAC;YACrC,KAAK,MAAM,UAAU,IAAI,MAAM,CAAC,WAAW,EAAE,CAAC;gBAC5C,IAAI,OAAiB,CAAC;gBACtB,MAAM,gBAAgB,GAAG,CAAC,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;gBAC1D,IAAI,gBAAgB,EAAE,CAAC;oBACrB,OAAO,GAAG,OAAO,CAAC,uBAAe,EAAE,UAAU,CAAC,UAAU,CAAC,CAAC;gBAC5D,CAAC;qBAAM,CAAC;oBACN,OAAO,GAAG,OAAO,CAAC,uBAAe,EAAE,UAAU,CAAC,GAAG,CAAC,CAAC;gBACrD,CAAC;gBACD,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAA,yBAAY,EAAC,OAAO,CAAC,CAAC,EAAE,CAAC;oBAC3C,MAAM,CAAC,IAAI,CAAC;wBACV,OAAO;wBACP,SAAS,EAAE,WAAW,CAAC,SAAS,CAAC,cAAc,CAAC;wBAChD,MAAM,EAAE,MAAM;qBACf,CAAC,CAAC;gBACL,CAAC;gBACD,UAAU,CAAC,GAAG,CAAC,IAAA,yBAAY,EAAC,OAAO,CAAC,CAAC,CAAC;gBACtC,IAAI,gBAAgB,EAAE,CAAC;oBACrB,OAAO,CAAC,mCAA2B,EAAE,UAAU,EAAE,MAAM,CAAC,CAAC;gBAC3D,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;CACF,CAAC;AAEF;;GAEG;AACU,QAAA,gBAAgB,GACmF;IAC9G,IAAI,EAAE,kBAAkB;IACxB,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE;QACvB,MAAM,IAAI,GAAG,IAAI,GAAG,EAAU,CAAC;QAC/B,IAAA,yCAAsB,EAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QACrC,OAAO,IAAI,CAAC;IACd,CAAC;CACF,CAAC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport {\n  translateNamed,\n  translateTerm,\n  translateTripleCollection,\n  translateTripleNesting,\n} from '@traqula/algebra-transformations-1-1';\nimport type { FlattenedTriple } from '@traqula/algebra-transformations-1-1';\nimport type * as T11 from '@traqula/rules-sparql-1-1';\nimport type {\n  Expression,\n  Ordering,\n  Path,\n  PatternBind,\n  SparqlQuery,\n  Term,\n  TripleCollection,\n  TripleNesting,\n  Wildcard,\n} from '@traqula/rules-sparql-1-2';\nimport {\n  findPatternBoundedVars,\n} from '@traqula/rules-sparql-1-2';\nimport { termToString } from 'rdf-string';\nimport type { AlgebraIndir } from './types.js';\n\nconst reificationIri = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#reifies';\n\nexport type MapAggregateType = Wildcard | Expression | Ordering | PatternBind;\n\nexport const translateTerm12: AlgebraIndir<(typeof translateTerm)['name'], RDF.Term, [Term]> = {\n  name: 'translateTerm',\n  fun: $ => (C, term) => {\n    if (C.astFactory.isTermTriple(term)) {\n      return C.dataFactory.quad(\n        $.SUBRULE(translateTerm12, term.subject),\n        $.SUBRULE(translateTerm12, term.predicate),\n        $.SUBRULE(translateTerm12, term.object),\n      );\n    }\n    if (C.astFactory.isTermLiteral(term)) {\n      if (!term.langOrIri) {\n        return C.dataFactory.literal(term.value);\n      }\n      if (typeof term.langOrIri === 'object') {\n        const iri = $.SUBRULE(translateNamed, term.langOrIri);\n        return C.dataFactory.literal(term.value, iri);\n      }\n      const [ lang, langDir ] = term.langOrIri.split('--');\n      if (langDir && (langDir === '' || langDir === 'ltr' || langDir === 'rtl')) {\n        return C.dataFactory.literal(term.value, {\n          language: lang,\n          direction: langDir,\n        });\n      }\n      return C.dataFactory.literal(term.value, term.langOrIri);\n    }\n    return translateTerm.fun($)(C, term);\n  },\n};\n\nexport const translateTripleCollection12: AlgebraIndir<\n  (typeof translateTripleCollection)['name'],\nvoid,\n[TripleCollection, FlattenedTriple[]]\n> = {\n  name: 'translateTripleCollection',\n  fun: s => (c, collection, result) => {\n    if (c.astFactory.isTripleCollectionReifiedTriple(collection)) {\n      const { SUBRULE } = s;\n      const { dataFactory } = c;\n      const identifier = SUBRULE(translateTerm12, collection.identifier);\n      SUBRULE(translateTripleNesting12, collection.triples[0], result);\n      // Given the rule for triple nesting, the triple itself is always generated last\n      // (followed by annotations, but they are not allowed within reified triples\n      const { subject, predicate, object } = result.pop()!;\n      const asTerm = dataFactory.quad(subject, <Exclude<typeof predicate, T11.PathPure>> predicate, object);\n      result.push({\n        subject: identifier,\n        predicate: dataFactory.namedNode(reificationIri),\n        object: asTerm,\n      });\n    } else {\n      translateTripleCollection.fun(s)(c, <T11.TripleCollection> collection, result);\n    }\n  },\n};\n\n/**\n * Generates: everything for the subject collection + everything for the object collection + itself +\n *              the annotations triples\n */\nexport const translateTripleNesting12: AlgebraIndir<\n  (typeof translateTripleNesting)['name'],\nvoid,\n[TripleNesting, FlattenedTriple[]]\n> = {\n  name: 'translateTripleNesting',\n  fun: s => (c, triple, result) => {\n    translateTripleNesting.fun(s)(c, <T11.TripleNesting>triple, result);\n    const SUBRULE = s.SUBRULE;\n    const { subject, predicate, object } = result.at(-1)!;\n    const { astFactory: F, dataFactory } = c;\n    if (triple.annotations && triple.annotations.length > 0) {\n      // Blocks know who identifies them. -> Can just add it to list of triples\n      //  -> a blocks identifier only need to be registered when the identifier is not explicitly registered before.\n      //  We register: <annotationNode, reifies, tripleNesting>\n      // You cannot have an annotation on a triple that has paths\n      const asTerm = dataFactory.quad(subject, <Exclude<typeof predicate, T11.PathPure>> predicate, object);\n      const registered = new Set<string>();\n      for (const annotation of triple.annotations) {\n        let subject: RDF.Term;\n        const tripleCollection = F.isTripleCollection(annotation);\n        if (tripleCollection) {\n          subject = SUBRULE(translateTerm12, annotation.identifier);\n        } else {\n          subject = SUBRULE(translateTerm12, annotation.val);\n        }\n        if (!registered.has(termToString(subject))) {\n          result.push({\n            subject,\n            predicate: dataFactory.namedNode(reificationIri),\n            object: asTerm,\n          });\n        }\n        registered.add(termToString(subject));\n        if (tripleCollection) {\n          SUBRULE(translateTripleCollection12, annotation, result);\n        }\n      }\n    }\n  },\n};\n\n/**\n * 18.2.1\n */\nexport const inScopeVariables:\nAlgebraIndir<'inScopeVariables', Set<string>, [SparqlQuery | TripleNesting | TripleCollection | Path | Term]> = {\n  name: 'inScopeVariables',\n  fun: () => (_, thingy) => {\n    const vars = new Set<string>();\n    findPatternBoundedVars(thingy, vars);\n    return vars;\n  },\n};\n"]}