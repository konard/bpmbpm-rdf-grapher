{"version":3,"file":"toAlgebra12.js","sourceRoot":"","sources":["../../../lib/toAlgebra12.ts"],"names":[],"mappings":";;;AA2HA,8BAIC;AA9HD,oEAAiE;AAwCjE,sFAM8C;AAC9C,wCAA6C;AAIhC,QAAA,kBAAkB,GAAG,mBAAY;KAC3C,MAAM,CAAC,uCAAkB,CAAC;KAC1B,YAAY,EAAkB;KAC9B,SAAS,CAAC,6CAAe,CAAC;KAC1B,SAAS,CAAC,yDAA2B,CAAC;KACtC,SAAS,CAAC,sDAAwB,CAAC;KACnC,SAAS,CAAC,8CAAgB,CAAC;KAC3B,SAAS,EAiDN,CAAC;AAEP;;;;;;;;;;;;GAYG;AACH,SAAgB,SAAS,CAAC,KAAsB,EAAE,UAA0B,EAAE;IAC5E,MAAM,CAAC,GAAG,IAAA,kDAAoB,EAAC,OAAO,CAAC,CAAC;IACxC,MAAM,WAAW,GAAG,0BAAkB,CAAC,KAAK,EAAE,CAAC;IAC/C,OAAO,WAAW,CAAC,cAAc,CAAC,CAAC,EAAE,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,eAAe,CAAC,CAAC;AACtF,CAAC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { toAlgebra11Builder } from '@traqula/algebra-sparql-1-1';\nimport type {\n  accumulateGroupGraphPattern,\n  Algebra,\n  Algebra as A,\n  ContextConfigs,\n  findAllVariables,\n  generateFreshVar,\n  mapAggregate,\n  recurseGraph,\n  registerContextDefinitions,\n  simplifiedJoin,\n  simplifyPath,\n  translateAggregates,\n  translateBasicGraphPattern,\n  translateBgp,\n  translateBlankNodesToVariables,\n  translateBoundAggregate,\n  translateDatasetClause,\n  translateExpression,\n  translateGraphPattern,\n  translateGraphRef,\n  translateGraphRefDefSpec,\n  translateGraphRefSpecific,\n  translateInlineData,\n  translateInsertDelete,\n  translateNamed,\n  translatePath,\n  translatePathPredicate,\n  translateQuad,\n  translateQuery,\n  translateSingleUpdate,\n  translateTerm,\n  translateTripleCollection,\n  translateTripleNesting,\n  translateUpdate,\n  translateUpdateGraphLoad,\n  translateUpdateTriplesBlock,\n} from '@traqula/algebra-transformations-1-1';\nimport type { AlgebraContext, FlattenedTriple, MapAggregateType } from '@traqula/algebra-transformations-1-2';\nimport {\n  createAlgebraContext,\n  inScopeVariables,\n  translateTerm12,\n  translateTripleCollection12,\n  translateTripleNesting12,\n} from '@traqula/algebra-transformations-1-2';\nimport { IndirBuilder } from '@traqula/core';\n\nimport type * as T12 from '@traqula/rules-sparql-1-2';\n\nexport const toAlgebra12Builder = IndirBuilder\n  .create(toAlgebra11Builder)\n  .widenContext<AlgebraContext>()\n  .patchRule(translateTerm12)\n  .patchRule(translateTripleCollection12)\n  .patchRule(translateTripleNesting12)\n  .patchRule(inScopeVariables)\n  .typePatch<{\n    // Aggregate\n    [translateAggregates.name]: [A.Operation, [T12.Query, A.Operation]];\n    [mapAggregate.name]: [MapAggregateType, [MapAggregateType, Record<string, T12.ExpressionAggregate>]];\n    [translateBoundAggregate.name]: [A.BoundAggregate, [T12.ExpressionAggregate, RDF.Variable]];\n    // General\n    [translateNamed.name]: [RDF.NamedNode, [T12.TermIri]];\n    [translateTerm.name]: [RDF.Term, [T12.Term]];\n    [registerContextDefinitions.name]: [void, [T12.ContextDefinition[]]];\n    [translateInlineData.name]: [A.Values, [T12.PatternValues]];\n    [translateDatasetClause.name]: [{ default: RDF.NamedNode[]; named: RDF.NamedNode[] }, [T12.DatasetClauses]];\n    [translateBlankNodesToVariables.name]: [A.Operation, [A.Operation]];\n    [findAllVariables.name]: [void, [object]];\n    [inScopeVariables.name]: [\n      Set<string>,\n      [T12.SparqlQuery | T12.TripleNesting | T12.TripleCollection | T12.Path | T12.Term],\n    ];\n    [generateFreshVar.name]: [RDF.Variable, []];\n    // Path\n    [translatePath.name]: [(A.Path | A.Pattern)[], [FlattenedTriple & { predicate: T12.PathPure }]];\n    [translatePathPredicate.name]: [A.PropertyPathSymbol, [RDF.NamedNode | T12.Path]];\n    [simplifyPath.name]: [(Algebra.Pattern | Algebra.Path)[], [RDF.Term, A.PropertyPathSymbol, RDF.Term]];\n    // Patterns\n    [translateExpression.name]: [A.Expression, [T12.Expression | T12.Wildcard]];\n    [translateGraphPattern.name]: [A.Operation, [T12.Pattern]];\n    [translateBgp.name]: [A.Operation, [T12.PatternBgp]];\n    [accumulateGroupGraphPattern.name]: [A.Operation, [A.Operation, T12.Pattern]];\n    [simplifiedJoin.name]: [A.Operation, [A.Operation, A.Operation]];\n    // TripleAndQuad\n    [translateTripleCollection.name]: [void, [T12.TripleCollection, FlattenedTriple[]]];\n    [translateBasicGraphPattern.name]: [void, [T12.BasicGraphPattern, FlattenedTriple[]]];\n    [translateTripleNesting.name]: [void, [T12.TripleNesting, FlattenedTriple[]]];\n    [recurseGraph.name]: [A.Operation, [A.Operation, RDF.Term, RDF.Variable | undefined]];\n    [translateQuad.name]: [A.Pattern, [FlattenedTriple]];\n    // Updates\n    [translateUpdate.name]: [A.Operation, [T12.Update]];\n    [translateSingleUpdate.name]: [A.Update, [T12.UpdateOperation]];\n    [translateInsertDelete.name]: [\n      A.Operation,\n      [T12.UpdateOperationInsertData | T12.UpdateOperationDeleteData\n        | T12.UpdateOperationDeleteWhere | T12.UpdateOperationModify],\n    ];\n    [translateUpdateTriplesBlock.name]: [A.Pattern, [T12.PatternBgp | T12.GraphQuads, RDF.NamedNode | undefined]];\n    [translateGraphRefSpecific.name]: [RDF.NamedNode, [T12.GraphRefSpecific]];\n    [translateGraphRefDefSpec.name]: [RDF.NamedNode | 'DEFAULT', [T12.GraphRefSpecific | T12.GraphRefDefault]];\n    [translateGraphRef.name]: ['DEFAULT' | 'NAMED' | 'ALL' | RDF.NamedNode, [T12.GraphRef]];\n    [translateUpdateGraphLoad.name]: [A.Load, [T12.UpdateOperationLoad]];\n    // ToAlgebra\n    [translateQuery.name]: [A.Operation, [T12.SparqlQuery, boolean | undefined, boolean | undefined]];\n  }>();\n\n/**\n * Translates the given SPARQL query to SPARQL Algebra.\n * @param query - sparql 1.2 AST generated by Traqula\n * @param options - Optional options object. Current options:\n * @param options.dataFactory - The Datafactory used to generate terms. Default @rdfjs/data-model.\n * @param options.quads - Boolean indicating whether triples should be converted to Quads\n *        (consumes GRAPH statements). Default false.\n * @param options.prefixes - Pre-defined prefixes for the given query. Default empty.\n * @param options.baseIRI - Base IRI that should be used for the query.\n *        Default undefined (throws error if required).\n * @param options.blankToVariable - translate all blank nodes into variables\n * @returns Operation\n */\nexport function toAlgebra(query: T12.SparqlQuery, options: ContextConfigs = {}): A.Operation {\n  const c = createAlgebraContext(options);\n  const transformer = toAlgebra12Builder.build();\n  return transformer.translateQuery(c, query, options.quads, options.blankToVariable);\n}\n"]}