import { ParserBuilder } from '@traqula/core';
import { sparql11ParserBuilder } from '@traqula/parser-sparql-1-1';
import { gram as g11, sparqlCodepointEscape, } from '@traqula/rules-sparql-1-1';
import { completeParseContext, copyParseContext, gram as S12, lex as l12 } from '@traqula/rules-sparql-1-2';
export const sparql12ParserBuilder = ParserBuilder.create(sparql11ParserBuilder)
    .widenContext()
    .typePatch()
    .addMany(S12.reifiedTripleBlock, S12.reifiedTripleBlockPath, S12.reifier, S12.varOrReifierId, S12.annotation, S12.annotationPath, S12.annotationBlockPath, S12.annotationBlock, S12.reifiedTriple, S12.reifiedTripleSubject, S12.reifiedTripleObject, S12.tripleTerm, S12.tripleTermSubject, S12.tripleTermObject, S12.tripleTermData, S12.tripleTermDataSubject, S12.tripleTermDataObject, S12.exprTripleTerm, S12.exprTripleTermSubject, S12.exprTripleTermObject)
    .addMany(S12.versionDecl, S12.versionSpecifier)
    .addMany(S12.buildInLangDir, S12.buildInLangStrDir, S12.buildInHasLang, S12.buildInHasLangDir, S12.buildInIsTriple, S12.buildInTriple, S12.buildInSubject, S12.buildInPredicate, S12.buildInObject)
    .patchRule(S12.dataBlockValue)
    .patchRule(S12.triplesSameSubject)
    .patchRule(S12.triplesSameSubjectPath)
    .patchRule(S12.object)
    .patchRule(S12.objectPath)
    .patchRule(S12.graphNode)
    .patchRule(S12.graphNodePath)
    .patchRule(S12.varOrTerm)
    .deleteRule(g11.graphTerm.name)
    .patchRule(S12.primaryExpression)
    .patchRule(S12.builtInCall)
    .patchRule(S12.rdfLiteral)
    .patchRule(S12.unaryExpression)
    .patchRule(S12.prologue);
/**
 * Generator that can generate a SPARQL 1.2 AST given a SPARQL 1.2 string.
 */
export class Parser {
    parser;
    defaultContext;
    constructor(args = {}) {
        this.parser = sparql12ParserBuilder.build({
            ...args,
            queryPreProcessor: sparqlCodepointEscape,
            tokenVocabulary: l12.sparql12LexerBuilder.tokenVocabulary,
        });
        this.defaultContext = completeParseContext(args.defaultContext ?? {});
    }
    /**
     * Parse a query string starting from the
     * [QueryUnit](https://www.w3.org/TR/sparql12-query/#rQueryUnit)
     * or [QueryUpdate](https://www.w3.org/TR/sparql12-query/#rUpdateUnit) rules.
     * @param query
     * @param context
     */
    parse(query, context = {}) {
        const ast = this.parser.queryOrUpdate(query, copyParseContext({ ...this.defaultContext, ...context }));
        ast.loc = this.defaultContext.astFactory.sourceLocationInlinedSource(query, ast.loc, 0, Number.MAX_SAFE_INTEGER);
        return ast;
    }
    /**
     * Parse a query string starting from the [Path](https://www.w3.org/TR/sparql12-query/#rPath) grammar rule.
     * @param query
     * @param context
     */
    parsePath(query, context = {}) {
        const ast = this.parser.path(query, copyParseContext({ ...this.defaultContext, ...context }));
        ast.loc = this.defaultContext.astFactory.sourceLocationInlinedSource(query, ast.loc, 0, Number.MAX_SAFE_INTEGER);
        if (this.defaultContext.astFactory.isPathPure(ast)) {
            return {
                ...ast,
                prefixes: {},
            };
        }
        return ast;
    }
}
//# sourceMappingURL=Parser.js.map