import { ParserBuilder } from '@traqula/core';
import type { Patch, Wrap, ParserBuildArgs } from '@traqula/core';
import { gram as g11 } from '@traqula/rules-sparql-1-1';
import type { TermIri } from '@traqula/rules-sparql-1-1';
import type * as T12 from '@traqula/rules-sparql-1-2';
export declare const sparql12ParserBuilder: ParserBuilder<T12.SparqlContext, "string" | "object" | "filter" | "copy" | "graphRef" | "load" | "clear" | "drop" | "create" | "add" | "move" | "modify" | "update" | "query" | "datasetClauses" | "bind" | "solutionModifier" | "expression" | "aggregate" | "functionCall" | "path" | "blankNode" | "queryUnit" | "selectQuery" | "subSelect" | "selectClause" | "constructQuery" | "describeQuery" | "askQuery" | "valuesClause" | "constructTemplate" | "constructTriples" | "updateUnit" | "update1" | "quadPattern" | "quadData" | "insertData" | "deleteData" | "deleteWhere" | "deleteClause" | "insertClause" | "graphOrDefault" | "graphRefAll" | "quads" | "quadsNotTriples" | "builtInStr" | "builtInLang" | "builtInLangmatches" | "builtInDatatype" | "builtInBound" | "builtInIri" | "builtInUri" | "builtInBnode" | "builtInRand" | "builtInAbs" | "builtInCeil" | "builtInFloor" | "builtInRound" | "builtInConcat" | "builtInStrlen" | "builtInUcase" | "builtInLcase" | "builtInEncode_for_uri" | "builtInContains" | "builtInStrstarts" | "builtInStrends" | "builtInStrbefore" | "builtInStrafter" | "builtInYear" | "builtInMonth" | "builtInDay" | "builtInHours" | "builtInMinutes" | "builtInSeconds" | "builtInTimezone" | "builtInTz" | "builtInNow" | "builtInUuid" | "builtInStruuid" | "builtInMd5" | "builtInSha1" | "builtInSha256" | "builtInSha384" | "builtInSha512" | "builtInCoalesce" | "builtInIf" | "builtInStrlang" | "builtInStrdt" | "builtInSameterm" | "builtInIsiri" | "builtInIsuri" | "builtInIsblank" | "builtInIsliteral" | "builtInIsnumeric" | "builtInCall" | "builtInRegex" | "builtInSubstr" | "builtInReplace" | "builtInExists" | "builtInNotexists" | "builtInCount" | "builtInSum" | "builtInMin" | "builtInMax" | "builtInAvg" | "builtInSample" | "builtInGroup_concat" | "usingClause" | "datasetClause" | "defaultGraphClause" | "usingClauses" | "namedGraphClause" | "sourceSelector" | "argList" | "expressionList" | "conditionalOrExpression" | "conditionalAndExpression" | "valueLogical" | "relationalExpression" | "numericExpression" | "additiveExpression" | "multiplicativeExpression" | "unaryExpression" | "primaryExpression" | "brackettedExpression" | "iriOrFunction" | "prologue" | "baseDecl" | "prefixDecl" | "verb" | "varOrTerm" | "varOrIri" | "var" | "rdfLiteral" | "numericLiteral" | "numericLiteralUnsigned" | "numericLiteralPositive" | "numericLiteralNegative" | "booleanLiteral" | "iri" | "iriFull" | "prefixedName" | "VerbA" | "pathEltOrInverse" | "pathSequence" | "pathAlternative" | "pathElt" | "pathMod" | "pathPrimary" | "pathNegatedPropertySet" | "pathOneInPropertySet" | "groupClause" | "groupCondition" | "havingClause" | "havingCondition" | "orderClause" | "orderCondition" | "limitOffsetClauses" | "limitClause" | "offsetClause" | "triplesBlock" | "triplesSameSubject" | "triplesSameSubjectPath" | "triplesTemplate" | "propertyList" | "propertyListPath" | "propertyListNotEmpty" | "propertyListPathNotEmpty" | "verbPath" | "verbSimple" | "objectList" | "objectListPath" | "objectPath" | "collection" | "collectionPath" | "triplesNode" | "triplesNodePath" | "blankNodePropertyList" | "blankNodePropertyListPath" | "graphNode" | "graphNodePath" | "whereClause" | "groupGraphPattern" | "groupGraphPatternSub" | "graphPatternNotTriples" | "optionalGraphPattern" | "graphGraphPattern" | "serviceGraphPattern" | "inlineData" | "dataBlock" | "inlineDataOneVar" | "inlineDataFull" | "dataBlockValue" | "minusGraphPattern" | "groupOrUnionGraphPattern" | "constraint" | "queryOrUpdate" | "reifiedTriple" | "versionDecl" | "versionSpecifier" | "reifiedTripleBlock" | "reifiedTripleBlockPath" | "varOrReifierId" | "reifier" | "annotationPath" | "annotation" | "annotationBlockPath" | "annotationBlock" | "reifiedTripleSubject" | "reifiedTripleObject" | "tripleTerm" | "tripleTermSubject" | "tripleTermObject" | "tripleTermData" | "tripleTermDataSubject" | "tripleTermDataObject" | "exprTripleTerm" | "exprTripleTermSubject" | "exprTripleTermObject" | "builtInLangdir" | "builtInStrLangdir" | "builtInHasLang" | "builtInHasLangdir" | "builtInIsTriple" | "builtInTriple" | "builtInSubject" | "builtInPredicate" | "builtInObject", {
    string: import("@traqula/core").ParserRule<T12.SparqlContext, "string", import("@traqula/rules-sparql-1-1").TermLiteralStr, []>;
    object: import("@traqula/core").ParserRule<T12.SparqlContext, "object", T12.TripleNesting, [T12.GraphNode, import("@traqula/rules-sparql-1-1").TermIriFull | import("@traqula/rules-sparql-1-1").TermIriPrefixed | import("@traqula/rules-sparql-1-1").TermVariable | import("@traqula/rules-sparql-1-1").PropertyPathChain | import("@traqula/rules-sparql-1-1").PathModified | import("@traqula/rules-sparql-1-1").PathNegated]>;
    filter: import("@traqula/core").ParserRule<T12.SparqlContext, "filter", T12.PatternFilter, []>;
    copy: import("@traqula/core").ParserRule<T12.SparqlContext, "copy", T12.UpdateOperationCopy, []>;
    graphRef: import("@traqula/core").ParserRule<T12.SparqlContext, "graphRef", import("@traqula/rules-sparql-1-1").GraphRefSpecific, []>;
    load: import("@traqula/core").ParserRule<T12.SparqlContext, "load", T12.UpdateOperationLoad, []>;
    clear: import("@traqula/core").ParserRule<T12.SparqlContext, "clear", T12.UpdateOperationClear, []>;
    drop: import("@traqula/core").ParserRule<T12.SparqlContext, "drop", T12.UpdateOperationDrop, []>;
    create: import("@traqula/core").ParserRule<T12.SparqlContext, "create", T12.UpdateOperationCreate, []>;
    add: import("@traqula/core").ParserRule<T12.SparqlContext, "add", T12.UpdateOperationAdd, []>;
    move: import("@traqula/core").ParserRule<T12.SparqlContext, "move", T12.UpdateOperationMove, []>;
    modify: import("@traqula/core").ParserRule<T12.SparqlContext, "modify", T12.UpdateOperationModify, []>;
    update: import("@traqula/core").ParserRule<T12.SparqlContext, "update", import("@traqula/rules-sparql-1-1").Update, []>;
    query: import("@traqula/core").ParserRule<T12.SparqlContext, "query", import("@traqula/rules-sparql-1-1").Query, []>;
    datasetClauses: import("@traqula/core").ParserRule<T12.SparqlContext, "datasetClauses", T12.DatasetClauses, []>;
    bind: import("@traqula/core").ParserRule<T12.SparqlContext, "bind", T12.PatternBind, []>;
    solutionModifier: import("@traqula/core").ParserRule<T12.SparqlContext, "solutionModifier", T12.SolutionModifiers, []>;
    expression: import("@traqula/core").ParserRule<T12.SparqlContext, "expression", T12.Expression, []>;
    aggregate: import("@traqula/core").ParserRule<T12.SparqlContext, "aggregate", T12.ExpressionAggregate, []>;
    functionCall: import("@traqula/core").ParserRule<T12.SparqlContext, "functionCall", T12.ExpressionFunctionCall, []>;
    path: import("@traqula/core").ParserRule<T12.SparqlContext, "path", import("@traqula/rules-sparql-1-1").Path, []>;
    blankNode: import("@traqula/core").ParserRule<T12.SparqlContext, "blankNode", import("@traqula/rules-sparql-1-1").TermBlank, []>;
    queryUnit: import("@traqula/core").ParserRule<T12.SparqlContext, "queryUnit", import("@traqula/rules-sparql-1-1").Query, []>;
    selectQuery: import("@traqula/core").ParserRule<T12.SparqlContext, "selectQuery", Omit<T12.QuerySelect, g11.HandledByBase>, []>;
    subSelect: import("@traqula/core").ParserRule<T12.SparqlContext, "subSelect", Omit<T12.QuerySelect, "prefixes">, []>;
    selectClause: import("@traqula/core").ParserRule<T12.SparqlContext, "selectClause", Wrap<Pick<T12.QuerySelect, "variables" | "distinct" | "reduced">>, []>;
    constructQuery: import("@traqula/core").ParserRule<T12.SparqlContext, "constructQuery", Omit<T12.QueryConstruct, g11.HandledByBase>, []>;
    describeQuery: import("@traqula/core").ParserRule<T12.SparqlContext, "describeQuery", Omit<T12.QueryDescribe, g11.HandledByBase>, []>;
    askQuery: import("@traqula/core").ParserRule<T12.SparqlContext, "askQuery", Omit<T12.QueryAsk, g11.HandledByBase>, []>;
    valuesClause: import("@traqula/core").ParserRule<T12.SparqlContext, "valuesClause", T12.PatternValues[] | undefined, []>;
    constructTemplate: import("@traqula/core").ParserRule<T12.SparqlContext, "constructTemplate", Wrap<T12.PatternBgp>, []>;
    constructTriples: import("@traqula/core").ParserRule<T12.SparqlContext, "constructTriples", T12.PatternBgp, []>;
    updateUnit: import("@traqula/core").ParserRule<T12.SparqlContext, "updateUnit", import("@traqula/rules-sparql-1-1").Update, []>;
    update1: import("@traqula/core").ParserRule<T12.SparqlContext, "update1", T12.UpdateOperation, []>;
    quadPattern: import("@traqula/core").ParserRule<T12.SparqlContext, "quadPattern", Wrap<T12.Quads[]>, []>;
    quadData: import("@traqula/core").ParserRule<T12.SparqlContext, "quadData", Wrap<T12.Quads[]>, []>;
    insertData: import("@traqula/core").ParserRule<T12.SparqlContext, "insertData", T12.UpdateOperationInsertData, []>;
    deleteData: import("@traqula/core").ParserRule<T12.SparqlContext, "deleteData", T12.UpdateOperationDeleteData, []>;
    deleteWhere: import("@traqula/core").ParserRule<T12.SparqlContext, "deleteWhere", T12.UpdateOperationDeleteWhere, []>;
    deleteClause: import("@traqula/core").ParserRule<T12.SparqlContext, "deleteClause", Wrap<T12.Quads[]>, []>;
    insertClause: import("@traqula/core").ParserRule<T12.SparqlContext, "insertClause", Wrap<T12.Quads[]>, []>;
    graphOrDefault: import("@traqula/core").ParserRule<T12.SparqlContext, "graphOrDefault", import("@traqula/rules-sparql-1-1").GraphRefDefault | import("@traqula/rules-sparql-1-1").GraphRefSpecific, []>;
    graphRefAll: import("@traqula/core").ParserRule<T12.SparqlContext, "graphRefAll", import("@traqula/rules-sparql-1-1").GraphRef, []>;
    quads: import("@traqula/core").ParserRule<T12.SparqlContext, "quads", Wrap<T12.Quads[]>, []>;
    quadsNotTriples: import("@traqula/core").ParserRule<T12.SparqlContext, "quadsNotTriples", T12.GraphQuads, []>;
    builtInStr: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInStr", T12.ExpressionOperation, []>;
    builtInLang: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInLang", T12.ExpressionOperation, []>;
    builtInLangmatches: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInLangmatches", T12.ExpressionOperation, []>;
    builtInDatatype: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInDatatype", T12.ExpressionOperation, []>;
    builtInBound: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInBound", T12.ExpressionOperation, []>;
    builtInIri: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInIri", T12.ExpressionOperation, []>;
    builtInUri: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInUri", T12.ExpressionOperation, []>;
    builtInBnode: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInBnode", T12.ExpressionOperation, []>;
    builtInRand: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInRand", T12.ExpressionOperation, []>;
    builtInAbs: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInAbs", T12.ExpressionOperation, []>;
    builtInCeil: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInCeil", T12.ExpressionOperation, []>;
    builtInFloor: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInFloor", T12.ExpressionOperation, []>;
    builtInRound: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInRound", T12.ExpressionOperation, []>;
    builtInConcat: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInConcat", T12.ExpressionOperation, []>;
    builtInStrlen: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInStrlen", T12.ExpressionOperation, []>;
    builtInUcase: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInUcase", T12.ExpressionOperation, []>;
    builtInLcase: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInLcase", T12.ExpressionOperation, []>;
    builtInEncode_for_uri: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInEncode_for_uri", T12.ExpressionOperation, []>;
    builtInContains: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInContains", T12.ExpressionOperation, []>;
    builtInStrstarts: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInStrstarts", T12.ExpressionOperation, []>;
    builtInStrends: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInStrends", T12.ExpressionOperation, []>;
    builtInStrbefore: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInStrbefore", T12.ExpressionOperation, []>;
    builtInStrafter: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInStrafter", T12.ExpressionOperation, []>;
    builtInYear: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInYear", T12.ExpressionOperation, []>;
    builtInMonth: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInMonth", T12.ExpressionOperation, []>;
    builtInDay: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInDay", T12.ExpressionOperation, []>;
    builtInHours: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInHours", T12.ExpressionOperation, []>;
    builtInMinutes: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInMinutes", T12.ExpressionOperation, []>;
    builtInSeconds: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInSeconds", T12.ExpressionOperation, []>;
    builtInTimezone: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInTimezone", T12.ExpressionOperation, []>;
    builtInTz: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInTz", T12.ExpressionOperation, []>;
    builtInNow: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInNow", T12.ExpressionOperation, []>;
    builtInUuid: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInUuid", T12.ExpressionOperation, []>;
    builtInStruuid: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInStruuid", T12.ExpressionOperation, []>;
    builtInMd5: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInMd5", T12.ExpressionOperation, []>;
    builtInSha1: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInSha1", T12.ExpressionOperation, []>;
    builtInSha256: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInSha256", T12.ExpressionOperation, []>;
    builtInSha384: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInSha384", T12.ExpressionOperation, []>;
    builtInSha512: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInSha512", T12.ExpressionOperation, []>;
    builtInCoalesce: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInCoalesce", T12.ExpressionOperation, []>;
    builtInIf: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInIf", T12.ExpressionOperation, []>;
    builtInStrlang: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInStrlang", T12.ExpressionOperation, []>;
    builtInStrdt: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInStrdt", T12.ExpressionOperation, []>;
    builtInSameterm: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInSameterm", T12.ExpressionOperation, []>;
    builtInIsiri: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInIsiri", T12.ExpressionOperation, []>;
    builtInIsuri: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInIsuri", T12.ExpressionOperation, []>;
    builtInIsblank: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInIsblank", T12.ExpressionOperation, []>;
    builtInIsliteral: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInIsliteral", T12.ExpressionOperation, []>;
    builtInIsnumeric: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInIsnumeric", T12.ExpressionOperation, []>;
    builtInCall: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInCall", import("@traqula/rules-sparql-1-1").Expression, []>;
    builtInRegex: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInRegex", g11.ExpressionFunctionX<[import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression] | [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>, []>;
    builtInSubstr: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInSubstr", T12.ExpressionOperation, []>;
    builtInReplace: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInReplace", T12.ExpressionOperation, []>;
    builtInExists: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInExists", T12.ExpressionPatternOperation, []>;
    builtInNotexists: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInNotexists", T12.ExpressionPatternOperation, []>;
    builtInCount: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInCount", T12.ExpressionAggregateDefault | T12.ExpressionAggregateOnWildcard, []>;
    builtInSum: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInSum", T12.ExpressionAggregateDefault, []>;
    builtInMin: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInMin", T12.ExpressionAggregateDefault, []>;
    builtInMax: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInMax", T12.ExpressionAggregateDefault, []>;
    builtInAvg: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInAvg", T12.ExpressionAggregateDefault, []>;
    builtInSample: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInSample", T12.ExpressionAggregateDefault, []>;
    builtInGroup_concat: import("@traqula/core").ParserRule<T12.SparqlContext, "builtInGroup_concat", T12.ExpressionAggregateDefault | T12.ExpressionAggregateSeparator, []>;
    usingClause: import("@traqula/core").ParserRule<T12.SparqlContext, "usingClause", Wrap<{
        clauseType: "default" | "named";
        value: T12.TermIri;
    }>, []>;
    datasetClause: import("@traqula/core").ParserRule<T12.SparqlContext, "datasetClause", Wrap<{
        clauseType: "default" | "named";
        value: T12.TermIri;
    }>, []>;
    defaultGraphClause: import("@traqula/core").ParserRule<T12.SparqlContext, "defaultGraphClause", TermIri, []>;
    usingClauses: import("@traqula/core").ParserRule<T12.SparqlContext, "usingClauses", T12.DatasetClauses, []>;
    namedGraphClause: import("@traqula/core").ParserRule<T12.SparqlContext, "namedGraphClause", Wrap<TermIri>, []>;
    sourceSelector: import("@traqula/core").ParserRule<T12.SparqlContext, "sourceSelector", TermIri, []>;
    argList: import("@traqula/core").ParserRule<T12.SparqlContext, "argList", Wrap<Patch<g11.IArgList, {
        args: T12.Expression[];
    }>>, []>;
    expressionList: import("@traqula/core").ParserRule<T12.SparqlContext, "expressionList", Wrap<T12.Expression[]>, []>;
    conditionalOrExpression: import("@traqula/core").ParserRule<T12.SparqlContext, "conditionalOrExpression", T12.Expression, []>;
    conditionalAndExpression: import("@traqula/core").ParserRule<T12.SparqlContext, "conditionalAndExpression", T12.Expression, []>;
    valueLogical: import("@traqula/core").ParserRule<T12.SparqlContext, "valueLogical", T12.Expression, []>;
    relationalExpression: import("@traqula/core").ParserRule<T12.SparqlContext, "relationalExpression", T12.Expression, []>;
    numericExpression: import("@traqula/core").ParserRule<T12.SparqlContext, "numericExpression", T12.Expression, []>;
    additiveExpression: import("@traqula/core").ParserRule<T12.SparqlContext, "additiveExpression", T12.Expression, []>;
    multiplicativeExpression: import("@traqula/core").ParserRule<T12.SparqlContext, "multiplicativeExpression", T12.Expression, []>;
    unaryExpression: import("@traqula/core").ParserRule<T12.SparqlContext, "unaryExpression", T12.Expression, []>;
    primaryExpression: import("@traqula/core").ParserRule<T12.SparqlContext, "primaryExpression", T12.Expression, []>;
    brackettedExpression: import("@traqula/core").ParserRule<T12.SparqlContext, "brackettedExpression", T12.Expression, []>;
    iriOrFunction: import("@traqula/core").ParserRule<T12.SparqlContext, "iriOrFunction", TermIri | T12.ExpressionFunctionCall, []>;
    prologue: import("@traqula/core").ParserRule<T12.SparqlContext, "prologue", T12.ContextDefinition[], []>;
    baseDecl: import("@traqula/core").ParserRule<T12.SparqlContext, "baseDecl", T12.ContextDefinition, []>;
    prefixDecl: import("@traqula/core").ParserRule<T12.SparqlContext, "prefixDecl", T12.ContextDefinition, []>;
    verb: import("@traqula/core").ParserRule<T12.SparqlContext, "verb", TermIri | import("@traqula/rules-sparql-1-1").TermVariable, []>;
    varOrTerm: import("@traqula/core").ParserRule<T12.SparqlContext, "varOrTerm", T12.Term, []>;
    varOrIri: import("@traqula/core").ParserRule<T12.SparqlContext, "varOrIri", TermIri | import("@traqula/rules-sparql-1-1").TermVariable, []>;
    var: import("@traqula/core").ParserRule<T12.SparqlContext, "var", import("@traqula/rules-sparql-1-1").TermVariable, []>;
    rdfLiteral: import("@traqula/core").ParserRule<T12.SparqlContext, "rdfLiteral", import("@traqula/rules-sparql-1-1").TermLiteral, []>;
    numericLiteral: import("@traqula/core").ParserRule<T12.SparqlContext, "numericLiteral", import("@traqula/rules-sparql-1-1").TermLiteralTyped, []>;
    numericLiteralUnsigned: import("@traqula/core").ParserRule<T12.SparqlContext, "numericLiteralUnsigned", import("@traqula/rules-sparql-1-1").TermLiteralTyped, []>;
    numericLiteralPositive: import("@traqula/core").ParserRule<T12.SparqlContext, "numericLiteralPositive", import("@traqula/rules-sparql-1-1").TermLiteralTyped, []>;
    numericLiteralNegative: import("@traqula/core").ParserRule<T12.SparqlContext, "numericLiteralNegative", import("@traqula/rules-sparql-1-1").TermLiteralTyped, []>;
    booleanLiteral: import("@traqula/core").ParserRule<T12.SparqlContext, "booleanLiteral", import("@traqula/rules-sparql-1-1").TermLiteralTyped, []>;
    iri: import("@traqula/core").ParserRule<T12.SparqlContext, "iri", TermIri, []>;
    iriFull: import("@traqula/core").ParserRule<T12.SparqlContext, "iriFull", import("@traqula/rules-sparql-1-1").TermIriFull, []>;
    prefixedName: import("@traqula/core").ParserRule<T12.SparqlContext, "prefixedName", import("@traqula/rules-sparql-1-1").TermIriPrefixed, []>;
    VerbA: import("@traqula/core").ParserRule<T12.SparqlContext, "VerbA", import("@traqula/rules-sparql-1-1").TermIriFull, []>;
    pathEltOrInverse: import("@traqula/core").ParserRule<T12.SparqlContext, "pathEltOrInverse", import("@traqula/rules-sparql-1-1").Path, []>;
    pathSequence: import("@traqula/core").ParserRule<T12.SparqlContext, "pathSequence", import("@traqula/rules-sparql-1-1").TermIriFull | import("@traqula/rules-sparql-1-1").TermIriPrefixed | import("@traqula/rules-sparql-1-1").PropertyPathChain | import("@traqula/rules-sparql-1-1").PathModified | import("@traqula/rules-sparql-1-1").PathNegated, []>;
    pathAlternative: import("@traqula/core").ParserRule<T12.SparqlContext, "pathAlternative", import("@traqula/rules-sparql-1-1").TermIriFull | import("@traqula/rules-sparql-1-1").TermIriPrefixed | import("@traqula/rules-sparql-1-1").PropertyPathChain | import("@traqula/rules-sparql-1-1").PathModified | import("@traqula/rules-sparql-1-1").PathNegated, []>;
    pathElt: import("@traqula/core").ParserRule<T12.SparqlContext, "pathElt", import("@traqula/rules-sparql-1-1").Path, []>;
    pathMod: import("@traqula/core").ParserRule<T12.SparqlContext, "pathMod", import("chevrotain").IToken & {
        image: "*" | "+" | "?";
    }, []>;
    pathPrimary: import("@traqula/core").ParserRule<T12.SparqlContext, "pathPrimary", import("@traqula/rules-sparql-1-1").Path, []>;
    pathNegatedPropertySet: import("@traqula/core").ParserRule<T12.SparqlContext, "pathNegatedPropertySet", import("@traqula/rules-sparql-1-1").PathNegated, []>;
    pathOneInPropertySet: import("@traqula/core").ParserRule<T12.SparqlContext, "pathOneInPropertySet", TermIri | import("@traqula/rules-sparql-1-1").PathNegatedElt, []>;
    groupClause: import("@traqula/core").ParserRule<T12.SparqlContext, "groupClause", T12.SolutionModifierGroup, []>;
    groupCondition: import("@traqula/core").ParserRule<T12.SparqlContext, "groupCondition", T12.Expression | T12.SolutionModifierGroupBind, []>;
    havingClause: import("@traqula/core").ParserRule<T12.SparqlContext, "havingClause", T12.SolutionModifierHaving, []>;
    havingCondition: import("@traqula/core").ParserRule<T12.SparqlContext, "havingCondition", T12.Expression, []>;
    orderClause: import("@traqula/core").ParserRule<T12.SparqlContext, "orderClause", T12.SolutionModifierOrder, []>;
    orderCondition: import("@traqula/core").ParserRule<T12.SparqlContext, "orderCondition", T12.Ordering, []>;
    limitOffsetClauses: import("@traqula/core").ParserRule<T12.SparqlContext, "limitOffsetClauses", import("@traqula/rules-sparql-1-1").SolutionModifierLimitOffset, []>;
    limitClause: import("@traqula/core").ParserRule<T12.SparqlContext, "limitClause", Wrap<number>, []>;
    offsetClause: import("@traqula/core").ParserRule<T12.SparqlContext, "offsetClause", Wrap<number>, []>;
    triplesBlock: import("@traqula/core").ParserRule<T12.SparqlContext, "triplesBlock", T12.PatternBgp, []>;
    triplesSameSubject: import("@traqula/core").ParserRule<T12.SparqlContext, "triplesSameSubject", import("@traqula/rules-sparql-1-1").BasicGraphPattern, []>;
    triplesSameSubjectPath: import("@traqula/core").ParserRule<T12.SparqlContext, "triplesSameSubjectPath", import("@traqula/rules-sparql-1-1").BasicGraphPattern, []>;
    triplesTemplate: import("@traqula/core").ParserRule<T12.SparqlContext, "triplesTemplate", T12.PatternBgp, []>;
    propertyList: import("@traqula/core").ParserRule<T12.SparqlContext, "propertyList", T12.TripleNesting[], [import("@traqula/rules-sparql-1-1").GraphNode]>;
    propertyListPath: import("@traqula/core").ParserRule<T12.SparqlContext, "propertyListPath", T12.TripleNesting[], [import("@traqula/rules-sparql-1-1").GraphNode]>;
    propertyListNotEmpty: import("@traqula/core").ParserRule<T12.SparqlContext, "propertyListNotEmpty", T12.TripleNesting[], [import("@traqula/rules-sparql-1-1").GraphNode]>;
    propertyListPathNotEmpty: import("@traqula/core").ParserRule<T12.SparqlContext, "propertyListPathNotEmpty", T12.TripleNesting[], [import("@traqula/rules-sparql-1-1").GraphNode]>;
    verbPath: import("@traqula/core").ParserRule<T12.SparqlContext, "verbPath", import("@traqula/rules-sparql-1-1").Path, []>;
    verbSimple: import("@traqula/core").ParserRule<T12.SparqlContext, "verbSimple", import("@traqula/rules-sparql-1-1").TermVariable, []>;
    objectList: import("@traqula/core").ParserRule<T12.SparqlContext, "objectList", T12.TripleNesting[], [T12.GraphNode, import("@traqula/rules-sparql-1-1").TermIriFull | import("@traqula/rules-sparql-1-1").TermIriPrefixed | import("@traqula/rules-sparql-1-1").TermVariable | import("@traqula/rules-sparql-1-1").PropertyPathChain | import("@traqula/rules-sparql-1-1").PathModified | import("@traqula/rules-sparql-1-1").PathNegated]>;
    objectListPath: import("@traqula/core").ParserRule<T12.SparqlContext, "objectListPath", T12.TripleNesting, [T12.GraphNode, import("@traqula/rules-sparql-1-1").TermIriFull | import("@traqula/rules-sparql-1-1").TermIriPrefixed | import("@traqula/rules-sparql-1-1").TermVariable | import("@traqula/rules-sparql-1-1").PropertyPathChain | import("@traqula/rules-sparql-1-1").PathModified | import("@traqula/rules-sparql-1-1").PathNegated]>;
    objectPath: import("@traqula/core").ParserRule<T12.SparqlContext, "objectPath", T12.TripleNesting, [T12.GraphNode, import("@traqula/rules-sparql-1-1").TermIriFull | import("@traqula/rules-sparql-1-1").TermIriPrefixed | import("@traqula/rules-sparql-1-1").TermVariable | import("@traqula/rules-sparql-1-1").PropertyPathChain | import("@traqula/rules-sparql-1-1").PathModified | import("@traqula/rules-sparql-1-1").PathNegated]>;
    collection: import("@traqula/core").ParserRule<T12.SparqlContext, "collection", T12.TripleCollectionList, []>;
    collectionPath: import("@traqula/core").ParserRule<T12.SparqlContext, "collectionPath", T12.TripleCollectionList, []>;
    triplesNode: import("@traqula/core").ParserRule<T12.SparqlContext, "triplesNode", T12.TripleCollection, []>;
    triplesNodePath: import("@traqula/core").ParserRule<T12.SparqlContext, "triplesNodePath", T12.TripleCollection, []>;
    blankNodePropertyList: import("@traqula/core").ParserRule<T12.SparqlContext, "blankNodePropertyList", Patch<import("@traqula/rules-sparql-1-1").TripleCollectionBlankNodeProperties, {
        triples: T12.TripleNesting[];
        identifier: T12.TermBlank | T12.TermVariable | T12.TermIri;
    }>, []>;
    blankNodePropertyListPath: import("@traqula/core").ParserRule<T12.SparqlContext, "blankNodePropertyListPath", Patch<import("@traqula/rules-sparql-1-1").TripleCollectionBlankNodeProperties, {
        triples: T12.TripleNesting[];
        identifier: T12.TermBlank | T12.TermVariable | T12.TermIri;
    }>, []>;
    graphNode: import("@traqula/core").ParserRule<T12.SparqlContext, "graphNode", T12.GraphNode, []>;
    graphNodePath: import("@traqula/core").ParserRule<T12.SparqlContext, "graphNodePath", T12.GraphNode, []>;
    whereClause: import("@traqula/core").ParserRule<T12.SparqlContext, "whereClause", Wrap<T12.PatternGroup>, []>;
    groupGraphPattern: import("@traqula/core").ParserRule<T12.SparqlContext, "groupGraphPattern", T12.PatternGroup, []>;
    groupGraphPatternSub: import("@traqula/core").ParserRule<T12.SparqlContext, "groupGraphPatternSub", T12.Pattern[], []>;
    graphPatternNotTriples: import("@traqula/core").ParserRule<T12.SparqlContext, "graphPatternNotTriples", T12.PatternGroup | T12.PatternUnion | T12.PatternOptional | T12.PatternMinus | T12.PatternGraph | T12.PatternService | T12.PatternFilter | T12.PatternBind | T12.PatternValues, []>;
    optionalGraphPattern: import("@traqula/core").ParserRule<T12.SparqlContext, "optionalGraphPattern", T12.PatternOptional, []>;
    graphGraphPattern: import("@traqula/core").ParserRule<T12.SparqlContext, "graphGraphPattern", T12.PatternGraph, []>;
    serviceGraphPattern: import("@traqula/core").ParserRule<T12.SparqlContext, "serviceGraphPattern", T12.PatternService, []>;
    inlineData: import("@traqula/core").ParserRule<T12.SparqlContext, "inlineData", T12.PatternValues, []>;
    dataBlock: import("@traqula/core").ParserRule<T12.SparqlContext, "dataBlock", T12.PatternValues, []>;
    inlineDataOneVar: import("@traqula/core").ParserRule<T12.SparqlContext, "inlineDataOneVar", T12.PatternValues, []>;
    inlineDataFull: import("@traqula/core").ParserRule<T12.SparqlContext, "inlineDataFull", T12.PatternValues, []>;
    dataBlockValue: import("@traqula/core").ParserRule<T12.SparqlContext, "dataBlockValue", TermIri | import("@traqula/rules-sparql-1-1").TermLiteral | T12.TermTriple | undefined, []>;
    minusGraphPattern: import("@traqula/core").ParserRule<T12.SparqlContext, "minusGraphPattern", T12.PatternMinus, []>;
    groupOrUnionGraphPattern: import("@traqula/core").ParserRule<T12.SparqlContext, "groupOrUnionGraphPattern", T12.PatternGroup | T12.PatternUnion, []>;
    constraint: import("@traqula/core").ParserRule<T12.SparqlContext, "constraint", T12.Expression, []>;
    queryOrUpdate: import("@traqula/core").ParserRule<T12.SparqlContext, "queryOrUpdate", T12.SparqlQuery, []>;
    reifiedTriple: import("@traqula/core").ParserRule<any, "reifiedTriple"> & T12.SparqlGrammarRule<"reifiedTriple", T12.TripleCollectionReifiedTriple, []> & T12.SparqlGeneratorRule<"reifiedTriple", T12.TripleCollectionReifiedTriple, []>;
    versionDecl: import("@traqula/core").ParserRule<any, "versionDecl"> & T12.SparqlGrammarRule<"versionDecl", T12.ContextDefinitionVersion, []> & T12.SparqlGeneratorRule<"versionDecl", T12.ContextDefinitionVersion, []>;
    versionSpecifier: import("@traqula/core").ParserRule<any, "versionSpecifier"> & T12.SparqlGrammarRule<"versionSpecifier", Wrap<string>>;
    reifiedTripleBlock: import("@traqula/core").ParserRule<any, "reifiedTripleBlock"> & T12.SparqlGrammarRule<"reifiedTripleBlock", import("@traqula/rules-sparql-1-1").BasicGraphPattern>;
    reifiedTripleBlockPath: import("@traqula/core").ParserRule<any, "reifiedTripleBlockPath"> & T12.SparqlGrammarRule<"reifiedTripleBlockPath", import("@traqula/rules-sparql-1-1").BasicGraphPattern>;
    varOrReifierId: import("@traqula/core").ParserRule<any, "varOrReifierId"> & T12.SparqlGrammarRule<"varOrReifierId", TermIri | import("@traqula/rules-sparql-1-1").TermVariable | import("@traqula/rules-sparql-1-1").TermBlank>;
    reifier: import("@traqula/core").ParserRule<any, "reifier"> & T12.SparqlGrammarRule<"reifier", Wrap<TermIri | import("@traqula/rules-sparql-1-1").TermVariable | import("@traqula/rules-sparql-1-1").TermBlank>>;
    annotationPath: import("@traqula/core").ParserRule<any, "annotationPath"> & T12.SparqlGrammarRule<"annotationPath", T12.Annotation[], []> & T12.SparqlGeneratorRule<"annotationPath", T12.Annotation[], []>;
    annotation: import("@traqula/core").ParserRule<any, "annotation"> & T12.SparqlGrammarRule<"annotation", T12.Annotation[], []> & T12.SparqlGeneratorRule<"annotation", T12.Annotation[], []>;
    annotationBlockPath: import("@traqula/core").ParserRule<any, "annotationBlockPath"> & T12.SparqlGrammarRule<"annotationBlockPath", Patch<import("@traqula/rules-sparql-1-1").TripleCollectionBlankNodeProperties, {
        triples: T12.TripleNesting[];
        identifier: T12.TermBlank | T12.TermVariable | T12.TermIri;
    }>, [TermIri | import("@traqula/rules-sparql-1-1").TermVariable | import("@traqula/rules-sparql-1-1").TermBlank]> & T12.SparqlGeneratorRule<"annotationBlockPath", Patch<import("@traqula/rules-sparql-1-1").TripleCollectionBlankNodeProperties, {
        triples: T12.TripleNesting[];
        identifier: T12.TermBlank | T12.TermVariable | T12.TermIri;
    }>>;
    annotationBlock: import("@traqula/core").ParserRule<any, "annotationBlock"> & T12.SparqlGrammarRule<"annotationBlock", Patch<import("@traqula/rules-sparql-1-1").TripleCollectionBlankNodeProperties, {
        triples: T12.TripleNesting[];
        identifier: T12.TermBlank | T12.TermVariable | T12.TermIri;
    }>, [TermIri | import("@traqula/rules-sparql-1-1").TermVariable | import("@traqula/rules-sparql-1-1").TermBlank]> & T12.SparqlGeneratorRule<"annotationBlock", Patch<import("@traqula/rules-sparql-1-1").TripleCollectionBlankNodeProperties, {
        triples: T12.TripleNesting[];
        identifier: T12.TermBlank | T12.TermVariable | T12.TermIri;
    }>>;
    reifiedTripleSubject: import("@traqula/core").ParserRule<any, "reifiedTripleSubject"> & T12.SparqlGrammarRule<"reifiedTripleSubject", T12.TripleCollectionReifiedTriple | T12.Term>;
    reifiedTripleObject: import("@traqula/core").ParserRule<any, "reifiedTripleObject"> & T12.SparqlGrammarRule<"reifiedTripleObject", T12.TripleCollectionReifiedTriple | T12.Term>;
    tripleTerm: import("@traqula/core").ParserRule<any, "tripleTerm"> & T12.SparqlGrammarRule<"tripleTerm", T12.TermTriple, []> & T12.SparqlGeneratorRule<"tripleTerm", T12.TermTriple, []>;
    tripleTermSubject: import("@traqula/core").ParserRule<any, "tripleTermSubject"> & T12.SparqlGrammarRule<"tripleTermSubject", TermIri | import("@traqula/rules-sparql-1-1").TermVariable | import("@traqula/rules-sparql-1-1").TermLiteral | import("@traqula/rules-sparql-1-1").TermBlank | T12.TermTriple>;
    tripleTermObject: import("@traqula/core").ParserRule<any, "tripleTermObject"> & T12.SparqlGrammarRule<"tripleTermObject", TermIri | import("@traqula/rules-sparql-1-1").TermVariable | import("@traqula/rules-sparql-1-1").TermLiteral | import("@traqula/rules-sparql-1-1").TermBlank | T12.TermTriple>;
    tripleTermData: import("@traqula/core").ParserRule<any, "tripleTermData"> & T12.SparqlGrammarRule<"tripleTermData", T12.TermTriple>;
    tripleTermDataSubject: import("@traqula/core").ParserRule<any, "tripleTermDataSubject"> & T12.SparqlGrammarRule<"tripleTermDataSubject", TermIri | import("@traqula/rules-sparql-1-1").TermLiteral | T12.TermTriple>;
    tripleTermDataObject: import("@traqula/core").ParserRule<any, "tripleTermDataObject"> & T12.SparqlGrammarRule<"tripleTermDataObject", TermIri | import("@traqula/rules-sparql-1-1").TermLiteral | T12.TermTriple>;
    exprTripleTerm: import("@traqula/core").ParserRule<any, "exprTripleTerm"> & T12.SparqlGrammarRule<"exprTripleTerm", T12.TermTriple>;
    exprTripleTermSubject: import("@traqula/core").ParserRule<any, "exprTripleTermSubject"> & T12.SparqlGrammarRule<"exprTripleTermSubject", TermIri | import("@traqula/rules-sparql-1-1").TermVariable | import("@traqula/rules-sparql-1-1").TermLiteral | T12.TermTriple>;
    exprTripleTermObject: import("@traqula/core").ParserRule<any, "exprTripleTermObject"> & T12.SparqlGrammarRule<"exprTripleTermObject", TermIri | import("@traqula/rules-sparql-1-1").TermVariable | import("@traqula/rules-sparql-1-1").TermLiteral | T12.TermTriple>;
    builtInLangdir: import("@traqula/core").ParserRule<any, "builtInLangdir"> & g11.RuleDefExpressionFunctionX<"builtInLangdir", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInStrLangdir: import("@traqula/core").ParserRule<any, "builtInStrLangdir"> & g11.RuleDefExpressionFunctionX<"builtInStrLangdir", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInHasLang: import("@traqula/core").ParserRule<any, "builtInHasLang"> & g11.RuleDefExpressionFunctionX<"builtInHasLang", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInHasLangdir: import("@traqula/core").ParserRule<any, "builtInHasLangdir"> & g11.RuleDefExpressionFunctionX<"builtInHasLangdir", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInIsTriple: import("@traqula/core").ParserRule<any, "builtInIsTriple"> & g11.RuleDefExpressionFunctionX<"builtInIsTriple", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInTriple: import("@traqula/core").ParserRule<any, "builtInTriple"> & g11.RuleDefExpressionFunctionX<"builtInTriple", [import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression, import("@traqula/rules-sparql-1-1").Expression]>;
    builtInSubject: import("@traqula/core").ParserRule<any, "builtInSubject"> & g11.RuleDefExpressionFunctionX<"builtInSubject", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInPredicate: import("@traqula/core").ParserRule<any, "builtInPredicate"> & g11.RuleDefExpressionFunctionX<"builtInPredicate", [import("@traqula/rules-sparql-1-1").Expression]>;
    builtInObject: import("@traqula/core").ParserRule<any, "builtInObject"> & g11.RuleDefExpressionFunctionX<"builtInObject", [import("@traqula/rules-sparql-1-1").Expression]>;
}>;
export type SparqlParser = ReturnType<typeof sparql12ParserBuilder.build>;
/**
 * Generator that can generate a SPARQL 1.2 AST given a SPARQL 1.2 string.
 */
export declare class Parser {
    private readonly parser;
    protected readonly defaultContext: T12.SparqlContext;
    constructor(args?: Pick<ParserBuildArgs, 'parserConfig' | 'lexerConfig'> & {
        defaultContext?: Partial<T12.SparqlContext>;
    });
    /**
     * Parse a query string starting from the
     * [QueryUnit](https://www.w3.org/TR/sparql12-query/#rQueryUnit)
     * or [QueryUpdate](https://www.w3.org/TR/sparql12-query/#rUpdateUnit) rules.
     * @param query
     * @param context
     */
    parse(query: string, context?: Partial<T12.SparqlContext>): T12.SparqlQuery;
    /**
     * Parse a query string starting from the [Path](https://www.w3.org/TR/sparql12-query/#rPath) grammar rule.
     * @param query
     * @param context
     */
    parsePath(query: string, context?: Partial<T12.SparqlContext>): (T12.Path & {
        prefixes: object;
    }) | TermIri;
}
