"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = exports.sparql12ParserBuilder = void 0;
const core_1 = require("@traqula/core");
const parser_sparql_1_1_1 = require("@traqula/parser-sparql-1-1");
const rules_sparql_1_1_1 = require("@traqula/rules-sparql-1-1");
const rules_sparql_1_2_1 = require("@traqula/rules-sparql-1-2");
exports.sparql12ParserBuilder = core_1.ParserBuilder.create(parser_sparql_1_1_1.sparql11ParserBuilder)
    .widenContext()
    .typePatch()
    .addMany(rules_sparql_1_2_1.gram.reifiedTripleBlock, rules_sparql_1_2_1.gram.reifiedTripleBlockPath, rules_sparql_1_2_1.gram.reifier, rules_sparql_1_2_1.gram.varOrReifierId, rules_sparql_1_2_1.gram.annotation, rules_sparql_1_2_1.gram.annotationPath, rules_sparql_1_2_1.gram.annotationBlockPath, rules_sparql_1_2_1.gram.annotationBlock, rules_sparql_1_2_1.gram.reifiedTriple, rules_sparql_1_2_1.gram.reifiedTripleSubject, rules_sparql_1_2_1.gram.reifiedTripleObject, rules_sparql_1_2_1.gram.tripleTerm, rules_sparql_1_2_1.gram.tripleTermSubject, rules_sparql_1_2_1.gram.tripleTermObject, rules_sparql_1_2_1.gram.tripleTermData, rules_sparql_1_2_1.gram.tripleTermDataSubject, rules_sparql_1_2_1.gram.tripleTermDataObject, rules_sparql_1_2_1.gram.exprTripleTerm, rules_sparql_1_2_1.gram.exprTripleTermSubject, rules_sparql_1_2_1.gram.exprTripleTermObject)
    .addMany(rules_sparql_1_2_1.gram.versionDecl, rules_sparql_1_2_1.gram.versionSpecifier)
    .addMany(rules_sparql_1_2_1.gram.buildInLangDir, rules_sparql_1_2_1.gram.buildInLangStrDir, rules_sparql_1_2_1.gram.buildInHasLang, rules_sparql_1_2_1.gram.buildInHasLangDir, rules_sparql_1_2_1.gram.buildInIsTriple, rules_sparql_1_2_1.gram.buildInTriple, rules_sparql_1_2_1.gram.buildInSubject, rules_sparql_1_2_1.gram.buildInPredicate, rules_sparql_1_2_1.gram.buildInObject)
    .patchRule(rules_sparql_1_2_1.gram.dataBlockValue)
    .patchRule(rules_sparql_1_2_1.gram.triplesSameSubject)
    .patchRule(rules_sparql_1_2_1.gram.triplesSameSubjectPath)
    .patchRule(rules_sparql_1_2_1.gram.object)
    .patchRule(rules_sparql_1_2_1.gram.objectPath)
    .patchRule(rules_sparql_1_2_1.gram.graphNode)
    .patchRule(rules_sparql_1_2_1.gram.graphNodePath)
    .patchRule(rules_sparql_1_2_1.gram.varOrTerm)
    .deleteRule(rules_sparql_1_1_1.gram.graphTerm.name)
    .patchRule(rules_sparql_1_2_1.gram.primaryExpression)
    .patchRule(rules_sparql_1_2_1.gram.builtInCall)
    .patchRule(rules_sparql_1_2_1.gram.rdfLiteral)
    .patchRule(rules_sparql_1_2_1.gram.unaryExpression)
    .patchRule(rules_sparql_1_2_1.gram.prologue);
/**
 * Generator that can generate a SPARQL 1.2 AST given a SPARQL 1.2 string.
 */
class Parser {
    parser;
    defaultContext;
    constructor(args = {}) {
        this.parser = exports.sparql12ParserBuilder.build({
            ...args,
            queryPreProcessor: rules_sparql_1_1_1.sparqlCodepointEscape,
            tokenVocabulary: rules_sparql_1_2_1.lex.sparql12LexerBuilder.tokenVocabulary,
        });
        this.defaultContext = (0, rules_sparql_1_2_1.completeParseContext)(args.defaultContext ?? {});
    }
    /**
     * Parse a query string starting from the
     * [QueryUnit](https://www.w3.org/TR/sparql12-query/#rQueryUnit)
     * or [QueryUpdate](https://www.w3.org/TR/sparql12-query/#rUpdateUnit) rules.
     * @param query
     * @param context
     */
    parse(query, context = {}) {
        const ast = this.parser.queryOrUpdate(query, (0, rules_sparql_1_2_1.copyParseContext)({ ...this.defaultContext, ...context }));
        ast.loc = this.defaultContext.astFactory.sourceLocationInlinedSource(query, ast.loc, 0, Number.MAX_SAFE_INTEGER);
        return ast;
    }
    /**
     * Parse a query string starting from the [Path](https://www.w3.org/TR/sparql12-query/#rPath) grammar rule.
     * @param query
     * @param context
     */
    parsePath(query, context = {}) {
        const ast = this.parser.path(query, (0, rules_sparql_1_2_1.copyParseContext)({ ...this.defaultContext, ...context }));
        ast.loc = this.defaultContext.astFactory.sourceLocationInlinedSource(query, ast.loc, 0, Number.MAX_SAFE_INTEGER);
        if (this.defaultContext.astFactory.isPathPure(ast)) {
            return {
                ...ast,
                prefixes: {},
            };
        }
        return ast;
    }
}
exports.Parser = Parser;
//# sourceMappingURL=Parser.js.map