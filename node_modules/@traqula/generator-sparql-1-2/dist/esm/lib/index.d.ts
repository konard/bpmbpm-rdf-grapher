import { GeneratorBuilder } from '@traqula/core';
import type { Wrap, Patch } from '@traqula/core';
import type { gram as g11 } from '@traqula/rules-sparql-1-1';
import type * as T12 from '@traqula/rules-sparql-1-2';
export declare const sparql12GeneratorBuilder: GeneratorBuilder<T12.SparqlGeneratorContext, "filter" | "copy" | "graphRef" | "load" | "clear" | "drop" | "create" | "add" | "move" | "modify" | "update" | "query" | "datasetClauses" | "bind" | "solutionModifier" | "expression" | "aggregate" | "path" | "blankNode" | "selectQuery" | "selectClause" | "constructQuery" | "describeQuery" | "askQuery" | "update1" | "insertData" | "deleteData" | "deleteWhere" | "graphRefAll" | "quads" | "quadsNotTriples" | "usingClauses" | "argList" | "iriOrFunction" | "prologue" | "baseDecl" | "prefixDecl" | "varOrTerm" | "var" | "graphTerm" | "rdfLiteral" | "iri" | "iriFull" | "prefixedName" | "groupClause" | "havingClause" | "orderClause" | "limitOffsetClauses" | "triplesBlock" | "collectionPath" | "triplesNodePath" | "blankNodePropertyListPath" | "graphNodePath" | "whereClause" | "groupGraphPattern" | "generatePattern" | "graphPatternNotTriples" | "optionalGraphPattern" | "graphGraphPattern" | "serviceGraphPattern" | "inlineData" | "minusGraphPattern" | "groupOrUnionGraphPattern" | "queryOrUpdate" | "reifiedTriple" | "versionDecl" | "annotationPath" | "annotationBlockPath" | "tripleTerm", {
    filter: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "filter", T12.PatternFilter, []>;
    copy: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "copy", T12.UpdateOperationCopy, []>;
    graphRef: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "graphRef", import("@traqula/rules-sparql-1-1").TermIri, []>;
    load: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "load", T12.UpdateOperationLoad, []>;
    clear: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "clear", T12.UpdateOperationClear, []>;
    drop: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "drop", T12.UpdateOperationDrop, []>;
    create: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "create", T12.UpdateOperationCreate, []>;
    add: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "add", T12.UpdateOperationAdd, []>;
    move: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "move", T12.UpdateOperationMove, []>;
    modify: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "modify", T12.UpdateOperationModify, []>;
    update: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "update", T12.Update, []>;
    query: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "query", T12.Query, []>;
    datasetClauses: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "datasetClauses", T12.DatasetClauses, []>;
    bind: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "bind", T12.PatternBind, []>;
    solutionModifier: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "solutionModifier", T12.SolutionModifiers, []>;
    expression: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "expression", T12.Expression, []>;
    aggregate: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "aggregate", T12.ExpressionAggregate, []>;
    path: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "path", import("@traqula/rules-sparql-1-1").Path, [boolean | undefined]>;
    blankNode: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "blankNode", import("@traqula/core").Node & {
        type: "term";
        subType: string;
    } & {
        subType: "blankNode";
    } & {
        label: string;
    }, []>;
    selectQuery: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "selectQuery", Omit<T12.QuerySelect, g11.HandledByBase>, []>;
    selectClause: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "selectClause", Wrap<Pick<T12.QuerySelect, "variables" | "distinct" | "reduced">>, []>;
    constructQuery: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "constructQuery", Omit<T12.QueryConstruct, g11.HandledByBase>, []>;
    describeQuery: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "describeQuery", Omit<T12.QueryDescribe, g11.HandledByBase>, []>;
    askQuery: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "askQuery", Omit<T12.QueryAsk, g11.HandledByBase>, []>;
    update1: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "update1", T12.UpdateOperation, []>;
    insertData: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "insertData", T12.UpdateOperationInsertData, []>;
    deleteData: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "deleteData", T12.UpdateOperationDeleteData, []>;
    deleteWhere: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "deleteWhere", T12.UpdateOperationDeleteWhere, []>;
    graphRefAll: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "graphRefAll", import("@traqula/rules-sparql-1-1").GraphRef, []>;
    quads: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "quads", Wrap<T12.Quads[]>, []>;
    quadsNotTriples: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "quadsNotTriples", T12.GraphQuads, []>;
    usingClauses: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "usingClauses", T12.DatasetClauses, []>;
    argList: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "argList", Patch<g11.IArgList, {
        args: T12.Expression[];
    }>, []>;
    iriOrFunction: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "iriOrFunction", import("@traqula/rules-sparql-1-1").TermIri | T12.ExpressionFunctionCall, []>;
    prologue: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "prologue", T12.ContextDefinition[], []>;
    baseDecl: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "baseDecl", import("@traqula/rules-sparql-1-1").ContextDefinitionBase, []>;
    prefixDecl: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "prefixDecl", import("@traqula/rules-sparql-1-1").ContextDefinitionPrefix, []>;
    varOrTerm: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "varOrTerm", T12.Term, []>;
    var: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "var", import("@traqula/core").Node & {
        type: "term";
        subType: string;
    } & {
        subType: "variable";
        value: string;
    }, []>;
    graphTerm: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "graphTerm", T12.GraphTerm, []>;
    rdfLiteral: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "rdfLiteral", import("@traqula/rules-sparql-1-1").TermLiteral, []>;
    iri: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "iri", import("@traqula/rules-sparql-1-1").TermIri, []>;
    iriFull: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "iriFull", import("@traqula/core").Node & {
        type: "term";
        subType: string;
    } & {
        subType: "namedNode";
    } & {
        value: string;
    }, []>;
    prefixedName: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "prefixedName", import("@traqula/core").Node & {
        type: "term";
        subType: string;
    } & {
        subType: "namedNode";
    } & {
        value: string;
        prefix: string;
    }, []>;
    groupClause: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "groupClause", T12.SolutionModifierGroup, []>;
    havingClause: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "havingClause", T12.SolutionModifierHaving, []>;
    orderClause: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "orderClause", T12.SolutionModifierOrder, []>;
    limitOffsetClauses: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "limitOffsetClauses", import("@traqula/rules-sparql-1-1").SolutionModifierLimitOffset, []>;
    triplesBlock: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "triplesBlock", T12.PatternBgp, []>;
    collectionPath: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "collectionPath", T12.TripleCollectionList, []>;
    triplesNodePath: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "triplesNodePath", T12.TripleCollection, []>;
    blankNodePropertyListPath: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "blankNodePropertyListPath", Patch<import("@traqula/rules-sparql-1-1").TripleCollectionBlankNodeProperties, {
        triples: T12.TripleNesting[];
        identifier: T12.TermBlank | T12.TermVariable | T12.TermIri;
    }>, []>;
    graphNodePath: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "graphNodePath", T12.GraphNode, []>;
    whereClause: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "whereClause", Wrap<T12.PatternGroup>, []>;
    groupGraphPattern: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "groupGraphPattern", T12.PatternGroup, []>;
    generatePattern: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "generatePattern", T12.Pattern, []>;
    graphPatternNotTriples: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "graphPatternNotTriples", T12.PatternGroup | T12.PatternUnion | T12.PatternOptional | T12.PatternMinus | T12.PatternGraph | T12.PatternService | T12.PatternFilter | T12.PatternBind | T12.PatternValues, []>;
    optionalGraphPattern: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "optionalGraphPattern", T12.PatternOptional, []>;
    graphGraphPattern: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "graphGraphPattern", T12.PatternGroup, []>;
    serviceGraphPattern: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "serviceGraphPattern", T12.PatternService, []>;
    inlineData: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "inlineData", T12.PatternValues, []>;
    minusGraphPattern: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "minusGraphPattern", T12.PatternMinus, []>;
    groupOrUnionGraphPattern: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "groupOrUnionGraphPattern", T12.PatternGroup | T12.PatternUnion, []>;
    queryOrUpdate: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "queryOrUpdate", T12.SparqlQuery, []>;
    reifiedTriple: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "reifiedTriple", T12.TripleCollectionReifiedTriple, []>;
    versionDecl: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "versionDecl", T12.ContextDefinitionVersion, []>;
    annotationPath: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "annotationPath", T12.Annotation[], []>;
    annotationBlockPath: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "annotationBlockPath", Patch<import("@traqula/rules-sparql-1-1").TripleCollectionBlankNodeProperties, {
        triples: T12.TripleNesting[];
        identifier: T12.TermBlank | T12.TermVariable | T12.TermIri;
    }>, []>;
    tripleTerm: import("@traqula/core").GeneratorRule<T12.SparqlGeneratorContext, "tripleTerm", T12.TermTriple, []>;
}>;
export type SparqlGenerator = ReturnType<typeof sparql12GeneratorBuilder.build>;
/**
 * Generator that can generate a SPARQL 1.2 query string given a SPARQL 1.2 Traqula AST.
 */
export declare class Generator {
    protected readonly defaultContext: T12.SparqlGeneratorContext;
    constructor(defaultContext?: Partial<T12.SparqlGeneratorContext>);
    private readonly generator;
    /**
     * Generates a query string starting from the
     * [QueryUnit](https://www.w3.org/TR/sparql12-query/#rQueryUnit)
     * or [QueryUpdate](https://www.w3.org/TR/sparql12-query/#rUpdateUnit) rules.
     * @param ast
     * @param context
     */
    generate(ast: T12.Query | T12.Update, context?: Partial<T12.SparqlGeneratorContext>): string;
    /**
     * Generates a query string starting from the [Path](https://www.w3.org/TR/sparql12-query/#rPath) grammar rule.
     * @param ast
     * @param context
     */
    generatePath(ast: T12.Path, context?: Partial<T12.SparqlGeneratorContext>): string;
}
