{"version":3,"file":"validators.js","sourceRoot":"","sources":["../../../lib/validators.ts"],"names":[],"mappings":"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","sourcesContent":["import { AstFactory } from './AstFactory.js';\nimport type {\n  Path,\n  Pattern,\n  SparqlQuery,\n  Term,\n  TermLiteral,\n  TripleCollection,\n  TripleNesting,\n  Wildcard,\n} from './sparql12Types.js';\n\nconst F = new AstFactory();\n\nfunction isLangDir(dir: string): dir is 'ltr' | 'rtl' {\n  return dir === 'ltr' || dir === 'rtl';\n}\n\nexport function langTagHasCorrectRange(literal: TermLiteral): void {\n  if (F.isTermLiteralLangStr(literal)) {\n    const dirSplit = literal.langOrIri.split('--');\n    if (dirSplit.length > 1) {\n      const [ _, direction ] = dirSplit;\n      if (!isLangDir(direction)) {\n        throw new Error(`language direction \"${direction}\" of literal \"${JSON.stringify(literal)}\" is not is required range 'ltr' | 'rtl'.`);\n      }\n    }\n  }\n}\n\nexport function findPatternBoundedVars(\n  iter: SparqlQuery | Pattern | TripleNesting | TripleCollection | Path | Term | Wildcard,\n  boundedVars: Set<string>,\n): void {\n  if (F.isQuery(iter) || F.isUpdate(iter)) {\n    if (F.isQuerySelect(iter) || F.isQueryDescribe(iter)) {\n      if (iter.where && iter.variables.some(x => F.isWildcard(x))) {\n        findPatternBoundedVars(iter.where, boundedVars);\n      } else {\n        for (const v of iter.variables) {\n          findPatternBoundedVars(v, boundedVars);\n        }\n      }\n      if (iter.solutionModifiers.group) {\n        const grouping = iter.solutionModifiers.group;\n        for (const g of grouping.groupings) {\n          if ('variable' in g) {\n            findPatternBoundedVars(g.variable, boundedVars);\n          }\n        }\n      }\n      if (iter.values?.values && iter.values.values.length > 0) {\n        const values = iter.values.values;\n        for (const v of Object.keys(values[0])) {\n          boundedVars.add(v);\n        }\n      }\n    }\n  } else if (F.isTerm(iter)) {\n    if (F.isTermVariable(iter)) {\n      boundedVars.add(iter.value);\n    }\n    if (F.isTermTriple(iter)) {\n      findPatternBoundedVars(iter.subject, boundedVars);\n      findPatternBoundedVars(iter.predicate, boundedVars);\n      findPatternBoundedVars(iter.object, boundedVars);\n    }\n  } else if (F.isTriple(iter)) {\n    findPatternBoundedVars(iter.subject, boundedVars);\n    findPatternBoundedVars(iter.predicate, boundedVars);\n    findPatternBoundedVars(iter.object, boundedVars);\n    for (const annotation of iter.annotations ?? []) {\n      findPatternBoundedVars(\n        F.isTripleCollection(annotation) ? annotation : annotation.val,\n        boundedVars,\n      );\n    }\n  } else if (F.isPath(iter)) {\n    if (!F.isTerm(iter)) {\n      for (const item of iter.items) {\n        findPatternBoundedVars(item, boundedVars);\n      }\n    }\n  } else if (F.isTripleCollection(iter) || F.isPatternBgp(iter)) {\n    for (const triple of iter.triples) {\n      findPatternBoundedVars(triple, boundedVars);\n    }\n  } else if (\n    F.isPatternGroup(iter) || F.isPatternUnion(iter) || F.isPatternOptional(iter) || F.isPatternService(iter)) {\n    for (const pattern of iter.patterns) {\n      findPatternBoundedVars(pattern, boundedVars);\n    }\n    if (F.isPatternService(iter)) {\n      findPatternBoundedVars(iter.name, boundedVars);\n    }\n  } else if (F.isPatternBind(iter)) {\n    findPatternBoundedVars(iter.variable, boundedVars);\n  } else if (F.isPatternValues(iter)) {\n    for (const variable of Object.keys(iter.values.at(0) ?? {})) {\n      boundedVars.add(variable);\n    }\n  } else if (F.isPatternGraph(iter)) {\n    findPatternBoundedVars(iter.name, boundedVars);\n    for (const pattern of iter.patterns) {\n      findPatternBoundedVars(pattern, boundedVars);\n    }\n  }\n}\n"]}