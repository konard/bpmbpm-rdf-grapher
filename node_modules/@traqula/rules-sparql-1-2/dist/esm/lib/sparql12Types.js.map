{"version":3,"file":"sparql12Types.js","sourceRoot":"","sources":["../../../lib/sparql12Types.ts"],"names":[],"mappings":"","sourcesContent":["import type { Localized, Node, Patch, Wrap } from '@traqula/core';\nimport type * as T11 from '@traqula/rules-sparql-1-1';\n\nexport type Sparql12Nodes =\n  | GraphRef\n  | UpdateOperation\n  | Update\n  | Query\n  | DatasetClauses\n  | TripleCollection\n  | TripleNesting\n  | Pattern\n  | SolutionModifier\n  | Expression\n  | Path\n  | ContextDefinition\n  | Wildcard\n  | Term;\n\nexport type GraphRefBase = T11.GraphRefBase;\nexport type GraphRefDefault = T11.GraphRefDefault;\nexport type GraphRefNamed = T11.GraphRefNamed;\nexport type GraphRefAll = T11.GraphRefAll;\nexport type GraphRefSpecific = T11.GraphRefSpecific;\nexport type GraphRef = T11.GraphRef;\n\nexport type Quads = PatternBgp | GraphQuads;\n\nexport type GraphQuads = Node & {\n  type: 'graph';\n  graph: TermIri | TermVariable;\n  triples: PatternBgp;\n};\n\n// https://www.w3.org/TR/sparql11-query/#rUpdate1\nexport type UpdateOperationBase = Node & { type: 'updateOperation'; subType: string };\nexport type UpdateOperationLoad = UpdateOperationBase & {\n  subType: 'load';\n  silent: boolean;\n  source: TermIri;\n  destination?: GraphRefSpecific;\n};\ntype UpdateOperationClearDropCreateBase = UpdateOperationBase & {\n  subType: 'clear' | 'drop' | 'create';\n  silent: boolean;\n  destination: GraphRef;\n};\nexport type UpdateOperationClear = UpdateOperationClearDropCreateBase & { subType: 'clear' };\nexport type UpdateOperationDrop = UpdateOperationClearDropCreateBase & { subType: 'drop' };\nexport type UpdateOperationCreate = UpdateOperationClearDropCreateBase & {\n  subType: 'create';\n  destination: GraphRefSpecific;\n};\ntype UpdateOperationAddMoveCopy = UpdateOperationBase & {\n  subType: 'add' | 'move' | 'copy';\n  silent: boolean;\n  source: GraphRefDefault | GraphRefSpecific;\n  destination: GraphRefDefault | GraphRefSpecific;\n};\nexport type UpdateOperationAdd = UpdateOperationAddMoveCopy & { subType: 'add' };\nexport type UpdateOperationMove = UpdateOperationAddMoveCopy & { subType: 'move' };\nexport type UpdateOperationCopy = UpdateOperationAddMoveCopy & { subType: 'copy' };\ntype UpdateOperationInsertDeleteDelWhere = UpdateOperationBase & {\n  subType: 'insertdata' | 'deletedata' | 'deletewhere';\n  data: Quads[];\n};\nexport type UpdateOperationInsertData = UpdateOperationInsertDeleteDelWhere & { subType: 'insertdata' };\nexport type UpdateOperationDeleteData = UpdateOperationInsertDeleteDelWhere & { subType: 'deletedata' };\nexport type UpdateOperationDeleteWhere = UpdateOperationInsertDeleteDelWhere & { subType: 'deletewhere' };\nexport type UpdateOperationModify = UpdateOperationBase & {\n  subType: 'modify';\n  graph: TermIri | undefined;\n  insert: Quads[];\n  delete: Quads[];\n  from: DatasetClauses;\n  where: PatternGroup;\n};\nexport type UpdateOperation =\n  | UpdateOperationLoad\n  | UpdateOperationClear\n  | UpdateOperationDrop\n  | UpdateOperationCreate\n  | UpdateOperationAdd\n  | UpdateOperationMove\n  | UpdateOperationCopy\n  | UpdateOperationInsertData\n  | UpdateOperationDeleteData\n  | UpdateOperationDeleteWhere\n  | UpdateOperationModify;\n\n// https://www.w3.org/TR/sparql11-query/#rUpdate\nexport type Update = Node & {\n  type: 'update';\n  updates: {\n    operation?: UpdateOperation;\n    context: ContextDefinition[];\n  }[];\n};\n\n// https://www.w3.org/TR/sparql11-query/#rQueryUnit\nexport type QueryBase = Node & {\n  type: 'query';\n  subType: string;\n\n  context: ContextDefinition[];\n  values?: PatternValues;\n  solutionModifiers: SolutionModifiers;\n  datasets: DatasetClauses;\n  where?: PatternGroup;\n};\nexport type QuerySelect = QueryBase & {\n  subType: 'select';\n  variables: (TermVariable | PatternBind)[] | [Wildcard];\n  distinct?: true;\n  reduced?: true;\n  where: PatternGroup;\n};\nexport type QueryConstruct = QueryBase & {\n  subType: 'construct';\n  template: PatternBgp;\n  where: PatternGroup;\n};\nexport type QueryDescribe = QueryBase & {\n  subType: 'describe';\n  variables: (TermVariable | TermIri)[] | [Wildcard];\n};\nexport type QueryAsk = QueryBase & {\n  subType: 'ask';\n  where: PatternGroup;\n};\nexport type Query =\n  | QuerySelect\n  | QueryConstruct\n  | QueryDescribe\n  | QueryAsk;\n\nexport type SparqlQuery = Query | Update;\n\n// https://www.w3.org/TR/sparql11-query/#rDatasetClause\nexport type DatasetClauses = Node & {\n  type: 'datasetClauses';\n  clauses: { clauseType: 'default' | 'named'; value: TermIri }[];\n};\n\n// https://www.w3.org/TR/sparql11-query/#rGraphNode\nexport type TripleCollectionBase = Node & {\n  type: 'tripleCollection';\n  subType: string;\n  triples: TripleNesting[];\n  identifier: Term;\n};\n/**\n * Both subject and predicate of the triples do not have a string manifestation.\n */\nexport type TripleCollectionList = TripleCollectionBase & {\n  subType: 'list';\n  identifier: TermBlank;\n};\n/**\n * The subject of the triples does not have a string manifestation.\n */\nexport type TripleCollectionBlankNodeProperties = Patch<T11.TripleCollectionBlankNodeProperties, {\n  triples: TripleNesting[];\n  identifier: TermBlank | TermVariable | TermIri;\n}>;\nexport type TripleCollectionReifiedTriple = TripleCollectionBase & {\n  subType: 'reifiedTriple';\n  identifier: TermVariable | TermIri | TermBlank;\n};\n\nexport type TripleCollection =\n  | TripleCollectionList\n  | TripleCollectionBlankNodeProperties\n  | TripleCollectionReifiedTriple;\n\n// https://www.w3.org/TR/sparql11-query/#rGraphNode\nexport type GraphNode = Term | TripleCollection;\nexport type Annotation = TripleCollectionBlankNodeProperties | Wrap<TermVariable | TermIri | TermBlank>;\n// https://www.w3.org/TR/sparql12-query/#rTriplesBlock\nexport type TripleNesting = Node & {\n  type: 'triple';\n  subject: GraphNode;\n  predicate: TermIri | TermVariable | Path;\n  object: GraphNode;\n  annotations?: Annotation[];\n};\n\nexport type PatternBase = Node & { type: 'pattern'; subType: string };\nexport type PatternFilter = PatternBase & {\n  subType: 'filter';\n  expression: Expression;\n};\nexport type PatternMinus = PatternBase & {\n  subType: 'minus';\n  patterns: Pattern[];\n};\n\nexport type PatternGroup = PatternBase & {\n  subType: 'group';\n  patterns: Pattern[];\n};\nexport type PatternOptional = PatternBase & {\n  subType: 'optional';\n  patterns: Pattern[];\n};\nexport type PatternGraph = PatternBase & {\n  subType: 'graph';\n  name: TermIri | TermVariable;\n  patterns: Pattern[];\n};\nexport type PatternUnion = PatternBase & {\n  subType: 'union';\n  patterns: PatternGroup[];\n};\nexport type BasicGraphPattern = (TripleNesting | TripleCollection)[];\nexport type PatternBgp = PatternBase & {\n  subType: 'bgp';\n  /**\n   * Only the first appearance of a subject and predicate have a string manifestation\n   */\n  triples: BasicGraphPattern;\n};\nexport type PatternBind = PatternBase & {\n  subType: 'bind';\n  expression: Expression;\n  variable: TermVariable;\n};\nexport type PatternService = PatternBase & {\n  subType: 'service';\n  name: TermIri | TermVariable;\n  silent: boolean;\n  patterns: Pattern[];\n};\n/**\n * A single list of assignments maps the variable identifier to the value\n */\nexport type ValuePatternRow = Record<string, TermIri | TermLiteral | undefined>;\nexport type PatternValues = PatternBase & {\n  subType: 'values';\n  values: ValuePatternRow[];\n};\nexport type SubSelect = QuerySelect;\n\nexport type Pattern =\n  | PatternBgp\n  | PatternGroup\n  | PatternUnion\n  | PatternOptional\n  | PatternMinus\n  | PatternGraph\n  | PatternService\n  | PatternFilter\n  | PatternBind\n  | PatternValues\n  | SubSelect;\n\nexport type SolutionModifiers = {\n  group?: SolutionModifierGroup;\n  having?: SolutionModifierHaving;\n  order?: SolutionModifierOrder;\n  limitOffset?: SolutionModifierLimitOffset;\n};\nexport type SolutionModifierBase = Node & { type: 'solutionModifier'; subType: string };\nexport type SolutionModifierGroupBind = Localized & {\n  variable: TermVariable;\n  value: Expression;\n};\nexport type SolutionModifierGroup = SolutionModifierBase & {\n  subType: 'group';\n  groupings: (Expression | SolutionModifierGroupBind)[];\n};\nexport type SolutionModifierHaving = SolutionModifierBase & {\n  subType: 'having';\n  having: Expression[];\n};\nexport type Ordering =\n  | Expression\n  | (Localized & { descending: boolean; expression: Expression });\nexport type SolutionModifierOrder = SolutionModifierBase & {\n  subType: 'order';\n  orderDefs: Ordering[];\n};\nexport type SolutionModifierLimitOffset = T11.SolutionModifierLimitOffset;\n\nexport type SolutionModifier =\n  | SolutionModifierGroup\n  | SolutionModifierHaving\n  | SolutionModifierOrder\n  | SolutionModifierLimitOffset;\n\nexport type ExpressionBase = Node & { type: 'expression'; subType: string };\n\ntype ExpressionAggregateBase = ExpressionBase & {\n  subType: 'aggregate';\n  distinct: boolean;\n};\nexport type ExpressionAggregateDefault = ExpressionAggregateBase & {\n  expression: [Expression];\n  aggregation: string;\n};\nexport type ExpressionAggregateOnWildcard = ExpressionAggregateBase & {\n  expression: [Wildcard];\n  aggregation: string;\n};\nexport type ExpressionAggregateSeparator = ExpressionAggregateBase & {\n  expression: [Expression];\n  aggregation: string;\n  separator: string;\n};\nexport type ExpressionAggregate =\n  | ExpressionAggregateDefault\n  | ExpressionAggregateOnWildcard\n  | ExpressionAggregateSeparator;\n\nexport type ExpressionOperation = ExpressionBase & {\n  subType: 'operation';\n  operator: string;\n  args: Expression[];\n};\n\nexport type ExpressionPatternOperation = ExpressionBase & {\n  subType: 'patternOperation';\n  operator: string;\n  // Can be a pattern in case of exists and not exists\n  args: PatternGroup;\n};\n\nexport type ExpressionFunctionCall = ExpressionBase & {\n  subType: 'functionCall';\n  function: TermIri;\n  distinct: boolean;\n  args: Expression[];\n};\n\nexport type Expression =\n  | ExpressionOperation\n  | ExpressionPatternOperation\n  | ExpressionFunctionCall\n  | ExpressionAggregate\n  | TermIri\n  | TermVariable\n  | TermLiteral\n  | TermTriple;\n\nexport type PropertyPathChain = T11.PropertyPathChain;\nexport type PathModified = T11.PathModified;\nexport type PathNegatedElt = T11.PathNegatedElt;\nexport type PathAlternativeLimited = T11.PathAlternativeLimited;\nexport type PathNegated = T11.PathNegated;\n// [[88]](https://www.w3.org/TR/sparql11-query/#rPath)\nexport type Path = T11.Path;\nexport type PathPure = PropertyPathChain | PathModified | PathNegated;\n\nexport type ContextDefinitionPrefix = T11.ContextDefinitionPrefix;\nexport type ContextDefinitionBase = T11.ContextDefinitionBase;\nexport type ContextDefinitionVersion = T11.ContextDefinitionBase_ & {\n  subType: 'version';\n  version: string;\n};\nexport type ContextDefinition = T11.ContextDefinition | ContextDefinitionVersion;\n\nexport type Wildcard = T11.Wildcard;\nexport type TermLiteralStr = T11.TermLiteralStr;\nexport type TermLiteralLangStr = T11.TermLiteralLangStr;\nexport type TermLiteralTyped = T11.TermLiteralTyped;\nexport type TermLiteral = T11.TermLiteral;\nexport type TermVariable = T11.TermVariable;\nexport type TermIriFull = T11.TermIriFull;\nexport type TermIriPrefixed = T11.TermIriPrefixed;\nexport type TermIri = T11.TermIri;\nexport type TermBlank = T11.TermBlank;\n\nexport type TermTriple = T11.TermBase & {\n  subType: 'triple';\n  subject: Term;\n  predicate: TermIri | TermVariable;\n  object: Term;\n};\n\nexport type Term = GraphTerm | TermVariable;\nexport type GraphTerm = TermIri | TermBlank | TermLiteral | TermTriple;\n"]}