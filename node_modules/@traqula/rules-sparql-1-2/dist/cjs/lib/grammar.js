"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateGraphTerm = exports.generateTriplesBlock = exports.unaryExpression = exports.rdfLiteral = exports.builtInCall = exports.buildInObject = exports.buildInPredicate = exports.buildInSubject = exports.buildInTriple = exports.buildInIsTriple = exports.buildInHasLangDir = exports.buildInHasLang = exports.buildInLangStrDir = exports.buildInLangDir = exports.exprTripleTermObject = exports.exprTripleTermSubject = exports.exprTripleTerm = exports.primaryExpression = exports.tripleTermDataObject = exports.tripleTermDataSubject = exports.tripleTermData = exports.tripleTermObject = exports.tripleTermSubject = exports.tripleTerm = exports.reifiedTripleObject = exports.reifiedTripleSubject = exports.reifiedTriple = exports.varOrTerm = exports.graphNodePath = exports.graphNode = exports.annotationBlock = exports.annotationBlockPath = exports.annotation = exports.annotationPath = exports.objectPath = exports.object = exports.triplesSameSubjectPath = exports.triplesSameSubject = exports.varOrReifierId = exports.reifier = exports.dataBlockValue = exports.reifiedTripleBlockPath = exports.reifiedTripleBlock = exports.prologue = exports.versionSpecifier = exports.versionDecl = void 0;
const core_1 = require("@traqula/core");
const rules_sparql_1_1_1 = require("@traqula/rules-sparql-1-1");
const l12 = __importStar(require("./lexer.js"));
const validators_js_1 = require("./validators.js");
/**
 *[[7]](https://www.w3.org/TR/sparql12-query/#rVersionDecl)
 */
exports.versionDecl = {
    name: 'versionDecl',
    impl: ({ ACTION, SUBRULE, CONSUME }) => (C) => {
        const versionToken = CONSUME(l12.version);
        const identifier = SUBRULE(exports.versionSpecifier);
        return ACTION(() => C.astFactory.contextDefinitionVersion(identifier.val, C.astFactory.sourceLocation(versionToken, identifier)));
    },
    gImpl: ({ PRINT_ON_OWN_LINE }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => {
            PRINT_ON_OWN_LINE('VERSION ', `${rules_sparql_1_1_1.gram.stringEscapedLexical(ast.version)}`);
        });
    },
};
/**
 * [[8]](https://www.w3.org/TR/sparql12-query/#rVersionSpecifier)
 */
exports.versionSpecifier = {
    name: 'versionSpecifier',
    impl: ({ ACTION, CONSUME, OR }) => (C) => {
        const token = OR([
            { ALT: () => CONSUME(rules_sparql_1_1_1.lex.terminals.stringLiteral1) },
            { ALT: () => CONSUME(rules_sparql_1_1_1.lex.terminals.stringLiteral2) },
        ]);
        return ACTION(() => C.astFactory.wrap(token.image.slice(1, -1), C.astFactory.sourceLocation(token)));
    },
};
/**
 * OVERRIDING RULE {@link S11.prologue}
 * [[4]](https://www.w3.org/TR/sparql12-query/#rPrologue)
 */
exports.prologue = {
    name: 'prologue',
    impl: ({ SUBRULE, MANY, OR }) => () => {
        const result = [];
        MANY(() => OR([
            { ALT: () => result.push(SUBRULE(rules_sparql_1_1_1.gram.baseDecl)) },
            // TODO: the [spec](https://www.w3.org/TR/sparql11-query/#iriRefs) says you cannot redefine prefixes.
            //  We might need to check this.
            { ALT: () => result.push(SUBRULE(rules_sparql_1_1_1.gram.prefixDecl)) },
            { ALT: () => result.push(SUBRULE(exports.versionDecl)) },
        ]));
        return result;
    },
    gImpl: ({ SUBRULE }) => (ast, { astFactory: F }) => {
        for (const context of ast) {
            if (F.isContextDefinitionBase(context)) {
                SUBRULE(rules_sparql_1_1_1.gram.baseDecl, context);
            }
            else if (F.isContextDefinitionPrefix(context)) {
                SUBRULE(rules_sparql_1_1_1.gram.prefixDecl, context);
            }
            else if (F.isContextDefinitionVersion(context)) {
                SUBRULE(exports.versionDecl, context);
            }
        }
    },
};
function reifiedTripleBlockImpl(name, allowPath) {
    return {
        name,
        impl: ({ ACTION, SUBRULE }) => (C) => {
            const triple = SUBRULE(exports.reifiedTriple);
            const properties = SUBRULE(allowPath ? rules_sparql_1_1_1.gram.propertyListPath : rules_sparql_1_1_1.gram.propertyList, ACTION(() => C.astFactory.dematerialized(triple.identifier)));
            return ACTION(() => [triple, ...properties]);
        },
    };
}
/**
 * [[58]](https://www.w3.org/TR/sparql12-query/#rReifiedTripleBlock) Used by triplesSameSubject
 */
exports.reifiedTripleBlock = reifiedTripleBlockImpl('reifiedTripleBlock', false);
/**
 * [[59]](https://www.w3.org/TR/sparql12-query/#rReifiedTripleBlockPath) Used by TriplesSameSubjectPath
 */
exports.reifiedTripleBlockPath = reifiedTripleBlockImpl('reifiedTripleBlockPath', true);
/**
 * OVERRIDING RULE: {@link S11.dataBlockValue}.
 * [[69]](https://www.w3.org/TR/sparql12-query/#rDataBlockValue)
 */
exports.dataBlockValue = {
    name: 'dataBlockValue',
    impl: $ => C => $.OR2([
        { ALT: () => rules_sparql_1_1_1.gram.dataBlockValue.impl($)(C) },
        { ALT: () => $.SUBRULE(exports.tripleTermData) },
    ]),
};
/**
 * [[70]](https://www.w3.org/TR/sparql12-query/#rReifier)
 */
exports.reifier = {
    name: 'reifier',
    impl: ({ ACTION, CONSUME, SUBRULE, OPTION }) => (C) => {
        const tildeToken = CONSUME(l12.tilde);
        const reifier = OPTION(() => SUBRULE(exports.varOrReifierId));
        return ACTION(() => {
            if (reifier === undefined && !C.parseMode.has('canCreateBlankNodes')) {
                throw new Error('Cannot create blanknodes in current parse mode');
            }
            return C.astFactory.wrap(reifier ?? C.astFactory.termBlank(undefined, C.astFactory.sourceLocation()), C.astFactory.sourceLocation(tildeToken, reifier));
        });
    },
};
/**
 * [[71]](https://www.w3.org/TR/sparql12-query/#rVarOrReifierId)
 */
exports.varOrReifierId = {
    name: 'varOrReifierId',
    impl: ({ SUBRULE, OR }) => C => OR([
        { GATE: () => C.parseMode.has('canParseVars'), ALT: () => SUBRULE(rules_sparql_1_1_1.gram.var_) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.iri) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.blankNode) },
    ]),
};
function triplesSameSubjectImpl(name, allowPaths) {
    return {
        name,
        impl: $ => C => $.OR2([
            { ALT: () => allowPaths ?
                    rules_sparql_1_1_1.gram.triplesSameSubjectPath.impl($)(C) :
                    rules_sparql_1_1_1.gram.triplesSameSubject.impl($)(C) },
            { ALT: () => $.SUBRULE(allowPaths ? exports.reifiedTripleBlockPath : exports.reifiedTripleBlock) },
        ]),
    };
}
/**
 * OVERRIDING RULE {@link S11.triplesSameSubject}
 * [[81]](https://www.w3.org/TR/sparql12-query/#rTriplesSameSubject)
 */
exports.triplesSameSubject = triplesSameSubjectImpl('triplesSameSubject', false);
/**
 * OVERRIDING RULE {@link S11.triplesSameSubjectPath}
 * [[87]](https://www.w3.org/TR/sparql12-query/#rTriplesSameSubjectPath)
 */
exports.triplesSameSubjectPath = triplesSameSubjectImpl('triplesSameSubjectPath', true);
function objectImpl(name, allowPaths) {
    return {
        name,
        impl: ({ ACTION, SUBRULE }) => (C, subject, predicate) => {
            const objectVal = SUBRULE(allowPaths ? exports.graphNodePath : exports.graphNode);
            const annotationVal = SUBRULE(allowPaths ? exports.annotationPath : exports.annotation);
            return ACTION(() => {
                const F = C.astFactory;
                if (F.isPathPure(predicate) && annotationVal.length > 0) {
                    throw new Error('Note 17 violation');
                }
                return F.annotatedTriple(subject, predicate, objectVal, annotationVal);
            });
        },
    };
}
/**
 * OVERRIDING RULE: {@link S11.object}.
 * [[86]](https://www.w3.org/TR/sparql12-query/#rObject) Used by ObjectList
 */
exports.object = objectImpl('object', false);
/**
 * OVERRIDING RULE: {@link S11.objectPath}.
 * [[87]](https://www.w3.org/TR/sparql12-query/#rTriplesSameSubjectPath) Used by ObjectListPath
 */
exports.objectPath = objectImpl('objectPath', true);
function annotationImpl(name, allowPaths) {
    return {
        name,
        impl: ({ ACTION, SUBRULE, OR, MANY }) => (C) => {
            const annotations = [];
            let currentReifier;
            MANY(() => {
                OR([
                    { ALT: () => {
                            const node = SUBRULE(exports.reifier);
                            annotations.push(node);
                            currentReifier = node.val;
                        } },
                    { ALT: () => {
                            ACTION(() => {
                                if (!currentReifier && !C.parseMode.has('canCreateBlankNodes')) {
                                    throw new Error('Cannot create blanknodes in current parse mode');
                                }
                                currentReifier = currentReifier ?? C.astFactory.termBlank(undefined, C.astFactory.sourceLocation());
                            });
                            const block = SUBRULE(allowPaths ? exports.annotationBlockPath : exports.annotationBlock, currentReifier);
                            ACTION(() => {
                                annotations.push(block);
                                currentReifier = undefined;
                            });
                        } },
                ]);
            });
            return annotations;
        },
        gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
            for (const annotation of ast) {
                if (F.isTripleCollectionBlankNodeProperties(annotation)) {
                    SUBRULE(exports.annotationBlockPath, annotation);
                }
                else {
                    F.printFilter(annotation, () => PRINT_WORD('~'));
                    SUBRULE(exports.graphNodePath, annotation.val);
                }
            }
        },
    };
}
/**
 * [[109]](https://www.w3.org/TR/sparql12-query/#rAnnotationPath)
 */
exports.annotationPath = annotationImpl('annotationPath', true);
/**
 * [[111]](https://www.w3.org/TR/sparql12-query/#rAnnotation)
 */
exports.annotation = annotationImpl('annotation', false);
function annotationBlockImpl(name, allowPaths) {
    return {
        name,
        impl: ({ ACTION, SUBRULE, CONSUME }) => (C, arg) => {
            const open = CONSUME(l12.annotationOpen);
            const res = SUBRULE(allowPaths ? rules_sparql_1_1_1.gram.propertyListPathNotEmpty : rules_sparql_1_1_1.gram.propertyListNotEmpty, arg);
            const close = CONSUME(l12.annotationClose);
            return ACTION(() => C.astFactory.tripleCollectionBlankNodeProperties(arg, res, C.astFactory.sourceLocation(open, close)));
        },
        gImpl: ({ SUBRULE, PRINT_WORD, HANDLE_LOC, NEW_LINE, PRINT_ON_OWN_LINE }) => (ast, C) => {
            const { astFactory: F, indentInc } = C;
            F.printFilter(ast, () => {
                PRINT_WORD('{|');
                if (ast.triples.length > 1) {
                    C[core_1.traqulaIndentation] += indentInc;
                    NEW_LINE();
                }
            });
            function printTriple(triple) {
                HANDLE_LOC(triple, () => {
                    if (F.isTerm(triple.predicate)) {
                        SUBRULE(exports.graphNodePath, triple.predicate);
                    }
                    else {
                        SUBRULE(rules_sparql_1_1_1.gram.pathGenerator, triple.predicate, undefined);
                    }
                    F.printFilter(triple, () => PRINT_WORD(''));
                    SUBRULE(exports.graphNodePath, triple.object);
                });
            }
            const [head, ...tail] = ast.triples;
            printTriple(head);
            for (const triple of tail) {
                F.printFilter(ast, () => {
                    PRINT_WORD(';');
                    NEW_LINE();
                });
                printTriple(triple);
            }
            F.printFilter(ast, () => {
                if (ast.triples.length > 1) {
                    PRINT_ON_OWN_LINE('|}');
                }
                else {
                    PRINT_WORD('|}');
                }
            });
        },
    };
}
/**
 * [[110]](https://www.w3.org/TR/sparql12-query/#rAnnotationBlockPath)
 */
exports.annotationBlockPath = annotationBlockImpl('annotationBlockPath', true);
/**
 * [[112]](https://www.w3.org/TR/sparql12-query/#rAnnotationBlock)
 */
exports.annotationBlock = annotationBlockImpl('annotationBlock', false);
/**
 * OVERRIDING RULE: {@link S11.graphNode}.
 * [[113]](https://www.w3.org/TR/sparql12-query/#rGraphNode)
 */
exports.graphNode = {
    name: 'graphNode',
    impl: $ => C => $.OR2([
        { ALT: () => rules_sparql_1_1_1.gram.graphNode.impl($)(C) },
        { ALT: () => $.SUBRULE(exports.reifiedTriple) },
    ]),
};
/**
 * OVERRIDING RULE: {@link S11.graphNodePath}.
 * [[114]](https://www.w3.org/TR/sparql12-query/#rGraphNodePath)
 */
exports.graphNodePath = {
    name: 'graphNodePath',
    impl: $ => C => $.OR2([
        { ALT: () => rules_sparql_1_1_1.gram.graphNodePath.impl($)(C) },
        { ALT: () => $.SUBRULE(exports.reifiedTriple) },
    ]),
    gImpl: $ => (ast, C) => {
        if (C.astFactory.isTripleCollectionReifiedTriple(ast)) {
            $.SUBRULE(exports.reifiedTriple, ast);
        }
        else {
            rules_sparql_1_1_1.gram.graphNodePath.gImpl($)(ast, C);
        }
    },
};
/**
 * OVERRIDING RULE: {@link S11.varOrTerm}.
 * [[115]](https://www.w3.org/TR/sparql12-query/#rVarOrTerm)
 */
exports.varOrTerm = {
    name: 'varOrTerm',
    impl: ({ ACTION, SUBRULE, OR, CONSUME }) => C => OR([
        { GATE: () => C.parseMode.has('canParseVars'), ALT: () => SUBRULE(rules_sparql_1_1_1.gram.var_) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.iri) },
        { ALT: () => SUBRULE(exports.rdfLiteral) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.numericLiteral) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.booleanLiteral) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.blankNode) },
        { ALT: () => {
                const token = CONSUME(rules_sparql_1_1_1.lex.terminals.nil);
                return ACTION(() => C.astFactory.termNamed(C.astFactory.sourceLocation(token), rules_sparql_1_1_1.CommonIRIs.NIL));
            } },
        { ALT: () => SUBRULE(exports.tripleTerm) },
    ]),
    // Generation remains untouched - go through graphTerm
};
/**
 * [[116]](https://www.w3.org/TR/sparql12-query/#rReifiedTriple)
 */
exports.reifiedTriple = {
    name: 'reifiedTriple',
    impl: ({ ACTION, CONSUME, SUBRULE, OPTION }) => (C) => {
        const open = CONSUME(l12.reificationOpen);
        const subject = SUBRULE(exports.reifiedTripleSubject);
        const predicate = SUBRULE(rules_sparql_1_1_1.gram.verb);
        const object = SUBRULE(exports.reifiedTripleObject);
        const reifierVal = OPTION(() => SUBRULE(exports.reifier));
        const close = CONSUME(l12.reificationClose);
        return ACTION(() => {
            // A reifier would be auto generated in this case, but we are not allowed to use them.
            if (reifierVal === undefined && !C.parseMode.has('canCreateBlankNodes')) {
                throw new Error('Cannot create blanknodes in current parse mode');
            }
            return C.astFactory.tripleCollectionReifiedTriple(C.astFactory.sourceLocation(open, close), subject, predicate, object, reifierVal?.val);
        });
    },
    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => PRINT_WORD('<<'));
        const triple = ast.triples[0];
        SUBRULE(exports.graphNodePath, triple.subject);
        F.printFilter(ast, () => PRINT_WORD(''));
        if (F.isPathPure(triple.predicate)) {
            SUBRULE(rules_sparql_1_1_1.gram.pathGenerator, triple.predicate, undefined);
        }
        else {
            SUBRULE(exports.graphNodePath, triple.predicate);
        }
        F.printFilter(ast, () => PRINT_WORD(''));
        SUBRULE(exports.graphNodePath, triple.object);
        SUBRULE(exports.annotationPath, [F.wrap(ast.identifier, ast.identifier.loc)]);
        F.printFilter(ast, () => PRINT_WORD('>>'));
    },
};
/**
 * [[117]](https://www.w3.org/TR/sparql12-query/#rReifiedTripleSubject)
 */
exports.reifiedTripleSubject = {
    name: 'reifiedTripleSubject',
    impl: ({ OR, SUBRULE }) => C => OR([
        { GATE: () => C.parseMode.has('canParseVars'), ALT: () => SUBRULE(rules_sparql_1_1_1.gram.var_) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.iri) },
        { ALT: () => SUBRULE(exports.rdfLiteral) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.numericLiteral) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.booleanLiteral) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.blankNode) },
        { ALT: () => SUBRULE(exports.reifiedTriple) },
        { ALT: () => SUBRULE(exports.tripleTerm) },
    ]),
};
/**
 * [[118]](https://www.w3.org/TR/sparql12-query/#rReifiedTripleObject)
 */
exports.reifiedTripleObject = {
    name: 'reifiedTripleObject',
    impl: exports.reifiedTripleSubject.impl,
};
/**
 * [[119]](https://www.w3.org/TR/sparql12-query/#rTripleTerm)
 */
exports.tripleTerm = {
    name: 'tripleTerm',
    impl: ({ ACTION, CONSUME, SUBRULE }) => (C) => {
        const open = CONSUME(l12.tripleTermOpen);
        const subject = SUBRULE(exports.tripleTermSubject);
        const predicate = SUBRULE(rules_sparql_1_1_1.gram.verb);
        const object = SUBRULE(exports.tripleTermObject);
        const close = CONSUME(l12.tripleTermClose);
        return ACTION(() => C.astFactory.termTriple(subject, predicate, object, C.astFactory.sourceLocation(open, close)));
    },
    gImpl: ({ SUBRULE, PRINT_WORD }) => (ast, { astFactory: F }) => {
        F.printFilter(ast, () => PRINT_WORD('<<('));
        SUBRULE(exports.graphNodePath, ast.subject);
        F.printFilter(ast, () => PRINT_WORD(''));
        SUBRULE(exports.graphNodePath, ast.predicate);
        F.printFilter(ast, () => PRINT_WORD(''));
        SUBRULE(exports.graphNodePath, ast.object);
        F.printFilter(ast, () => PRINT_WORD(')>>'));
    },
};
/**
 * [[120]](https://www.w3.org/TR/sparql12-query/#rTripleTermSubject)
 */
exports.tripleTermSubject = {
    name: 'tripleTermSubject',
    impl: ({ SUBRULE, OR }) => C => OR([
        { GATE: () => C.parseMode.has('canParseVars'), ALT: () => SUBRULE(rules_sparql_1_1_1.gram.var_) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.iri) },
        { ALT: () => SUBRULE(exports.rdfLiteral) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.numericLiteral) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.booleanLiteral) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.blankNode) },
        { ALT: () => SUBRULE(exports.tripleTerm) },
    ]),
};
/**
 * [[121]](https://www.w3.org/TR/sparql12-query/#rTripleTermObject)
 */
exports.tripleTermObject = {
    name: 'tripleTermObject',
    impl: exports.tripleTermSubject.impl,
};
/**
 * [[122]](https://www.w3.org/TR/sparql12-query/#rTripleTermData)
 */
exports.tripleTermData = {
    name: 'tripleTermData',
    impl: ({ ACTION, CONSUME, OR, SUBRULE }) => (C) => {
        const open = CONSUME(l12.tripleTermOpen);
        const subject = SUBRULE(exports.tripleTermDataSubject);
        const predicate = OR([
            { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.iri) },
            { ALT: () => {
                    const token = CONSUME(rules_sparql_1_1_1.lex.a);
                    return ACTION(() => C.astFactory.termNamed(C.astFactory.sourceLocation(token), rules_sparql_1_1_1.CommonIRIs.TYPE));
                } },
        ]);
        const object = SUBRULE(exports.tripleTermDataObject);
        const close = CONSUME(l12.tripleTermClose);
        return ACTION(() => C.astFactory.termTriple(subject, predicate, object, C.astFactory.sourceLocation(open, close)));
    },
};
/**
 * [[123]](https://www.w3.org/TR/sparql12-query/#rTripleTermDataSubject)
 */
exports.tripleTermDataSubject = {
    name: 'tripleTermDataSubject',
    impl: ({ OR, SUBRULE }) => () => OR([
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.iri) },
    ]),
};
/**
 * [[124]](https://www.w3.org/TR/sparql12-query/#rTripleTermDataObject)
 */
exports.tripleTermDataObject = {
    name: 'tripleTermDataObject',
    impl: ({ OR, SUBRULE }) => () => OR([
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.iri) },
        { ALT: () => SUBRULE(exports.rdfLiteral) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.numericLiteral) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.booleanLiteral) },
        { ALT: () => SUBRULE(exports.tripleTermData) },
    ]),
};
/**
 * OVERRIDING RULE: {@link S11.primaryExpression}.
 * [[136]](https://www.w3.org/TR/sparql12-query/#rPrimaryExpression)
 */
exports.primaryExpression = {
    name: 'primaryExpression',
    impl: $ => C => $.OR2([
        { ALT: () => rules_sparql_1_1_1.gram.primaryExpression.impl($)(C) },
        { ALT: () => $.SUBRULE(exports.exprTripleTerm) },
    ]),
};
/**
 * [[137]](https://www.w3.org/TR/sparql12-query/#rExprTripleTerm)
 */
exports.exprTripleTerm = {
    name: 'exprTripleTerm',
    impl: ({ ACTION, CONSUME, SUBRULE }) => (C) => {
        const open = CONSUME(l12.tripleTermOpen);
        const subject = SUBRULE(exports.exprTripleTermSubject);
        const predicate = SUBRULE(rules_sparql_1_1_1.gram.verb);
        const object = SUBRULE(exports.exprTripleTermObject);
        const close = CONSUME(l12.tripleTermClose);
        return ACTION(() => C.astFactory.termTriple(subject, predicate, object, C.astFactory.sourceLocation(open, close)));
    },
};
/**
 * [[138]](https://www.w3.org/TR/sparql12-query/#rExprTripleTermSubject)
 */
exports.exprTripleTermSubject = {
    name: 'exprTripleTermSubject',
    impl: ({ OR, SUBRULE }) => C => OR([
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.iri) },
        { GATE: () => C.parseMode.has('canParseVars'), ALT: () => SUBRULE(rules_sparql_1_1_1.gram.var_) },
    ]),
};
/**
 * [[139]](https://www.w3.org/TR/sparql12-query/#rExprTripleTermObject)
 */
exports.exprTripleTermObject = {
    name: 'exprTripleTermObject',
    impl: ({ OR, SUBRULE }) => C => OR([
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.iri) },
        { ALT: () => SUBRULE(exports.rdfLiteral) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.numericLiteral) },
        { ALT: () => SUBRULE(rules_sparql_1_1_1.gram.booleanLiteral) },
        { GATE: () => C.parseMode.has('canParseVars'), ALT: () => SUBRULE(rules_sparql_1_1_1.gram.var_) },
        { ALT: () => SUBRULE(exports.exprTripleTerm) },
    ]),
};
exports.buildInLangDir = (0, rules_sparql_1_1_1.funcExpr1)(l12.buildInLangDir);
exports.buildInLangStrDir = (0, rules_sparql_1_1_1.funcExpr3)(l12.buildInStrLangDir);
exports.buildInHasLang = (0, rules_sparql_1_1_1.funcExpr1)(l12.buildInHasLang);
exports.buildInHasLangDir = (0, rules_sparql_1_1_1.funcExpr1)(l12.buildInHasLangDir);
exports.buildInIsTriple = (0, rules_sparql_1_1_1.funcExpr1)(l12.buildInIsTRIPLE);
exports.buildInTriple = (0, rules_sparql_1_1_1.funcExpr3)(l12.buildInTRIPLE);
exports.buildInSubject = (0, rules_sparql_1_1_1.funcExpr1)(l12.buildInSUBJECT);
exports.buildInPredicate = (0, rules_sparql_1_1_1.funcExpr1)(l12.buildInPREDICATE);
exports.buildInObject = (0, rules_sparql_1_1_1.funcExpr1)(l12.buildInOBJECT);
/**
 * OVERRIDING RULE: {@link S11.builtInCall}.
 * [[141]](https://www.w3.org/TR/sparql12-query/#rBuiltInCall)
 */
exports.builtInCall = {
    name: 'builtInCall',
    impl: $ => C => $.OR2([
        { ALT: () => rules_sparql_1_1_1.gram.builtInCall.impl($)(C) },
        { ALT: () => $.SUBRULE(exports.buildInLangDir) },
        { ALT: () => $.SUBRULE(exports.buildInLangStrDir) },
        { ALT: () => $.SUBRULE(exports.buildInHasLang) },
        { ALT: () => $.SUBRULE(exports.buildInHasLangDir) },
        { ALT: () => $.SUBRULE(exports.buildInIsTriple) },
        { ALT: () => $.SUBRULE(exports.buildInTriple) },
        { ALT: () => $.SUBRULE(exports.buildInSubject) },
        { ALT: () => $.SUBRULE(exports.buildInPredicate) },
        { ALT: () => $.SUBRULE(exports.buildInObject) },
    ]),
};
/**
 * OVERRIDING RULE: {@link S11.rdfLiteral}.
 * No retyping is needed since the return type is the same
 * [[149]](https://www.w3.org/TR/sparql12-query/#rRDFLiteral)
 */
exports.rdfLiteral = {
    name: 'rdfLiteral',
    impl: ({ ACTION, SUBRULE, OPTION, CONSUME, OR }) => (C) => {
        const value = SUBRULE(rules_sparql_1_1_1.gram.string);
        return OPTION(() => OR([
            { ALT: () => {
                    const langTag = CONSUME(l12.LANG_DIR);
                    return ACTION(() => {
                        const literal = C.astFactory.termLiteral(C.astFactory.sourceLocation(value, langTag), value.value, langTag.image.slice(1).toLowerCase());
                        (0, validators_js_1.langTagHasCorrectRange)(literal);
                        return literal;
                    });
                } },
            { ALT: () => {
                    CONSUME(rules_sparql_1_1_1.lex.symbols.hathat);
                    const iriVal = SUBRULE(rules_sparql_1_1_1.gram.iri);
                    return ACTION(() => C.astFactory.termLiteral(C.astFactory.sourceLocation(value, iriVal), value.value, iriVal));
                } },
        ])) ?? value;
    },
};
exports.unaryExpression = {
    name: 'unaryExpression',
    impl: ({ ACTION, CONSUME, SUBRULE1, SUBRULE2, OR1, OR2 }) => C => OR1([
        { ALT: () => SUBRULE1(exports.primaryExpression) },
        { ALT: () => {
                const operator = CONSUME(rules_sparql_1_1_1.lex.symbols.exclamation);
                const expr = SUBRULE1(exports.unaryExpression);
                return ACTION(() => C.astFactory.expressionOperation('!', [expr], C.astFactory.sourceLocation(operator, expr)));
            } },
        { ALT: () => {
                const operator = OR2([
                    { ALT: () => CONSUME(rules_sparql_1_1_1.lex.symbols.opPlus) },
                    { ALT: () => CONSUME(rules_sparql_1_1_1.lex.symbols.opMinus) },
                ]);
                const expr = SUBRULE2(exports.primaryExpression);
                return ACTION(() => C.astFactory.expressionOperation(operator.image === '!' ? '!' : (operator.image === '+' ? 'UPLUS' : 'UMINUS'), [expr], C.astFactory.sourceLocation(operator, expr)));
            } },
    ]),
};
/**
 * OVERRIDING RULE: {@link S11.triplesBlock}.
 */
exports.generateTriplesBlock = {
    name: 'triplesBlock',
    gImpl: ({ SUBRULE, PRINT_WORD, NEW_LINE, HANDLE_LOC }) => (ast, { astFactory: F }) => {
        for (const [index, triple] of ast.triples.entries()) {
            HANDLE_LOC(triple, () => {
                const nextTriple = ast.triples.at(index + 1);
                if (F.isTripleCollection(triple)) {
                    SUBRULE(exports.graphNodePath, triple);
                    // A top level tripleCollection block means that it is either not used in a triple
                    //   - or is the subject of a triple. In case it is the subject,
                    //   the identifier of the block will be the subject of the next triple and that subject is not materialized.
                    const isSubjectOfTriple = nextTriple?.type === 'triple' &&
                        F.isSourceLocationNoMaterialize(nextTriple.subject.loc);
                    if (!isSubjectOfTriple) {
                        F.printFilter(triple, () => {
                            PRINT_WORD('.');
                            NEW_LINE();
                        });
                    }
                }
                else {
                    // Subject
                    SUBRULE(exports.graphNodePath, triple.subject);
                    F.printFilter(ast, () => PRINT_WORD(''));
                    // Predicate
                    if (F.isPathPure(triple.predicate)) {
                        SUBRULE(rules_sparql_1_1_1.gram.pathGenerator, triple.predicate, undefined);
                    }
                    else {
                        SUBRULE(exports.graphNodePath, triple.predicate);
                    }
                    F.printFilter(ast, () => PRINT_WORD(''));
                    // Object
                    SUBRULE(exports.graphNodePath, triple.object);
                    SUBRULE(exports.annotationPath, triple.annotations ?? []);
                    // If no more things, or a top level collection (only possible if new block was part), or new subject: add DOT
                    if (nextTriple === undefined || F.isTripleCollection(nextTriple) ||
                        !F.isSourceLocationNoMaterialize(nextTriple.subject.loc)) {
                        F.printFilter(ast, () => {
                            PRINT_WORD('.');
                            NEW_LINE();
                        });
                    }
                    else if (F.isSourceLocationNoMaterialize(nextTriple.predicate.loc)) {
                        F.printFilter(ast, () => PRINT_WORD(','));
                    }
                    else {
                        F.printFilter(ast, () => {
                            PRINT_WORD(';');
                            NEW_LINE();
                        });
                    }
                }
            });
        }
    },
};
/**
 * OVERRIDING RULE: {@link S11.graphTerm}.
 * No retyping is needed since the return type is the same
 * [[149]](https://www.w3.org/TR/sparql12-query/#rRDFLiteral)
 */
exports.generateGraphTerm = {
    name: 'graphTerm',
    gImpl: $ => (ast, C) => {
        if (C.astFactory.isTermTriple(ast)) {
            $.SUBRULE(exports.tripleTerm, ast);
        }
        else {
            rules_sparql_1_1_1.gram.graphTerm.gImpl($)(ast, C);
        }
    },
};
//# sourceMappingURL=grammar.js.map