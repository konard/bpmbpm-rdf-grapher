"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndirBuilder = void 0;
const dynamicIndirected_js_1 = require("./dynamicIndirected.js");
const helpers_js_1 = require("./helpers.js");
class IndirBuilder {
    static create(start) {
        if (Array.isArray(start)) {
            return new IndirBuilder((0, helpers_js_1.listToIndirectionMap)(start));
        }
        return new IndirBuilder({ ...start.rules });
    }
    rules;
    constructor(startRules) {
        this.rules = startRules;
    }
    widenContext() {
        return this;
    }
    typePatch() {
        return this;
    }
    /**
     * Change the implementation of an existing indirection.
     */
    patchRule(patch) {
        const self = this;
        self.rules[patch.name] = patch;
        return self;
    }
    /**
     * Add an indirection function. If the rule already exists, but the implementation differs, an error will be thrown.
     */
    addRuleRedundant(rule) {
        const self = this;
        const rules = self.rules;
        if (rules[rule.name] !== undefined && rules[rule.name] !== rule) {
            throw new Error(`Function ${rule.name} already exists in the builder`);
        }
        rules[rule.name] = rule;
        return self;
    }
    /**
     * Add a rule to the grammar. Will raise a typescript error if the rule already exists in the grammar.
     */
    addRule(rule) {
        return this.addRuleRedundant(rule);
    }
    addMany(...rules) {
        this.rules = { ...this.rules, ...(0, helpers_js_1.listToIndirectionMap)(rules) };
        return this;
    }
    /**
     * Delete a grammar rule by its name.
     */
    deleteRule(ruleName) {
        delete this.rules[ruleName];
        return this;
    }
    getRule(ruleName) {
        return this.rules[ruleName];
    }
    build() {
        return new dynamicIndirected_js_1.DynamicIndirect(this.rules);
    }
}
exports.IndirBuilder = IndirBuilder;
//# sourceMappingURL=IndirBuilder.js.map