{"version":3,"file":"AstCoreFactory.js","sourceRoot":"","sources":["../../../lib/AstCoreFactory.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IToken } from '@traqula/chevrotain';\n\nimport type {\n  SourceLocation,\n  SourceLocationNodeAutoGenerate,\n  SourceLocationNodeReplace,\n  SourceLocationNoMaterialize,\n  SourceLocationSource,\n  SourceLocationStringReplace,\n  Node,\n  Localized,\n  Wrap,\n  Typed,\n  SubTyped,\n  SourceLocationInlinedSource,\n} from './types.js';\n\nexport interface AstCoreFactoryArgs {\n  /**\n   * Whether the AstFactory can track sources, if not, the sourceLocation function returns autoGen. Default true\n   */\n  tracksSourceLocation: boolean;\n}\n\nexport class AstCoreFactory implements AstCoreFactoryArgs {\n  public tracksSourceLocation: boolean;\n  public constructor(args: Partial<AstCoreFactoryArgs> = {}) {\n    this.tracksSourceLocation = args.tracksSourceLocation ?? true;\n  }\n\n  public wrap<T>(val: T, loc: SourceLocation): Wrap<T> {\n    return { val, loc };\n  }\n\n  public isLocalized(obj: unknown): obj is Localized {\n    return typeof obj === 'object' && obj !== null && 'loc' in obj &&\n      typeof obj.loc === 'object' && obj.loc !== null && 'sourceLocationType' in obj.loc;\n  }\n\n  public sourceLocation(...elements: (undefined | IToken | Localized)[]): SourceLocation {\n    if (!this.tracksSourceLocation) {\n      return this.gen();\n    }\n\n    const pureElements = elements.filter(x => x !== undefined);\n    if (pureElements.length === 0) {\n      return this.sourceLocationNoMaterialize();\n    }\n\n    const filtered = pureElements.filter(element =>\n      !this.isLocalized(element) || this.isSourceLocationSource(element.loc) ||\n      this.isSourceLocationStringReplace(element.loc) || this.isSourceLocationNodeReplace(element.loc));\n    if (filtered.length === 0) {\n      return this.gen();\n    }\n    const first = filtered.at(0)!;\n    const last = filtered.at(-1)!;\n    return {\n      sourceLocationType: 'source',\n      start: this.isLocalized(first) ?\n          (<SourceLocationSource | SourceLocationStringReplace> first.loc).start :\n        first.startOffset,\n      end: this.isLocalized(last) ?\n          (<SourceLocationSource | SourceLocationStringReplace> last.loc).end :\n          (last.endOffset! + 1),\n    };\n  }\n\n  public sourceLocationNoMaterialize(): SourceLocation {\n    if (!this.tracksSourceLocation) {\n      return this.gen();\n    }\n    return { sourceLocationType: 'noMaterialize' };\n  }\n\n  /**\n   * Returns a copy of the argument that is not materialized\n   */\n  public dematerialized<T extends Node>(arg: T): T {\n    return { ...arg, loc: this.sourceLocationNoMaterialize() };\n  }\n\n  public safeObjectTransform(value: unknown, mapper: (some: object) => any): any {\n    if (value && typeof value === 'object') {\n      // If you wonder why this is all so hard, this is the reason. We cannot lose the methods of our Array objects\n      if (Array.isArray(value)) {\n        return value.map(x => this.safeObjectTransform(x, mapper));\n      }\n      return mapper(value);\n    }\n    return value;\n  }\n\n  public forcedAutoGenTree<T extends object>(obj: T): T {\n    const copy = { ...obj };\n    for (const [ key, value ] of Object.entries(copy)) {\n      (<Record<string, object>> copy)[key] = this.safeObjectTransform(value, obj => this.forcedAutoGenTree(obj));\n    }\n    if (this.isLocalized(copy)) {\n      copy.loc = this.gen();\n    }\n    return copy;\n  }\n\n  public forceMaterialized<T extends Node>(arg: T): T {\n    if (this.isSourceLocationNoMaterialize(arg.loc)) {\n      return this.forcedAutoGenTree(arg);\n    }\n    return { ...arg };\n  }\n\n  public isSourceLocation(loc: object): loc is SourceLocation {\n    return 'sourceLocationType' in loc;\n  }\n\n  public sourceLocationSource(start: number, end: number): SourceLocationSource {\n    return {\n      sourceLocationType: 'source',\n      start,\n      end,\n    };\n  }\n\n  /**\n   * {@inheritDoc SourceLocationInlinedSource}\n   */\n  public sourceLocationInlinedSource(\n    newSource: string,\n    subLoc: SourceLocation,\n    start: number,\n    end: number,\n    startOnNew = 0,\n    endOnNew: number = newSource.length,\n  ): SourceLocation {\n    if (!this.tracksSourceLocation) {\n      return this.gen();\n    }\n    if (this.isSourceLocationSource(subLoc)) {\n      startOnNew = subLoc.start;\n      endOnNew = subLoc.end;\n    }\n    return {\n      sourceLocationType: 'inlinedSource',\n      newSource,\n      start,\n      end,\n      loc: subLoc,\n      startOnNew,\n      endOnNew,\n    }satisfies SourceLocationInlinedSource;\n  };\n\n  public isSourceLocationInlinedSource(loc: object): loc is SourceLocationInlinedSource {\n    return this.isSourceLocation(loc) && loc.sourceLocationType === 'inlinedSource';\n  }\n\n  public gen(): SourceLocationNodeAutoGenerate {\n    return { sourceLocationType: 'autoGenerate' };\n  }\n\n  public isSourceLocationSource(loc: object): loc is SourceLocationSource {\n    return this.isSourceLocation(loc) && loc.sourceLocationType === 'source';\n  }\n\n  public sourceLocationStringReplace(newSource: string, start: number, end: number): SourceLocation {\n    if (!this.tracksSourceLocation) {\n      return this.gen();\n    }\n    return { sourceLocationType: 'stringReplace', newSource, start, end } satisfies SourceLocationStringReplace;\n  }\n\n  public isSourceLocationStringReplace(loc: object): loc is SourceLocationStringReplace {\n    return this.isSourceLocation(loc) && loc.sourceLocationType === 'stringReplace';\n  }\n\n  public sourceLocationNodeReplaceUnsafe(loc: SourceLocation): SourceLocationNodeReplace {\n    if (this.isSourceLocationSource(loc)) {\n      return this.sourceLocationNodeReplace(loc);\n    }\n    if (this.isSourceLocationInlinedSource(loc)) {\n      return this.sourceLocationNodeReplaceUnsafe(loc.loc);\n    }\n    throw new Error(`Cannot convert SourceLocation of type ${loc.sourceLocationType} to SourceLocationNodeReplace`);\n  }\n\n  public sourceLocationNodeReplace(location: SourceLocationSource): SourceLocationNodeReplace;\n  public sourceLocationNodeReplace(start: number, end: number): SourceLocationNodeReplace;\n  public sourceLocationNodeReplace(startOrLoc: number | SourceLocationSource, end?: number): SourceLocationNodeReplace {\n    let starting;\n    let ending;\n    if (typeof startOrLoc === 'number') {\n      starting = startOrLoc;\n      ending = end!;\n    } else {\n      starting = startOrLoc.start;\n      ending = startOrLoc.end;\n    }\n    return {\n      sourceLocationType: 'nodeReplace',\n      start: starting,\n      end: ending,\n    };\n  }\n\n  public isSourceLocationNodeReplace(loc: object): loc is SourceLocationNodeReplace {\n    return this.isSourceLocation(loc) && loc.sourceLocationType === 'nodeReplace';\n  }\n\n  public isSourceLocationNodeAutoGenerate(loc: object): loc is SourceLocationNodeAutoGenerate {\n    return this.isSourceLocation(loc) && loc.sourceLocationType === 'autoGenerate';\n  }\n\n  public isPrintingLoc(loc: SourceLocation): boolean {\n    return this.isSourceLocationNodeReplace(loc) ||\n      this.isSourceLocationNodeAutoGenerate(loc) ||\n      (this.isSourceLocationInlinedSource(loc) && this.isPrintingLoc(loc.loc));\n  }\n\n  public printFilter(node: Localized, callback: () => void): void {\n    if (this.isPrintingLoc(node.loc)) {\n      callback();\n    }\n  }\n\n  public isSourceLocationNoMaterialize(loc: object): loc is SourceLocationNoMaterialize {\n    return this.isSourceLocation(loc) && loc.sourceLocationType === 'noMaterialize';\n  }\n\n  public isOfType<Type extends string>(obj: object, type: Type): obj is Typed<Type> {\n    const casted: { type?: any } = obj;\n    return casted.type === type;\n  }\n\n  public isOfSubType<Type extends string, SubType extends string>(obj: object, type: Type, subType: SubType):\n    obj is SubTyped<Type, SubType> {\n    const temp: { type?: unknown; subType?: unknown } = obj;\n    return temp.type === type && temp.subType === subType;\n  }\n}\n"]}