"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DynamicGenerator = void 0;
const AstCoreFactory_js_1 = require("../AstCoreFactory.js");
const utils_js_1 = require("../utils.js");
class DynamicGenerator {
    rules;
    factory = new AstCoreFactory_js_1.AstCoreFactory();
    __context = undefined;
    origSource = '';
    handledInlineSource;
    generatedUntil = 0;
    toEnsure = [];
    /**
     * Should not contain empty strings
     * @protected
     */
    stringBuilder = [];
    constructor(rules) {
        this.rules = rules;
        // eslint-disable-next-line ts/no-unnecessary-type-assertion
        for (const rule of Object.values(rules)) {
            // Define function implementation
            this[rule.name] =
                ((input, context, args) => {
                    this.stringBuilder.length = 0;
                    this.origSource = context.origSource;
                    this.generatedUntil = context?.offset ?? 0;
                    this.setContext(context);
                    this.subrule(rule, input, args);
                    this.catchup(this.origSource.length);
                    return this.stringBuilder.join('');
                });
        }
    }
    setContext(context) {
        this.__context = context;
    }
    getSafeContext() {
        return this.__context;
    }
    subrule = (cstDef, ast, ...arg) => {
        const def = this.rules[cstDef.name];
        if (!def) {
            throw new Error(`Rule ${cstDef.name} not found`);
        }
        const generate = () => def.gImpl({
            SUBRULE: this.subrule,
            PRINT: this.print,
            ENSURE: this.ensure,
            ENSURE_EITHER: this.ensureEither,
            NEW_LINE: this.newLine,
            HANDLE_LOC: this.handleLoc,
            CATCHUP: this.catchup,
            PRINT_WORD: this.printWord,
            PRINT_WORDS: this.printWords,
            PRINT_ON_EMPTY: this.printOnEmpty,
            PRINT_ON_OWN_LINE: this.printOnOwnLine,
        })(ast, this.getSafeContext(), ...arg);
        if (this.factory.isLocalized(ast)) {
            this.handleLoc(ast, generate);
        }
        else {
            generate();
        }
    };
    handleLoc = (localized, handle) => {
        if (this.factory.isSourceLocationNoMaterialize(localized.loc)) {
            return;
        }
        if (this.factory.isSourceLocationStringReplace(localized.loc)) {
            this.catchup(localized.loc.start);
            this.print(localized.loc.newSource);
            this.generatedUntil = localized.loc.end;
            return;
        }
        if (this.factory.isSourceLocationNodeReplace(localized.loc)) {
            this.catchup(localized.loc.start);
            this.generatedUntil = localized.loc.end;
        }
        if (this.factory.isSourceLocationSource(localized.loc)) {
            this.catchup(localized.loc.start);
        }
        if (this.factory.isSourceLocationInlinedSource(localized.loc) && this.handledInlineSource !== localized.loc) {
            // Calling handleLoc on the same AST multiple times should be the same as doing it once.
            this.handledInlineSource = localized.loc;
            this.catchup(localized.loc.start);
            const origSource = this.origSource;
            const origPointer = this.generatedUntil;
            this.origSource = localized.loc.newSource;
            this.generatedUntil = 0;
            this.catchup(localized.loc.startOnNew);
            this.handleLoc(localized.loc, handle);
            this.generatedUntil = localized.loc.endOnNew;
            this.catchup(this.origSource.length);
            this.origSource = origSource;
            this.generatedUntil = Math.max(origPointer, localized.loc.end);
            return;
        }
        // If autoGenerate - do nothing
        const ret = handle();
        if (this.factory.isSourceLocationSource(localized.loc)) {
            this.catchup(localized.loc.end);
        }
        return ret;
    };
    /**
     * Catchup until, excluding
     */
    catchup = (until) => {
        const start = this.generatedUntil;
        if (start < until) {
            this.print(this.origSource.slice(start, until));
        }
        this.generatedUntil = Math.max(this.generatedUntil, until);
    };
    handeEnsured(toPrint) {
        for (const callBack of this.toEnsure) {
            callBack(toPrint);
        }
        this.toEnsure.length = 0;
    }
    print = (...args) => {
        const joined = args.join('');
        this.handeEnsured(joined);
        this.stringBuilder.push(joined);
    };
    doesEndWith(subsStr) {
        const len = subsStr.length;
        let temp = '';
        while (temp.length < len && this.stringBuilder.length > 0) {
            temp = this.stringBuilder.pop() + temp;
        }
        this.stringBuilder.push(temp);
        return temp.endsWith(subsStr);
    }
    ensure = (...args) => {
        // Check whether already present
        const toEnsure = args.join('');
        if (!this.doesEndWith(toEnsure)) {
            this.toEnsure.push((willPrint) => {
                if (!willPrint.startsWith(toEnsure) && !this.doesEndWith(toEnsure)) {
                    this.stringBuilder.push(toEnsure);
                }
            });
        }
    };
    ensureEither = (...args) => {
        if (args.length === 1) {
            this.ensure(...args);
        }
        else if (args.length > 1 &&
            // Not already matched?
            !args.some(subStr => this.doesEndWith(subStr))) {
            this.toEnsure.push((willPrint) => {
                if (!args.some(subStr => willPrint.startsWith(subStr)) && !args.some(subStr => this.doesEndWith(subStr))) {
                    this.stringBuilder.push(args[0]);
                }
            });
        }
    };
    pruneEndingBlanks() {
        let temp = '';
        while (/^[ \t]*$/u.test(temp) && this.stringBuilder.length > 0) {
            temp = this.stringBuilder.pop() + temp;
        }
        this.print(temp.trimEnd());
    }
    newLine = (arg) => {
        const indentation = this.getSafeContext()[utils_js_1.traqulaIndentation] ?? 0;
        const force = arg?.force ?? false;
        if (indentation < 0) {
            const newlineAlternative = this.getSafeContext()[utils_js_1.traqulaNewlineAlternative];
            if (newlineAlternative !== undefined &&
                // If we force, it means we would print \n no matter. - otherwise check whether we have printed the char
                (force || (this.stringBuilder.at(-1) !== newlineAlternative))) {
                this.print(newlineAlternative);
            }
            return;
        }
        this.pruneEndingBlanks();
        if (force) {
            this.print('\n', ' '.repeat(indentation));
        }
        else {
            let temp = '';
            while (!temp.includes('\n') && this.stringBuilder.length > 0) {
                temp = this.stringBuilder.pop() + temp;
            }
            if (/\n[ \t]*$/u.test(temp)) {
                // Pointer is on empty newline -> set correct indentation
                temp = temp.replace(/\n[ \t]*$/u, `\n${' '.repeat(indentation)}`);
                this.print(temp);
            }
            else {
                // Pointer not on empty newline, print newline.
                this.print(temp, '\n', ' '.repeat(indentation));
            }
        }
    };
    printWord = (...args) => {
        this.ensureEither(' ', '\n');
        this.print(...args);
        this.ensureEither(' ', '\n');
    };
    printWords = (...args) => {
        for (const arg of args) {
            this.printWord(arg);
        }
    };
    printOnEmpty = (...args) => {
        this.newLine();
        this.print(...args);
    };
    printOnOwnLine = (...args) => {
        this.newLine();
        this.print(...args);
        this.newLine();
    };
}
exports.DynamicGenerator = DynamicGenerator;
//# sourceMappingURL=dynamicGenerator.js.map