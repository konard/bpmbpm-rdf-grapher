"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorBuilder = void 0;
const dynamicGenerator_js_1 = require("./dynamicGenerator.js");
/**
 * Converts a list of ruledefs to a record mapping a name to the corresponding ruledef.
 */
function listToRuleDefMap(rules) {
    const newRules = {};
    for (const rule of rules) {
        newRules[rule.name] = rule;
    }
    return newRules;
}
class GeneratorBuilder {
    static create(start) {
        if (Array.isArray(start)) {
            return new GeneratorBuilder(listToRuleDefMap(start));
        }
        return new GeneratorBuilder({ ...start.rules });
    }
    rules;
    constructor(startRules) {
        this.rules = startRules;
    }
    widenContext() {
        return this;
    }
    typePatch() {
        return this;
    }
    /**
     * Change the implementation of an existing generator rule.
     */
    patchRule(patch) {
        const self = this;
        self.rules[patch.name] = patch;
        return self;
    }
    /**
     * Add a rule to the grammar. If the rule already exists, but the implementation differs, an error will be thrown.
     */
    addRuleRedundant(rule) {
        const self = this;
        const rules = self.rules;
        if (rules[rule.name] !== undefined && rules[rule.name] !== rule) {
            throw new Error(`Rule ${rule.name} already exists in the GeneratorBuilder`);
        }
        rules[rule.name] = rule;
        return self;
    }
    /**
     * Add a rule to the grammar. Will raise a typescript error if the rule already exists in the grammar.
     */
    addRule(rule) {
        return this.addRuleRedundant(rule);
    }
    addMany(...rules) {
        this.rules = { ...this.rules, ...listToRuleDefMap(rules) };
        return this;
    }
    /**
     * Delete a grammar rule by its name.
     */
    deleteRule(ruleName) {
        delete this.rules[ruleName];
        return this;
    }
    getRule(ruleName) {
        return this.rules[ruleName];
    }
    /**
     * Merge this grammar GeneratorBuilder with another.
     * It is best to merge the bigger grammar with the smaller one.
     * If the two builders both have a grammar rule with the same name,
     * no error will be thrown case they map to the same ruledef object.
     * If they map to a different object, an error will be thrown.
     * To fix this problem, the overridingRules array should contain a rule with the same conflicting name,
     * this rule implementation will be used.
     */
    merge(GeneratorBuilder, overridingRules) {
        // Assume the other grammar is bigger than yours. So start from that one and add this one
        const otherRules = { ...GeneratorBuilder.rules };
        const myRules = this.rules;
        for (const rule of Object.values(myRules)) {
            if (otherRules[rule.name] === undefined) {
                otherRules[rule.name] = rule;
            }
            else {
                const existingRule = otherRules[rule.name];
                // If same rule, no issue, move on. Else
                if (existingRule !== rule) {
                    const override = overridingRules.find(x => x.name === rule.name);
                    // If override specified, take override, else, inform user that there is a conflict
                    if (override) {
                        otherRules[rule.name] = override;
                    }
                    else {
                        throw new Error(`Rule with name "${rule.name}" already exists in the GeneratorBuilder, specify an override to resolve conflict`);
                    }
                }
            }
        }
        this.rules = otherRules;
        return this;
    }
    build() {
        return new dynamicGenerator_js_1.DynamicGenerator(this.rules);
    }
}
exports.GeneratorBuilder = GeneratorBuilder;
//# sourceMappingURL=generatorBuilder.js.map