{"version":3,"file":"TransformerObject.js","sourceRoot":"","sources":["../../../../lib/transformers/TransformerObject.ts"],"names":[],"mappings":"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","sourcesContent":["export interface VisitContext {\n  /**\n   * Whether you should stop iterating after this object. Default false.\n   */\n  shortcut?: boolean;\n  /**\n   * Whether you should continue iterating deeper with this object. Default true.\n   */\n  continue?: boolean;\n  /**\n   * Object keys that can be ignored, meaning they do not get visited.\n   */\n  ignoreKeys?: Set<string>;\n}\n\nexport interface TransformContext extends VisitContext {\n  /**\n   * Object keys that will be shallowly copied but not traversed.\n   * When the same key is included here and in ignoreKeys, the copy will still be made.\n   */\n  shallowKeys?: Set<string>;\n  /**\n   * Whether the visited object should be shallowly copied or not. Defaults to true.\n   */\n  copy?: boolean;\n}\n\nexport interface SelectiveTraversalContext<Nodes> {\n  /**\n   * Nodes you should visit next. Defaults to empty list\n   */\n  next?: Nodes[];\n  /**\n   * Whether you should stop visiting after visiting this object. Default false.\n   */\n  shortcut?: boolean;\n}\n\nexport class TransformerObject {\n  protected maxStackSize = 1_000_000;\n  /**\n   * Creates stateless transformer.\n   * @param defaultContext\n   */\n  public constructor(protected readonly defaultContext: TransformContext = {}) {}\n\n  public clone(newDefaultContext: TransformContext = {}): TransformerObject {\n    return new TransformerObject({ ...this.defaultContext, ...newDefaultContext });\n  }\n\n  /**\n   * Function to shallow clone any type.\n   * @param obj\n   * @protected\n   */\n  public cloneObj<T>(obj: T): T {\n    if (obj === null || typeof obj !== 'object') {\n      return obj;\n    }\n\n    const proto = Object.getPrototypeOf(obj);\n\n    // Fast path: plain object\n    if (proto === Object.prototype || proto === null) {\n      // Spread or assign preserves fast properties\n      return { ...obj };\n    }\n\n    // Otherwise, preserve prototype for custom objects\n    return Object.assign(Object.create(proto), obj);\n  }\n\n  /**\n   * Recursively transforms all objects that are not arrays. Mapper is called on deeper objects first.\n   * @param startObject object to start iterating from\n   * @param mapper mapper to transform the various objects - argument is a copy of the original\n   * @param preVisitor callback that is evaluated before iterating deeper.\n   *   If continues is false, we do not iterate deeper, current object is still mapped. - default: true\n   *   If shortcut is true, we do not iterate deeper, nor do we branch out, this mapper will be the last one called.\n   *    - Default false\n   */\n  public transformObject(\n    startObject: object,\n    mapper: (copy: object, orig: object) => unknown,\n    preVisitor: (orig: object) => TransformContext = () => ({}),\n  ): unknown {\n    const defaults = this.defaultContext;\n    const defaultCopyFlag = defaults.copy ?? true;\n    const defaultContinues = defaults.continue ?? true;\n    const defaultIgnoreKeys = defaults.ignoreKeys;\n    const defaultShallowKeys = defaults.shallowKeys;\n    const defaultDidShortCut = defaults.shortcut ?? false;\n\n    // Code handles own stack instead of using recursion - this optimizes it for deep operations.\n    let didShortCut = false;\n    const resultWrap = { res: startObject };\n\n    // Grows with stack\n    const stack = [ startObject ];\n    const stackParent: object[] = [ resultWrap ];\n    const stackParentKey: string[] = [ 'res' ];\n\n    // Grows with reverse stack - when popping down the stack, you realise you still want to map something.\n    // Counter of stack size when we started adding the children of this object, going beyond this means a new parent\n    const handleMapperOnLen: number[] = [];\n    const mapperCopyStack: object[] = [];\n    const mapperOrigStack: object[] = [];\n    const mapperParent: object[] = [];\n    const mapperParentKey: string[] = [];\n\n    function handleMapper(): void {\n      while (stack.length === handleMapperOnLen.at(-1)) {\n        handleMapperOnLen.pop();\n        const copyToMap = mapperCopyStack.pop()!;\n        const origToMap = mapperOrigStack.pop()!;\n        const parent = <Record<string, unknown>> mapperParent.pop()!;\n        const parentKey = mapperParentKey.pop()!;\n        parent[parentKey] = mapper(copyToMap, origToMap);\n      }\n    }\n\n    while (stack.length > 0 && stack.length < this.maxStackSize) {\n      const curObject = stack.pop()!;\n      const curParent = stackParent.pop()!;\n      const curKey = stackParentKey.pop()!;\n\n      // Only add to the stack when you did not shortcut\n      if (!didShortCut) {\n        if (Array.isArray(curObject)) {\n          const newArr = [ ...curObject ];\n          handleMapperOnLen.push(stack.length);\n          mapperCopyStack.push(newArr);\n          mapperOrigStack.push(curObject);\n          mapperParent.push(curParent);\n          mapperParentKey.push(curKey);\n\n          for (let index = curObject.length - 1; index >= 0; index--) {\n            const val = curObject[index];\n            if (val !== null && typeof val === 'object') {\n              stack.push(val);\n              stackParent.push(newArr);\n              stackParentKey.push(index.toString());\n            }\n          }\n          handleMapper();\n          continue;\n        }\n\n        // Perform pre visit before expanding the stack\n        const context = preVisitor(<any>curObject);\n        const copyFlag = context.copy ?? defaultCopyFlag;\n        const continues = context.continue ?? defaultContinues;\n        const ignoreKeys = context.ignoreKeys ?? defaultIgnoreKeys;\n        const shallowKeys = context.shallowKeys ?? defaultShallowKeys;\n        didShortCut = context.shortcut ?? defaultDidShortCut;\n\n        const copy = copyFlag ? this.cloneObj(curObject) : curObject;\n\n        // Register that you want to be visited\n        handleMapperOnLen.push(stack.length);\n        mapperCopyStack.push(copy);\n        mapperOrigStack.push(curObject);\n        mapperParent.push(curParent);\n        mapperParentKey.push(curKey);\n\n        // Extend stack if needed. When shortcutted, should still unwind the stack, but no longer add to it.\n        if (continues && !didShortCut) {\n          for (const key in copy) {\n            if (!Object.hasOwn(copy, key)) {\n              continue;\n            }\n            const val = (<Record<string, unknown>> copy)[key];\n\n            // If shallow copy required, do\n            const onlyShallow = shallowKeys && shallowKeys?.has(key);\n            if (onlyShallow) {\n              // Do not add stack entry - assign straight away\n              (<Record<string, unknown>> copy)[key] = this.cloneObj(val);\n            }\n            if (ignoreKeys && ignoreKeys.has(key)) {\n              // Do not add stack entry\n              continue;\n            }\n            if (!onlyShallow && val !== null && typeof val === 'object') {\n              // Do add stack entry.\n              stack.push(val);\n              stackParentKey.push(key);\n              stackParent.push(copy);\n            }\n          }\n        }\n      }\n      handleMapper();\n    }\n    if (stack.length >= this.maxStackSize) {\n      throw new Error('Transform object stack overflowed');\n    }\n    handleMapper();\n\n    return <any> resultWrap.res;\n  }\n\n  /**\n   * Visitor that visits all objects. Visits deeper objects first.\n   */\n  public visitObject(\n    startObject: object,\n    visitor: (orig: object) => void,\n    preVisitor: (orig: object) => VisitContext = () => ({}),\n  ): void {\n    const defaults = this.defaultContext;\n    const defaultContinues = defaults.continue ?? true;\n    const defaultIgnoreKeys = defaults.ignoreKeys;\n    const defaultShortcut = defaults.shortcut ?? false;\n\n    let didShortCut = false;\n\n    // Stack of things to preVisit\n    const stack = [ startObject ];\n    // When the stack is done preVisiting things above this lengths, visit the bellow\n    const handleVisitorOnLen: number[] = [];\n    const visitorStack: object[] = [];\n\n    function handleVisitor(): void {\n      while (stack.length === handleVisitorOnLen.at(-1)) {\n        handleVisitorOnLen.pop();\n        const toVisit = visitorStack.pop()!;\n        visitor(toVisit);\n      }\n    }\n\n    while (stack.length > 0 && stack.length < this.maxStackSize) {\n      const curObject = stack.pop()!;\n\n      if (!didShortCut) {\n        if (Array.isArray(curObject)) {\n          for (let i = curObject.length - 1; i >= 0; i--) {\n            stack.push(curObject[i]);\n          }\n          handleVisitor();\n          continue;\n        }\n\n        // Perform pre visit before expanding the stack\n        const context = preVisitor(curObject);\n        didShortCut = context.shortcut ?? defaultShortcut;\n        const continues = context.continue ?? defaultContinues;\n        const ignoreKeys = context.ignoreKeys ?? defaultIgnoreKeys;\n\n        // Register that you want to be visited\n        handleVisitorOnLen.push(stack.length);\n        visitorStack.push(curObject);\n\n        // Extend stack if needed. When shortcutted, should still unwind the stack, but no longer add to it.\n        if (continues && !didShortCut) {\n          for (const key in curObject) {\n            if (!Object.hasOwn(curObject, key)) {\n              continue;\n            }\n            if (ignoreKeys && ignoreKeys.has(key)) {\n              continue;\n            }\n            const val = (<Record<string, unknown>> curObject)[key];\n            if (val && typeof val === 'object') {\n              stack.push(val);\n            }\n          }\n        }\n      }\n      handleVisitor();\n    }\n    if (stack.length >= this.maxStackSize) {\n      throw new Error('Transform object stack overflowed');\n    }\n    handleVisitor();\n  }\n}\n"]}