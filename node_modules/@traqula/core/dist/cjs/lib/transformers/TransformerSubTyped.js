"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformerSubTyped = void 0;
const TransformerTyped_js_1 = require("./TransformerTyped.js");
class TransformerSubTyped extends TransformerTyped_js_1.TransformerTyped {
    constructor(defaultContext = {}, defaultNodePreVisitor = {}) {
        super(defaultContext, defaultNodePreVisitor);
    }
    ;
    clone(newDefaultContext = {}, newDefaultNodePreVisitor = {}) {
        return new TransformerSubTyped({ ...this.defaultContext, ...newDefaultContext }, { ...this.defaultNodePreVisitor, ...newDefaultNodePreVisitor });
    }
    /**
     * Transform a single node ({@link Typed}).
     * Similar to {@link this.transformNode} but also allowing you to target the subTypes.
     * @param startObject the object from which we will start the transformation,
     *   potentially visiting and transforming its descendants along the way.
     * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally
     *    containing preVisitor and transformer.
     *    The preVisitor allows you to provide {@link TransformContext} for the current object,
     *    altering how it will be transformed.
     *    The transformer allows you to manipulate the copy of the current object,
     *    and expects you to return the value that should take the current objects place.
     * @param nodeSpecificCallBacks Same as nodeCallBacks but using an additional level of indirection to
     *     indicate the subType.
     * @return the result of transforming the requested descendant operations (based on the preVisitor)
     * using a transformer that works its way back up from the descendant to the startObject.
     */
    transformNodeSpecific(startObject, nodeCallBacks, nodeSpecificCallBacks) {
        const transformWrapper = (copy, orig) => {
            let ogTransform;
            const casted = copy;
            if (casted.type && casted.subType) {
                const specific = nodeSpecificCallBacks[casted.type];
                if (specific) {
                    ogTransform = specific[casted.subType]?.transform;
                }
                if (!ogTransform) {
                    ogTransform = nodeCallBacks[casted.type]?.transform;
                }
            }
            return ogTransform ? ogTransform(casted, orig) : copy;
        };
        const preVisitWrapper = (curObject) => {
            let ogPreVisit;
            const casted = curObject;
            if (casted.type && casted.subType) {
                const specific = nodeSpecificCallBacks[casted.type];
                if (specific) {
                    ogPreVisit = specific[casted.subType]?.preVisitor;
                }
                if (!ogPreVisit) {
                    ogPreVisit = nodeCallBacks[casted.type]?.preVisitor;
                }
            }
            return ogPreVisit ? ogPreVisit(casted) : {};
        };
        return this.transformObject(startObject, transformWrapper, preVisitWrapper);
    }
    /**
     * Visit a selected subTree given a startObject, steering the visits based on {@link Typed} nodes.
     * Similar to {@link this.visitNode}, but also allowing you to target subTypes.
     * Will call the preVisitor on the outer distinct, then the visitor of the special distinct,
     * followed by the visiting the outer distinct, printing '231'.
     * The pre-visitor visits starting from the root, going deeper, while the actual visitor goes in reverse.
     * @param startObject the object from which we will start visiting,
     *   potentially visiting its descendants along the way.
     * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally
     *    containing preVisitor and visitor.
     *    The preVisitor allows you to provide {@link VisitContext} for the current object,
     *    altering how it will be visited.
     *    The visitor allows you to visit the object from deepest to the outermost object.
     *    This is useful if you for example want to manipulate the objects you visit during your visits,
     *    similar to {@link mapOperation}.
     * @param nodeSpecificCallBacks Same as nodeCallBacks but using an additional level of indirection to
     *     indicate the subType.
     */
    visitNodeSpecific(startObject, nodeCallBacks, nodeSpecificCallBacks) {
        const visitWrapper = (curObject) => {
            let ogTransform;
            const casted = curObject;
            if (casted.type && casted.subType) {
                const specific = nodeSpecificCallBacks[casted.type];
                if (specific) {
                    ogTransform = specific[casted.subType]?.visitor;
                }
                if (!ogTransform) {
                    ogTransform = nodeCallBacks[casted.type]?.visitor;
                }
            }
            if (ogTransform) {
                ogTransform(casted);
            }
        };
        const preVisitWrapper = (curObject) => {
            let ogPreVisit;
            const casted = curObject;
            if (casted.type && casted.subType) {
                const specific = nodeSpecificCallBacks[casted.type];
                if (specific) {
                    ogPreVisit = specific[casted.subType]?.preVisitor;
                }
                if (!ogPreVisit) {
                    ogPreVisit = nodeCallBacks[casted.type]?.preVisitor;
                }
            }
            return ogPreVisit ? ogPreVisit(casted) : {};
        };
        this.visitObject(startObject, visitWrapper, preVisitWrapper);
    }
}
exports.TransformerSubTyped = TransformerSubTyped;
//# sourceMappingURL=TransformerSubTyped.js.map