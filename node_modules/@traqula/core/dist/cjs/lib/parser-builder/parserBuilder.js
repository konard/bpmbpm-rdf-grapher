"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParserBuilder = void 0;
const LexerBuilder_js_1 = require("../lexer-builder/LexerBuilder.js");
const dynamicParser_js_1 = require("./dynamicParser.js");
/**
 * Converts a list of ruledefs to a record mapping a name to the corresponding ruledef.
 */
function listToRuleDefMap(rules) {
    const newRules = {};
    for (const rule of rules) {
        newRules[rule.name] = rule;
    }
    return newRules;
}
/**
 * The grammar builder. This is the core of traqula (besides using the amazing chevrotain framework).
 * Using the builder you can create a grammar + AST creator.
 * At any point in time, a parser can be constructed from the added rules.
 * Constructing a parser will cause a validation which will validate the correctness of the grammar.
 */
// This code is wild so other code can be simple.
class ParserBuilder {
    /**
     * Create a builder from some initial grammar rules or an existing builder.
     * If a builder is provided, a new copy will be created.
     */
    static create(start) {
        if (Array.isArray(start)) {
            return new ParserBuilder(listToRuleDefMap(start));
        }
        return new ParserBuilder({ ...start.rules });
    }
    rules;
    constructor(startRules) {
        this.rules = startRules;
    }
    widenContext() {
        return this;
    }
    typePatch() {
        return this;
    }
    /**
     * Change the implementation of an existing grammar rule.
     */
    patchRule(patch) {
        const self = this;
        self.rules[patch.name] = patch;
        return self;
    }
    /**
     * Add a rule to the grammar. If the rule already exists, but the implementation differs, an error will be thrown.
     */
    addRuleRedundant(rule) {
        const self = this;
        const rules = self.rules;
        if (rules[rule.name] !== undefined && rules[rule.name] !== rule) {
            throw new Error(`Rule ${rule.name} already exists in the builder`);
        }
        rules[rule.name] = rule;
        return self;
    }
    /**
     * Add a rule to the grammar. Will raise a typescript error if the rule already exists in the grammar.
     */
    addRule(rule) {
        return this.addRuleRedundant(rule);
    }
    addMany(...rules) {
        this.rules = { ...this.rules, ...listToRuleDefMap(rules) };
        return this;
    }
    /**
     * Delete a grammar rule by its name.
     */
    deleteRule(ruleName) {
        delete this.rules[ruleName];
        return this;
    }
    getRule(ruleName) {
        return this.rules[ruleName];
    }
    /**
     * Merge this grammar builder with another.
     * It is best to merge the bigger grammar with the smaller one.
     * If the two builders both have a grammar rule with the same name,
     * no error will be thrown case they map to the same ruledef object.
     * If they map to a different object, an error will be thrown.
     * To fix this problem, the overridingRules array should contain a rule with the same conflicting name,
     * this rule implementation will be used.
     */
    merge(builder, overridingRules) {
        // Assume the other grammar is bigger than yours. So start from that one and add this one
        const otherRules = { ...builder.rules };
        const myRules = this.rules;
        for (const rule of Object.values(myRules)) {
            if (otherRules[rule.name] === undefined) {
                otherRules[rule.name] = rule;
            }
            else {
                const existingRule = otherRules[rule.name];
                // If same rule, no issue, move on. Else
                if (existingRule !== rule) {
                    const override = overridingRules.find(x => x.name === rule.name);
                    // If override specified, take override, else, inform user that there is a conflict
                    if (override) {
                        otherRules[rule.name] = override;
                    }
                    else {
                        throw new Error(`Rule with name "${rule.name}" already exists in the builder, specify an override to resolve conflict`);
                    }
                }
            }
        }
        this.rules = otherRules;
        return this;
    }
    defaultErrorHandler(input, errors) {
        const firstError = errors[0];
        const messageBuilder = ['Parse error'];
        const lineIdx = firstError.token.startLine;
        if (lineIdx !== undefined && !Number.isNaN(lineIdx)) {
            const errorLine = input.split('\n')[lineIdx - 1];
            messageBuilder.push(` on line ${lineIdx}
${errorLine}`);
            const columnIdx = firstError.token.startColumn;
            if (columnIdx !== undefined) {
                messageBuilder.push(`\n${'-'.repeat(columnIdx - 1)}^`);
            }
        }
        messageBuilder.push(`\n${firstError.message}`);
        throw new Error(messageBuilder.join(''));
    }
    build({ tokenVocabulary, parserConfig = {}, lexerConfig = {}, queryPreProcessor = s => s, errorHandler, }) {
        const lexer = LexerBuilder_js_1.LexerBuilder.create().add(...tokenVocabulary).build({
            positionTracking: 'onlyOffset',
            recoveryEnabled: false,
            ensureOptimizations: true,
            safeMode: false,
            skipValidations: true,
            ...lexerConfig,
        });
        // Get the chevrotain parser
        const parser = this.consume({
            tokenVocabulary: tokenVocabulary,
            config: parserConfig,
        });
        // Start building a parser that does not pass input using a state, but instead gets it as a function argument.
        const selfSufficientParser = {};
        // To do that, we need to create a wrapper for each parser rule.
        // eslint-disable-next-line ts/no-unnecessary-type-assertion
        for (const rule of Object.values(this.rules)) {
            selfSufficientParser[rule.name] = ((input, context, ...args) => {
                const processedInput = queryPreProcessor(input);
                const lexResult = lexer.tokenize(processedInput);
                // This also resets the parser
                parser.input = lexResult.tokens;
                parser.setContext(context);
                const result = parser[rule.name](context, ...args);
                if (parser.errors.length > 0) {
                    // Console.log(JSON.stringify(lexResult, null, 2));
                    if (errorHandler) {
                        errorHandler(parser.errors);
                    }
                    else {
                        this.defaultErrorHandler(processedInput, parser.errors);
                    }
                }
                return result;
            });
        }
        return selfSufficientParser;
    }
    consume({ tokenVocabulary, config = {} }) {
        return new dynamicParser_js_1.DynamicParser(this.rules, tokenVocabulary, config);
    }
}
exports.ParserBuilder = ParserBuilder;
//# sourceMappingURL=parserBuilder.js.map