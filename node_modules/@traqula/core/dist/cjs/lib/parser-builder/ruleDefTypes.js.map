{"version":3,"file":"ruleDefTypes.js","sourceRoot":"","sources":["../../../../lib/parser-builder/ruleDefTypes.ts"],"names":[],"mappings":"","sourcesContent":["import type {\n  AtLeastOneSepMethodOpts,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  ConsumeMethodOpts,\n  IToken,\n  TokenType,\n} from '@traqula/chevrotain';\n\n/**\n * Get the return-type of a RuleDef\n */\nexport type RuleDefReturn<T extends ParserRule> = T extends ParserRule<any, string, infer Ret> ? Ret : never;\n\n/**\n * Type used to declare grammar rules.\n */\nexport type ParserRule<\n  /**\n   * Context object available in rule implementation.\n   */\n  Context = any,\n  /**\n   * Name of grammar rule, should be a strict subtype of string like 'myGrammarRule'.\n   */\n  NameType extends string = string,\n  /**\n   * Type that will be returned after a correct parse of this rule.\n   * This type will be the return type of calling SUBRULE with this grammar rule.\n   */\n  ReturnType = unknown,\n  /**\n   * Function arguments that can be given to convey the state of the current parse operation.\n   */\n  ParamType extends any[] = any[],\n> = {\n  name: NameType;\n  impl: (def: ImplArgs) => (context: Context, ...params: ParamType) => ReturnType;\n};\n\n/**\n * Type expected by grammar rules in the main `impl` function.\n */\nexport interface ImplArgs extends CstDef {\n  cache: WeakMap<ParserRule, unknown>;\n}\n\n/**\n * Type definition used by {@link CstDef.SUBRULE} and family.\n */\ntype SubRuleFunc = <T extends string, U = unknown, ARGS extends any[] = any>(\n  cstDef: ParserRule<any, T, U, ARGS>,\n  ...argument: ARGS\n) => U;\n/**\n * Type definition used by {@link CstDef.BACKTRACK}.\n */\ntype BacktrackFunc = <T extends string, U = unknown, ARGS extends any[] = any>(\n  cstDef: ParserRule<any, T, U, ARGS>,\n  ...argument: ARGS\n) => () => boolean;\n\n/**\n * Mainly a repetition of the functions exposed by the {@link EmbeddedActionsParser},\n * with some small adjustments that allow for the API changes made by traqula.\n * Specifically changes are made to the {@link CstDef.SUBRULE} (and family) interface,\n * and to the {@link CstDef.BACKTRACK} interface.\n */\nexport interface CstDef {\n  /**\n   *\n   * A Parsing DSL method use to consume a single Token.\n   * In EBNF terms this is equivalent to a Terminal.\n   *\n   * A Token will be consumed, IFF the next token in the token vector matches `tokType`.\n   * otherwise the parser may attempt to perform error recovery (if enabled).\n   *\n   * The index in the method name indicates the unique occurrence of a terminal consumption\n   * inside a the top level rule. What this means is that if a terminal appears\n   * more than once in a single rule, each appearance must have a **different** index.\n   *\n   * For example:\n   * ```\n   *   this.RULE(\"qualifiedName\", () => {\n   *   this.CONSUME1(Identifier);\n   *     this.MANY(() => {\n   *       this.CONSUME1(Dot);\n   *       // here we use CONSUME2 because the terminal\n   *       // 'Identifier' has already appeared previously in the\n   *       // the rule 'parseQualifiedName'\n   *       this.CONSUME2(Identifier);\n   *     });\n   *   })\n   * ```\n   *\n   * - See more details on the [unique suffixes requirement](http://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES).\n   *\n   * @param tokType - The Type of the token to be consumed.\n   * @param options - optional properties to modify the behavior of CONSUME.\n   */\n  CONSUME: (tokType: TokenType, options?: ConsumeMethodOpts) => IToken;\n  CONSUME1: (tokType: TokenType, options?: ConsumeMethodOpts) => IToken;\n  CONSUME2: (tokType: TokenType, options?: ConsumeMethodOpts) => IToken;\n  CONSUME3: (tokType: TokenType, options?: ConsumeMethodOpts) => IToken;\n  CONSUME4: (tokType: TokenType, options?: ConsumeMethodOpts) => IToken;\n  CONSUME5: (tokType: TokenType, options?: ConsumeMethodOpts) => IToken;\n  CONSUME6: (tokType: TokenType, options?: ConsumeMethodOpts) => IToken;\n  CONSUME7: (tokType: TokenType, options?: ConsumeMethodOpts) => IToken;\n  CONSUME8: (tokType: TokenType, options?: ConsumeMethodOpts) => IToken;\n  CONSUME9: (tokType: TokenType, options?: ConsumeMethodOpts) => IToken;\n  /**\n   * Parsing DSL Method that Indicates an Optional production.\n   * in EBNF notation this is equivalent to: \"[...]\".\n   *\n   * Note that there are two syntax forms:\n   * - Passing the grammar action directly:\n   *   ```\n   *     this.OPTION(() => {\n   *       this.CONSUME(Digit)}\n   *     );\n   *   ```\n   *\n   * - using an \"options\" object:\n   *   ```\n   *     this.OPTION({\n   *       GATE:predicateFunc,\n   *       DEF: () => {\n   *         this.CONSUME(Digit)\n   *     }});\n   *   ```\n   *\n   * The optional 'GATE' property in \"options\" object form can be used to add constraints\n   * to invoking the grammar action.\n   *\n   * As in CONSUME the index in the method name indicates the occurrence\n   * of the optional production in it's top rule.\n   *\n   * @param  actionORMethodDef - The grammar action to optionally invoke once\n   *                             or an \"OPTIONS\" object describing the grammar action and optional properties.\n   *\n   * @returns The `GrammarAction` return value (OUT) if the optional syntax is encountered\n   *          or `undefined` if not.\n   */\n  OPTION: <OUT>(\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ) => OUT | undefined;\n  OPTION1: <OUT>(\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ) => OUT | undefined;\n  OPTION2: <OUT>(\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ) => OUT | undefined;\n  OPTION3: <OUT>(\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ) => OUT | undefined;\n  OPTION4: <OUT>(\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ) => OUT | undefined;\n  OPTION5: <OUT>(\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ) => OUT | undefined;\n  OPTION6: <OUT>(\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ) => OUT | undefined;\n  OPTION7: <OUT>(\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ) => OUT | undefined;\n  OPTION8: <OUT>(\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ) => OUT | undefined;\n  OPTION9: <OUT>(\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ) => OUT | undefined;\n  /**\n   * Parsing DSL method that indicates a choice between a set of alternatives must be made.\n   * This is equivalent to an EBNF alternation (A | B | C | D ...), except\n   * that the alternatives are ordered like in a PEG grammar.\n   * This means that the **first** matching alternative is always chosen.\n   *\n   * There are several forms for the inner alternatives array:\n   *\n   * - Passing alternatives array directly:\n   *   ```\n   *     this.OR([\n   *       { ALT:() => { this.CONSUME(One) }},\n   *       { ALT:() => { this.CONSUME(Two) }},\n   *       { ALT:() => { this.CONSUME(Three) }}\n   *     ])\n   *   ```\n   *\n   * - Passing alternative array directly with predicates (GATE):\n   *   ```\n   *     this.OR([\n   *       { GATE: predicateFunc1, ALT:() => { this.CONSUME(One) }},\n   *       { GATE: predicateFuncX, ALT:() => { this.CONSUME(Two) }},\n   *       { GATE: predicateFuncX, ALT:() => { this.CONSUME(Three) }}\n   *     ])\n   *   ```\n   *\n   * - These syntax forms can also be mixed:\n   *   ```\n   *     this.OR([\n   *       {\n   *         GATE: predicateFunc1,\n   *         ALT:() => { this.CONSUME(One) }\n   *       },\n   *       { ALT:() => { this.CONSUME(Two) }},\n   *       { ALT:() => { this.CONSUME(Three) }}\n   *     ])\n   *   ```\n   *\n   * - Additionally an \"options\" object may be used:\n   *   ```\n   *     this.OR({\n   *       DEF:[\n   *         { ALT:() => { this.CONSUME(One) }},\n   *         { ALT:() => { this.CONSUME(Two) }},\n   *         { ALT:() => { this.CONSUME(Three) }}\n   *       ],\n   *       // OPTIONAL property\n   *       ERR_MSG: \"A Number\"\n   *     })\n   *   ```\n   *\n   * The 'predicateFuncX' in the long form can be used to add constraints to choosing the alternative.\n   *\n   * As in CONSUME the index in the method name indicates the occurrence\n   * of the alternation production in it's top rule.\n   *\n   * @param altsOrOpts - A set of alternatives or an \"OPTIONS\" object describing the alternatives\n   * and optional properties.\n   *\n   * @returns The result of invoking the chosen alternative.\n   */\n  OR: <T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>) => T;\n  OR1: <T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>) => T;\n  OR2: <T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>) => T;\n  OR3: <T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>) => T;\n  OR4: <T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>) => T;\n  OR5: <T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>) => T;\n  OR6: <T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>) => T;\n  OR7: <T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>) => T;\n  OR8: <T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>) => T;\n  OR9: <T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>) => T;\n  /**\n   * Parsing DSL method, that indicates a repetition of zero or more.\n   * This is equivalent to EBNF repetition \\{...\\}.\n   *\n   * Note that there are two syntax forms:\n   * - Passing the grammar action directly:\n   *   ```\n   *     this.MANY(() => {\n   *       this.CONSUME(Comma)\n   *       this.CONSUME(Digit)\n   *      })\n   *   ```\n   *\n   * - using an \"options\" object:\n   *   ```\n   *     this.MANY({\n   *       GATE: predicateFunc,\n   *       DEF: () => {\n   *              this.CONSUME(Comma)\n   *              this.CONSUME(Digit)\n   *            }\n   *     });\n   *   ```\n   *\n   * The optional 'GATE' property in \"options\" object form can be used to add constraints\n   * to invoking the grammar action.\n   *\n   * As in CONSUME the index in the method name indicates the occurrence\n   * of the repetition production in it's top rule.\n   *\n   * @param actionORMethodDef - The grammar action to optionally invoke multiple times\n   *                             or an \"OPTIONS\" object describing the grammar action and optional properties.\n   *\n   */\n  MANY: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,\n  ) => void;\n  MANY1: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,\n  ) => void;\n  MANY2: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,\n  ) => void;\n  MANY3: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,\n  ) => void;\n  MANY4: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,\n  ) => void;\n  MANY5: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,\n  ) => void;\n  MANY6: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,\n  ) => void;\n  MANY7: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,\n  ) => void;\n  MANY8: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,\n  ) => void;\n  MANY9: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,\n  ) => void;\n  /**\n   * Parsing DSL method, that indicates a repetition of zero or more with a separator\n   * Token between the repetitions.\n   *\n   * Example:\n   *\n   * ```\n   *     this.MANY_SEP({\n   *         SEP:Comma,\n   *         DEF: () => {\n   *             this.CONSUME(Number};\n   *             // ...\n   *         })\n   * ```\n   *\n   * Note that because this DSL method always requires more than one argument the options object is always required\n   * and it is not possible to use a shorter form like in the MANY DSL method.\n   *\n   * Note that for the purposes of deciding on whether or not another iteration exists\n   * Only a single Token is examined (The separator). Therefore if the grammar being implemented is\n   * so \"crazy\" to require multiple tokens to identify an item separator please use the more basic DSL methods\n   * to implement it.\n   *\n   * As in CONSUME the index in the method name indicates the occurrence\n   * of the repetition production in it's top rule.\n   *\n   * @param options - An object defining the grammar of each iteration and the separator between iterations\n   *\n   */\n  MANY_SEP: (options: ManySepMethodOpts<any>) => void;\n  MANY_SEP1: (options: ManySepMethodOpts<any>) => void;\n  MANY_SEP2: (options: ManySepMethodOpts<any>) => void;\n  MANY_SEP3: (options: ManySepMethodOpts<any>) => void;\n  MANY_SEP4: (options: ManySepMethodOpts<any>) => void;\n  MANY_SEP5: (options: ManySepMethodOpts<any>) => void;\n  MANY_SEP6: (options: ManySepMethodOpts<any>) => void;\n  MANY_SEP7: (options: ManySepMethodOpts<any>) => void;\n  MANY_SEP8: (options: ManySepMethodOpts<any>) => void;\n  MANY_SEP9: (options: ManySepMethodOpts<any>) => void;\n  /**\n   * Convenience method, same as MANY but the repetition is of one or more.\n   * failing to match at least one repetition will result in a parsing error and\n   * cause a parsing error.\n   *\n   * @see MANY\n   *\n   * @param actionORMethodDef  - The grammar action to optionally invoke multiple times\n   *                             or an \"OPTIONS\" object describing the grammar action and optional properties.\n   *\n   */\n  AT_LEAST_ONE: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,\n  ) => void;\n  AT_LEAST_ONE1: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,\n  ) => void;\n  AT_LEAST_ONE2: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,\n  ) => void;\n  AT_LEAST_ONE3: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,\n  ) => void;\n  AT_LEAST_ONE4: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,\n  ) => void;\n  AT_LEAST_ONE5: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,\n  ) => void;\n  AT_LEAST_ONE6: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,\n  ) => void;\n  AT_LEAST_ONE7: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,\n  ) => void;\n  AT_LEAST_ONE8: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,\n  ) => void;\n  AT_LEAST_ONE9: (\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,\n  ) => void;\n  /**\n   * Convenience method, same as MANY_SEP but the repetition is of one or more.\n   * failing to match at least one repetition will result in a parsing error and\n   * cause the parser to attempt error recovery.\n   *\n   * Note that an additional optional property ERR_MSG can be used to provide custom error messages.\n   *\n   * @see MANY_SEP\n   *\n   * @param options - An object defining the grammar of each iteration and the separator between iterations\n   *\n   * @return ISeparatedIterationResult<OUT>\n   */\n  AT_LEAST_ONE_SEP: (options: AtLeastOneSepMethodOpts<any>) => void;\n  AT_LEAST_ONE_SEP1: (options: AtLeastOneSepMethodOpts<any>) => void;\n  AT_LEAST_ONE_SEP2: (options: AtLeastOneSepMethodOpts<any>) => void;\n  AT_LEAST_ONE_SEP3: (options: AtLeastOneSepMethodOpts<any>) => void;\n  AT_LEAST_ONE_SEP4: (options: AtLeastOneSepMethodOpts<any>) => void;\n  AT_LEAST_ONE_SEP5: (options: AtLeastOneSepMethodOpts<any>) => void;\n  AT_LEAST_ONE_SEP6: (options: AtLeastOneSepMethodOpts<any>) => void;\n  AT_LEAST_ONE_SEP7: (options: AtLeastOneSepMethodOpts<any>) => void;\n  AT_LEAST_ONE_SEP8: (options: AtLeastOneSepMethodOpts<any>) => void;\n  AT_LEAST_ONE_SEP9: (options: AtLeastOneSepMethodOpts<any>) => void;\n  /**\n   * Perform an action that is only executed during actual parsing and not during parser initialization.\n   * (When a lot of this secretly return null)\n   * @param impl\n   * @constructor\n   */\n  ACTION: <T>(impl: () => T) => T;\n  BACKTRACK: BacktrackFunc;\n  SUBRULE: SubRuleFunc;\n  SUBRULE1: SubRuleFunc;\n  SUBRULE2: SubRuleFunc;\n  SUBRULE3: SubRuleFunc;\n  SUBRULE4: SubRuleFunc;\n  SUBRULE5: SubRuleFunc;\n  SUBRULE6: SubRuleFunc;\n  SUBRULE7: SubRuleFunc;\n  SUBRULE8: SubRuleFunc;\n  SUBRULE9: SubRuleFunc;\n}\n"]}