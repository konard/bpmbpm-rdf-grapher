{"version":3,"file":"IndirBuilder.js","sourceRoot":"","sources":["../../../../lib/indirection-builder/IndirBuilder.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,eAAe,EAAE,MAAM,wBAAwB,CAAC;AAEzD,OAAO,EAAE,oBAAoB,EAAE,MAAM,cAAc,CAAC;AAEpD,MAAM,OAAO,YAAY;IAUhB,MAAM,CAAC,MAAM,CAMlB,KAAqD;QAErD,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;YACzB,OAA0D,IAAI,YAAY,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC;QAC1G,CAAC;QACD,OAAO,IAAI,YAAY,CAAC,EAAE,GAAiC,KAAM,CAAC,KAAK,EAAE,CAAC,CAAC;IAC7E,CAAC;IAEO,KAAK,CAAW;IAExB,YAAoB,UAAoB;QACtC,IAAI,CAAC,KAAK,GAAG,UAAU,CAAC;IAC1B,CAAC;IAEM,YAAY;QAOjB,OAAa,IAAI,CAAC;IACpB,CAAC;IAEM,SAAS;QASd,OAAa,IAAI,CAAC;IACpB,CAAC;IAED;;OAEG;IACI,SAAS,CAA2C,KAAsC;QAK/F,MAAM,IAAI,GAEE,IAAI,CAAC;QACjB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,GAAS,KAAK,CAAC;QACrC,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACI,gBAAgB,CAA4C,IAAqC;QAKtG,MAAM,IAAI,GAGE,IAAI,CAAC;QACjB,MAAM,KAAK,GAAuC,IAAI,CAAC,KAAK,CAAC;QAC7D,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,SAAS,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC;YAChE,MAAM,IAAI,KAAK,CAAC,YAAY,IAAI,CAAC,IAAI,gCAAgC,CAAC,CAAC;QACzE,CAAC;QACD,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;QACxB,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACI,OAAO,CACZ,IAA6D;QAI7D,OAAO,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;IACrC,CAAC;IAEM,OAAO,CACZ,GAAG,KAAoD;QAYvD,IAAI,CAAC,KAAK,GAAG,EAAE,GAAG,IAAI,CAAC,KAAK,EAAE,GAAG,oBAAoB,CAAC,KAAK,CAAC,EAAE,CAAC;QAC/D,OAAuB,IAAI,CAAC;IAC9B,CAAC;IAED;;OAEG;IACI,UAAU,CAAkB,QAAW;QAG5C,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QAC5B,OAEY,IAAI,CAAC;IACnB,CAAC;IAEM,OAAO,CAAkB,QAAW;QAEzC,OAAa,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;IACpC,CAAC;IAEM,KAAK;QACV,OAA4D,IAAI,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC9F,CAAC;CACF","sourcesContent":["import type { ParseNamesFromList } from '../parser-builder/builderTypes.js';\nimport type { CheckOverlap } from '../utils.js';\nimport { DynamicIndirect } from './dynamicIndirected.js';\nimport type { IndirDef, IndirectionMap, IndirectObjFromIndirDefs, ParseIndirsToObject } from './helpers.js';\nimport { listToIndirectionMap } from './helpers.js';\n\nexport class IndirBuilder<Context, Names extends string, RuleDefs extends IndirectionMap<Names>> {\n  public static create<Context, Names extends string, RuleDefs extends IndirectionMap<Names>>(\n    args: IndirBuilder<Context, Names, RuleDefs>\n  ): IndirBuilder<Context, Names, RuleDefs>;\n  public static create<\n    Rules extends readonly IndirDef[] = readonly IndirDef[],\n    Context = Rules[0] extends IndirDef<infer context> ? context : never,\n    Names extends string = ParseNamesFromList<Rules>,\n    RuleDefs extends IndirectionMap<Names> = ParseIndirsToObject<Rules>,\n  >(rules: Rules): IndirBuilder<Context, Names, RuleDefs>;\n  public static create<\n    Rules extends readonly IndirDef[] = readonly IndirDef[],\n    Context = Rules[0] extends IndirDef<infer context> ? context : never,\n    Names extends string = ParseNamesFromList<Rules>,\n    RuleDefs extends IndirectionMap<Names> = ParseIndirsToObject<Rules>,\n  >(\n    start: Rules | IndirBuilder<Context, Names, RuleDefs>,\n  ): IndirBuilder<Context, Names, RuleDefs> {\n    if (Array.isArray(start)) {\n      return <IndirBuilder<Context, Names, RuleDefs>> <unknown> new IndirBuilder(listToIndirectionMap(start));\n    }\n    return new IndirBuilder({ ...(<IndirBuilder<any, any, any>>start).rules });\n  }\n\n  private rules: RuleDefs;\n\n  private constructor(startRules: RuleDefs) {\n    this.rules = startRules;\n  }\n\n  public widenContext<NewContext extends Context>(): IndirBuilder<\n    NewContext,\n    Names,\n    {[Key in keyof RuleDefs]: Key extends Names ?\n        (RuleDefs[Key] extends IndirDef<any, any, infer RT, infer PT> ? IndirDef<NewContext, Key, RT, PT> : never)\n      : never }\n  > {\n    return <any> this;\n  }\n\n  public typePatch<Patch extends {[Key in Names]?: [any] | [any, any[]]}>():\n  IndirBuilder<Context, Names, {[Key in Names]: Key extends keyof Patch ? (\n    Patch[Key] extends [any, any[]] ? IndirDef<Context, Key, Patch[Key][0], Patch[Key][1]> : (\n      // Only  one - infer arg yourself\n      Patch[Key] extends [ any ] ? (\n        RuleDefs[Key] extends IndirDef<any, any, any, infer Par> ? IndirDef<Context, Key, Patch[Key][0], Par> : never\n      ) : never\n    )\n  ) : (RuleDefs[Key] extends IndirDef<Context, Key> ? RuleDefs[Key] : never) }> {\n    return <any> this;\n  }\n\n  /**\n   * Change the implementation of an existing indirection.\n   */\n  public patchRule<U extends Names, RET, ARGS extends any[]>(patch: IndirDef<Context, U, RET, ARGS>):\n  IndirBuilder<Context, Names, {[Key in Names]: Key extends U ?\n    IndirDef<Context, Key, RET, ARGS> :\n      (RuleDefs[Key] extends IndirDef<Context, Key> ? RuleDefs[Key] : never)\n  } > {\n    const self = <IndirBuilder<Context, Names, {[Key in Names]: Key extends U ?\n      IndirDef<Context, Key, RET, ARGS> : (RuleDefs[Key] extends IndirDef<Context, Key> ? RuleDefs[Key] : never) }>>\n      <unknown> this;\n    self.rules[patch.name] = <any> patch;\n    return self;\n  }\n\n  /**\n   * Add an indirection function. If the rule already exists, but the implementation differs, an error will be thrown.\n   */\n  public addRuleRedundant<U extends string, RET, ARGS extends any[]>(rule: IndirDef<Context, U, RET, ARGS>):\n  IndirBuilder<Context, Names | U, {[K in Names | U]: K extends U ?\n    IndirDef<Context, K, RET, ARGS> :\n      (K extends Names ? (RuleDefs[K] extends IndirDef<Context, K> ? RuleDefs[K] : never) : never)\n  }> {\n    const self = <IndirBuilder<Context, Names | U, {[K in Names | U]: K extends U ?\n      IndirDef<Context, K, RET, ARGS> :\n        (K extends Names ? (RuleDefs[K] extends IndirDef<Context, K> ? RuleDefs[K] : never) : never) }>>\n      <unknown> this;\n    const rules = <Record<string, IndirDef<Context>>> self.rules;\n    if (rules[rule.name] !== undefined && rules[rule.name] !== rule) {\n      throw new Error(`Function ${rule.name} already exists in the builder`);\n    }\n    rules[rule.name] = rule;\n    return self;\n  }\n\n  /**\n   * Add a rule to the grammar. Will raise a typescript error if the rule already exists in the grammar.\n   */\n  public addRule<U extends string, RET, ARGS extends any[]>(\n    rule: CheckOverlap<U, Names, IndirDef<Context, U, RET, ARGS>>,\n  ): IndirBuilder<Context, Names | U, {[K in Names | U]: K extends U ?\n    IndirDef<Context, K, RET, ARGS> :\n      (K extends Names ? (RuleDefs[K] extends IndirDef<Context, K> ? RuleDefs[K] : never) : never) }> {\n    return this.addRuleRedundant(rule);\n  }\n\n  public addMany<U extends readonly IndirDef<Context>[]>(\n    ...rules: CheckOverlap<ParseNamesFromList<U>, Names, U>\n  ): IndirBuilder<\n    Context,\n    Names | ParseNamesFromList<U>,\n    {[K in Names | ParseNamesFromList<U>]:\n      K extends keyof ParseIndirsToObject<typeof rules> ? (\n        ParseIndirsToObject<typeof rules>[K] extends IndirDef<Context, K> ? ParseIndirsToObject<typeof rules>[K] : never\n      ) : (\n        K extends Names ? (RuleDefs[K] extends IndirDef<Context, K> ? RuleDefs[K] : never) : never\n      )\n    }\n  > {\n    this.rules = { ...this.rules, ...listToIndirectionMap(rules) };\n    return <any> <unknown> this;\n  }\n\n  /**\n   * Delete a grammar rule by its name.\n   */\n  public deleteRule<U extends Names>(ruleName: U):\n  IndirBuilder<Context, Exclude<Names, U>, {[K in Exclude<Names, U>]:\n    RuleDefs[K] extends IndirDef<Context, K> ? RuleDefs[K] : never }> {\n    delete this.rules[ruleName];\n    return <IndirBuilder<Context, Exclude<Names, U>, {[K in Exclude<Names, U>]:\n      RuleDefs[K] extends IndirDef<Context, K> ? RuleDefs[K] : never }>>\n      <unknown> this;\n  }\n\n  public getRule<U extends Names>(ruleName: U): RuleDefs[U] extends IndirDef<any, U, infer RT, infer PT> ?\n    IndirDef<Context, U, RT, PT> : never {\n    return <any> this.rules[ruleName];\n  }\n\n  public build(): IndirectObjFromIndirDefs<Context, Names, RuleDefs> {\n    return <IndirectObjFromIndirDefs<Context, Names, RuleDefs>> new DynamicIndirect(this.rules);\n  }\n}\n"]}