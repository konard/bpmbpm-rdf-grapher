import type { ParseNamesFromList } from '../parser-builder/builderTypes.js';
import type { CheckOverlap } from '../utils.js';
import type { IndirDef, IndirectionMap, IndirectObjFromIndirDefs, ParseIndirsToObject } from './helpers.js';
export declare class IndirBuilder<Context, Names extends string, RuleDefs extends IndirectionMap<Names>> {
    static create<Context, Names extends string, RuleDefs extends IndirectionMap<Names>>(args: IndirBuilder<Context, Names, RuleDefs>): IndirBuilder<Context, Names, RuleDefs>;
    static create<Rules extends readonly IndirDef[] = readonly IndirDef[], Context = Rules[0] extends IndirDef<infer context> ? context : never, Names extends string = ParseNamesFromList<Rules>, RuleDefs extends IndirectionMap<Names> = ParseIndirsToObject<Rules>>(rules: Rules): IndirBuilder<Context, Names, RuleDefs>;
    private rules;
    private constructor();
    widenContext<NewContext extends Context>(): IndirBuilder<NewContext, Names, {
        [Key in keyof RuleDefs]: Key extends Names ? (RuleDefs[Key] extends IndirDef<any, any, infer RT, infer PT> ? IndirDef<NewContext, Key, RT, PT> : never) : never;
    }>;
    typePatch<Patch extends {
        [Key in Names]?: [any] | [any, any[]];
    }>(): IndirBuilder<Context, Names, {
        [Key in Names]: Key extends keyof Patch ? (Patch[Key] extends [any, any[]] ? IndirDef<Context, Key, Patch[Key][0], Patch[Key][1]> : (Patch[Key] extends [any] ? (RuleDefs[Key] extends IndirDef<any, any, any, infer Par> ? IndirDef<Context, Key, Patch[Key][0], Par> : never) : never)) : (RuleDefs[Key] extends IndirDef<Context, Key> ? RuleDefs[Key] : never);
    }>;
    /**
     * Change the implementation of an existing indirection.
     */
    patchRule<U extends Names, RET, ARGS extends any[]>(patch: IndirDef<Context, U, RET, ARGS>): IndirBuilder<Context, Names, {
        [Key in Names]: Key extends U ? IndirDef<Context, Key, RET, ARGS> : (RuleDefs[Key] extends IndirDef<Context, Key> ? RuleDefs[Key] : never);
    }>;
    /**
     * Add an indirection function. If the rule already exists, but the implementation differs, an error will be thrown.
     */
    addRuleRedundant<U extends string, RET, ARGS extends any[]>(rule: IndirDef<Context, U, RET, ARGS>): IndirBuilder<Context, Names | U, {
        [K in Names | U]: K extends U ? IndirDef<Context, K, RET, ARGS> : (K extends Names ? (RuleDefs[K] extends IndirDef<Context, K> ? RuleDefs[K] : never) : never);
    }>;
    /**
     * Add a rule to the grammar. Will raise a typescript error if the rule already exists in the grammar.
     */
    addRule<U extends string, RET, ARGS extends any[]>(rule: CheckOverlap<U, Names, IndirDef<Context, U, RET, ARGS>>): IndirBuilder<Context, Names | U, {
        [K in Names | U]: K extends U ? IndirDef<Context, K, RET, ARGS> : (K extends Names ? (RuleDefs[K] extends IndirDef<Context, K> ? RuleDefs[K] : never) : never);
    }>;
    addMany<U extends readonly IndirDef<Context>[]>(...rules: CheckOverlap<ParseNamesFromList<U>, Names, U>): IndirBuilder<Context, Names | ParseNamesFromList<U>, {
        [K in Names | ParseNamesFromList<U>]: K extends keyof ParseIndirsToObject<typeof rules> ? (ParseIndirsToObject<typeof rules>[K] extends IndirDef<Context, K> ? ParseIndirsToObject<typeof rules>[K] : never) : (K extends Names ? (RuleDefs[K] extends IndirDef<Context, K> ? RuleDefs[K] : never) : never);
    }>;
    /**
     * Delete a grammar rule by its name.
     */
    deleteRule<U extends Names>(ruleName: U): IndirBuilder<Context, Exclude<Names, U>, {
        [K in Exclude<Names, U>]: RuleDefs[K] extends IndirDef<Context, K> ? RuleDefs[K] : never;
    }>;
    getRule<U extends Names>(ruleName: U): RuleDefs[U] extends IndirDef<any, U, infer RT, infer PT> ? IndirDef<Context, U, RT, PT> : never;
    build(): IndirectObjFromIndirDefs<Context, Names, RuleDefs>;
}
