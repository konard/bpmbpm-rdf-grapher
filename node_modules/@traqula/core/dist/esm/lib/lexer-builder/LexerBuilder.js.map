{"version":3,"file":"LexerBuilder.js","sourceRoot":"","sources":["../../../../lib/lexer-builder/LexerBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ILexerConfig, TokenType } from '@traqula/chevrotain';\nimport { Lexer } from '@traqula/chevrotain';\nimport type { CheckOverlap, NamedToken } from '../utils.js';\n\nexport class LexerBuilder<NAMES extends string = string> {\n  private readonly tokens: TokenType[];\n\n  public static create<U extends LexerBuilder<T>, T extends string = never>(starter?: U): U {\n    return <U> new LexerBuilder(starter);\n  }\n\n  private constructor(starter?: LexerBuilder<NAMES>) {\n    this.tokens = starter?.tokens ? [ ...starter.tokens ] : [];\n  }\n\n  public merge<OtherNames extends string, OW extends string>(\n    merge: LexerBuilder<OtherNames>,\n    overwrite: NamedToken<OW>[] = [],\n  ):\n    LexerBuilder<NAMES | OtherNames> {\n    const extraTokens = merge.tokens.filter((token) => {\n      const overwriteToken = overwrite.find(t => t.name === token.name);\n      if (overwriteToken) {\n        return false;\n      }\n      const match = this.tokens.find(t => t.name === token.name);\n      if (match) {\n        if (match !== token) {\n          throw new Error(`Token with name ${token.name} already exists. Implementation is different and no overwrite was provided.`);\n        }\n        return false;\n      }\n      return true;\n    });\n    this.tokens.push(...extraTokens);\n    return this;\n  }\n\n  public add<Name extends string>(...token: CheckOverlap<Name, NAMES, NamedToken<Name>[]>):\n  LexerBuilder<Name | NAMES> {\n    this.tokens.push(...token);\n    return this;\n  }\n\n  public addBefore<Name extends string>(\n    before: NamedToken<NAMES>,\n    ...token: CheckOverlap<Name, NAMES, NamedToken<Name>[]>\n  ): LexerBuilder<NAMES | Name> {\n    const index = this.tokens.indexOf(before);\n    if (index === -1) {\n      throw new Error('Token not found');\n    }\n    this.tokens.splice(index, 0, ...token);\n    return this;\n  }\n\n  private moveBeforeOrAfter<Name extends string>(\n    beforeOrAfter: 'before' | 'after',\n    before: NamedToken<NAMES>,\n    ...tokens: CheckOverlap<Name, NAMES, never, NamedToken<Name>[]>\n  ): LexerBuilder<NAMES> {\n    const beforeIndex = this.tokens.indexOf(before) + (beforeOrAfter === 'before' ? 0 : 1);\n    if (beforeIndex === -1) {\n      throw new Error('BeforeToken not found');\n    }\n    for (const token of tokens) {\n      const tokenIndex = this.tokens.indexOf(token);\n      if (tokenIndex === -1) {\n        throw new Error('Token not found');\n      }\n      this.tokens.splice(tokenIndex, 1);\n      this.tokens.splice(beforeIndex, 0, token);\n    }\n    return this;\n  }\n\n  /**\n   * @param before token to move rest before\n   * @param tokens tokens to move before the first token\n   */\n  public moveBefore<Name extends string>(\n    before: NamedToken<NAMES>,\n    ...tokens: CheckOverlap<Name, NAMES, never, NamedToken<Name>[]>\n  ): LexerBuilder<NAMES> {\n    return this.moveBeforeOrAfter('before', before, ...tokens);\n  }\n\n  public moveAfter<Name extends string>(\n    after: NamedToken<NAMES>,\n    ...tokens: CheckOverlap<Name, NAMES, never, NamedToken<Name>[]>\n  ): LexerBuilder<NAMES> {\n    return this.moveBeforeOrAfter('after', after, ...tokens);\n  }\n\n  public addAfter<Name extends string>(\n    after: NamedToken<NAMES>,\n    ...token: CheckOverlap<Name, NAMES, never, NamedToken<Name>[]>\n  ): LexerBuilder<NAMES | Name> {\n    const index = this.tokens.indexOf(after);\n    if (index === -1) {\n      throw new Error('Token not found');\n    }\n    this.tokens.splice(index + 1, 0, ...token);\n    return this;\n  }\n\n  public delete<Name extends NAMES>(...token: NamedToken<Name>[]): LexerBuilder<Exclude<NAMES, Name>> {\n    for (const t of token) {\n      const index = this.tokens.indexOf(t);\n      if (index === -1) {\n        throw new Error('Token not found');\n      }\n      this.tokens.splice(index, 1);\n    }\n    return this;\n  }\n\n  public build(lexerConfig?: ILexerConfig): Lexer {\n    return new Lexer(this.tokens, {\n      positionTracking: 'onlyStart',\n      recoveryEnabled: false,\n      ensureOptimizations: true,\n      // SafeMode: true,\n      // SkipValidations: true,\n      ...lexerConfig,\n    });\n  }\n\n  public get tokenVocabulary(): readonly TokenType[] {\n    return this.tokens;\n  }\n}\n"]}