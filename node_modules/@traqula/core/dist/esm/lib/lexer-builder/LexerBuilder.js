import { Lexer } from '@traqula/chevrotain';
export class LexerBuilder {
    tokens;
    static create(starter) {
        return new LexerBuilder(starter);
    }
    constructor(starter) {
        this.tokens = starter?.tokens ? [...starter.tokens] : [];
    }
    merge(merge, overwrite = []) {
        const extraTokens = merge.tokens.filter((token) => {
            const overwriteToken = overwrite.find(t => t.name === token.name);
            if (overwriteToken) {
                return false;
            }
            const match = this.tokens.find(t => t.name === token.name);
            if (match) {
                if (match !== token) {
                    throw new Error(`Token with name ${token.name} already exists. Implementation is different and no overwrite was provided.`);
                }
                return false;
            }
            return true;
        });
        this.tokens.push(...extraTokens);
        return this;
    }
    add(...token) {
        this.tokens.push(...token);
        return this;
    }
    addBefore(before, ...token) {
        const index = this.tokens.indexOf(before);
        if (index === -1) {
            throw new Error('Token not found');
        }
        this.tokens.splice(index, 0, ...token);
        return this;
    }
    moveBeforeOrAfter(beforeOrAfter, before, ...tokens) {
        const beforeIndex = this.tokens.indexOf(before) + (beforeOrAfter === 'before' ? 0 : 1);
        if (beforeIndex === -1) {
            throw new Error('BeforeToken not found');
        }
        for (const token of tokens) {
            const tokenIndex = this.tokens.indexOf(token);
            if (tokenIndex === -1) {
                throw new Error('Token not found');
            }
            this.tokens.splice(tokenIndex, 1);
            this.tokens.splice(beforeIndex, 0, token);
        }
        return this;
    }
    /**
     * @param before token to move rest before
     * @param tokens tokens to move before the first token
     */
    moveBefore(before, ...tokens) {
        return this.moveBeforeOrAfter('before', before, ...tokens);
    }
    moveAfter(after, ...tokens) {
        return this.moveBeforeOrAfter('after', after, ...tokens);
    }
    addAfter(after, ...token) {
        const index = this.tokens.indexOf(after);
        if (index === -1) {
            throw new Error('Token not found');
        }
        this.tokens.splice(index + 1, 0, ...token);
        return this;
    }
    delete(...token) {
        for (const t of token) {
            const index = this.tokens.indexOf(t);
            if (index === -1) {
                throw new Error('Token not found');
            }
            this.tokens.splice(index, 1);
        }
        return this;
    }
    build(lexerConfig) {
        return new Lexer(this.tokens, {
            positionTracking: 'onlyStart',
            recoveryEnabled: false,
            ensureOptimizations: true,
            // SafeMode: true,
            // SkipValidations: true,
            ...lexerConfig,
        });
    }
    get tokenVocabulary() {
        return this.tokens;
    }
}
//# sourceMappingURL=LexerBuilder.js.map