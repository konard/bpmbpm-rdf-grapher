export class AstCoreFactory {
    tracksSourceLocation;
    constructor(args = {}) {
        this.tracksSourceLocation = args.tracksSourceLocation ?? true;
    }
    wrap(val, loc) {
        return { val, loc };
    }
    isLocalized(obj) {
        return typeof obj === 'object' && obj !== null && 'loc' in obj &&
            typeof obj.loc === 'object' && obj.loc !== null && 'sourceLocationType' in obj.loc;
    }
    sourceLocation(...elements) {
        if (!this.tracksSourceLocation) {
            return this.gen();
        }
        const pureElements = elements.filter(x => x !== undefined);
        if (pureElements.length === 0) {
            return this.sourceLocationNoMaterialize();
        }
        const filtered = pureElements.filter(element => !this.isLocalized(element) || this.isSourceLocationSource(element.loc) ||
            this.isSourceLocationStringReplace(element.loc) || this.isSourceLocationNodeReplace(element.loc));
        if (filtered.length === 0) {
            return this.gen();
        }
        const first = filtered.at(0);
        const last = filtered.at(-1);
        return {
            sourceLocationType: 'source',
            start: this.isLocalized(first) ?
                first.loc.start :
                first.startOffset,
            end: this.isLocalized(last) ?
                last.loc.end :
                (last.endOffset + 1),
        };
    }
    sourceLocationNoMaterialize() {
        if (!this.tracksSourceLocation) {
            return this.gen();
        }
        return { sourceLocationType: 'noMaterialize' };
    }
    /**
     * Returns a copy of the argument that is not materialized
     */
    dematerialized(arg) {
        return { ...arg, loc: this.sourceLocationNoMaterialize() };
    }
    safeObjectTransform(value, mapper) {
        if (value && typeof value === 'object') {
            // If you wonder why this is all so hard, this is the reason. We cannot lose the methods of our Array objects
            if (Array.isArray(value)) {
                return value.map(x => this.safeObjectTransform(x, mapper));
            }
            return mapper(value);
        }
        return value;
    }
    forcedAutoGenTree(obj) {
        const copy = { ...obj };
        for (const [key, value] of Object.entries(copy)) {
            copy[key] = this.safeObjectTransform(value, obj => this.forcedAutoGenTree(obj));
        }
        if (this.isLocalized(copy)) {
            copy.loc = this.gen();
        }
        return copy;
    }
    forceMaterialized(arg) {
        if (this.isSourceLocationNoMaterialize(arg.loc)) {
            return this.forcedAutoGenTree(arg);
        }
        return { ...arg };
    }
    isSourceLocation(loc) {
        return 'sourceLocationType' in loc;
    }
    sourceLocationSource(start, end) {
        return {
            sourceLocationType: 'source',
            start,
            end,
        };
    }
    /**
     * {@inheritDoc SourceLocationInlinedSource}
     */
    sourceLocationInlinedSource(newSource, subLoc, start, end, startOnNew = 0, endOnNew = newSource.length) {
        if (!this.tracksSourceLocation) {
            return this.gen();
        }
        if (this.isSourceLocationSource(subLoc)) {
            startOnNew = subLoc.start;
            endOnNew = subLoc.end;
        }
        return {
            sourceLocationType: 'inlinedSource',
            newSource,
            start,
            end,
            loc: subLoc,
            startOnNew,
            endOnNew,
        };
    }
    ;
    isSourceLocationInlinedSource(loc) {
        return this.isSourceLocation(loc) && loc.sourceLocationType === 'inlinedSource';
    }
    gen() {
        return { sourceLocationType: 'autoGenerate' };
    }
    isSourceLocationSource(loc) {
        return this.isSourceLocation(loc) && loc.sourceLocationType === 'source';
    }
    sourceLocationStringReplace(newSource, start, end) {
        if (!this.tracksSourceLocation) {
            return this.gen();
        }
        return { sourceLocationType: 'stringReplace', newSource, start, end };
    }
    isSourceLocationStringReplace(loc) {
        return this.isSourceLocation(loc) && loc.sourceLocationType === 'stringReplace';
    }
    sourceLocationNodeReplaceUnsafe(loc) {
        if (this.isSourceLocationSource(loc)) {
            return this.sourceLocationNodeReplace(loc);
        }
        if (this.isSourceLocationInlinedSource(loc)) {
            return this.sourceLocationNodeReplaceUnsafe(loc.loc);
        }
        throw new Error(`Cannot convert SourceLocation of type ${loc.sourceLocationType} to SourceLocationNodeReplace`);
    }
    sourceLocationNodeReplace(startOrLoc, end) {
        let starting;
        let ending;
        if (typeof startOrLoc === 'number') {
            starting = startOrLoc;
            ending = end;
        }
        else {
            starting = startOrLoc.start;
            ending = startOrLoc.end;
        }
        return {
            sourceLocationType: 'nodeReplace',
            start: starting,
            end: ending,
        };
    }
    isSourceLocationNodeReplace(loc) {
        return this.isSourceLocation(loc) && loc.sourceLocationType === 'nodeReplace';
    }
    isSourceLocationNodeAutoGenerate(loc) {
        return this.isSourceLocation(loc) && loc.sourceLocationType === 'autoGenerate';
    }
    isPrintingLoc(loc) {
        return this.isSourceLocationNodeReplace(loc) ||
            this.isSourceLocationNodeAutoGenerate(loc) ||
            (this.isSourceLocationInlinedSource(loc) && this.isPrintingLoc(loc.loc));
    }
    printFilter(node, callback) {
        if (this.isPrintingLoc(node.loc)) {
            callback();
        }
    }
    isSourceLocationNoMaterialize(loc) {
        return this.isSourceLocation(loc) && loc.sourceLocationType === 'noMaterialize';
    }
    isOfType(obj, type) {
        const casted = obj;
        return casted.type === type;
    }
    isOfSubType(obj, type, subType) {
        const temp = obj;
        return temp.type === type && temp.subType === subType;
    }
}
//# sourceMappingURL=AstCoreFactory.js.map