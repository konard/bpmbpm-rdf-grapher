{"version":3,"file":"TransformerSubTyped.js","sourceRoot":"","sources":["../../../../lib/transformers/TransformerSubTyped.ts"],"names":[],"mappings":"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","sourcesContent":["import type { SubTyped, Typed } from '../types.js';\nimport type {\n  TransformContext,\n  VisitContext,\n} from './TransformerObject.js';\nimport type { DefaultNodePreVisitor, Safeness, SafeWrap } from './TransformerTyped.js';\nimport { TransformerTyped } from './TransformerTyped.js';\n\nexport class TransformerSubTyped<Nodes extends Typed> extends TransformerTyped<Nodes> {\n  public constructor(\n    defaultContext: TransformContext = {},\n    defaultNodePreVisitor: DefaultNodePreVisitor<Nodes> = {},\n  ) {\n    super(defaultContext, defaultNodePreVisitor);\n  };\n\n  public override clone(\n    newDefaultContext: TransformContext = {},\n    newDefaultNodePreVisitor: DefaultNodePreVisitor<Nodes> = {},\n  ): TransformerSubTyped<Nodes> {\n    return new TransformerSubTyped(\n      { ...this.defaultContext, ...newDefaultContext },\n      { ...this.defaultNodePreVisitor, ...newDefaultNodePreVisitor },\n    );\n  }\n\n  /**\n   * Transform a single node ({@link Typed}).\n   * Similar to {@link this.transformNode} but also allowing you to target the subTypes.\n   * @param startObject the object from which we will start the transformation,\n   *   potentially visiting and transforming its descendants along the way.\n   * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally\n   *    containing preVisitor and transformer.\n   *    The preVisitor allows you to provide {@link TransformContext} for the current object,\n   *    altering how it will be transformed.\n   *    The transformer allows you to manipulate the copy of the current object,\n   *    and expects you to return the value that should take the current objects place.\n   * @param nodeSpecificCallBacks Same as nodeCallBacks but using an additional level of indirection to\n   *     indicate the subType.\n   * @return the result of transforming the requested descendant operations (based on the preVisitor)\n   * using a transformer that works its way back up from the descendant to the startObject.\n   */\n  public transformNodeSpecific<Safe extends Safeness = 'safe', OutType = unknown>(\n    startObject: object,\n    nodeCallBacks: {[T in Nodes['type']]?: {\n      transform?: (copy: SafeWrap<Safe, Extract<Nodes, Typed<T>>>, orig: Extract<Nodes, Typed<T>>) => unknown;\n      preVisitor?: (orig: Extract<Nodes, Typed<T>>) => TransformContext;\n    }},\n    nodeSpecificCallBacks: {[Type in Nodes['type']]?: {\n      [SubType in Extract<Nodes, SubTyped<Type>>['subType']]?: {\n        transform?: (op: SafeWrap<Safe, Extract<Nodes, SubTyped<Type, SubType>>>) => unknown;\n        preVisitor?: (op: Extract<Nodes, SubTyped<Type, SubType>>) => TransformContext;\n      }}},\n  ): Safe extends 'unsafe' ? OutType : unknown {\n    const transformWrapper = (copy: object, orig: object): unknown => {\n      let ogTransform: ((copy: any, orig: any) => unknown) | undefined;\n      const casted = <SubTyped<Nodes['type']>>copy;\n      if (casted.type && casted.subType) {\n        const specific = nodeSpecificCallBacks[casted.type];\n        if (specific) {\n          ogTransform = specific[<keyof typeof specific> casted.subType]?.transform;\n        }\n        if (!ogTransform) {\n          ogTransform = nodeCallBacks[casted.type]?.transform;\n        }\n      }\n      return ogTransform ? ogTransform(casted, orig) : copy;\n    };\n    const preVisitWrapper = (curObject: object): VisitContext => {\n      let ogPreVisit: ((node: any) => VisitContext) | undefined;\n      const casted = <SubTyped<Nodes['type']>>curObject;\n      if (casted.type && casted.subType) {\n        const specific = nodeSpecificCallBacks[casted.type];\n        if (specific) {\n          ogPreVisit = specific[<keyof typeof specific> casted.subType]?.preVisitor;\n        }\n        if (!ogPreVisit) {\n          ogPreVisit = nodeCallBacks[casted.type]?.preVisitor;\n        }\n      }\n      return ogPreVisit ? ogPreVisit(casted) : {};\n    };\n    return <any> this.transformObject(startObject, transformWrapper, preVisitWrapper);\n  }\n\n  /**\n   * Visit a selected subTree given a startObject, steering the visits based on {@link Typed} nodes.\n   * Similar to {@link this.visitNode}, but also allowing you to target subTypes.\n   * Will call the preVisitor on the outer distinct, then the visitor of the special distinct,\n   * followed by the visiting the outer distinct, printing '231'.\n   * The pre-visitor visits starting from the root, going deeper, while the actual visitor goes in reverse.\n   * @param startObject the object from which we will start visiting,\n   *   potentially visiting its descendants along the way.\n   * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally\n   *    containing preVisitor and visitor.\n   *    The preVisitor allows you to provide {@link VisitContext} for the current object,\n   *    altering how it will be visited.\n   *    The visitor allows you to visit the object from deepest to the outermost object.\n   *    This is useful if you for example want to manipulate the objects you visit during your visits,\n   *    similar to {@link mapOperation}.\n   * @param nodeSpecificCallBacks Same as nodeCallBacks but using an additional level of indirection to\n   *     indicate the subType.\n   */\n  public visitNodeSpecific(\n    startObject: object,\n    nodeCallBacks: {[T in Nodes['type']]?: {\n      visitor?: (op: Extract<Nodes, Typed<T>>) => void;\n      preVisitor?: (op: Extract<Nodes, Typed<T>>) => VisitContext;\n    }},\n    nodeSpecificCallBacks: {[Type in Nodes['type']]?:\n      {[Subtype in Extract<Nodes, SubTyped<Type>>['subType']]?: {\n        visitor?: (op: Extract<Nodes, SubTyped<Type, Subtype>>) => void;\n        preVisitor?: (op: Extract<Nodes, SubTyped<Type, Subtype>>) => VisitContext;\n      }}},\n  ): void {\n    const visitWrapper = (curObject: object): void => {\n      let ogTransform: ((node: any) => void) | undefined;\n      const casted = <SubTyped<Nodes['type']>>curObject;\n      if (casted.type && casted.subType) {\n        const specific = nodeSpecificCallBacks[casted.type];\n        if (specific) {\n          ogTransform = specific[<keyof typeof specific> casted.subType]?.visitor;\n        }\n        if (!ogTransform) {\n          ogTransform = nodeCallBacks[casted.type]?.visitor;\n        }\n      }\n      if (ogTransform) {\n        ogTransform(casted);\n      }\n    };\n    const preVisitWrapper = (curObject: object): VisitContext => {\n      let ogPreVisit: ((node: any) => VisitContext) | undefined;\n      const casted = <SubTyped<Nodes['type']>>curObject;\n      if (casted.type && casted.subType) {\n        const specific = nodeSpecificCallBacks[casted.type];\n        if (specific) {\n          ogPreVisit = specific[<keyof typeof specific> casted.subType]?.preVisitor;\n        }\n        if (!ogPreVisit) {\n          ogPreVisit = nodeCallBacks[casted.type]?.preVisitor;\n        }\n      }\n      return ogPreVisit ? ogPreVisit(casted) : {};\n    };\n    this.visitObject(startObject, visitWrapper, preVisitWrapper);\n  }\n}\n"]}