{"version":3,"file":"TransformerTyped.js","sourceRoot":"","sources":["../../../../lib/transformers/TransformerTyped.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Typed } from '../types.js';\nimport type { TransformContext, VisitContext } from './TransformerObject.js';\nimport { TransformerObject } from './TransformerObject.js';\n\nexport type Safeness = 'safe' | 'unsafe';\nexport type SafeWrap<Safe extends Safeness, obj extends object> =\n  Safe extends 'safe' ? {[key in keyof obj]: unknown } : obj;\n\nexport type DefaultNodePreVisitor<Nodes extends Typed> = {[T in Nodes['type']]?: TransformContext };\n\nexport class TransformerTyped<Nodes extends Typed> extends TransformerObject {\n  public constructor(\n    defaultContext: TransformContext = {},\n    protected defaultNodePreVisitor: DefaultNodePreVisitor<Nodes> = {},\n  ) {\n    super(defaultContext);\n  };\n\n  public override clone(\n    newDefaultContext: TransformContext = {},\n    newDefaultNodePreVisitor: DefaultNodePreVisitor<Nodes> = {},\n  ): TransformerTyped<Nodes> {\n    return new TransformerTyped(\n      { ...this.defaultContext, ...newDefaultContext },\n      { ...this.defaultNodePreVisitor, ...newDefaultNodePreVisitor },\n    );\n  }\n\n  /**\n   * Transform a single node ({@link Typed}).\n   * @param startObject the object from which we will start the transformation,\n   *   potentially visiting and transforming its descendants along the way.\n   * @param nodeCallBacks a dictionary mapping the various node types to objects optionally\n   *    containing preVisitor and transformer.\n   *    The preVisitor allows you to provide {@link TransformContext} for the current object,\n   *    altering how it will be transformed.\n   *    The transformer allows you to manipulate the copy of the current object,\n   *    and expects you to return the value that should take the current objects place.\n   * @return the result of transforming the requested descendant operations (based on the preVisitor)\n   * using a transformer that works its way back up from the descendant to the startObject.\n   */\n  public transformNode<Safe extends Safeness = 'safe', OutType = unknown>(\n    startObject: object,\n    nodeCallBacks: {[T in Nodes['type']]?: {\n      transform?: (copy: SafeWrap<Safe, Extract<Nodes, Typed<T>>>, orig: Extract<Nodes, Typed<T>>) => unknown;\n      preVisitor?: (orig: Extract<Nodes, Typed<T>>) => TransformContext;\n    }},\n  ): Safe extends 'unsafe' ? OutType : unknown {\n    const transformWrapper = (copy: object, orig: object): unknown => {\n      let ogTransform: ((copy: any, orig: any) => unknown) | undefined;\n      const casted = <Typed<Nodes['type']>>copy;\n      if (casted.type) {\n        ogTransform = nodeCallBacks[casted.type]?.transform;\n      }\n      return ogTransform ? ogTransform(casted, orig) : copy;\n    };\n    const nodeDefaults = this.defaultNodePreVisitor;\n    const preVisitWrapper = (curObject: object): VisitContext => {\n      let ogPreVisit: ((node: any) => VisitContext) | undefined;\n      let nodeContext: VisitContext = {};\n      const casted = <Typed<Nodes['type']>>curObject;\n      if (casted.type) {\n        ogPreVisit = nodeCallBacks[casted.type]?.preVisitor;\n        nodeContext = nodeDefaults[casted.type] ?? nodeContext;\n      }\n      return ogPreVisit ? { ...nodeContext, ...ogPreVisit(casted) } : nodeContext;\n    };\n    return <any> this.transformObject(startObject, transformWrapper, preVisitWrapper);\n  }\n\n  /**\n   * Visit a selected subTree given a startObject, steering the visits based on {@link Typed} nodes.\n   * Will first call the preVisitor on the project and notice it should not iterate on its descendants.\n   * It then visits the project, and the outermost distinct, printing '21'.\n   * The pre-visitor visits starting from the root, going deeper, while the actual visitor goes in reverse.\n   * @param startObject the object from which we will start visiting,\n   *   potentially visiting its descendants along the way.\n   * @param nodeCallBacks a dictionary mapping the various operation types to objects optionally\n   *    containing preVisitor and visitor.\n   *    The preVisitor allows you to provide {@link VisitContext} for the current object,\n   *    altering how it will be visited.\n   *    The visitor allows you to visit the object from deepest to the outermost object.\n   *    This is useful if you for example want to manipulate the objects you visit during your visits,\n   *    similar to {@link this.transformNode}.\n   */\n  public visitNode(\n    startObject: object,\n    nodeCallBacks: {[T in Nodes['type']]?: {\n      visitor?: (op: Extract<Nodes, Typed<T>>) => void;\n      preVisitor?: (op: Extract<Nodes, Typed<T>>) => VisitContext;\n    }},\n  ): void {\n    const visitorWrapper = (curObject: object): void => {\n      const casted = <Typed<Nodes['type']>>curObject;\n      if (casted.type) {\n        const ogTransform = nodeCallBacks[casted.type]?.visitor;\n        if (ogTransform) {\n          ogTransform(<any> casted);\n        }\n      }\n    };\n    const nodeDefaults = this.defaultNodePreVisitor;\n    const preVisitWrapper = (curObject: object): VisitContext => {\n      let ogPreVisit: ((node: any) => VisitContext) | undefined;\n      let nodeContext: VisitContext = {};\n      const casted = <Typed<Nodes['type']>>curObject;\n      if (casted.type) {\n        ogPreVisit = nodeCallBacks[casted.type]?.preVisitor;\n        nodeContext = nodeDefaults[casted.type] ?? nodeContext;\n      }\n      return ogPreVisit ? { ...nodeContext, ...ogPreVisit(casted) } : nodeContext;\n    };\n    return this.visitObject(startObject, visitorWrapper, preVisitWrapper);\n  }\n}\n"]}