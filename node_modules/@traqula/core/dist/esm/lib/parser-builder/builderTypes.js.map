{"version":3,"file":"builderTypes.js","sourceRoot":"","sources":["../../../../lib/parser-builder/builderTypes.ts"],"names":[],"mappings":"","sourcesContent":["import type { ParserMethod } from '@traqula/chevrotain';\nimport type { ParserRule } from './ruleDefTypes.js';\n\n/**\n * Get union-type of names used in list of ruledefs.\n */\nexport type ParseNamesFromList<T extends readonly { name: string }[]> = T[number]['name'];\n\n/**\n * Convert a list of ruledefs to a record that maps each rule name to its definition.\n */\nexport type ParseRuleMap<RuleNames extends string> = {[Key in RuleNames]: ParserRule<any, Key> };\n\n/**\n * Convert a list of RuleDefs to a Record with the name of the RuleDef as the key, matching the RuleDefMap type.\n */\nexport type ParseRulesToObject<\n  T extends readonly ParserRule[],\n  Names extends string = ParseNamesFromList<T>,\n  Agg extends Record<string, ParserRule> = Record<never, never>,\n> = T extends readonly [infer First, ...infer Rest] ? (\n  First extends ParserRule ? (\n    Rest extends readonly ParserRule[] ? (\n      ParseRulesToObject<Rest, Names, {[K in keyof Agg | First['name']]: K extends First['name'] ? First : Agg[K] }>\n    ) : never\n  ) : never\n) : ParseRuleMap<Names> & Agg;\n\nexport type ParserFromRules<Context, Names extends string, RuleDefs extends ParseRuleMap<Names>> = {\n  [K in Names]: RuleDefs[K] extends ParserRule<Context, K, infer RET, infer ARGS> ?\n      (input: string, context: Context, ...args: ARGS) => RET : never\n};\n\nexport type ParseMethodsFromRules<Context, Names extends string, RuleDefs extends ParseRuleMap<Names>> = {\n  [K in Names]: RuleDefs[K] extends ParserRule<Context, K, infer RET, infer ARGS> ?\n    ParserMethod<[Context, ...ARGS], RET> : never\n};\n"]}