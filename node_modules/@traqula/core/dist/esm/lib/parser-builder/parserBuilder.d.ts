import type { ILexerConfig, IParserConfig, IRecognitionException, TokenType } from '@traqula/chevrotain';
import type { CheckOverlap } from '../utils.js';
import type { ParserFromRules, ParseRuleMap, ParseRulesToObject, ParseNamesFromList } from './builderTypes.js';
import type { ParserRule } from './ruleDefTypes.js';
export interface ParserBuildArgs {
    tokenVocabulary: readonly TokenType[];
    parserConfig?: IParserConfig;
    lexerConfig?: ILexerConfig;
    queryPreProcessor?: (input: string) => string;
    errorHandler?: (errors: IRecognitionException[]) => void;
}
/**
 * The grammar builder. This is the core of traqula (besides using the amazing chevrotain framework).
 * Using the builder you can create a grammar + AST creator.
 * At any point in time, a parser can be constructed from the added rules.
 * Constructing a parser will cause a validation which will validate the correctness of the grammar.
 */
export declare class ParserBuilder<Context, Names extends string, RuleDefs extends ParseRuleMap<Names>> {
    /**
     * Create a builder from some initial grammar rules or an existing builder.
     * If a builder is provided, a new copy will be created.
     */
    static create<Rules extends readonly ParserRule[] = readonly ParserRule[], Context = Rules[0] extends ParserRule<infer context> ? context : never, Names extends string = ParseNamesFromList<Rules>, RuleDefs extends ParseRuleMap<Names> = ParseRulesToObject<Rules>>(start: Rules | ParserBuilder<Context, Names, RuleDefs>): ParserBuilder<Context, Names, RuleDefs>;
    private rules;
    private constructor();
    widenContext<NewContext extends Context>(): ParserBuilder<NewContext, Names, {
        [Key in keyof RuleDefs]: Key extends Names ? (RuleDefs[Key] extends ParserRule<any, any, infer RT, infer PT> ? ParserRule<NewContext, Key, RT, PT> : never) : never;
    }>;
    typePatch<Patch extends {
        [Key in Names]?: [any] | [any, any[]];
    }>(): ParserBuilder<Context, Names, {
        [Key in Names]: Key extends keyof Patch ? (Patch[Key] extends [any, any[]] ? ParserRule<Context, Key, Patch[Key][0], Patch[Key][1]> : (Patch[Key] extends [any] ? (RuleDefs[Key] extends ParserRule<any, any, any, infer Par> ? ParserRule<Context, Key, Patch[Key][0], Par> : never) : never)) : (RuleDefs[Key] extends ParserRule<Context, Key> ? RuleDefs[Key] : never);
    }>;
    /**
     * Change the implementation of an existing grammar rule.
     */
    patchRule<U extends Names, RET, ARGS extends any[]>(patch: ParserRule<Context, U, RET, ARGS>): ParserBuilder<Context, Names, {
        [Key in Names]: Key extends U ? ParserRule<Context, Key, RET, ARGS> : (RuleDefs[Key] extends ParserRule<Context, Key> ? RuleDefs[Key] : never);
    }>;
    /**
     * Add a rule to the grammar. If the rule already exists, but the implementation differs, an error will be thrown.
     */
    addRuleRedundant<U extends string, RET, ARGS extends any[]>(rule: ParserRule<Context, U, RET, ARGS>): ParserBuilder<Context, Names | U, {
        [K in Names | U]: K extends U ? ParserRule<Context, K, RET, ARGS> : (K extends Names ? (RuleDefs[K] extends ParserRule<Context, K> ? RuleDefs[K] : never) : never);
    }>;
    /**
     * Add a rule to the grammar. Will raise a typescript error if the rule already exists in the grammar.
     */
    addRule<U extends string, RET, ARGS extends any[]>(rule: CheckOverlap<U, Names, ParserRule<Context, U, RET, ARGS>>): ParserBuilder<Context, Names | U, {
        [K in Names | U]: K extends U ? ParserRule<Context, K, RET, ARGS> : (K extends Names ? (RuleDefs[K] extends ParserRule<Context, K> ? RuleDefs[K] : never) : never);
    }>;
    addMany<U extends readonly ParserRule<Context>[]>(...rules: CheckOverlap<ParseNamesFromList<U>, Names, U>): ParserBuilder<Context, Names | ParseNamesFromList<U>, {
        [K in Names | ParseNamesFromList<U>]: K extends keyof ParseRulesToObject<typeof rules> ? (ParseRulesToObject<typeof rules>[K] extends ParserRule<Context, K> ? ParseRulesToObject<typeof rules>[K] : never) : (K extends Names ? (RuleDefs[K] extends ParserRule<Context, K> ? RuleDefs[K] : never) : never);
    }>;
    /**
     * Delete a grammar rule by its name.
     */
    deleteRule<U extends Names>(ruleName: U): ParserBuilder<Context, Exclude<Names, U>, {
        [K in Exclude<Names, U>]: RuleDefs[K] extends ParserRule<Context, K> ? RuleDefs[K] : never;
    }>;
    getRule<U extends Names>(ruleName: U): RuleDefs[U] extends ParserRule<any, U, infer RT, infer PT> ? ParserRule<Context, U, RT, PT> : never;
    /**
     * Merge this grammar builder with another.
     * It is best to merge the bigger grammar with the smaller one.
     * If the two builders both have a grammar rule with the same name,
     * no error will be thrown case they map to the same ruledef object.
     * If they map to a different object, an error will be thrown.
     * To fix this problem, the overridingRules array should contain a rule with the same conflicting name,
     * this rule implementation will be used.
     */
    merge<OtherNames extends string, OtherRules extends ParseRuleMap<OtherNames>, OW extends readonly ParserRule<Context>[]>(builder: ParserBuilder<Context, OtherNames, OtherRules>, overridingRules: OW): ParserBuilder<Context, Names | OtherNames | ParseNamesFromList<OW>, {
        [K in Names | OtherNames | ParseNamesFromList<OW>]: K extends keyof ParseRulesToObject<OW> ? (ParseRulesToObject<OW>[K] extends ParserRule<Context, K> ? ParseRulesToObject<OW>[K] : never) : (K extends Names ? (RuleDefs[K] extends ParserRule<Context, K> ? RuleDefs[K] : never) : K extends OtherNames ? (OtherRules[K] extends ParserRule<Context, K> ? OtherRules[K] : never) : never);
    }>;
    private defaultErrorHandler;
    build({ tokenVocabulary, parserConfig, lexerConfig, queryPreProcessor, errorHandler, }: ParserBuildArgs): ParserFromRules<Context, Names, RuleDefs>;
    private consume;
}
