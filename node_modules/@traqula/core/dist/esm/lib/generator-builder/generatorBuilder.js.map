{"version":3,"file":"generatorBuilder.js","sourceRoot":"","sources":["../../../../lib/generator-builder/generatorBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ParseNamesFromList } from '../parser-builder/builderTypes.js';\nimport type { CheckOverlap } from '../utils.js';\nimport type { GeneratorFromRules, GenRuleMap, GenRulesToObject } from './builderTypes.js';\nimport { DynamicGenerator } from './dynamicGenerator.js';\nimport type { GeneratorRule } from './generatorTypes.js';\n\n/**\n * Converts a list of ruledefs to a record mapping a name to the corresponding ruledef.\n */\nfunction listToRuleDefMap<T extends readonly GeneratorRule[]>(rules: T): GenRulesToObject<T> {\n  const newRules: Record<string, GeneratorRule> = {};\n  for (const rule of rules) {\n    newRules[rule.name] = rule;\n  }\n  return <GenRulesToObject<T>>newRules;\n}\n\nexport class GeneratorBuilder<Context, Names extends string, RuleDefs extends GenRuleMap<Names>> {\n  /**\n   * Create a GeneratorBuilder from some initial grammar rules or an existing GeneratorBuilder.\n   * If a GeneratorBuilder is provided, a new copy will be created.\n   */\n  public static create<Context, Names extends string, RuleDefs extends GenRuleMap<Names>>(\n    args: GeneratorBuilder<Context, Names, RuleDefs>\n  ): GeneratorBuilder<Context, Names, RuleDefs>;\n  public static create<\n    Rules extends readonly GeneratorRule[] = readonly GeneratorRule[],\n    Context = Rules[0] extends GeneratorRule<infer context> ? context : never,\n    Names extends string = ParseNamesFromList<Rules>,\n    RuleDefs extends GenRuleMap<Names> = GenRulesToObject<Rules>,\n  >(rules: Rules): GeneratorBuilder<Context, Names, RuleDefs>;\n  public static create<\n    Rules extends readonly GeneratorRule[] = readonly GeneratorRule[],\n    Context = Rules[0] extends GeneratorRule<infer context> ? context : never,\n    Names extends string = ParseNamesFromList<Rules>,\n    RuleDefs extends GenRuleMap<Names> = GenRulesToObject<Rules>,\n  >(\n    start: Rules | GeneratorBuilder<Context, Names, RuleDefs>,\n  ): GeneratorBuilder<Context, Names, RuleDefs> {\n    if (Array.isArray(start)) {\n      return <GeneratorBuilder<Context, Names, RuleDefs>> <unknown> new GeneratorBuilder(listToRuleDefMap(start));\n    }\n    return new GeneratorBuilder({ ...(<GeneratorBuilder<any, any, any>>start).rules });\n  }\n\n  private rules: RuleDefs;\n\n  private constructor(startRules: RuleDefs) {\n    this.rules = startRules;\n  }\n\n  public widenContext<NewContext extends Context>(): GeneratorBuilder<\n    NewContext,\n    Names,\n    {[Key in keyof RuleDefs]: Key extends Names ?\n        (RuleDefs[Key] extends GeneratorRule<any, any, infer RT, infer PT> ?\n          GeneratorRule<NewContext, Key, RT, PT> : never)\n      : never }\n  > {\n    return <any> this;\n  }\n\n  public typePatch<Patch extends {[Key in Names]?: [any] | [any, any[]]}>():\n  GeneratorBuilder<Context, Names, {[Key in Names]: Key extends keyof Patch ? (\n    Patch[Key] extends [any, any[]] ? GeneratorRule<Context, Key, Patch[Key][0], Patch[Key][1]> : (\n      // Only  one - infer arg yourself\n      Patch[Key] extends [ any ] ?\n        RuleDefs[Key] extends GeneratorRule<any, any, any, infer Par> ?\n          GeneratorRule<Context, Key, Patch[Key][0], Par> : never\n        : never\n    )) : RuleDefs[Key] extends GeneratorRule<any, Key> ? RuleDefs[Key] : never\n  }> {\n    return <any> this;\n  }\n\n  /**\n   * Change the implementation of an existing generator rule.\n   */\n  public patchRule<U extends Names, RET, ARGS extends any[]>(patch: GeneratorRule<Context, U, RET, ARGS>):\n  GeneratorBuilder<Context, Names, {[Key in Names]: Key extends U ?\n    GeneratorRule<Context, Key, RET, ARGS> :\n      (RuleDefs[Key] extends GeneratorRule<Context, Key> ? RuleDefs[Key] : never)\n  } > {\n    const self = <GeneratorBuilder<Context, Names, {[Key in Names]: Key extends U ?\n      GeneratorRule<Context, Key, RET, ARGS> :\n        (RuleDefs[Key] extends GeneratorRule<Context, Key> ? RuleDefs[Key] : never) }>>\n      <unknown> this;\n    self.rules[patch.name] = <any> patch;\n    return self;\n  }\n\n  /**\n   * Add a rule to the grammar. If the rule already exists, but the implementation differs, an error will be thrown.\n   */\n  public addRuleRedundant<U extends string, RET, ARGS extends any[]>(rule: GeneratorRule<Context, U, RET, ARGS>):\n  GeneratorBuilder<Context, Names | U, {[K in Names | U]: K extends Names ?\n      (RuleDefs[K] extends GeneratorRule<Context, K> ? RuleDefs[K] : never)\n    : (K extends U ? GeneratorRule<Context, K, RET, ARGS> : never)\n  }> {\n    const self = <GeneratorBuilder<Context, Names | U, {[K in Names | U]: K extends Names ?\n        (RuleDefs[K] extends GeneratorRule<Context, K> ? RuleDefs[K] : never)\n      : (K extends U ? GeneratorRule<Context, K, RET, ARGS> : never) }>>\n      <unknown> this;\n    const rules = <Record<string, GeneratorRule<Context>>> self.rules;\n    if (rules[rule.name] !== undefined && rules[rule.name] !== rule) {\n      throw new Error(`Rule ${rule.name} already exists in the GeneratorBuilder`);\n    }\n    rules[rule.name] = rule;\n    return self;\n  }\n\n  /**\n   * Add a rule to the grammar. Will raise a typescript error if the rule already exists in the grammar.\n   */\n  public addRule<U extends string, RET, ARGS extends any[]>(\n    rule: CheckOverlap<U, Names, GeneratorRule<Context, U, RET, ARGS>>,\n  ): GeneratorBuilder<Context, Names | U, {[K in Names | U]: K extends Names ?\n      (RuleDefs[K] extends GeneratorRule<Context, K> ? RuleDefs[K] : never)\n    : (K extends U ? GeneratorRule<Context, K, RET, ARGS> : never)\n  }> {\n    return this.addRuleRedundant(rule);\n  }\n\n  public addMany<U extends readonly GeneratorRule<Context>[]>(\n    ...rules: CheckOverlap<ParseNamesFromList<U>, Names, U>\n  ): GeneratorBuilder<\n    Context,\n    Names | ParseNamesFromList<U>,\n    {[K in Names | ParseNamesFromList<U>]:\n      K extends keyof GenRulesToObject<typeof rules> ? (\n        GenRulesToObject<typeof rules>[K] extends GeneratorRule<Context, K> ? GenRulesToObject<typeof rules>[K] : never\n      ) : (\n        K extends Names ? (RuleDefs[K] extends GeneratorRule<Context, K> ? RuleDefs[K] : never) : never\n      )\n    }\n  > {\n    this.rules = { ...this.rules, ...listToRuleDefMap(rules) };\n    return <any> <unknown> this;\n  }\n\n  /**\n   * Delete a grammar rule by its name.\n   */\n  public deleteRule<U extends Names>(ruleName: U):\n  GeneratorBuilder<Context, Exclude<Names, U>, {[K in Exclude<Names, U>]:\n    RuleDefs[K] extends GeneratorRule<Context, K> ? RuleDefs[K] : never }> {\n    delete this.rules[ruleName];\n    return <GeneratorBuilder<Context, Exclude<Names, U>, {[K in Exclude<Names, U>]:\n      RuleDefs[K] extends GeneratorRule<Context, K> ? RuleDefs[K] : never }>>\n      <unknown> this;\n  }\n\n  public getRule<U extends Names>(ruleName: U): RuleDefs[U] extends GeneratorRule<any, U, infer RT, infer PT> ?\n    GeneratorRule<Context, U, RT, PT> : never {\n    return <any> this.rules[ruleName];\n  }\n\n  /**\n   * Merge this grammar GeneratorBuilder with another.\n   * It is best to merge the bigger grammar with the smaller one.\n   * If the two builders both have a grammar rule with the same name,\n   * no error will be thrown case they map to the same ruledef object.\n   * If they map to a different object, an error will be thrown.\n   * To fix this problem, the overridingRules array should contain a rule with the same conflicting name,\n   * this rule implementation will be used.\n   */\n  public merge<\n    OtherNames extends string,\n    OtherRules extends GenRuleMap<OtherNames>,\n    OW extends readonly GeneratorRule<Context>[],\n  >(\n    GeneratorBuilder: GeneratorBuilder<Context, OtherNames, OtherRules>,\n    overridingRules: OW,\n  ):\n    GeneratorBuilder<\n      Context,\n      Names | OtherNames | ParseNamesFromList<OW>,\n      {[K in Names | OtherNames | ParseNamesFromList<OW>]:\n        K extends keyof GenRulesToObject<OW> ? (\n          GenRulesToObject<OW>[K] extends GeneratorRule<Context, K> ? GenRulesToObject<OW>[K] : never\n        )\n          : (\n              K extends Names ? (RuleDefs[K] extends GeneratorRule<Context, K> ? RuleDefs[K] : never)\n                : K extends OtherNames ? (OtherRules[K] extends GeneratorRule<Context, K> ? OtherRules[K] : never)\n                  : never\n            ) }\n    > {\n    // Assume the other grammar is bigger than yours. So start from that one and add this one\n    const otherRules: Record<string, GeneratorRule<Context>> = { ...GeneratorBuilder.rules };\n    const myRules: Record<string, GeneratorRule<Context>> = this.rules;\n\n    for (const rule of Object.values(myRules)) {\n      if (otherRules[rule.name] === undefined) {\n        otherRules[rule.name] = rule;\n      } else {\n        const existingRule = otherRules[rule.name];\n        // If same rule, no issue, move on. Else\n        if (existingRule !== rule) {\n          const override = overridingRules.find(x => x.name === rule.name);\n          // If override specified, take override, else, inform user that there is a conflict\n          if (override) {\n            otherRules[rule.name] = override;\n          } else {\n            throw new Error(`Rule with name \"${rule.name}\" already exists in the GeneratorBuilder, specify an override to resolve conflict`);\n          }\n        }\n      }\n    }\n\n    this.rules = <any> <unknown> otherRules;\n    return <any> <unknown> this;\n  }\n\n  public build(): GeneratorFromRules<Context, Names, RuleDefs> {\n    return <GeneratorFromRules<Context, Names, RuleDefs>> new DynamicGenerator(this.rules);\n  }\n}\n"]}