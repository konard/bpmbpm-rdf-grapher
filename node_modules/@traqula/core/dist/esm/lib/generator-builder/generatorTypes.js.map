{"version":3,"file":"generatorTypes.js","sourceRoot":"","sources":["../../../../lib/generator-builder/generatorTypes.ts"],"names":[],"mappings":"","sourcesContent":["import type { Localized } from '../types.js';\n\n/**\n * Type used to declare generator rules.\n */\nexport type GeneratorRule<\n  /**\n   * Context object available in rule implementation.\n   */\n  Context = any,\n  /**\n   * Name of grammar rule, should be a strict subtype of string like 'myGrammarRule'.\n   */\n  NameType extends string = string,\n  /**\n   * Type that of the AST that we will generate the string for.\n   * This type will be the provided when calling SUBRULE with this generator rule.\n   * Generation happens on a per AST node basis.\n   * The core will implement the generation as such. If this ever changes, we will cross that bridge when we get there.\n   */\n  AstType = any,\n  /**\n   * Function arguments that can be given to convey the state of the current parse operation.\n   */\n  ParamType extends any[] = any[],\n> = {\n  name: NameType;\n  gImpl: (def: RuleDefArg) =>\n  (ast: AstType, context: Context, ...params: ParamType) => void;\n};\n\nexport interface RuleDefArg {\n  /**\n   * Call another generator rule so it can generate its string representation.\n   * @param rule the rule to be called\n   * @param input the ast input to work on\n   * @param arg the remaining parameters required by this rule.\n   */\n  SUBRULE: <T, U extends any[]>(rule: GeneratorRule<any, any, T, U>, input: T, ...arg: U) => void;\n  /**\n   * Print the characters to the output string\n   * @param args arguments to be printed\n   */\n  PRINT: (...args: string[]) => void;\n  /**\n   * Ensures the requested characters are printed at the current location.\n   * Will not change the constructed string in case either:\n   *  1. The string builder ends in the to ensure string.\n   *  2: The next printed string starts with the ensure string.\n   * Otherwise, prints the sting.\n   */\n  ENSURE: (...args: string[]) => void;\n  /**\n   * Ensures either one of the provided strings. If no string can be ensured, it will print the first argument.\n   */\n  ENSURE_EITHER: (...args: string[]) => void;\n  /**\n   * Create a new line, will ensure the previous line does not end in blank characters.\n   * Will only print a newline if the pointer is not currently on a new line.\n   * When the traqulaIndentation is changed in the meanwhile, this will ensure the indentation of teh pointer updated.\n   */\n  NEW_LINE: (arg?: {\n    /**\n     * Whether the newline should be printed regardless of the pointer is already on an empty newline.\n     */\n    force?: boolean;\n  }) => void;\n  /**\n   * Handles the location of a node as if it was generated using a SUBRULE.\n   * Can be used to generate many nodes within a single subrule call while still having correct localization handling.\n   * @param loc\n   * @param nodeHandle\n   * @constructor\n   */\n  HANDLE_LOC: <T>(loc: Localized, nodeHandle: () => T) => T | undefined;\n  /**\n   * Catchup the string until a given length,\n   * printing everything from the current catchup location until the index you provide.\n   * @param until\n   * @constructor\n   */\n  CATCHUP: (until: number) => void;\n\n  // Derivations from the above fundamental functions\n  /**\n   * Prints all arguments as one word, ensuring it has a space before and behind each word\n   * @param args\n   */\n  PRINT_WORD: (...args: string[]) => void;\n  /**\n   * Prints all arguments as words, ensuring they all have a space before and behind them.\n   * @param args\n   */\n  PRINT_WORDS: (...args: string[]) => void;\n  /**\n   * Start a newline to print arguments on\n   */\n  PRINT_ON_EMPTY: (...args: string[]) => void;\n  /**\n   * Prints arguments on its own (shared) line\n   */\n  PRINT_ON_OWN_LINE: (...args: string[]) => void;\n}\n"]}