import type { ParseNamesFromList } from '../parser-builder/builderTypes.js';
import type { CheckOverlap } from '../utils.js';
import type { GeneratorFromRules, GenRuleMap, GenRulesToObject } from './builderTypes.js';
import type { GeneratorRule } from './generatorTypes.js';
export declare class GeneratorBuilder<Context, Names extends string, RuleDefs extends GenRuleMap<Names>> {
    /**
     * Create a GeneratorBuilder from some initial grammar rules or an existing GeneratorBuilder.
     * If a GeneratorBuilder is provided, a new copy will be created.
     */
    static create<Context, Names extends string, RuleDefs extends GenRuleMap<Names>>(args: GeneratorBuilder<Context, Names, RuleDefs>): GeneratorBuilder<Context, Names, RuleDefs>;
    static create<Rules extends readonly GeneratorRule[] = readonly GeneratorRule[], Context = Rules[0] extends GeneratorRule<infer context> ? context : never, Names extends string = ParseNamesFromList<Rules>, RuleDefs extends GenRuleMap<Names> = GenRulesToObject<Rules>>(rules: Rules): GeneratorBuilder<Context, Names, RuleDefs>;
    private rules;
    private constructor();
    widenContext<NewContext extends Context>(): GeneratorBuilder<NewContext, Names, {
        [Key in keyof RuleDefs]: Key extends Names ? (RuleDefs[Key] extends GeneratorRule<any, any, infer RT, infer PT> ? GeneratorRule<NewContext, Key, RT, PT> : never) : never;
    }>;
    typePatch<Patch extends {
        [Key in Names]?: [any] | [any, any[]];
    }>(): GeneratorBuilder<Context, Names, {
        [Key in Names]: Key extends keyof Patch ? (Patch[Key] extends [any, any[]] ? GeneratorRule<Context, Key, Patch[Key][0], Patch[Key][1]> : (Patch[Key] extends [any] ? RuleDefs[Key] extends GeneratorRule<any, any, any, infer Par> ? GeneratorRule<Context, Key, Patch[Key][0], Par> : never : never)) : RuleDefs[Key] extends GeneratorRule<any, Key> ? RuleDefs[Key] : never;
    }>;
    /**
     * Change the implementation of an existing generator rule.
     */
    patchRule<U extends Names, RET, ARGS extends any[]>(patch: GeneratorRule<Context, U, RET, ARGS>): GeneratorBuilder<Context, Names, {
        [Key in Names]: Key extends U ? GeneratorRule<Context, Key, RET, ARGS> : (RuleDefs[Key] extends GeneratorRule<Context, Key> ? RuleDefs[Key] : never);
    }>;
    /**
     * Add a rule to the grammar. If the rule already exists, but the implementation differs, an error will be thrown.
     */
    addRuleRedundant<U extends string, RET, ARGS extends any[]>(rule: GeneratorRule<Context, U, RET, ARGS>): GeneratorBuilder<Context, Names | U, {
        [K in Names | U]: K extends Names ? (RuleDefs[K] extends GeneratorRule<Context, K> ? RuleDefs[K] : never) : (K extends U ? GeneratorRule<Context, K, RET, ARGS> : never);
    }>;
    /**
     * Add a rule to the grammar. Will raise a typescript error if the rule already exists in the grammar.
     */
    addRule<U extends string, RET, ARGS extends any[]>(rule: CheckOverlap<U, Names, GeneratorRule<Context, U, RET, ARGS>>): GeneratorBuilder<Context, Names | U, {
        [K in Names | U]: K extends Names ? (RuleDefs[K] extends GeneratorRule<Context, K> ? RuleDefs[K] : never) : (K extends U ? GeneratorRule<Context, K, RET, ARGS> : never);
    }>;
    addMany<U extends readonly GeneratorRule<Context>[]>(...rules: CheckOverlap<ParseNamesFromList<U>, Names, U>): GeneratorBuilder<Context, Names | ParseNamesFromList<U>, {
        [K in Names | ParseNamesFromList<U>]: K extends keyof GenRulesToObject<typeof rules> ? (GenRulesToObject<typeof rules>[K] extends GeneratorRule<Context, K> ? GenRulesToObject<typeof rules>[K] : never) : (K extends Names ? (RuleDefs[K] extends GeneratorRule<Context, K> ? RuleDefs[K] : never) : never);
    }>;
    /**
     * Delete a grammar rule by its name.
     */
    deleteRule<U extends Names>(ruleName: U): GeneratorBuilder<Context, Exclude<Names, U>, {
        [K in Exclude<Names, U>]: RuleDefs[K] extends GeneratorRule<Context, K> ? RuleDefs[K] : never;
    }>;
    getRule<U extends Names>(ruleName: U): RuleDefs[U] extends GeneratorRule<any, U, infer RT, infer PT> ? GeneratorRule<Context, U, RT, PT> : never;
    /**
     * Merge this grammar GeneratorBuilder with another.
     * It is best to merge the bigger grammar with the smaller one.
     * If the two builders both have a grammar rule with the same name,
     * no error will be thrown case they map to the same ruledef object.
     * If they map to a different object, an error will be thrown.
     * To fix this problem, the overridingRules array should contain a rule with the same conflicting name,
     * this rule implementation will be used.
     */
    merge<OtherNames extends string, OtherRules extends GenRuleMap<OtherNames>, OW extends readonly GeneratorRule<Context>[]>(GeneratorBuilder: GeneratorBuilder<Context, OtherNames, OtherRules>, overridingRules: OW): GeneratorBuilder<Context, Names | OtherNames | ParseNamesFromList<OW>, {
        [K in Names | OtherNames | ParseNamesFromList<OW>]: K extends keyof GenRulesToObject<OW> ? (GenRulesToObject<OW>[K] extends GeneratorRule<Context, K> ? GenRulesToObject<OW>[K] : never) : (K extends Names ? (RuleDefs[K] extends GeneratorRule<Context, K> ? RuleDefs[K] : never) : K extends OtherNames ? (OtherRules[K] extends GeneratorRule<Context, K> ? OtherRules[K] : never) : never);
    }>;
    build(): GeneratorFromRules<Context, Names, RuleDefs>;
}
