<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RDF Grapher ver7so - Визуализация RDF данных с поддержкой TriG + SPARQL Smart Design + Ontology </title>

    <!--
        RDF Grapher ver7so - Сервис для парсинга RDF данных и их визуализации в виде графа
        Новые возможности ver7so: SPARQL Smart Design + Ontology
        Новые возможности ver6d:
        - Поддержка TriG формата с именованными графами
        - Отображение имени схемы (именованного графа) как заголовка диаграммы
        - Режим VAD (Value Added Chain Diagram): процессы отображаются как cds-фигуры
        - Поддержка исполнителей процессов через ExecutorGroup
        - Валидация VAD-данных на соответствие разрешенным типам и предикатам
        - Специальные стили для VAD элементов
        - Связи hasNext между процессами с направлением восток-запад

        Этот сервис является продолжением https://www.ldf.fi/service/rdf-grapher в части BPM
        Использует клиентские JavaScript библиотеки:
        - N3.js для парсинга RDF (замена Redland Raptor)
        - Viz.js для рендеринга графов (замена Graphviz)

        Сервис работает полностью на стороне клиента и может быть размещен на GitHub Pages
    -->

    <!-- Стили для интерфейса -->
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Контейнер для панелей свойств узлов -->
    <div id="properties-panels-container"></div>

    <div class="description">
        <p>
            <strong>Загрузить пример RDF данных:</strong>
            <span class="example-link" onclick="loadExampleTurtle()">Turtle</span> |
            <span class="example-link" onclick="loadExampleVAD()">Turtle VAD</span> |
            <span class="example-link" onclick="loadExampleNTriples()">N-Triples</span> |
            <span class="example-link" onclick="loadExampleNQuads()">N-Quads</span> |
            <span class="example-link" onclick="loadExampleTriG()">TriG</span> |
            <span class="example-link" onclick="loadExampleTrigVAD()">Trig VAD</span> |
            <span class="example-link" onclick="loadExampleTrigVADv2()">Trig VADv2</span>
        </p>
    </div>

    <div class="container">
        <div class="rdf-input-header">
            <label for="rdf-input">RDF данные или URI:</label>
            <button class="show-in-window-btn" onclick="showRdfInSeparateWindow()">Показать в отдельном окне</button>
        </div>
        <textarea id="rdf-input" placeholder="Введите RDF данные в формате Turtle, N-Triples, N-Quads или TriG..."></textarea>

        <div class="format-selectors">
            <div class="form-group">
                <label for="input-format">Входной формат:</label>
                <select id="input-format">
                    <option value="turtle" selected>Turtle</option>
                    <option value="n-triples">N-Triples</option>
                    <option value="n-quads">N-Quads</option>
                    <option value="trig">TriG</option>
                </select>
            </div>

            <div class="form-group">
                <label for="output-format">Выходной формат:</label>
                <select id="output-format">
                    <option value="svg" selected>SVG</option>
                    <option value="png">PNG</option>
                </select>
            </div>

            <div class="form-group">
                <label for="layout-engine">Движок компоновки:</label>
                <select id="layout-engine">
                    <option value="dot" selected>dot (иерархическая)</option>
                    <option value="neato">neato (spring model)</option>
                    <option value="fdp">fdp (force-directed)</option>
                    <option value="circo">circo (круговая)</option>
                    <option value="twopi">twopi (радиальная)</option>
                </select>
            </div>

            <div class="form-group">
                <label for="visualization-mode">Режим визуализации:</label>
                <select id="visualization-mode" onchange="updateModeDescription()">
                    <option value="notation" selected>Режим нотации</option>
                    <option value="base">Базовый режим</option>
                    <option value="aggregation">Режим агрегации</option>
                    <option value="vad">Режим VAD</option>
                    <option value="vad-trig">Режим VAD TriG</option>
                </select>
                <div class="mode-description" id="mode-description">
                    С выделением типов объектов и предикатов цветом и формами
                </div>
            </div>

            <div class="form-group">
                <label for="sparql-mode">Режим SPARQL:</label>
                <select id="sparql-mode" onchange="toggleSparqlPanel()">
                    <option value="no" selected>No</option>
                    <option value="yes">Yes</option>
                    <option value="smart-design">SPARQL Smart Design</option>
                </select>
                <div class="mode-description" id="sparql-mode-description">
                    Включите для выполнения SPARQL запросов к графу
                </div>
            </div>

            <div class="form-group" id="max-label-length-group">
                <label for="max-label-length">Макс. длина имени:</label>
                <input type="number" id="max-label-length" value="25" min="5" max="200" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                <div class="mode-description" id="max-label-length-description">
                    Перенос по словам при превышении
                </div>
            </div>

            <div class="form-group" id="max-vad-row-length-group" style="display: none;">
                <label for="max-vad-row-length">Макс. длина VAD:</label>
                <input type="number" id="max-vad-row-length" value="8" min="2" max="20" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                <div class="mode-description" id="max-vad-row-length-description">
                    Количество VAD-элементов в строке до переноса
                </div>
            </div>
        </div>

        <button id="visualize-btn" onclick="visualize()">Отобразить</button>
    </div>

    <!-- Smart Design Container - отображается только при выборе "SPARQL Smart Design" в режиме VAD TriG -->
    <div class="smart-design-container" id="smart-design-container">
        <!-- Панель Smart Design -->
        <div class="smart-design-panel">
            <h3>Smart Design</h3>
            <!-- Верхний ряд: TriG -->
            <div class="smart-design-trig-row">
                <div class="smart-design-field smart-design-field-trig">
                    <label for="smart-design-trig">TriG:</label>
                    <select id="smart-design-trig">
                        <option value="">-- Выберите TriG --</option>
                    </select>
                </div>
            </div>
            <!-- Нижний ряд: Subject Type, Subject, Predicate, Object -->
            <div class="smart-design-fields">
                <div class="smart-design-field">
                    <label for="smart-design-subject-type">Subject Type:</label>
                    <select id="smart-design-subject-type">
                        <option value="">-- Выберите тип Subject --</option>
                    </select>
                </div>
                <div class="smart-design-field">
                    <label for="smart-design-subject">Subject:</label>
                    <select id="smart-design-subject">
                        <option value="">-- Выберите Subject --</option>
                    </select>
                </div>
                <div class="smart-design-field">
                    <label for="smart-design-predicate">Predicate:</label>
                    <select id="smart-design-predicate">
                        <option value="">-- Выберите Predicate --</option>
                    </select>
                </div>
                <div class="smart-design-field">
                    <label for="smart-design-object">Object:</label>
                    <select id="smart-design-object">
                        <option value="">-- Выберите Object --</option>
                    </select>
                </div>
            </div>
            <div class="smart-design-buttons">
                <button class="new-trig-btn" onclick="openNewTrigModal()">New TriG</button>
                <button onclick="smartDesignCreate()">Создать SPARQL</button>
                <button onclick="smartDesignCreateWithPrefix()" style="background-color: #1565C0;">Создать SPARQL (prefix)</button>
                <button class="delete-btn" onclick="smartDesignDelete()">Удалить триплет</button>
                <button class="clear-btn" onclick="smartDesignClear()">Очистить</button>
                <button id="smart-design-mode-toggle" onclick="toggleSmartDesignMode()" style="background-color: #607D8B; margin-left: 10px;">Режим: Фильтр</button>
            </div>
            <div id="smart-design-message" class="smart-design-message" style="display: none;"></div>
        </div>
        <!-- Панель Result in SPARQL -->
        <div class="result-sparql-panel">
            <h3>Result in SPARQL</h3>
            <textarea class="result-sparql-textarea" id="result-sparql-query" placeholder="Здесь будет сгенерированный SPARQL запрос..."></textarea>
            <div class="smart-design-buttons" style="margin-top: 10px;">
                <button class="apply-btn" onclick="smartDesignApply()">Применить как Simple Triple</button>
                <button class="apply-btn" onclick="smartDesignApplyShorthand()" style="background-color: #8E24AA;">Применить как Shorthand Triple</button>
            </div>
            <div id="result-sparql-message" class="smart-design-message" style="display: none;"></div>
        </div>
    </div>

    <!-- Модальное окно для создания нового TriG -->
    <div id="new-trig-modal" class="new-trig-modal">
        <div class="new-trig-modal-content">
            <div class="new-trig-modal-header">
                <h3>Создание нового TriG контейнера</h3>
                <button class="new-trig-modal-close" onclick="closeNewTrigModal()">&times;</button>
            </div>
            <div class="new-trig-modal-body">
                <div class="new-trig-field">
                    <label for="new-trig-id">ID нового TriG:</label>
                    <input type="text" id="new-trig-id" placeholder="Введите ID (например: myNewGraph)">
                </div>
                <div class="new-trig-field">
                    <label for="new-trig-label">rdfs:label (название):</label>
                    <input type="text" id="new-trig-label" placeholder="Введите название">
                </div>
                <div class="new-trig-field">
                    <label for="new-trig-parent">vad:hasParentTrig (родитель):</label>
                    <select id="new-trig-parent">
                        <option value="">-- Выберите родителя --</option>
                    </select>
                </div>
                <div class="new-trig-field">
                    <label for="new-trig-type">vad:typeOfScheme (тип схемы):</label>
                    <input type="text" id="new-trig-type" placeholder="Введите тип схемы">
                </div>
            </div>
            <div class="new-trig-modal-buttons">
                <button class="new-trig-cancel-btn" onclick="closeNewTrigModal()">Отмена</button>
                <button class="new-trig-create-btn" onclick="createNewTrig()">Создать запрос New TriG</button>
            </div>
        </div>
    </div>

    <div class="result-container" id="result-container">
        <h2>Результат:</h2>

        <!-- VAD TriG режим: контейнер с диаграммой слева и панелями справа -->
        <div class="vad-trig-container" id="vad-trig-container" style="display: none;">
            <!-- Обертка для диаграммы -->
            <div class="vad-trig-diagram-wrapper">
                <div class="diagram-panel">
                    <div class="diagram-panel-header">Диаграмма</div>
                    <div class="diagram-panel-content">
                        <div class="zoom-container vad-trig-zoom-container" id="vad-trig-zoom-container">
                            <div class="zoom-content" id="vad-trig-zoom-content">
                                <div id="vad-trig-output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="zoom-controls vad-trig-zoom-controls" id="vad-trig-zoom-controls" style="display: none;">
                        <button onclick="zoomOut()">-</button>
                        <span id="vad-trig-zoom-level">100%</span>
                        <button onclick="zoomIn()">+</button>
                        <button onclick="zoomReset()">Сброс</button>
                        <button onclick="zoomFit()">Вписать</button>
                    </div>
                </div>
            </div>

            <!-- Панели слева -->
            <div class="vad-trig-left-panels">
                <!-- Панель дерева TriG -->
                <div class="trig-tree-panel">
                    <div class="trig-tree-header">Дерево TriG</div>
                    <div class="trig-tree-content" id="trig-tree-content">
                        <div class="trig-properties-empty">Выберите данные TriG</div>
                    </div>
                </div>

                <!-- Панель свойств объекта -->
                <div class="trig-properties-panel">
                    <div class="trig-properties-header">Окно свойств объекта</div>
                    <div class="trig-properties-content" id="trig-properties-content">
                        <div class="trig-properties-empty">Выберите TriG в дереве</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="zoom-controls" id="zoom-controls" style="display: none;">
            <button onclick="zoomOut()">-</button>
            <span id="zoom-level">100%</span>
            <button onclick="zoomIn()">+</button>
            <button onclick="zoomReset()">Сброс</button>
            <button onclick="zoomFit()">Вписать</button>
        </div>
        <div class="zoom-container" id="zoom-container">
            <div class="zoom-content" id="zoom-content">
                <div id="output"></div>
            </div>
        </div>
        <div class="export-buttons" id="export-buttons" style="display: none;">
            <button onclick="downloadSVG()">Скачать SVG</button>
            <button onclick="downloadPNG()">Скачать PNG</button>
            <button onclick="openInNewWindowGitHub()">Показать в окне github</button>
            <button onclick="openInNewWindowLdfFi()">Показать в окне ldf.fi</button>
            <button onclick="openInNewWindowGraphvizOnline()">Показать в окне GraphvizOnline</button>
        </div>
        <div class="legend-panel" id="legend-panel" style="display: none;">
            <h3>Легенда стилей:</h3>
            <div class="legend-content" id="legend-content"></div>
        </div>
        <div class="prefixes-panel" id="prefixes-panel" style="display: none;">
            <h3>Prefixes:</h3>
            <div class="prefixes-content" id="prefixes-content"></div>
        </div>
        <div class="sparql-panel" id="sparql-panel">
            <h3>SPARQL запрос:</h3>
            <textarea class="sparql-query-textarea" id="sparql-query" placeholder="Введите SPARQL запрос...">SELECT ?s ?p ?o
WHERE {
    ?s ?p ?o .
}</textarea>
            <div class="sparql-buttons">
                <button onclick="executeSparqlQuery()">Выполнить запрос</button>
                <button onclick="resetSparqlQuery()">Сбросить</button>
            </div>
            <div class="sparql-results" id="sparql-results" style="display: none;">
                <h4>Результаты запроса:</h4>
                <div id="sparql-results-content"></div>
            </div>
        </div>
        <div class="filter-panel" id="filter-panel" style="display: none;">
            <h3>Фильтры типов:</h3>
            <div class="filter-controls">
                <button onclick="selectAllFilters()">Выделить все</button>
                <button onclick="deselectAllFilters()">Снять все</button>
            </div>
            <div class="filter-content" id="filter-content"></div>
        </div>
    </div>

    <!-- Подключение библиотеки N3.js для парсинга RDF -->
    <script src="https://unpkg.com/n3@1.17.2/browser/n3.min.js"></script>

    <!-- Подключение библиотеки Viz.js для рендеринга графов -->
    <script src="https://unpkg.com/@viz-js/viz@3.4.0/lib/viz-standalone.js"></script>

    <!-- Подключение библиотеки Comunica для SPARQL запросов -->
    <script src="https://rdf.js.org/comunica-browser/versions/v4/engines/query-sparql-rdfjs/comunica-browser.js"></script>

    <script>
        /**
         * RDF Grapher ver4p - Основной JavaScript модуль
         */

        // ============================================================================
        // РЕЖИМ ВИЗУАЛИЗАЦИИ
        // ============================================================================

        const Mode = 'notation';

        // ============================================================================
        // КОНФИГУРАЦИЯ ФИЛЬТРОВ
        // ============================================================================

        const Filter = {
            hiddenPredicates: [
                'rdf:type',
                'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
                'rdfs:subClassOf',
                'http://www.w3.org/2000/01/rdf-schema#subClassOf'
            ]
        };

        const FilterBase = {
            hiddenPredicates: []
        };

        const FilterAggregation = {
            hiddenPredicates: [
                'rdf:type',
                'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
                'rdfs:subClassOf',
                'http://www.w3.org/2000/01/rdf-schema#subClassOf'
            ]
        };

        // Фильтры для режима VAD - скрываем hasParentTrig и rdf:type
        const FilterVAD = {
            hiddenPredicates: [
                'rdf:type',
                'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
                'vad:hasParentTrig',
                'http://example.org/vad#hasParentTrig'
            ]
        };

        function getFilterConfig(mode) {
            if (mode === 'base') {
                return FilterBase;
            } else if (mode === 'aggregation') {
                return FilterAggregation;
            } else if (mode === 'vad' || mode === 'vad-trig') {
                return FilterVAD;
            }
            return Filter;
        }

        // ============================================================================
        // КОНФИГУРАЦИЯ АГРЕГАЦИИ
        // ============================================================================

        const MaxAggregationParams = 5;
        const DEFAULT_MAX_LABEL_LENGTH = 25;
        let currentMaxLabelLength = DEFAULT_MAX_LABEL_LENGTH;

        // Максимальное количество VAD элементов (CDS) в одной горизонтальной строке
        const DEFAULT_MAX_VAD_ROW_LENGTH = 8;
        let currentMaxVadRowLength = DEFAULT_MAX_VAD_ROW_LENGTH;

        // ============================================================================
        // КОНФИГУРАЦИЯ VAD (Value Added Chain Diagram)
        // ============================================================================

        /**
         * VAD_ALLOWED_TYPES - Разрешенные типы объектов для режима VAD
         */
        const VAD_ALLOWED_TYPES = [
            'vad:TypeProcess',
            'http://example.org/vad#TypeProcess',
            'vad:ExecutorGroup',
            'http://example.org/vad#ExecutorGroup',
            'vad:TypeExecutor',
            'http://example.org/vad#TypeExecutor',
            'vad:VADProcessDia',
            'http://example.org/vad#VADProcessDia',
            'vad:ProcessTree',
            'http://example.org/vad#ProcessTree',
            'vad:ExecutorTree',
            'http://example.org/vad#ExecutorTree',
            'vad:Basic',
            'http://example.org/vad#Basic',
            'vad:Detailed',
            'http://example.org/vad#Detailed',
            'vad:DetailedChild',
            'http://example.org/vad#DetailedChild',
            'vad:DetailedExternal',
            'http://example.org/vad#DetailedExternal'
        ];

        /**
         * VAD_ALLOWED_PREDICATES - Разрешенные предикаты для режима VAD
         */
        const VAD_ALLOWED_PREDICATES = [
            'rdf:type',
            'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
            'rdfs:label',
            'http://www.w3.org/2000/01/rdf-schema#label',
            'dcterms:description',
            'http://purl.org/dc/terms/description',
            'vad:hasNext',
            'http://example.org/vad#hasNext',
            'vad:hasExecutor',
            'http://example.org/vad#hasExecutor',
            'vad:hasParentTrig',
            'http://example.org/vad#hasParentTrig',
            'vad:includes',
            'http://example.org/vad#includes',
            'vad:processSubtype',
            'http://example.org/vad#processSubtype',
            'vad:hasTrig',
            'http://example.org/vad#hasTrig',
            'vad:definesProcess',
            'http://example.org/vad#definesProcess',
            'vad:isSubprocessTrig',
            'http://example.org/vad#isSubprocessTrig'
        ];

        /**
         * PTREE_PREDICATES - Предикаты, которые для сущностей типа vad:TypeProcess
         * должны храниться в графе vad:ptree (Дерево Процессов)
         * Остальные предикаты остаются в соответствующем TriG (схеме процесса)
         */
        const PTREE_PREDICATES = [
            'rdf:type',
            'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
            'rdfs:label',
            'http://www.w3.org/2000/01/rdf-schema#label',
            'dcterms:description',
            'http://purl.org/dc/terms/description',
            'vad:hasTrig',
            'http://example.org/vad#hasTrig'
        ];

        /**
         * RTREE_PREDICATES - Предикаты, которые для сущностей типа vad:TypeExecutor
         * должны храниться в графе vad:rtree (Дерево Исполнителей)
         * Остальные предикаты остаются в соответствующем TriG (схеме процесса)
         */
        const RTREE_PREDICATES = [
            'rdf:type',
            'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
            'rdfs:label',
            'http://www.w3.org/2000/01/rdf-schema#label'
        ];

        /**
         * TRIG_TYPES - Типы TriG графов в VAD онтологии
         * Используется для валидации и определения типов графов
         */
        const TRIG_TYPES = {
            PROCESS_TREE: ['vad:ProcessTree', 'http://example.org/vad#ProcessTree'],
            EXECUTOR_TREE: ['vad:ExecutorTree', 'http://example.org/vad#ExecutorTree'],
            VAD_PROCESS_DIA: ['vad:VADProcessDia', 'http://example.org/vad#VADProcessDia']
        };

        /**
         * PROCESS_SUBTYPES - Подтипы процессов в VAD онтологии
         */
        const PROCESS_SUBTYPES = {
            BASIC: ['vad:Basic', 'http://example.org/vad#Basic'],
            DETAILED: ['vad:Detailed', 'http://example.org/vad#Detailed'],
            DETAILED_CHILD: ['vad:DetailedChild', 'http://example.org/vad#DetailedChild'],
            DETAILED_EXTERNAL: ['vad:DetailedExternal', 'http://example.org/vad#DetailedExternal']
        };

        /**
         * TYPE_PREDICATE_MAP - Сводная таблица «Объект-Предикат» (Приложение 1 к онтологии)
         * Определяет допустимые предикаты для каждого типа объекта в зависимости от контекста TriG
         *
         * Связь с онтологией: Приложение 1 в vad-basic-ontology.ttl
         */
        const TYPE_PREDICATE_MAP = {
            // Process в ptree (концепт) - общие свойства
            'vad:TypeProcess': {
                ptree: [
                    'rdf:type',
                    'rdfs:label',
                    'dcterms:description',
                    'vad:hasTrig'
                ],
                // Process в VADProcessDia (индивид) - индивидуальные свойства
                vadProcessDia: [
                    'vad:isSubprocessTrig',
                    'vad:hasExecutor',
                    'vad:processSubtype',
                    'vad:hasNext'
                ]
            },
            // Executor в rtree - общие свойства
            'vad:TypeExecutor': {
                rtree: [
                    'rdf:type',
                    'rdfs:label'
                ]
            },
            // ExecutorGroup в VADProcessDia
            'vad:ExecutorGroup': {
                vadProcessDia: [
                    'rdf:type',
                    'rdfs:label',
                    'vad:includes'
                ]
            },
            // VADProcessDia - свойства схемы процесса
            'vad:VADProcessDia': {
                vadProcessDia: [
                    'rdf:type',
                    'rdfs:label',
                    'vad:hasParentTrig',
                    'vad:definesProcess'
                ]
            },
            // ProcessTree (vad:ptree)
            'vad:ProcessTree': {
                ptree: [
                    'rdf:type',
                    'rdfs:label',
                    'vad:hasParentTrig'
                ]
            },
            // ExecutorTree (vad:rtree)
            'vad:ExecutorTree': {
                rtree: [
                    'rdf:type',
                    'rdfs:label',
                    'vad:hasParentTrig'
                ]
            }
        };

        /**
         * Режим работы Smart Design:
         * - 'filtered' - справочники фильтруются по связанным значениям (Subject Type -> Predicate)
         * - 'full' - справочники отображают полный набор значений
         */
        let smartDesignMode = 'filtered';

        /**
         * Проверяет, является ли предикат предикатом для ptree
         * @param {string} predicateUri - URI или prefixed name предиката
         * @returns {boolean}
         */
        function isPtreePredicate(predicateUri) {
            return PTREE_PREDICATES.some(allowed =>
                predicateUri === allowed || predicateUri.endsWith('#' + allowed.split(':')[1])
            );
        }

        /**
         * Проверяет, является ли предикат предикатом для rtree
         * @param {string} predicateUri - URI или prefixed name предиката
         * @returns {boolean}
         */
        function isRtreePredicate(predicateUri) {
            return RTREE_PREDICATES.some(allowed =>
                predicateUri === allowed || predicateUri.endsWith('#' + allowed.split(':')[1])
            );
        }

        /**
         * Проверяет, является ли субъект типом vad:TypeProcess
         * @param {string} subjectUri - URI субъекта
         * @returns {boolean}
         */
        function isSubjectVadProcess(subjectUri) {
            const types = nodeTypesCache[subjectUri] || [];
            return types.some(t =>
                t === 'vad:TypeProcess' || t === 'http://example.org/vad#TypeProcess'
            );
        }

        /**
         * Проверяет, является ли субъект типом vad:TypeExecutor
         * @param {string} subjectUri - URI субъекта
         * @returns {boolean}
         */
        function isSubjectVadExecutor(subjectUri) {
            const types = nodeTypesCache[subjectUri] || [];
            return types.some(t =>
                t === 'vad:TypeExecutor' || t === 'http://example.org/vad#TypeExecutor'
            );
        }

        /**
         * Определяет тип TriG графа
         * @param {string} trigUri - URI TriG графа
         * @param {Array} quads - Массив квадов
         * @returns {string|null} - Тип графа или null
         */
        function getTrigType(trigUri, quads) {
            const typeQuad = quads.find(quad =>
                quad.subject.value === trigUri &&
                (quad.predicate.value.endsWith('#type') ||
                 quad.predicate.value === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
            );

            if (typeQuad) {
                const typeValue = typeQuad.object.value;
                if (TRIG_TYPES.PROCESS_TREE.some(t => typeValue === t || typeValue.endsWith('#ProcessTree'))) {
                    return 'vad:ProcessTree';
                }
                if (TRIG_TYPES.EXECUTOR_TREE.some(t => typeValue === t || typeValue.endsWith('#ExecutorTree'))) {
                    return 'vad:ExecutorTree';
                }
                if (TRIG_TYPES.VAD_PROCESS_DIA.some(t => typeValue === t || typeValue.endsWith('#VADProcessDia'))) {
                    return 'vad:VADProcessDia';
                }
            }

            // Определение типа по эвристике (для обратной совместимости)
            if (trigUri.endsWith('#ptree') || trigUri.includes('ptree')) {
                return 'vad:ProcessTree';
            }
            if (trigUri.endsWith('#rtree') || trigUri.includes('rtree')) {
                return 'vad:ExecutorTree';
            }
            return 'vad:VADProcessDia';
        }

        /**
         * Проверяет, является ли тип типом ProcessTree
         * @param {string} typeUri - URI типа
         * @returns {boolean}
         */
        function isProcessTreeType(typeUri) {
            return TRIG_TYPES.PROCESS_TREE.some(t =>
                typeUri === t || typeUri.endsWith('#ProcessTree')
            );
        }

        /**
         * Проверяет, является ли тип типом ExecutorTree
         * @param {string} typeUri - URI типа
         * @returns {boolean}
         */
        function isExecutorTreeType(typeUri) {
            return TRIG_TYPES.EXECUTOR_TREE.some(t =>
                typeUri === t || typeUri.endsWith('#ExecutorTree')
            );
        }

        /**
         * Проверяет, является ли тип типом VADProcessDia
         * @param {string} typeUri - URI типа
         * @returns {boolean}
         */
        function isVADProcessDiaType(typeUri) {
            return TRIG_TYPES.VAD_PROCESS_DIA.some(t =>
                typeUri === t || typeUri.endsWith('#VADProcessDia')
            );
        }

        /**
         * Проверяет, является ли подтип процесса детализированным (Detailed, DetailedChild, DetailedExternal)
         * @param {string} subtypeUri - URI подтипа
         * @returns {boolean}
         */
        function isDetailedSubtype(subtypeUri) {
            return PROCESS_SUBTYPES.DETAILED.some(t => subtypeUri === t || subtypeUri.endsWith('#Detailed')) ||
                   PROCESS_SUBTYPES.DETAILED_CHILD.some(t => subtypeUri === t || subtypeUri.endsWith('#DetailedChild')) ||
                   PROCESS_SUBTYPES.DETAILED_EXTERNAL.some(t => subtypeUri === t || subtypeUri.endsWith('#DetailedExternal'));
        }

        /**
         * Проверяет существование триплета во всех графах (для проверки дубликатов)
         * Поддерживает проверку как полных URI, так и prefixed names
         * @param {string} subjectValue - URI или prefixed name субъекта
         * @param {string} predicateValue - URI или prefixed name предиката
         * @param {string} objectValue - URI, prefixed name или литерал объекта
         * @returns {Object|null} - {graphUri, graphLabel} если найден дубликат, иначе null
         */
        function findDuplicateTriple(subjectValue, predicateValue, objectValue) {
            // Преобразуем prefixed names в полные URI для сравнения
            let subjectUri = subjectValue;
            let predicateUri = predicateValue;
            let objectUri = objectValue;

            for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                if (subjectValue.startsWith(prefix + ':')) {
                    subjectUri = namespace + subjectValue.substring(prefix.length + 1);
                }
                if (predicateValue.startsWith(prefix + ':')) {
                    predicateUri = namespace + predicateValue.substring(prefix.length + 1);
                }
                if (objectValue.startsWith(prefix + ':')) {
                    objectUri = namespace + objectValue.substring(prefix.length + 1);
                }
            }

            // Также преобразуем полные URI в prefixed names для альтернативной проверки
            const subjectPrefixed = getPrefixedName(subjectUri, currentPrefixes);
            const predicatePrefixed = getPrefixedName(predicateUri, currentPrefixes);
            const objectPrefixed = getPrefixedName(objectUri, currentPrefixes);

            for (const quad of currentQuads) {
                const qSubjectUri = quad.subject.value;
                const qPredicateUri = quad.predicate.value;
                const qObjectValue = quad.object.value;
                const qSubjectPrefixed = getPrefixedName(qSubjectUri, currentPrefixes);
                const qPredicatePrefixed = getPrefixedName(qPredicateUri, currentPrefixes);
                const qObjectPrefixed = quad.object.termType === 'Literal'
                    ? quad.object.value
                    : getPrefixedName(qObjectValue, currentPrefixes);

                // Сравниваем как полные URI, так и prefixed names
                const subjectMatch = (subjectUri === qSubjectUri) || (subjectPrefixed === qSubjectPrefixed);
                const predicateMatch = (predicateUri === qPredicateUri) || (predicatePrefixed === qPredicatePrefixed);
                const objectMatch = (objectUri === qObjectValue) || (objectPrefixed === qObjectPrefixed) ||
                    (objectValue === qObjectValue) || (objectValue === qObjectPrefixed);

                if (subjectMatch && predicateMatch && objectMatch) {
                    const graphUri = quad.graph ? quad.graph.value : null;
                    const graphLabel = graphUri ? getPrefixedName(graphUri, currentPrefixes) : 'default graph';
                    return { graphUri, graphLabel };
                }
            }

            return null;
        }

        /**
         * Определяет целевой граф для триплета на основе правил ptree
         * Если субъект является vad:TypeProcess и предикат в PTREE_PREDICATES,
         * триплет должен быть добавлен в vad:ptree
         * @param {string} subjectValue - URI или prefixed name субъекта
         * @param {string} predicateValue - URI или prefixed name предиката
         * @param {string} originalTrigValue - Исходный выбранный граф
         * @param {string} objectValue - URI или prefixed name объекта (опционально, для проверки rdf:type)
         * @returns {string} - URI графа для добавления триплета
         */
        function determineTargetGraph(subjectValue, predicateValue, originalTrigValue, objectValue = null) {
            // Преобразуем prefixed names в полные URI
            let subjectUri = subjectValue;
            let predicateUri = predicateValue;
            let objectUri = objectValue;

            for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                if (subjectValue.startsWith(prefix + ':')) {
                    subjectUri = namespace + subjectValue.substring(prefix.length + 1);
                }
                if (predicateValue.startsWith(prefix + ':')) {
                    predicateUri = namespace + predicateValue.substring(prefix.length + 1);
                }
                if (objectValue && objectValue.startsWith(prefix + ':')) {
                    objectUri = namespace + objectValue.substring(prefix.length + 1);
                }
            }

            // Специальный случай: добавление rdf:type vad:TypeProcess - всегда в ptree
            const isRdfType = (predicateUri === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' ||
                              predicateValue === 'rdf:type');
            const isProcessType = (objectUri === 'http://example.org/vad#TypeProcess' ||
                                  objectValue === 'vad:TypeProcess');
            if (isRdfType && isProcessType) {
                return 'vad:ptree';
            }

            // Проверяем, является ли субъект типом vad:TypeProcess
            if (isSubjectVadProcess(subjectUri)) {
                // Проверяем, является ли предикат предикатом для ptree
                if (isPtreePredicate(predicateUri) || isPtreePredicate(predicateValue)) {
                    // Возвращаем vad:ptree
                    return 'vad:ptree';
                }
            }

            return originalTrigValue;
        }

        /**
         * Валидирует RDF триплеты на соответствие схеме VAD
         * @param {Array} quads - Массив RDF триплетов
         * @param {Object} prefixes - Объект с префиксами
         * @returns {Object} - {valid: boolean, errors: Array}
         */
        function validateVAD(quads, prefixes) {
            const errors = [];

            quads.forEach((quad, index) => {
                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, prefixes);

                // Проверяем, что предикат разрешен
                const predicateAllowed = VAD_ALLOWED_PREDICATES.some(allowed =>
                    predicateUri === allowed || predicateLabel === allowed
                );

                if (!predicateAllowed) {
                    const subjectLabel = getPrefixedName(quad.subject.value, prefixes);
                    const objectLabel = quad.object.termType === 'Literal'
                        ? `"${quad.object.value}"`
                        : getPrefixedName(quad.object.value, prefixes);

                    errors.push({
                        triple: `${subjectLabel} ${predicateLabel} ${objectLabel}`,
                        position: 'predicate',
                        value: predicateLabel,
                        message: `Недопустимый предикат: ${predicateLabel}`
                    });
                }

                // Если предикат - rdf:type, проверяем, что тип разрешен
                const typePredicates = [
                    'rdf:type',
                    'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
                ];

                if (typePredicates.includes(predicateUri) || typePredicates.includes(predicateLabel)) {
                    const typeUri = quad.object.value;
                    const typeLabel = getPrefixedName(typeUri, prefixes);

                    const typeAllowed = VAD_ALLOWED_TYPES.some(allowed =>
                        typeUri === allowed || typeLabel === allowed
                    );

                    if (!typeAllowed) {
                        const subjectLabel = getPrefixedName(quad.subject.value, prefixes);

                        errors.push({
                            triple: `${subjectLabel} ${predicateLabel} ${typeLabel}`,
                            position: 'object (type)',
                            value: typeLabel,
                            message: `Недопустимый тип объекта: ${typeLabel}`
                        });
                    }
                }
            });

            return {
                valid: errors.length === 0,
                errors: errors
            };
        }

        /**
         * Форматирует ошибки валидации VAD для отображения
         * @param {Array} errors - Массив ошибок
         * @returns {string} - Отформатированное сообщение
         */
        function formatVADErrors(errors) {
            let message = 'ОШИБКА ВАЛИДАЦИИ VAD\n';
            message += '═══════════════════════════════════════\n\n';

            errors.forEach((error, index) => {
                message += `Ошибка ${index + 1}:\n`;
                message += `  Триплет: ${error.triple}\n`;
                message += `  Позиция: ${error.position}\n`;
                message += `  Значение: ${error.value}\n`;
                message += `  ${error.message}\n\n`;
            });

            message += '═══════════════════════════════════════\n';
            message += `Всего ошибок: ${errors.length}\n`;
            message += '\nРазрешенные типы: vad:TypeProcess, vad:ExecutorGroup, vad:TypeExecutor\n';
            message += 'Разрешенные предикаты: rdf:type, rdfs:label, dcterms:description,\n';
            message += '  vad:hasNext, vad:hasExecutor, vad:hasParentTrig, vad:includes,\n';
            message += '  vad:processSubtype, vad:hasTrig';

            return message;
        }

        // ============================================================================
        // КОНФИГУРАЦИЯ СТИЛЕЙ
        // ============================================================================

        const StyleName = {
            nodeStyles: {
                'PersonStyle': {
                    types: ['foaf:Person', 'schema:Person', 'http://xmlns.com/foaf/0.1/Person'],
                    dot: 'shape="octagon" height="0.75" width="0.75" fixedsize="true" color="#9C27B0" fillcolor="#F3E5F5" fontname="Arial" fontsize="10" style="filled"',
                    label: 'Люди (foaf:Person)',
                    description: 'Объекты типа foaf:Person или schema:Person'
                },
                'OrganizationStyle': {
                    types: ['foaf:Organization', 'schema:Organization', 'http://xmlns.com/foaf/0.1/Organization'],
                    dot: 'shape="box" height="0.6" width="1.2" color="Blue" fillcolor="#E6F3FF" fontname="Arial" fontsize="10" style="filled,bold"',
                    label: 'Организации (foaf:Organization)',
                    description: 'Объекты типа foaf:Organization'
                },
                'DocumentStyle': {
                    types: ['foaf:Document', 'schema:Document', 'http://xmlns.com/foaf/0.1/Document'],
                    dot: 'shape="note" height="0.6" width="1.0" color="Green" fillcolor="#E8F5E9" fontname="Arial" fontsize="10" style="filled"',
                    label: 'Документы (foaf:Document)',
                    description: 'Объекты типа foaf:Document'
                },
                'LiteralStyle': {
                    types: ['_Literal'],
                    dot: 'shape="box" color="#666666" fillcolor="#FFFFCC" fontname="Arial" fontsize="9" style="filled,rounded"',
                    label: 'Литералы (Literal)',
                    description: 'Строковые значения, числа, даты'
                },
                'BlankNodeStyle': {
                    types: ['_BlankNode'],
                    dot: 'shape="ellipse" color="#999999" fillcolor="#E0E0E0" fontname="Arial" fontsize="9" style="filled,dashed"',
                    label: 'Пустые узлы (BlankNode)',
                    description: 'Анонимные узлы без URI'
                },
                'default': {
                    types: [],
                    dot: 'shape="ellipse" color="#1976D2" fillcolor="#CCE5FF" fontname="Arial" fontsize="10" style="filled"',
                    label: 'По умолчанию (URI)',
                    description: 'Все остальные URI-ресурсы'
                }
            },
            edgeStyles: {
                'TypeStyle': {
                    predicates: ['rdf:type', 'a', 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'],
                    dot: 'color="#9C27B0" penwidth="2" style="dashed" arrowhead="empty"',
                    label: 'Тип объекта (rdf:type)',
                    description: 'Связь объекта с его RDF-типом'
                },
                'KnowsStyle': {
                    predicates: ['foaf:knows', 'http://xmlns.com/foaf/0.1/knows'],
                    dot: 'color="#4CAF50" penwidth="2" style="solid" arrowhead="vee"',
                    label: 'Знает (foaf:knows)',
                    description: 'Социальная связь между людьми'
                },
                'MemberStyle': {
                    predicates: ['foaf:member', 'schema:member', 'http://xmlns.com/foaf/0.1/member'],
                    dot: 'color="#795548" penwidth="2" style="solid" arrowhead="diamond"',
                    label: 'Член (foaf:member)',
                    description: 'Членство в организации'
                },
                'AttributeStyle': {
                    predicates: [
                        'foaf:name', 'http://xmlns.com/foaf/0.1/name',
                        'foaf:age', 'http://xmlns.com/foaf/0.1/age',
                        'rdfs:label', 'http://www.w3.org/2000/01/rdf-schema#label',
                        'rdfs:comment', 'http://www.w3.org/2000/01/rdf-schema#comment'
                    ],
                    dot: 'color="#2196F3" penwidth="1" style="dotted" arrowhead="normal"',
                    label: 'Атрибуты (name, label...)',
                    description: 'Свойства объекта: имя, возраст и др.'
                },
                'default': {
                    predicates: [],
                    dot: 'color="#666666" penwidth="1" style="solid" arrowhead="normal"',
                    label: 'По умолчанию',
                    description: 'Все остальные предикаты'
                }
            }
        };

        // ============================================================================
        // СТИЛИ VAD (Value Added Chain Diagram)
        // ============================================================================

        const VADNodeStyles = {
            'ProcessStyleBasic': {
                types: ['vad:TypeProcess', 'http://example.org/vad#TypeProcess'],
                subtypes: ['vad:Basic', 'http://example.org/vad#Basic'],
                // cds shape (chevron) с зелёной заливкой для базового типа
                dot: 'shape="cds" height="0.8" width="1.5" color="#2E7D32" fillcolor="#A5D6A7" fontname="Arial" fontsize="11" style="filled"',
                label: 'Процесс Базовый (vad:Basic)',
                description: 'Базовый бизнес-процесс в VAD диаграмме'
            },
            'ProcessStyleDetailed': {
                types: ['vad:TypeProcess', 'http://example.org/vad#TypeProcess'],
                subtypes: ['vad:Detailed', 'http://example.org/vad#Detailed'],
                // cds shape (chevron) с голубой заливкой для детализированного типа
                dot: 'shape="cds" height="0.8" width="1.5" color="#1565C0" fillcolor="#90CAF9" fontname="Arial" fontsize="11" style="filled"',
                label: 'Процесс Детализированный (vad:Detailed)',
                description: 'Детализированный бизнес-процесс в VAD диаграмме'
            },
            'ExecutorGroupStyle': {
                types: ['vad:ExecutorGroup', 'http://example.org/vad#ExecutorGroup'],
                dot: 'shape="ellipse" color="#B8860B" fillcolor="#FFFFCC" fontname="Arial" fontsize="9" style="filled"',
                label: 'Группа исполнителей (vad:ExecutorGroup)',
                description: 'Группа исполнителей процесса (эллипс с желтоватой заливкой)'
            },
            'ExecutorStyle': {
                types: ['vad:TypeExecutor', 'http://example.org/vad#TypeExecutor'],
                dot: 'shape="ellipse" height="0.4" width="0.8" color="#6A1B9A" fillcolor="#E1BEE7" fontname="Arial" fontsize="9" style="filled"',
                label: 'Исполнитель (vad:TypeExecutor)',
                description: 'Исполнитель процесса'
            },
            'default': {
                types: [],
                dot: 'shape="ellipse" color="#1976D2" fillcolor="#CCE5FF" fontname="Arial" fontsize="10" style="filled"',
                label: 'По умолчанию',
                description: 'Другие объекты'
            }
        };

        const VADEdgeStyles = {
            'HasNextStyle': {
                predicates: ['vad:hasNext', 'http://example.org/vad#hasNext'],
                // Зелёная стрелка для связей между процессами
                dot: 'color="#2E7D32" penwidth="2" style="solid" arrowhead="vee"',
                label: 'Следующий (vad:hasNext)',
                description: 'Связь с следующим процессом'
            },
            'HasExecutorStyle': {
                predicates: ['vad:hasExecutor', 'http://example.org/vad#hasExecutor'],
                dot: 'color="#1565C0" penwidth="1" style="dashed" arrowhead="none"',
                label: 'Исполнитель (vad:hasExecutor)',
                description: 'Связь процесса с группой исполнителей (ненаправленная)'
            },
            'IncludesStyle': {
                predicates: ['vad:includes', 'http://example.org/vad#includes'],
                dot: 'color="#6A1B9A" penwidth="1" style="dotted" arrowhead="normal"',
                label: 'Включает (vad:includes)',
                description: 'Связь группы с исполнителями'
            },
            'HasParentStyle': {
                predicates: ['vad:hasParentTrig', 'http://example.org/vad#hasParentTrig'],
                dot: 'color="#999999" penwidth="1" style="dashed" arrowhead="empty"',
                label: 'Родитель (vad:hasParentTrig)',
                description: 'Связь с родительским процессом'
            },
            'TypeStyle': {
                predicates: ['rdf:type', 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'],
                dot: 'color="#9C27B0" penwidth="1" style="dashed" arrowhead="empty"',
                label: 'Тип (rdf:type)',
                description: 'Тип объекта'
            },
            'default': {
                predicates: [],
                dot: 'color="#666666" penwidth="1" style="solid" arrowhead="normal"',
                label: 'По умолчанию',
                description: 'Другие связи'
            }
        };

        const AggregationNodeStyles = {
            'PersonStyle': {
                types: ['foaf:Person', 'schema:Person', 'http://xmlns.com/foaf/0.1/Person'],
                dot: 'shape="ellipse" color="#9C27B0" penwidth="2" fillcolor="#F3E5F5" fontname="Arial" fontsize="10" style="filled"',
                label: 'Люди (foaf:Person)',
                description: 'Объекты типа foaf:Person'
            },
            'OrganizationStyle': {
                types: ['foaf:Organization', 'schema:Organization', 'http://xmlns.com/foaf/0.1/Organization'],
                dot: 'shape="ellipse" color="Blue" penwidth="3" fillcolor="#E3F2FD" fontname="Arial" fontsize="10" style="filled"',
                label: 'Организации (foaf:Organization)',
                description: 'Объекты типа foaf:Organization'
            },
            'DocumentStyle': {
                types: ['foaf:Document', 'schema:Document', 'http://xmlns.com/foaf/0.1/Document'],
                dot: 'shape="ellipse" color="Green" penwidth="2" fillcolor="#E8F5E9" fontname="Arial" fontsize="10" style="filled"',
                label: 'Документы (foaf:Document)',
                description: 'Объекты типа foaf:Document'
            },
            'BlankNodeStyle': {
                types: ['_BlankNode'],
                dot: 'shape="ellipse" color="#999999" penwidth="1" fillcolor="#E0E0E0" fontname="Arial" fontsize="9" style="filled,dashed"',
                label: 'Пустые узлы (BlankNode)',
                description: 'Анонимные узлы без URI'
            },
            'default': {
                types: [],
                dot: 'shape="ellipse" color="#1976D2" penwidth="1" fillcolor="#CCE5FF" fontname="Arial" fontsize="10" style="filled"',
                label: 'По умолчанию (URI)',
                description: 'Все остальные URI-ресурсы'
            }
        };

        // ============================================================================
        // ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ
        // ============================================================================

        let currentSvgElement = null;
        let currentScale = 1.0;
        let currentPrefixes = {};
        let nodeTypesCache = {};
        let nodeSubtypesCache = {};
        let currentQuads = [];
        let nodeLabelToUri = {};
        let selectedNodeElement = null;
        let propertiesPanelCounter = 0;
        let openPropertiesPanels = [];
        let currentMode = Mode;
        let draggedPanel = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let currentStore = null;
        let comunicaEngine = null;
        let currentDotCode = '';

        const defaultSparqlQuery = `SELECT ?s ?p ?o
WHERE {
    ?s ?p ?o .
}`;

        /**
         * Генерирует SPARQL PREFIX декларации из объекта префиксов
         * @param {Object} prefixes - Объект с префиксами {prefix: uri}
         * @returns {string} - Строка с PREFIX декларациями
         */
        function generateSparqlPrefixes(prefixes) {
            if (!prefixes || Object.keys(prefixes).length === 0) {
                return '';
            }

            let prefixLines = [];
            for (const [prefix, uri] of Object.entries(prefixes)) {
                prefixLines.push(`PREFIX ${prefix}: <${uri}>`);
            }
            return prefixLines.join('\n') + '\n\n';
        }

        /**
         * Генерирует SPARQL запрос с GRAPH clause для указанного TriG
         * @param {string} trigUri - URI TriG для фильтрации
         * @returns {string} - SPARQL запрос с GRAPH clause и PREFIX декларациями
         */
        function getSparqlQueryForTriG(trigUri) {
            if (!trigUri) return defaultSparqlQuery;

            const prefixedUri = getPrefixedName(trigUri, currentPrefixes);
            // Если URI имеет префикс, используем его, иначе используем полный URI в угловых скобках
            const graphRef = prefixedUri.includes(':') && !prefixedUri.startsWith('http')
                ? prefixedUri
                : `<${trigUri}>`;

            // Генерируем PREFIX декларации для SPARQL запроса
            const prefixDeclarations = generateSparqlPrefixes(currentPrefixes);

            return `${prefixDeclarations}SELECT ?s ?p ?o
WHERE {
    GRAPH ${graphRef} {
        ?s ?p ?o .
    }
}`;
        }

        /**
         * Обновляет SPARQL запрос в текстовом поле для текущего выбранного TriG
         */
        function updateSparqlQueryForTriG() {
            if (currentMode !== 'vad-trig' || !selectedTrigUri) return;

            const queryInput = document.getElementById('sparql-query');
            if (!queryInput) return;

            queryInput.value = getSparqlQueryForTriG(selectedTrigUri);
        }

        let activeFilters = [...getFilterConfig(Mode).hiddenPredicates];
        let allPredicates = [];

        // ============================================================================
        // ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ДЛЯ VAD TriG РЕЖИМА
        // ============================================================================

        let trigHierarchy = {};  // Иерархия TriG графов: { uri -> { label, hasParentTrig, children, quads } }
        let selectedTrigUri = null;  // Текущий выбранный TriG для отображения
        let allTrigGraphs = [];  // Список всех TriG графов
        let isNewTrigQuery = false;  // Флаг: текущий SPARQL запрос создан функцией "New TriG"
        const PTREE_GRAPH_URI = 'http://example.org/vad#ptree';  // URI графа Дерево Процессов
        const RTREE_GRAPH_URI = 'http://example.org/vad#rtree';  // URI графа Дерево Исполнителей

        /**
         * Получает метаданные процесса из vad:ptree (rdfs:label, dcterms:description, vad:hasTrig)
         * @param {string} processUri - URI процесса
         * @param {Object} prefixes - Словарь префиксов
         * @returns {Object} - { label: string|null, description: string|null, hasTrig: string|null }
         */
        function getProcessMetadataFromPtree(processUri, prefixes) {
            const result = { label: null, description: null, hasTrig: null };

            // Если нет trigHierarchy или нет vad:ptree, возвращаем пустой результат
            if (!trigHierarchy || !trigHierarchy[PTREE_GRAPH_URI]) {
                return result;
            }

            const ptreeQuads = trigHierarchy[PTREE_GRAPH_URI].quads;

            ptreeQuads.forEach(quad => {
                if (quad.subject.value !== processUri) return;

                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, prefixes);

                if (predicateLabel === 'rdfs:label' || predicateUri === 'http://www.w3.org/2000/01/rdf-schema#label') {
                    result.label = quad.object.value;
                }
                if (predicateLabel === 'dcterms:description' || predicateUri === 'http://purl.org/dc/terms/description') {
                    result.description = quad.object.value;
                }
                if (predicateLabel === 'vad:hasTrig' || predicateUri === 'http://example.org/vad#hasTrig') {
                    result.hasTrig = quad.object.value;
                }
            });

            return result;
        }

        /**
         * Получает имя исполнителя (rdfs:label) из vad:rtree
         * @param {string} executorUri - URI исполнителя
         * @param {Object} prefixes - Словарь префиксов
         * @returns {string|null} - rdfs:label исполнителя или null
         */
        function getExecutorNameFromRtree(executorUri, prefixes) {
            // Если нет trigHierarchy или нет vad:rtree, возвращаем null
            if (!trigHierarchy || !trigHierarchy[RTREE_GRAPH_URI]) {
                return null;
            }

            const rtreeQuads = trigHierarchy[RTREE_GRAPH_URI].quads;

            for (const quad of rtreeQuads) {
                if (quad.subject.value !== executorUri) continue;

                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, prefixes);

                if (predicateLabel === 'rdfs:label' || predicateUri === 'http://www.w3.org/2000/01/rdf-schema#label') {
                    return quad.object.value;
                }
            }

            return null;
        }

        // ============================================================================
        // ФУНКЦИИ ДЛЯ VAD TriG РЕЖИМА
        // ============================================================================

        /**
         * Парсит иерархию TriG графов из квадов
         * @param {Array} quads - Все квады из RDF данных
         * @param {Object} prefixes - Словарь префиксов
         * @returns {Object} - { valid: boolean, errors: [], hierarchy: {}, rootTrigUri: string }
         */
        function parseTriGHierarchy(quads, prefixes) {
            const errors = [];
            const hierarchy = {};
            const graphUris = new Set();

            // Собираем все уникальные именованные графы
            quads.forEach(quad => {
                if (quad.graph && quad.graph.value && quad.graph.value !== '') {
                    graphUris.add(quad.graph.value);
                }
            });

            // Инициализируем структуру для каждого графа
            graphUris.forEach(graphUri => {
                hierarchy[graphUri] = {
                    uri: graphUri,
                    label: null,
                    hasParent: null,
                    children: [],
                    quads: [],
                    processes: []
                };
            });

            // Собираем квады для каждого графа
            quads.forEach(quad => {
                const graphUri = quad.graph?.value || '';
                if (graphUri && hierarchy[graphUri]) {
                    hierarchy[graphUri].quads.push(quad);
                }
            });

            // Ищем rdfs:label и vad:hasParentTrig для каждого графа (определяются вне графа)
            quads.forEach(quad => {
                const subjectUri = quad.subject.value;
                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, prefixes);

                // Проверяем, является ли субъект именованным графом
                if (hierarchy[subjectUri]) {
                    // rdfs:label для графа
                    if (predicateLabel === 'rdfs:label' || predicateUri === 'http://www.w3.org/2000/01/rdf-schema#label') {
                        hierarchy[subjectUri].label = quad.object.value;
                    }

                    // vad:hasParentTrig для графа
                    if (predicateLabel === 'vad:hasParentTrig' || predicateUri === 'http://example.org/vad#hasParentTrig') {
                        hierarchy[subjectUri].hasParent = quad.object.value;
                    }
                }
            });

            // Проверяем, что все графы имеют hasParentTrig
            Object.values(hierarchy).forEach(graphInfo => {
                if (!graphInfo.hasParent) {
                    const graphLabel = getPrefixedName(graphInfo.uri, prefixes);
                    errors.push({
                        graph: graphLabel,
                        message: `TriG "${graphLabel}" не имеет свойства hasParentTrig. В режиме VAD TriG каждый TriG граф должен иметь свойство hasParentTrig.`
                    });
                }
            });

            if (errors.length > 0) {
                return { valid: false, errors, hierarchy: null, rootTrigUri: null };
            }

            // Строим дерево: находим корневые элементы (hasParentTrig = vad:root)
            const rootUri = 'http://example.org/vad#root';
            let rootTrigUri = null;

            Object.values(hierarchy).forEach(graphInfo => {
                const parentUri = graphInfo.hasParent;
                const parentLabel = getPrefixedName(parentUri, prefixes);

                // Проверяем, является ли родитель "root"
                if (parentUri === rootUri || parentLabel === 'vad:root') {
                    // vad:ptree - это специальный граф для метаданных процессов,
                    // он не должен быть выбран как rootTrigUri для отображения схемы
                    if (graphInfo.uri !== PTREE_GRAPH_URI) {
                        rootTrigUri = graphInfo.uri;
                    }
                } else if (hierarchy[parentUri]) {
                    // Добавляем как дочерний элемент к родителю
                    hierarchy[parentUri].children.push(graphInfo.uri);
                }
            });

            // Собираем информацию о процессах для каждого графа
            // Шаг 1: Собираем все URI процессов из всех графов (включая vad:ptree)
            const allProcessUris = new Set();
            Object.values(hierarchy).forEach(graphInfo => {
                graphInfo.quads.forEach(quad => {
                    const predicateUri = quad.predicate.value;
                    const predicateLabel = getPrefixedName(predicateUri, prefixes);

                    // Если это rdf:type и тип = vad:TypeProcess
                    if (predicateLabel === 'rdf:type' || predicateUri === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type') {
                        const typeUri = quad.object.value;
                        const typeLabel = getPrefixedName(typeUri, prefixes);
                        if (typeLabel === 'vad:TypeProcess' || typeUri === 'http://example.org/vad#TypeProcess') {
                            allProcessUris.add(quad.subject.value);
                        }
                    }
                });
            });

            // Шаг 2: Для каждого графа (кроме ptree) определяем, какие процессы в нём присутствуют
            // Процесс считается присутствующим в графе, если у него есть свойства (vad:hasExecutor, vad:hasNext и т.д.) в этом графе
            const processPredicates = [
                'http://example.org/vad#hasExecutor',
                'vad:hasExecutor',
                'http://example.org/vad#hasNext',
                'vad:hasNext',
                'http://example.org/vad#processSubtype',
                'vad:processSubtype'
            ];

            Object.values(hierarchy).forEach(graphInfo => {
                // Для vad:ptree пропускаем присваивание процессов (это граф метаданных)
                if (graphInfo.uri === PTREE_GRAPH_URI) {
                    return;
                }

                // Ищем процессы, которые имеют свойства в этом графе
                const processesInGraph = new Set();
                graphInfo.quads.forEach(quad => {
                    const subjectUri = quad.subject.value;
                    const predicateUri = quad.predicate.value;
                    const predicateLabel = getPrefixedName(predicateUri, prefixes);

                    // Если субъект является процессом (из allProcessUris) и предикат - это свойство процесса
                    if (allProcessUris.has(subjectUri)) {
                        if (processPredicates.includes(predicateUri) || processPredicates.includes(predicateLabel)) {
                            processesInGraph.add(subjectUri);
                        }
                    }
                });

                graphInfo.processes = Array.from(processesInGraph);
            });

            return { valid: true, errors: [], hierarchy, rootTrigUri };
        }

        /**
         * Форматирует ошибки VAD TriG для отображения
         * @param {Array} errors - Массив ошибок
         * @returns {string} - Отформатированное сообщение
         */
        function formatVADTriGErrors(errors) {
            let message = 'ОШИБКА ВАЛИДАЦИИ VAD TriG\n';
            message += '═══════════════════════════════════════\n\n';

            errors.forEach((error, index) => {
                message += `Ошибка ${index + 1}:\n`;
                message += `  TriG граф: ${error.graph}\n`;
                message += `  ${error.message}\n\n`;
            });

            message += '═══════════════════════════════════════\n';
            message += `Всего ошибок: ${errors.length}\n`;
            message += '\nВ режиме VAD TriG каждый TriG граф должен иметь свойство vad:hasParentTrig.\n';
            message += 'Корневой граф должен иметь hasParentTrig = vad:root.\n';
            message += 'Дочерние графы указывают на родительский граф через hasParentTrig.';

            return message;
        }

        /**
         * Строит HTML для дерева TriG
         * @param {string} trigUri - URI текущего TriG
         * @param {Object} hierarchy - Иерархия TriG
         * @param {Object} prefixes - Словарь префиксов
         * @param {number} level - Уровень вложенности (для отступов)
         * @returns {string} - HTML дерева
         */
        function buildTriGTreeHtml(trigUri, hierarchy, prefixes, level = 0) {
            const graphInfo = hierarchy[trigUri];
            if (!graphInfo) return '';

            const prefixedUri = getPrefixedName(trigUri, prefixes);
            const localName = getLocalName(trigUri);
            const displayLabel = graphInfo.label || localName;
            const isSelected = trigUri === selectedTrigUri;
            const hasChildren = graphInfo.children.length > 0;
            const hasProcesses = graphInfo.processes.length > 0;
            const hasExpandableContent = hasChildren || hasProcesses;

            let html = '';

            // Элемент дерева
            html += `<div class="trig-tree-item ${isSelected ? 'selected active' : ''}"
                         data-trig-uri="${escapeHtml(trigUri)}"
                         onclick="selectTriG('${escapeHtml(trigUri)}')">`;

            // Значок раскрытия/закрытия
            if (hasExpandableContent) {
                html += `<span class="trig-tree-toggle">▼</span>`;
            } else {
                html += `<span class="trig-tree-toggle"></span>`;
            }

            // Метка с id
            html += `<span class="trig-tree-label">${escapeHtml(displayLabel)}</span>`;
            html += `<span class="trig-tree-id">(${escapeHtml(localName)})</span>`;
            html += `</div>`;

            // Содержимое дерева (дочерние TriG и состав объектов)
            if (hasExpandableContent) {
                html += `<div class="trig-tree-children">`;

                // Сначала показываем дочерние TriG
                graphInfo.children.forEach(childUri => {
                    html += buildTriGTreeHtml(childUri, hierarchy, prefixes, level + 1);
                });

                // Затем показываем "Состав объектов" с процессами
                if (hasProcesses) {
                    html += buildObjectCompositionHtml(trigUri, graphInfo.processes, prefixes);
                }

                html += `</div>`;
            }

            return html;
        }

        /**
         * Строит HTML для раздела "Состав объектов" с процессами
         * @param {string} trigUri - URI TriG, которому принадлежат процессы
         * @param {Array} processes - Массив URI процессов
         * @param {Object} prefixes - Словарь префиксов
         * @returns {string} - HTML раздела
         */
        function buildObjectCompositionHtml(trigUri, processes, prefixes) {
            const objectCompositionId = `obj-comp-${escapeHtml(trigUri).replace(/[^a-zA-Z0-9]/g, '_')}`;

            let html = '';

            // Заголовок "Состав объектов"
            html += `<div class="trig-tree-item object-composition-header"
                         onclick="toggleObjectComposition('${objectCompositionId}')">`;
            html += `<span class="trig-tree-toggle object-composition-toggle" id="${objectCompositionId}-toggle">▶</span>`;
            html += `<span class="trig-tree-label object-composition-label">Состав объектов</span>`;
            html += `<span class="trig-tree-id">(${processes.length})</span>`;
            html += `</div>`;

            // Список процессов (скрыт по умолчанию)
            html += `<div class="trig-tree-children object-composition-list" id="${objectCompositionId}" style="display: none;">`;

            processes.forEach(processUri => {
                const processLabel = getPrefixedName(processUri, prefixes);
                const processLocalName = getLocalName(processUri);

                // Ищем rdfs:label процесса - сначала в текущем TriG, затем в vad:ptree
                let processDisplayName = processLocalName;
                if (trigHierarchy && trigHierarchy[trigUri]) {
                    const graphQuads = trigHierarchy[trigUri].quads;
                    const labelQuad = graphQuads.find(q =>
                        q.subject.value === processUri &&
                        (q.predicate.value === 'http://www.w3.org/2000/01/rdf-schema#label' ||
                         getPrefixedName(q.predicate.value, prefixes) === 'rdfs:label')
                    );
                    if (labelQuad) {
                        processDisplayName = labelQuad.object.value;
                    } else {
                        // Fallback: ищем в vad:ptree
                        const ptreeMetadata = getProcessMetadataFromPtree(processUri, prefixes);
                        if (ptreeMetadata.label) {
                            processDisplayName = ptreeMetadata.label;
                        }
                    }
                }

                html += `<div class="trig-tree-item process-item"
                             data-process-uri="${escapeHtml(processUri)}"
                             data-trig-uri="${escapeHtml(trigUri)}"
                             onclick="event.stopPropagation(); selectProcess('${escapeHtml(processUri)}', '${escapeHtml(trigUri)}')">`;
                html += `<span class="trig-tree-toggle"></span>`;
                html += `<span class="process-icon">⚙</span>`;
                html += `<span class="trig-tree-label">${escapeHtml(processDisplayName)}</span>`;
                html += `</div>`;
            });

            html += `</div>`;

            return html;
        }

        /**
         * Переключает видимость списка объектов (Состав объектов)
         * @param {string} listId - ID списка для переключения
         */
        function toggleObjectComposition(listId) {
            const list = document.getElementById(listId);
            const toggle = document.getElementById(listId + '-toggle');

            if (list && toggle) {
                if (list.style.display === 'none') {
                    list.style.display = 'block';
                    toggle.textContent = '▼';
                } else {
                    list.style.display = 'none';
                    toggle.textContent = '▶';
                }
            }
        }

        /**
         * Обработчик выбора процесса в дереве
         * @param {string} processUri - URI выбранного процесса
         * @param {string} trigUri - URI TriG, содержащего процесс
         */
        function selectProcess(processUri, trigUri) {
            // Если выбранный процесс из другого TriG, сначала переключаемся на этот TriG
            if (selectedTrigUri !== trigUri) {
                selectTriG(trigUri);
            }

            // Подсвечиваем процесс на диаграмме
            highlightProcessOnDiagram(processUri);
        }

        /**
         * Подсвечивает процесс на диаграмме
         * @param {string} processUri - URI процесса для подсветки
         */
        function highlightProcessOnDiagram(processUri) {
            // Снимаем предыдущее выделение
            const previouslySelected = document.querySelectorAll('#vad-trig-output .node.process-highlighted');
            previouslySelected.forEach(node => {
                node.classList.remove('process-highlighted');
            });

            // Находим узел процесса по его ID (используем nodeLabelToUri для поиска)
            const prefixedUri = getPrefixedName(processUri, currentPrefixes);
            const nodeId = generateVadNodeId(processUri, currentPrefixes);

            // Ищем узел SVG по ID или по тексту
            const output = document.getElementById('vad-trig-output');
            if (!output) return;

            const nodes = output.querySelectorAll('.node');
            nodes.forEach(node => {
                const titleElement = node.querySelector('title');
                if (titleElement) {
                    const nodeTitle = titleElement.textContent.trim();
                    // Проверяем, совпадает ли ID узла или его метка с URI процесса
                    if (nodeTitle === nodeId || nodeLabelToUri[nodeTitle] === processUri) {
                        node.classList.add('process-highlighted');
                        // Прокручиваем к выбранному элементу
                        node.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            });

            // Также выделяем элемент в дереве
            const processItems = document.querySelectorAll('.process-item');
            processItems.forEach(item => {
                if (item.getAttribute('data-process-uri') === processUri) {
                    item.classList.add('process-selected');
                } else {
                    item.classList.remove('process-selected');
                }
            });
        }

        /**
         * Отображает дерево TriG
         * @param {Object} hierarchy - Иерархия TriG
         * @param {string} rootUri - URI корневого TriG
         * @param {Object} prefixes - Словарь префиксов
         */
        function displayTriGTree(hierarchy, rootUri, prefixes) {
            const treeContent = document.getElementById('trig-tree-content');
            if (!treeContent) return;

            if (!rootUri || !hierarchy[rootUri]) {
                treeContent.innerHTML = '<div class="trig-properties-empty">Нет доступных TriG графов</div>';
                return;
            }

            const html = buildTriGTreeHtml(rootUri, hierarchy, prefixes, 0);
            treeContent.innerHTML = html;
        }

        /**
         * Отображает свойства выбранного TriG
         * @param {string} trigUri - URI TriG
         * @param {Object} hierarchy - Иерархия TriG
         * @param {Object} prefixes - Словарь префиксов
         */
        function displayTriGProperties(trigUri, hierarchy, prefixes) {
            const propertiesContent = document.getElementById('trig-properties-content');
            if (!propertiesContent) return;

            const graphInfo = hierarchy[trigUri];
            if (!graphInfo) {
                propertiesContent.innerHTML = '<div class="trig-properties-empty">Выберите TriG в дереве</div>';
                return;
            }

            let html = '';

            // Основные свойства TriG
            const prefixedUri = getPrefixedName(trigUri, prefixes);

            // URI with copy button
            html += `<div class="trig-property-item">`;
            html += `<div class="trig-property-predicate">URI</div>`;
            html += `<div class="trig-property-value-container">`;
            html += `<div class="trig-property-value uri">${escapeHtml(prefixedUri)}</div>`;
            html += `<button class="copy-id-btn" onclick="copyObjectId('${escapeHtml(trigUri)}', this)">Копировать</button>`;
            html += `</div>`;
            html += `</div>`;

            // Label
            if (graphInfo.label) {
                html += `<div class="trig-property-item">`;
                html += `<div class="trig-property-predicate">rdfs:label</div>`;
                html += `<div class="trig-property-value literal">"${escapeHtml(graphInfo.label)}"</div>`;
                html += `</div>`;
            }

            // hasParent
            if (graphInfo.hasParent) {
                const parentLabel = getPrefixedName(graphInfo.hasParent, prefixes);
                html += `<div class="trig-property-item">`;
                html += `<div class="trig-property-predicate">vad:hasParentTrig</div>`;
                html += `<div class="trig-property-value uri">${escapeHtml(parentLabel)}</div>`;
                html += `</div>`;
            }

            // Количество процессов
            html += `<div class="trig-property-item">`;
            html += `<div class="trig-property-predicate">Процессы (vad:TypeProcess)</div>`;
            html += `<div class="trig-property-value">${graphInfo.processes.length} шт.</div>`;
            html += `</div>`;

            // Количество дочерних TriG
            if (graphInfo.children.length > 0) {
                html += `<div class="trig-property-item">`;
                html += `<div class="trig-property-predicate">Дочерние TriG</div>`;
                html += `<div class="trig-property-value">${graphInfo.children.length} шт.</div>`;
                html += `</div>`;
            }

            // Количество триплетов
            html += `<div class="trig-property-item">`;
            html += `<div class="trig-property-predicate">Триплеты</div>`;
            html += `<div class="trig-property-value">${graphInfo.quads.length} шт.</div>`;
            html += `</div>`;

            propertiesContent.innerHTML = html;
        }

        /**
         * Обработчик выбора TriG в дереве
         * @param {string} trigUri - URI выбранного TriG
         */
        function selectTriG(trigUri) {
            selectedTrigUri = trigUri;

            // Обновляем выделение в дереве
            const treeItems = document.querySelectorAll('.trig-tree-item');
            treeItems.forEach(item => {
                if (item.getAttribute('data-trig-uri') === trigUri) {
                    item.classList.add('selected', 'active');
                } else {
                    item.classList.remove('selected', 'active');
                }
            });

            // Отображаем свойства выбранного TriG
            displayTriGProperties(trigUri, trigHierarchy, currentPrefixes);

            // Перевизуализируем граф для выбранного TriG
            revisualizeTrigVAD(trigUri);

            // Обновляем SPARQL запрос для выбранного TriG
            updateSparqlQueryForTriG();
        }

        /**
         * Перевизуализирует VAD для выбранного TriG
         * @param {string} trigUri - URI TriG для отображения
         */
        async function revisualizeTrigVAD(trigUri) {
            const graphInfo = trigHierarchy[trigUri];
            if (!graphInfo) return;

            const layoutEngine = document.getElementById('layout-engine').value;

            try {
                // Используем квады только из выбранного графа
                const filteredQuads = graphInfo.quads.filter(quad => {
                    const predicateUri = quad.predicate.value;
                    const predicateLabel = getPrefixedName(predicateUri, currentPrefixes);
                    return !isPredicateHidden(predicateUri, predicateLabel);
                });

                // Генерируем DOT-код в режиме VAD
                const originalMode = currentMode;
                currentMode = 'vad';  // Используем логику VAD для рендеринга

                // Временно заменяем currentQuads на квады выбранного графа
                const originalQuads = currentQuads;
                currentQuads = graphInfo.quads;

                const dotCode = rdfToDot(filteredQuads, currentPrefixes);
                currentDotCode = dotCode;
                console.log('VAD TriG - Сгенерированный DOT-код:', dotCode);

                // Восстанавливаем
                currentQuads = originalQuads;
                currentMode = originalMode;

                const viz = await Viz.instance();
                const svgString = viz.renderString(dotCode, { format: 'svg', engine: layoutEngine });

                // В режиме VAD TriG используем специальный контейнер vad-trig-output
                const output = document.getElementById('vad-trig-output');
                output.innerHTML = svgString;
                currentSvgElement = output.querySelector('svg');
                document.getElementById('vad-trig-zoom-controls').style.display = 'flex';
                addNodeClickHandlers();

            } catch (error) {
                console.error('Ошибка при перевизуализации VAD TriG:', error);
            }
        }

        /**
         * Показывает или скрывает панели VAD TriG режима
         * @param {boolean} show - Показать или скрыть
         */
        function toggleVADTriGPanels(show) {
            const vadTrigContainer = document.getElementById('vad-trig-container');
            const regularZoomContainer = document.getElementById('zoom-container');
            const regularZoomControls = document.getElementById('zoom-controls');
            const regularOutput = document.getElementById('output');

            if (vadTrigContainer) {
                vadTrigContainer.style.display = show ? 'flex' : 'none';
            }

            // Hide regular zoom container and clear output when showing VAD TriG panels
            if (regularZoomContainer) {
                regularZoomContainer.style.display = show ? 'none' : 'block';
            }
            if (regularZoomControls && show) {
                regularZoomControls.style.display = 'none';
            }
            if (regularOutput && show) {
                regularOutput.innerHTML = '';
            }
        }

        // ============================================================================
        // ФУНКЦИИ РАБОТЫ СО СТИЛЯМИ
        // ============================================================================

        const BaseStyles = {
            literal: 'shape="box" style="filled" fillcolor="#ffffcc"',
            blankNode: 'shape="ellipse" style="filled" fillcolor="#e0e0e0"',
            uri: 'shape="ellipse" style="filled" fillcolor="#cce5ff"',
            edge: ''
        };

        function getNodeStyle(nodeUri, isLiteral, isBlankNode) {
            if (currentMode === 'base') {
                if (isLiteral) return BaseStyles.literal;
                if (isBlankNode) return BaseStyles.blankNode;
                return BaseStyles.uri;
            }

            if (currentMode === 'aggregation') {
                if (isBlankNode) return AggregationNodeStyles['BlankNodeStyle'].dot;
                const nodeTypes = nodeTypesCache[nodeUri] || [];
                for (const [styleName, styleConfig] of Object.entries(AggregationNodeStyles)) {
                    if (styleName === 'default') continue;
                    for (const type of styleConfig.types) {
                        if (type.startsWith('_')) continue;
                        if (nodeTypes.includes(type)) return styleConfig.dot;
                    }
                }
                return AggregationNodeStyles['default'].dot;
            }

            if (currentMode === 'vad' || currentMode === 'vad-trig') {
                if (isBlankNode) return VADNodeStyles['default'].dot;
                const nodeTypes = nodeTypesCache[nodeUri] || [];
                const nodeSubtypes = nodeSubtypesCache[nodeUri] || [];

                // First, check styles that have subtypes defined (ProcessStyleBasic, ProcessStyleDetailed)
                for (const [styleName, styleConfig] of Object.entries(VADNodeStyles)) {
                    if (styleName === 'default') continue;
                    if (!styleConfig.subtypes) continue; // Skip styles without subtypes

                    // Check if node has matching type
                    const hasMatchingType = styleConfig.types.some(type => nodeTypes.includes(type));
                    if (!hasMatchingType) continue;

                    // Check if node has matching subtype
                    const hasMatchingSubtype = styleConfig.subtypes.some(subtype => nodeSubtypes.includes(subtype));
                    if (hasMatchingSubtype) return styleConfig.dot;
                }

                // Then, check styles without subtypes (ExecutorGroupStyle, ExecutorStyle, etc.)
                for (const [styleName, styleConfig] of Object.entries(VADNodeStyles)) {
                    if (styleName === 'default') continue;
                    if (styleConfig.subtypes) continue; // Skip styles with subtypes (already checked)

                    for (const type of styleConfig.types) {
                        if (nodeTypes.includes(type)) return styleConfig.dot;
                    }
                }

                // For Process nodes without explicit subtype, default to ProcessStyleBasic
                const isProcess = nodeTypes.some(t =>
                    t === 'vad:TypeProcess' || t === 'http://example.org/vad#TypeProcess'
                );
                if (isProcess) {
                    return VADNodeStyles['ProcessStyleBasic'].dot;
                }

                return VADNodeStyles['default'].dot;
            }

            // Режим нотации
            if (isLiteral) return StyleName.nodeStyles['LiteralStyle'].dot;
            if (isBlankNode) return StyleName.nodeStyles['BlankNodeStyle'].dot;

            const nodeTypes = nodeTypesCache[nodeUri] || [];
            for (const [styleName, styleConfig] of Object.entries(StyleName.nodeStyles)) {
                if (styleName === 'default') continue;
                for (const type of styleConfig.types) {
                    if (type.startsWith('_')) continue;
                    if (nodeTypes.includes(type)) return styleConfig.dot;
                }
            }
            return StyleName.nodeStyles['default'].dot;
        }

        function getEdgeStyle(predicateUri, predicateLabel) {
            if (currentMode === 'base') return BaseStyles.edge;

            if (currentMode === 'vad') {
                for (const [styleName, styleConfig] of Object.entries(VADEdgeStyles)) {
                    if (styleName === 'default') continue;
                    for (const predicate of styleConfig.predicates) {
                        if (predicateUri === predicate || predicateLabel === predicate) {
                            return styleConfig.dot;
                        }
                    }
                }
                return VADEdgeStyles['default'].dot;
            }

            // Режим нотации или агрегации
            for (const [styleName, styleConfig] of Object.entries(StyleName.edgeStyles)) {
                if (styleName === 'default') continue;
                for (const predicate of styleConfig.predicates) {
                    if (predicateUri === predicate || predicateLabel === predicate) {
                        return styleConfig.dot;
                    }
                }
            }
            return StyleName.edgeStyles['default'].dot;
        }

        function buildNodeTypesCache(quads, prefixes) {
            nodeTypesCache = {};
            nodeSubtypesCache = {};
            const typePredicates = [
                'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
                'rdf:type',
                'a'
            ];
            const subtypePredicates = [
                'http://example.org/vad#processSubtype',
                'vad:processSubtype'
            ];

            // Функция для обработки квадов и наполнения кешей
            function processQuads(quadsToProcess) {
                quadsToProcess.forEach(quad => {
                    const predicateValue = quad.predicate.value;
                    const predicateLabel = getPrefixedName(predicateValue, prefixes);

                    // Build types cache
                    if (typePredicates.includes(predicateValue) ||
                        typePredicates.includes(predicateLabel) ||
                        predicateLabel === 'a') {

                        const subjectUri = quad.subject.value;
                        const typeUri = quad.object.value;
                        const typeLabel = getPrefixedName(typeUri, prefixes);

                        if (!nodeTypesCache[subjectUri]) {
                            nodeTypesCache[subjectUri] = [];
                        }

                        if (!nodeTypesCache[subjectUri].includes(typeUri)) {
                            nodeTypesCache[subjectUri].push(typeUri);
                        }
                        if (!nodeTypesCache[subjectUri].includes(typeLabel)) {
                            nodeTypesCache[subjectUri].push(typeLabel);
                        }
                    }

                    // Build subtypes cache for vad:processSubtype
                    if (subtypePredicates.includes(predicateValue) ||
                        subtypePredicates.includes(predicateLabel)) {

                        const subjectUri = quad.subject.value;
                        const subtypeUri = quad.object.value;
                        const subtypeLabel = getPrefixedName(subtypeUri, prefixes);

                        if (!nodeSubtypesCache[subjectUri]) {
                            nodeSubtypesCache[subjectUri] = [];
                        }

                        if (!nodeSubtypesCache[subjectUri].includes(subtypeUri)) {
                            nodeSubtypesCache[subjectUri].push(subtypeUri);
                        }
                        if (!nodeSubtypesCache[subjectUri].includes(subtypeLabel)) {
                            nodeSubtypesCache[subjectUri].push(subtypeLabel);
                        }
                    }
                });
            }

            // Обрабатываем переданные квады
            processQuads(quads);

            // Дополнительно: в режиме VAD TriG также включаем типы из vad:ptree
            // чтобы rdf:type vad:TypeProcess были доступны для всех TriG графов
            if (trigHierarchy && trigHierarchy[PTREE_GRAPH_URI]) {
                const ptreeQuads = trigHierarchy[PTREE_GRAPH_URI].quads;
                processQuads(ptreeQuads);
            }
        }

        // ============================================================================
        // ФУНКЦИИ МАСШТАБИРОВАНИЯ
        // ============================================================================

        function applyZoom() {
            // Применяем масштаб к обоим контейнерам (обычный и VAD TriG)
            const zoomContent = document.getElementById('zoom-content');
            const zoomLevel = document.getElementById('zoom-level');
            const vadTrigZoomContent = document.getElementById('vad-trig-zoom-content');
            const vadTrigZoomLevel = document.getElementById('vad-trig-zoom-level');

            if (zoomContent) zoomContent.style.transform = `scale(${currentScale})`;
            if (zoomLevel) zoomLevel.textContent = Math.round(currentScale * 100) + '%';
            if (vadTrigZoomContent) vadTrigZoomContent.style.transform = `scale(${currentScale})`;
            if (vadTrigZoomLevel) vadTrigZoomLevel.textContent = Math.round(currentScale * 100) + '%';
        }

        function zoomIn() {
            if (currentScale < 3.0) { currentScale += 0.1; applyZoom(); }
        }

        function zoomOut() {
            if (currentScale > 0.1) { currentScale -= 0.1; applyZoom(); }
        }

        function zoomReset() {
            currentScale = 1.0;
            applyZoom();
        }

        function zoomFit() {
            // Определяем, какой контейнер сейчас активен
            const vadTrigContainer = document.getElementById('vad-trig-container');
            const isVadTrigMode = vadTrigContainer && vadTrigContainer.style.display !== 'none';

            let zoomContainer, output;
            if (isVadTrigMode) {
                zoomContainer = document.getElementById('vad-trig-zoom-container');
                output = document.getElementById('vad-trig-output');
            } else {
                zoomContainer = document.getElementById('zoom-container');
                output = document.getElementById('output');
            }

            const svg = output ? output.querySelector('svg') : null;
            if (!zoomContainer || !svg) return;

            const containerWidth = zoomContainer.clientWidth - 20;
            const containerHeight = zoomContainer.clientHeight - 20;

            let svgWidth = parseFloat(svg.getAttribute('width')) || svg.getBoundingClientRect().width;
            let svgHeight = parseFloat(svg.getAttribute('height')) || svg.getBoundingClientRect().height;

            const widthStr = svg.getAttribute('width') || '';
            const heightStr = svg.getAttribute('height') || '';
            if (widthStr.includes('pt')) svgWidth = parseFloat(widthStr) * 1.33;
            if (heightStr.includes('pt')) svgHeight = parseFloat(heightStr) * 1.33;

            const scaleX = containerWidth / svgWidth;
            const scaleY = containerHeight / svgHeight;
            currentScale = Math.min(scaleX, scaleY, 1.0);
            applyZoom();
        }

        // ============================================================================
        // ФУНКЦИИ ПАНЕЛИ СВОЙСТВ УЗЛА
        // ============================================================================

        function closePropertiesPanel(panelId) {
            const panel = document.getElementById(panelId);
            if (panel) {
                panel.remove();
                openPropertiesPanels = openPropertiesPanels.filter(p => p.id !== panelId);
            }
            if (selectedNodeElement) {
                selectedNodeElement.classList.remove('selected');
                selectedNodeElement = null;
            }
        }

        function closeAllPropertiesPanels() {
            const container = document.getElementById('properties-panels-container');
            if (container) container.innerHTML = '';
            openPropertiesPanels = [];
            if (selectedNodeElement) {
                selectedNodeElement.classList.remove('selected');
                selectedNodeElement = null;
            }
        }

        function getNodeProperties(nodeUri) {
            const properties = [];
            currentQuads.forEach(quad => {
                if (quad.subject.value === nodeUri) {
                    const predicateLabel = getPrefixedName(quad.predicate.value, currentPrefixes);
                    const isLiteral = quad.object.termType === 'Literal';
                    const objectLabel = isLiteral
                        ? `"${quad.object.value}"`
                        : getPrefixedName(quad.object.value, currentPrefixes);

                    properties.push({
                        predicate: quad.predicate.value,
                        predicateLabel: predicateLabel,
                        object: quad.object.value,
                        objectLabel: objectLabel,
                        isLiteral: isLiteral
                    });
                }
            });
            return properties;
        }

        function showNodeProperties(nodeUri, nodeLabel) {
            const container = document.getElementById('properties-panels-container');
            if (!container) return;

            const existingPanel = openPropertiesPanels.find(p => p.uri === nodeUri);
            if (existingPanel) {
                const panel = document.getElementById(existingPanel.id);
                if (panel) bringPanelToFront(panel);
                return;
            }

            propertiesPanelCounter++;
            const panelId = 'properties-panel-' + propertiesPanelCounter;

            const offsetMultiplier = openPropertiesPanels.length % 5;
            const rightOffset = 20 + (offsetMultiplier * 30);
            const topOffset = 100 + (offsetMultiplier * 30);

            const properties = getNodeProperties(nodeUri);

            let propertiesHtml = '';
            if (properties.length === 0) {
                propertiesHtml = '<div class="properties-empty">У этого узла нет свойств</div>';
            } else {
                properties.forEach(prop => {
                    propertiesHtml += '<div class="property-item">';
                    propertiesHtml += `<div class="property-predicate">${prop.predicateLabel}</div>`;
                    propertiesHtml += `<div class="property-value ${prop.isLiteral ? 'literal' : 'uri'}">${prop.objectLabel}</div>`;
                    propertiesHtml += '</div>';
                });
            }

            const nodeTypes = nodeTypesCache[nodeUri] || [];
            if (nodeTypes.length > 0) {
                const prefixedTypes = nodeTypes.filter(t => t.includes(':') && !t.startsWith('http'));
                if (prefixedTypes.length > 0) {
                    propertiesHtml += '<div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ddd;">';
                    propertiesHtml += '<div style="font-size: 12px; color: #666; margin-bottom: 5px;">Тип узла:</div>';
                    prefixedTypes.forEach(type => {
                        propertiesHtml += `<span class="properties-type-badge">${type}</span> `;
                    });
                    propertiesHtml += '</div>';
                }
            }

            const escapedNodeLabel = nodeLabel.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const panelHtml = `
                <div class="properties-panel visible" id="${panelId}" style="right: ${rightOffset}px; top: ${topOffset}px;">
                    <div class="properties-header" onmousedown="startDragPanel(event, '${panelId}')">
                        <div class="properties-header-content">
                            <div class="properties-header-title">Свойства объекта</div>
                            <div class="properties-header-row">
                                <h3>${nodeLabel}</h3>
                                <button class="properties-copy-btn" onclick="event.stopPropagation(); copyObjectId('${escapedNodeLabel}', this)">Копировать</button>
                            </div>
                        </div>
                        <button class="properties-close-btn" onclick="closePropertiesPanel('${panelId}')">&times;</button>
                    </div>
                    <div class="properties-content">
                        ${propertiesHtml}
                    </div>
                </div>
            `;

            container.insertAdjacentHTML('beforeend', panelHtml);
            openPropertiesPanels.push({ id: panelId, uri: nodeUri, label: nodeLabel });

            const newPanel = document.getElementById(panelId);
            if (newPanel) bringPanelToFront(newPanel);
        }

        function bringPanelToFront(panel) {
            let maxZIndex = 1000;
            openPropertiesPanels.forEach(p => {
                const el = document.getElementById(p.id);
                if (el) {
                    const z = parseInt(el.style.zIndex) || 1000;
                    if (z > maxZIndex) maxZIndex = z;
                }
            });
            panel.style.zIndex = maxZIndex + 1;
        }

        function startDragPanel(event, panelId) {
            if (event.target.classList.contains('properties-close-btn')) return;
            const panel = document.getElementById(panelId);
            if (!panel) return;

            draggedPanel = panel;
            const rect = panel.getBoundingClientRect();
            dragOffsetX = event.clientX - rect.left;
            dragOffsetY = event.clientY - rect.top;

            bringPanelToFront(panel);
            document.addEventListener('mousemove', dragPanel);
            document.addEventListener('mouseup', stopDragPanel);
            event.preventDefault();
        }

        function dragPanel(event) {
            if (!draggedPanel) return;
            const newLeft = event.clientX - dragOffsetX;
            const newTop = event.clientY - dragOffsetY;
            draggedPanel.style.left = newLeft + 'px';
            draggedPanel.style.top = newTop + 'px';
            draggedPanel.style.right = 'auto';
        }

        function stopDragPanel() {
            draggedPanel = null;
            document.removeEventListener('mousemove', dragPanel);
            document.removeEventListener('mouseup', stopDragPanel);
        }

        // ============================================================================
        // ФУНКЦИИ ДЛЯ КЛИКОВ ПО УЗЛАМ
        // ============================================================================

        function addNodeClickHandlers() {
            // Add click handlers to both regular output and VAD TriG output
            const regularSvg = document.querySelector('#output svg');
            const vadTrigSvg = document.querySelector('#vad-trig-output svg');

            const svgElements = [regularSvg, vadTrigSvg].filter(svg => svg !== null);

            svgElements.forEach(svg => {
                const nodes = svg.querySelectorAll('.node');
                nodes.forEach(node => {
                    node.addEventListener('click', handleNodeClick);
                    node.addEventListener('dblclick', handleNodeDoubleClick);
                });
            });
        }

        function handleNodeClick(event) {
            const nodeElement = event.currentTarget;
            const titleElement = nodeElement.querySelector('title');
            if (!titleElement) return;

            const dotId = titleElement.textContent;

            let nodeUri = null;
            let nodeLabel = null;

            for (const [label, info] of Object.entries(nodeLabelToUri)) {
                if (info.dotId === dotId) {
                    nodeUri = info.uri;
                    nodeLabel = label;
                    break;
                }
            }

            if (!nodeUri) return;

            // Снимаем выделение с элементов TriG-дерева при клике на узел диаграммы
            clearTriGTreeSelection();

            if (selectedNodeElement) {
                selectedNodeElement.classList.remove('selected');
            }
            nodeElement.classList.add('selected');
            selectedNodeElement = nodeElement;

            showNodeProperties(nodeUri, nodeLabel);
        }

        /**
         * Обработчик двойного клика по узлу диаграммы
         * Для процессов с подтипом "Детализированный" (vad:Detailed) открывает соответствующую схему TriG
         * @param {Event} event - Событие двойного клика
         */
        function handleNodeDoubleClick(event) {
            event.preventDefault();
            event.stopPropagation();

            const nodeElement = event.currentTarget;
            const titleElement = nodeElement.querySelector('title');
            if (!titleElement) return;

            const dotId = titleElement.textContent;

            let nodeUri = null;
            let nodeLabel = null;

            for (const [label, info] of Object.entries(nodeLabelToUri)) {
                if (info.dotId === dotId) {
                    nodeUri = info.uri;
                    nodeLabel = label;
                    break;
                }
            }

            if (!nodeUri) return;

            // Ищем свойство vad:hasTrig для данного узла
            const hasTrigPredicate = 'http://example.org/vad#hasTrig';
            let targetTrigUri = null;

            // Сначала проверяем в vad:ptree (там хранятся метаданные процессов, включая hasTrig)
            if (trigHierarchy && trigHierarchy[PTREE_GRAPH_URI]) {
                const ptreeQuads = trigHierarchy[PTREE_GRAPH_URI].quads;
                for (const quad of ptreeQuads) {
                    if (quad.subject.value === nodeUri && quad.predicate.value === hasTrigPredicate) {
                        targetTrigUri = quad.object.value;
                        break;
                    }
                }
            }

            // Если не найдено в ptree, проверяем в текущем графе или во всех графах
            if (!targetTrigUri) {
                const quadsToCheck = selectedTrigUri && trigHierarchy[selectedTrigUri]
                    ? trigHierarchy[selectedTrigUri].quads
                    : currentQuads;

                for (const quad of quadsToCheck) {
                    if (quad.subject.value === nodeUri && quad.predicate.value === hasTrigPredicate) {
                        targetTrigUri = quad.object.value;
                        break;
                    }
                }
            }

            // Если найден связанный TriG, открываем его
            if (targetTrigUri && trigHierarchy[targetTrigUri]) {
                selectTriG(targetTrigUri);
            }
        }

        /**
         * Снимает выделение со всех элементов TriG-дерева
         */
        function clearTriGTreeSelection() {
            // Снимаем выделение с TriG-элементов дерева
            const treeItems = document.querySelectorAll('.trig-tree-item');
            treeItems.forEach(item => {
                item.classList.remove('selected', 'active');
            });

            // Снимаем выделение с процессов в дереве
            const processItems = document.querySelectorAll('.process-item.process-selected');
            processItems.forEach(item => {
                item.classList.remove('process-selected');
            });

            // Снимаем подсветку процесса на диаграмме
            const highlightedProcesses = document.querySelectorAll('.node.process-highlighted');
            highlightedProcesses.forEach(node => {
                node.classList.remove('process-highlighted');
            });
        }

        // ============================================================================
        // ФУНКЦИИ ФИЛЬТРОВ
        // ============================================================================

        function isPredicateHidden(predicateUri, predicateLabel) {
            return activeFilters.includes(predicateUri) || activeFilters.includes(predicateLabel);
        }

        function displayFilters() {
            const filterPanel = document.getElementById('filter-panel');
            const filterContent = document.getElementById('filter-content');

            allPredicates = [];
            const predicateSet = new Set();

            currentQuads.forEach(quad => {
                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, currentPrefixes);
                if (!predicateSet.has(predicateLabel)) {
                    predicateSet.add(predicateLabel);
                    allPredicates.push({ uri: predicateUri, label: predicateLabel });
                }
            });

            if (allPredicates.length === 0) {
                filterPanel.style.display = 'none';
                return;
            }

            allPredicates.sort((a, b) => a.label.localeCompare(b.label));

            let html = '';
            allPredicates.forEach(pred => {
                const isHidden = isPredicateHidden(pred.uri, pred.label);
                const checkboxId = 'filter-' + pred.label.replace(/[^a-zA-Z0-9]/g, '_');

                html += `<div class="filter-item">`;
                html += `<input type="checkbox" id="${checkboxId}" ${!isHidden ? 'checked' : ''} onchange="togglePredicateFilter('${pred.uri}', '${pred.label}', this.checked)">`;
                html += `<label for="${checkboxId}">${pred.label}</label>`;
                html += `</div>`;
            });

            filterContent.innerHTML = html;
            filterPanel.style.display = 'block';
        }

        function togglePredicateFilter(predicateUri, predicateLabel, isVisible) {
            if (isVisible) {
                activeFilters = activeFilters.filter(f => f !== predicateUri && f !== predicateLabel);
            } else {
                if (!activeFilters.includes(predicateUri)) {
                    activeFilters.push(predicateUri);
                }
                if (!activeFilters.includes(predicateLabel)) {
                    activeFilters.push(predicateLabel);
                }
            }
            revisualize();
        }

        function selectAllFilters() {
            activeFilters = [];
            displayFilters();
            revisualize();
        }

        function deselectAllFilters() {
            activeFilters = allPredicates.flatMap(p => [p.uri, p.label]);
            displayFilters();
            revisualize();
        }

        async function revisualize() {
            const layoutEngine = document.getElementById('layout-engine').value;

            try {
                const filteredQuads = currentQuads.filter(quad => {
                    const predicateUri = quad.predicate.value;
                    const predicateLabel = getPrefixedName(predicateUri, currentPrefixes);
                    return !isPredicateHidden(predicateUri, predicateLabel);
                });

                const dotCode = rdfToDot(filteredQuads, currentPrefixes);
                currentDotCode = dotCode;
                console.log('Пересгенерированный DOT-код:', dotCode);

                const viz = await Viz.instance();
                const svgString = viz.renderString(dotCode, { format: 'svg', engine: layoutEngine });

                const output = document.getElementById('output');
                output.innerHTML = svgString;
                currentSvgElement = output.querySelector('svg');
                addNodeClickHandlers();

            } catch (error) {
                console.error('Ошибка при перевизуализации:', error);
            }
        }

        // ============================================================================
        // ФУНКЦИИ ЗАГРУЗКИ ПРИМЕРОВ
        // ============================================================================

        function loadExampleTurtle() {
            fetch('Turtle.ttl')
                .then(response => response.text())
                .then(text => {
                    document.getElementById('rdf-input').value = text;
                    document.getElementById('input-format').value = 'turtle';
                    document.getElementById('visualization-mode').value = 'notation';
                    updateModeDescription();
                })
                .catch(error => console.error('Error loading Turtle.ttl:', error));
        }

        /**
         * Загружает пример VAD (Value Added Chain Diagram)
         */
        function loadExampleVAD() {
            fetch('VAD.ttl')
                .then(response => response.text())
                .then(exampleVAD => {
                    document.getElementById('rdf-input').value = exampleVAD;
                    document.getElementById('input-format').value = 'turtle';
                    document.getElementById('visualization-mode').value = 'vad';
                    updateModeDescription();
                })
                .catch(error => console.error('Error loading VAD.ttl:', error));
        }

        function loadExampleNTriples() {
            fetch('NTriples.ttl')
                .then(response => response.text())
                .then(text => {
                    document.getElementById('rdf-input').value = text;
                    document.getElementById('input-format').value = 'n-triples';
                    document.getElementById('visualization-mode').value = 'notation';
                    updateModeDescription();
                })
                .catch(error => console.error('Error loading NTriples.ttl:', error));
        }

        /**
         * Загружает пример RDF данных в формате N-Quads
         */
        function loadExampleNQuads() {
            fetch('NQuads.ttl')
                .then(response => response.text())
                .then(text => {
                    document.getElementById('rdf-input').value = text;
                    document.getElementById('input-format').value = 'n-quads';
                    document.getElementById('visualization-mode').value = 'notation';
                    updateModeDescription();
                })
                .catch(error => console.error('Error loading NQuads.ttl:', error));
        }

        /**
         * Загружает пример RDF данных в формате TriG
         */
        function loadExampleTriG() {
            fetch('TriG.ttl')
                .then(response => response.text())
                .then(text => {
                    document.getElementById('rdf-input').value = text;
                    document.getElementById('input-format').value = 'trig';
                    document.getElementById('visualization-mode').value = 'notation';
                    updateModeDescription();
                })
                .catch(error => console.error('Error loading TriG.ttl:', error));
        }

        /**
         * Загружает пример TriG VAD - все объекты Turtle VAD в одном именованном графе
         * Имя графа (Trig1) и его label отображаются как название схемы вверху диаграммы
         */
        function loadExampleTrigVAD() {
            fetch('Trig_VAD.ttl')
                .then(response => response.text())
                    document.getElementById('rdf-input').value = exampleTrigVAD;
                    document.getElementById('input-format').value = 'trig';
                    document.getElementById('visualization-mode').value = 'vad';
                    updateModeDescription();
                })
                .catch(error => console.error('Error loading Trig_VAD.ttl:', error));
        }

        /**
         * Загружает пример TriG VADv2 с иерархией TriG графов
         * Содержит:
         * - Trig1: корневой граф (hasParentTrig = root)
         * - Trig11: дочерний граф (hasParentTrig = Trig1)
         */
        function loadExampleTrigVADv2() {
            fetch('Trig_VADv2.ttl')
                .then(response => response.text())
                    document.getElementById('rdf-input').value = exampleTrigVADv2;
                    document.getElementById('input-format').value = 'trig';
                    document.getElementById('visualization-mode').value = 'vad-trig';
                    updateModeDescription();
                })
                .catch(error => console.error('Error loading Trig_VADv2.ttl:', error));
        }

        /**
         * Для обратной совместимости: вызывает загрузку примера Turtle
         */
        function loadExample() {
            loadExampleTurtle();
        }

        // ============================================================================
        // ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ДЛЯ РАБОТЫ С URI
        // ============================================================================

        function getLocalName(uri) {
            if (typeof uri !== 'string') return String(uri);
            const hashIndex = uri.lastIndexOf('#');
            const slashIndex = uri.lastIndexOf('/');
            const splitIndex = Math.max(hashIndex, slashIndex);
            if (splitIndex !== -1 && splitIndex < uri.length - 1) {
                return uri.substring(splitIndex + 1);
            }
            return uri;
        }

        function getPrefixedName(uri, prefixes) {
            if (typeof uri !== 'string') return String(uri);
            for (const [prefix, namespace] of Object.entries(prefixes)) {
                if (uri.startsWith(namespace)) {
                    const localName = uri.substring(namespace.length);
                    return prefix + ':' + localName;
                }
            }
            return getLocalName(uri);
        }

        function escapeDotString(str) {
            return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        }

        function generateNodeId(value) {
            let hash = 0;
            for (let i = 0; i < value.length; i++) {
                const char = value.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return 'node' + Math.abs(hash);
        }

        /**
         * Генерирует ID узла для VAD режима на основе RDF идентификатора.
         * Преобразует prefixed name (например, vad:Process1) в валидный DOT ID (vad_Process1).
         * @param {string} uri - URI узла
         * @param {Object} prefixes - Словарь префиксов
         * @returns {string} - Валидный DOT ID
         */
        function generateVadNodeId(uri, prefixes) {
            const prefixedName = getPrefixedName(uri, prefixes);
            // Заменяем ':' на '_' для получения валидного DOT ID
            // Также заменяем другие недопустимые символы на '_'
            return prefixedName.replace(/[:\-\.\s]/g, '_');
        }

        function isNameOrLabelPredicate(predicateLabel) {
            const lowerPredicate = predicateLabel.toLowerCase();
            return lowerPredicate.includes('name') || lowerPredicate.includes('label');
        }

        function escapeHtmlLabel(str) {
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        /**
         * Экранирует HTML символы для безопасного отображения
         * @param {string} text - Исходный текст
         * @returns {string} - Экранированный текст
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Копирует ID объекта в буфер обмена
         * @param {string} id - ID для копирования
         * @param {HTMLElement} button - Кнопка, которая была нажата
         */
        function copyObjectId(id, button) {
            navigator.clipboard.writeText(id).then(() => {
                // Показываем подтверждение
                const originalText = button.textContent;
                button.textContent = 'Скопировано!';
                button.classList.add('copied');

                // Возвращаем оригинальный текст через 2 секунды
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Ошибка копирования:', err);
                // Fallback для старых браузеров
                const textArea = document.createElement('textarea');
                textArea.value = id;
                textArea.style.position = 'fixed';
                textArea.style.left = '-9999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    button.textContent = 'Скопировано!';
                    button.classList.add('copied');
                    setTimeout(() => {
                        button.textContent = 'Копировать';
                        button.classList.remove('copied');
                    }, 2000);
                } catch (e) {
                    console.error('Fallback copy failed:', e);
                }
                document.body.removeChild(textArea);
            });
        }

        function wrapTextByWords(text, maxLength) {
            if (!text || text.length <= maxLength) return [text];
            const words = text.split(/\s+/);
            const lines = [];
            let currentLine = '';
            for (const word of words) {
                if (currentLine.length === 0) {
                    currentLine = word;
                } else if (currentLine.length + 1 + word.length <= maxLength) {
                    currentLine += ' ' + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine.length > 0) lines.push(currentLine);
            return lines;
        }

        function formatLabelWithWrap(label, maxLength, isBold = false) {
            const lines = wrapTextByWords(label, maxLength);
            const needsWrap = lines.length > 1;
            if (!needsWrap) {
                if (isBold) return `<B>${escapeHtmlLabel(label)}</B>`;
                return escapeHtmlLabel(label);
            }
            let result = '';
            for (let i = 0; i < lines.length; i++) {
                if (i > 0) result += '<BR/>';
                const escapedLine = escapeHtmlLabel(lines[i]);
                if (isBold) {
                    result += `<FONT POINT-SIZE="9"><B>${escapedLine}</B></FONT>`;
                } else {
                    result += `<FONT POINT-SIZE="9">${escapedLine}</FONT>`;
                }
            }
            return result;
        }

        // ============================================================================
        // ГЕНЕРАЦИЯ DOT-КОДА
        // ============================================================================

        /**
         * Генерирует DOT-код для режима VAD
         * В этом режиме:
         * - Процессы отображаются как cds (chevron) с зеленой заливкой
         * - Под процессами показываются исполнители
         * - Связи hasNext идут с востока на запад
         * - hasParentTrig не показывается, но есть в свойствах
         */
        function rdfToDotVAD(quads, prefixes = {}) {
            buildNodeTypesCache(currentQuads, prefixes);
            nodeLabelToUri = {};

            // Собираем информацию о процессах и их исполнителях
            const processes = new Map();  // URI процесса -> информация
            const executorGroups = new Map();  // URI группы -> список исполнителей
            const hasNextEdges = [];  // Связи hasNext между процессами

            // ver5t: Извлекаем информацию об именованном графе для отображения заголовка схемы
            let namedGraphUri = null;
            const graphLabels = new Map();  // URI графа -> rdfs:label

            // Собираем все именованные графы и их метки
            quads.forEach(quad => {
                // Получаем URI именованного графа (если есть)
                if (quad.graph && quad.graph.value && quad.graph.value !== '') {
                    if (!namedGraphUri) {
                        namedGraphUri = quad.graph.value;  // Берём первый именованный граф
                    }
                }
            });

            // Ищем rdfs:label для именованных графов (определяется вне графа)
            quads.forEach(quad => {
                const subjectUri = quad.subject.value;
                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, prefixes);

                if (predicateLabel === 'rdfs:label' || predicateUri === 'http://www.w3.org/2000/01/rdf-schema#label') {
                    // Проверяем, является ли subject именованным графом
                    if (subjectUri === namedGraphUri) {
                        graphLabels.set(subjectUri, quad.object.value);
                    }
                }
            });

            // Первый проход: собираем все объекты
            quads.forEach(quad => {
                const subjectUri = quad.subject.value;
                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, prefixes);
                const objectValue = quad.object.value;

                // Проверяем типы
                const subjectTypes = nodeTypesCache[subjectUri] || [];
                const isProcess = subjectTypes.some(t =>
                    t === 'vad:TypeProcess' || t === 'http://example.org/vad#TypeProcess'
                );

                if (isProcess) {
                    if (!processes.has(subjectUri)) {
                        processes.set(subjectUri, {
                            uri: subjectUri,
                            label: getPrefixedName(subjectUri, prefixes),
                            name: null,
                            executorGroup: null,
                            hasNext: [],
                            hasParent: null
                        });
                    }

                    const processInfo = processes.get(subjectUri);

                    // Собираем rdfs:label для имени
                    if (predicateLabel === 'rdfs:label' || predicateUri === 'http://www.w3.org/2000/01/rdf-schema#label') {
                        processInfo.name = objectValue;
                    }

                    // Собираем hasExecutor
                    if (predicateLabel === 'vad:hasExecutor' || predicateUri === 'http://example.org/vad#hasExecutor') {
                        processInfo.executorGroup = objectValue;
                    }

                    // Собираем hasNext
                    if (predicateLabel === 'vad:hasNext' || predicateUri === 'http://example.org/vad#hasNext') {
                        processInfo.hasNext.push(objectValue);
                        hasNextEdges.push({ from: subjectUri, to: objectValue });
                    }

                    // Собираем hasParent
                    if (predicateLabel === 'vad:hasParentTrig' || predicateUri === 'http://example.org/vad#hasParentTrig') {
                        processInfo.hasParent = objectValue;
                    }
                }

                // Собираем информацию о группах исполнителей
                const isExecutorGroup = subjectTypes.some(t =>
                    t === 'vad:ExecutorGroup' || t === 'http://example.org/vad#ExecutorGroup'
                );

                if (isExecutorGroup) {
                    if (!executorGroups.has(subjectUri)) {
                        executorGroups.set(subjectUri, {
                            uri: subjectUri,
                            label: null,
                            executors: []
                        });
                    }

                    const groupInfo = executorGroups.get(subjectUri);

                    if (predicateLabel === 'rdfs:label' || predicateUri === 'http://www.w3.org/2000/01/rdf-schema#label') {
                        groupInfo.label = objectValue;
                    }

                    if (predicateLabel === 'vad:includes' || predicateUri === 'http://example.org/vad#includes') {
                        groupInfo.executors.push(objectValue);
                    }
                }
            });

            // Дополняем метаданные процессов из vad:ptree (если не найдены в текущем TriG)
            processes.forEach((processInfo, processUri) => {
                if (!processInfo.name) {
                    const ptreeMetadata = getProcessMetadataFromPtree(processUri, prefixes);
                    if (ptreeMetadata.label) {
                        processInfo.name = ptreeMetadata.label;
                    }
                }
            });

            // Собираем имена исполнителей
            // Сначала из текущих quads (если rdfs:label есть в этом графе)
            const executorNames = new Map();
            quads.forEach(quad => {
                const subjectUri = quad.subject.value;
                const predicateUri = quad.predicate.value;
                const predicateLabel = getPrefixedName(predicateUri, prefixes);
                const objectValue = quad.object.value;

                const subjectTypes = nodeTypesCache[subjectUri] || [];
                const isExecutor = subjectTypes.some(t =>
                    t === 'vad:TypeExecutor' || t === 'http://example.org/vad#TypeExecutor'
                );

                if (isExecutor && (predicateLabel === 'rdfs:label' || predicateUri === 'http://www.w3.org/2000/01/rdf-schema#label')) {
                    executorNames.set(subjectUri, objectValue);
                }
            });

            // Дополняем имена исполнителей из vad:rtree (если не найдены в текущем TriG)
            executorGroups.forEach((groupInfo, groupUri) => {
                groupInfo.executors.forEach(executorUri => {
                    if (!executorNames.has(executorUri)) {
                        const nameFromRtree = getExecutorNameFromRtree(executorUri, prefixes);
                        if (nameFromRtree) {
                            executorNames.set(executorUri, nameFromRtree);
                        }
                    }
                });
            });

            // Генерация DOT-кода
            // Используем rankdir=TB чтобы rank=same группировал узлы горизонтально
            // А процессы идут в одной строке благодаря rank=same
            let dot = 'digraph VADGraph {\n';
            dot += '    // VAD (Value Added Chain Diagram)\n';
            dot += '    rankdir=TB;\n';  // Top-to-bottom позволяет горизонтальное выравнивание через rank=same
            dot += '    node [fontname="Arial"];\n';
            dot += '    edge [fontname="Arial", fontsize=10];\n';
            dot += '    splines=spline;\n';  // spline для лучшей маршрутизации skip-ребер
            dot += '    nodesep=0.8;\n';  // Расстояние между узлами
            dot += '    ranksep=0.3;\n';  // Минимальное расстояние между рангами (CDS и ExecutorGroup)

            // ver5t: Добавляем заголовок схемы из именованного графа (если есть)
            // Сначала проверяем graphLabels (для обычного VAD режима)
            // Затем проверяем trigHierarchy (для VAD TriG режима)
            let schemaTitle = null;
            if (namedGraphUri && graphLabels.has(namedGraphUri)) {
                schemaTitle = graphLabels.get(namedGraphUri);
            } else if (namedGraphUri && trigHierarchy && trigHierarchy[namedGraphUri] && trigHierarchy[namedGraphUri].label) {
                schemaTitle = trigHierarchy[namedGraphUri].label;
            }
            if (schemaTitle) {
                dot += `    label="${escapeDotString(schemaTitle)}";\n`;
                dot += '    labelloc="t";\n';  // Заголовок вверху
                dot += '    fontname="Arial";\n';
                dot += '    fontsize=16;\n';
            }
            dot += '\n';

            // Фильтруем процессы - показываем только те, которые не являются материнскими
            // (Process0 скрыт, потому что он не имеет hasNext и является родителем)
            const visibleProcesses = new Map();
            processes.forEach((processInfo, uri) => {
                // Показываем процесс, если он имеет hasNext или на него ссылается hasNext
                const hasOutgoingNext = processInfo.hasNext.length > 0;
                const hasIncomingNext = [...processes.values()].some(p => p.hasNext.includes(uri));

                if (hasOutgoingNext || hasIncomingNext) {
                    visibleProcesses.set(uri, processInfo);
                }
            });

            // Строим порядок процессов для определения skip-ребер (ребер, которые пропускают промежуточные узлы)
            // Топологическая сортировка процессов по hasNext для определения их порядка
            const processOrder = [];
            const visited = new Set();
            const processUris = [...visibleProcesses.keys()];

            // Найти начальный процесс (процесс без входящих hasNext)
            const incomingCount = new Map();
            processUris.forEach(uri => incomingCount.set(uri, 0));
            hasNextEdges.forEach(edge => {
                if (visibleProcesses.has(edge.to)) {
                    incomingCount.set(edge.to, (incomingCount.get(edge.to) || 0) + 1);
                }
            });

            // Топологическая сортировка (BFS)
            const queue = [];
            processUris.forEach(uri => {
                if (incomingCount.get(uri) === 0) {
                    queue.push(uri);
                }
            });

            while (queue.length > 0) {
                const uri = queue.shift();
                if (!visited.has(uri)) {
                    visited.add(uri);
                    processOrder.push(uri);
                    const processInfo = visibleProcesses.get(uri);
                    if (processInfo) {
                        processInfo.hasNext.forEach(nextUri => {
                            if (visibleProcesses.has(nextUri)) {
                                const count = incomingCount.get(nextUri) - 1;
                                incomingCount.set(nextUri, count);
                                if (count === 0 && !visited.has(nextUri)) {
                                    queue.push(nextUri);
                                }
                            }
                        });
                    }
                }
            }

            // Добавляем оставшиеся процессы (на случай циклов или изолированных)
            processUris.forEach(uri => {
                if (!visited.has(uri)) {
                    processOrder.push(uri);
                }
            });

            // Создаем индекс позиции процесса для определения skip-ребер
            const processPositionIndex = new Map();
            processOrder.forEach((uri, index) => {
                processPositionIndex.set(uri, index);
            });

            // Добавляем узлы процессов (CDS) и ExecutorGroup как отдельные узлы
            dot += '    // Процессы VAD (cds shape) и ExecutorGroup (ellipse желтый)\n';

            // Сначала добавляем все узлы CDS
            visibleProcesses.forEach((processInfo, uri) => {
                const nodeId = generateVadNodeId(uri, prefixes);
                const processName = processInfo.name || processInfo.label;

                // Формируем HTML label с именем процесса (БЕЗ жирного шрифта)
                const wrappedProcessName = wrapTextByWords(processName, currentMaxLabelLength);

                let htmlLabel = '<';
                for (let i = 0; i < wrappedProcessName.length; i++) {
                    if (i > 0) htmlLabel += '<BR/>';
                    htmlLabel += escapeHtmlLabel(wrappedProcessName[i]);
                }
                htmlLabel += '>';

                // Определяем стиль узла на основе vad:processSubtype
                // Проверяем nodeSubtypesCache для определения типа процесса (Detailed, DetailedChild, DetailedExternal или Basic)
                const nodeSubtypes = nodeSubtypesCache[uri] || [];
                const isDetailed = nodeSubtypes.some(subtype => isDetailedSubtype(subtype));

                // Выбираем стиль: голубой для Detailed, зеленый для Basic (по умолчанию)
                let nodeStyle;
                if (isDetailed) {
                    // ProcessStyleDetailed: голубая заливка для детализированного типа
                    nodeStyle = 'shape="cds" height="0.8" width="1.5" color="#1565C0" fillcolor="#90CAF9" fontname="Arial" fontsize="11" style="filled"';
                } else {
                    // ProcessStyleBasic: зеленая заливка для базового типа (по умолчанию)
                    nodeStyle = 'shape="cds" height="0.8" width="1.5" color="#2E7D32" fillcolor="#A5D6A7" fontname="Arial" fontsize="11" style="filled"';
                }
                dot += `    ${nodeId} [label=${htmlLabel} ${nodeStyle}];\n`;

                nodeLabelToUri[processInfo.label] = { uri: uri, dotId: nodeId };
            });

            dot += '\n';

            // Добавляем ExecutorGroup узлы (желтые эллипсы)
            // ExecutorGroup объекты теперь кликабельны и показывают свойства
            dot += '    // ExecutorGroup узлы (эллипсы с желтоватой заливкой)\n';
            visibleProcesses.forEach((processInfo, uri) => {
                const nodeId = generateVadNodeId(uri, prefixes);

                // Получаем список исполнителей
                let executorsList = '';
                let executorGroupUri = null;
                if (processInfo.executorGroup && executorGroups.has(processInfo.executorGroup)) {
                    executorGroupUri = processInfo.executorGroup;
                    const group = executorGroups.get(processInfo.executorGroup);
                    const executorNamesList = group.executors.map(exUri =>
                        executorNames.get(exUri) || getPrefixedName(exUri, prefixes)
                    );
                    executorsList = executorNamesList.join(', ');
                }

                if (executorsList && executorGroupUri) {
                    const executorNodeId = `${nodeId}_exec`;
                    const wrappedExecutors = wrapTextByWords(executorsList, currentMaxLabelLength);

                    let execLabel = '<<FONT POINT-SIZE="9">';
                    for (let i = 0; i < wrappedExecutors.length; i++) {
                        if (i > 0) execLabel += '<BR/>';
                        execLabel += escapeHtmlLabel(wrappedExecutors[i]);
                    }
                    execLabel += '</FONT>>';

                    // ExecutorGroup как эллипс с желтоватой заливкой
                    dot += `    ${executorNodeId} [label=${execLabel} shape="ellipse" color="#B8860B" fillcolor="#FFFFCC" fontname="Arial" style="filled"];\n`;

                    // Регистрируем ExecutorGroup для кликабельности (показ свойств объекта)
                    const executorGroupLabel = getPrefixedName(executorGroupUri, prefixes);
                    nodeLabelToUri[executorGroupLabel] = { uri: executorGroupUri, dotId: executorNodeId };
                }
            });

            dot += '\n';

            // Собираем ID узлов для rank constraints, используя порядок из topological sort
            const cdsNodeIds = [];
            const execNodeIds = [];
            const nodeIdToUri = new Map();  // Обратное отображение для быстрого поиска

            // Используем отсортированный порядок процессов
            processOrder.forEach(uri => {
                if (visibleProcesses.has(uri)) {
                    const processInfo = visibleProcesses.get(uri);
                    const nodeId = generateVadNodeId(uri, prefixes);
                    cdsNodeIds.push(nodeId);
                    nodeIdToUri.set(nodeId, uri);

                    if (processInfo.executorGroup && executorGroups.has(processInfo.executorGroup)) {
                        const group = executorGroups.get(processInfo.executorGroup);
                        if (group.executors.length > 0) {
                            execNodeIds.push(`${nodeId}_exec`);
                        }
                    }
                }
            });

            // Разбиваем процессы на строки по currentMaxVadRowLength
            const rows = [];
            for (let i = 0; i < cdsNodeIds.length; i += currentMaxVadRowLength) {
                rows.push(cdsNodeIds.slice(i, i + currentMaxVadRowLength));
            }

            // Собираем соответствующие execNodeIds для каждой строки
            // Важно: execNodeIds должны соответствовать позициям cdsNodeIds
            const execRows = [];
            rows.forEach((rowCdsIds, rowIndex) => {
                const rowExecIds = [];
                rowCdsIds.forEach(cdsId => {
                    const execId = `${cdsId}_exec`;
                    if (execNodeIds.includes(execId)) {
                        rowExecIds.push(execId);
                    }
                });
                execRows.push(rowExecIds);
            });

            // Генерация rank constraints для каждой строки
            dot += '    // Rank constraints для CDS строк и ExecutorGroup строк\n';
            rows.forEach((rowCdsIds, rowIndex) => {
                // CDS строка
                dot += `    { rank=same; ${rowCdsIds.join('; ')}; }\n`;
            });

            // Генерация rank constraints для ExecutorGroup строк
            execRows.forEach((rowExecIds, rowIndex) => {
                if (rowExecIds.length > 0) {
                    dot += `    { rank=same; ${rowExecIds.join('; ')}; }\n`;
                }
            });

            // Добавляем невидимые ребра между строками для правильного разделения рядов
            // Это необходимо для того, чтобы Graphviz разместил строки одну под другой
            // FIX issue #60: Связываем ПЕРВЫЙ CDS текущей строки с ПЕРВЫМ CDS следующей строки
            // для выравнивания всех строк по левому краю (как требуется в issue #60)
            dot += '\n    // Невидимые ребра между строками для разделения рядов и выравнивания по левому краю\n';
            for (let rowIndex = 0; rowIndex < rows.length - 1; rowIndex++) {
                const currentRowCdsIds = rows[rowIndex];
                const nextRowCdsIds = rows[rowIndex + 1];

                if (currentRowCdsIds.length > 0 && nextRowCdsIds.length > 0) {
                    // Связываем ПЕРВЫЙ CDS текущей строки с ПЕРВЫМ CDS следующей строки
                    // Это выравнивает все строки по левому краю (issue #60)
                    const firstCurrentCdsId = currentRowCdsIds[0];
                    const firstNextCdsId = nextRowCdsIds[0];
                    dot += `    ${firstCurrentCdsId} -> ${firstNextCdsId} [style=invis weight=100 minlen=2];\n`;
                }
            }
            dot += '\n';

            // Добавляем видимые связи vad:hasExecutor между CDS и ExecutorGroup
            dot += '    // Связи vad:hasExecutor - видимые ребра от процессов к группам исполнителей\n';
            visibleProcesses.forEach((processInfo, uri) => {
                const nodeId = generateVadNodeId(uri, prefixes);

                let hasExecutorGroup = false;
                if (processInfo.executorGroup && executorGroups.has(processInfo.executorGroup)) {
                    const group = executorGroups.get(processInfo.executorGroup);
                    hasExecutorGroup = group.executors.length > 0;
                }

                if (hasExecutorGroup) {
                    const executorNodeId = `${nodeId}_exec`;
                    // Видимая связь vad:hasExecutor (синяя пунктирная, ненаправленная)
                    dot += `    ${nodeId} -> ${executorNodeId} [color="#1565C0" penwidth="1" style="dashed" arrowhead="none" weight=10];\n`;
                }
            });

            dot += '\n';

            // Добавляем ребра hasNext между процессами
            // Все ребра hasNext используют порты East -> West (выход справа, вход слева) согласно issue #58
            dot += '    // Связи hasNext - горизонтальный поток процессов (East -> West)\n';

            // Добавляем все ребра hasNext
            hasNextEdges.forEach(edge => {
                // Проверяем, что оба процесса видимы
                if (visibleProcesses.has(edge.from) && visibleProcesses.has(edge.to)) {
                    const fromId = generateVadNodeId(edge.from, prefixes);
                    const toId = generateVadNodeId(edge.to, prefixes);

                    // Все ребра hasNext используют порты East -> West (выход справа, вход слева)
                    // Это обеспечивает единообразное направление связей согласно требованиям issue #58
                    dot += `    ${fromId}:e -> ${toId}:w [color="#2E7D32" penwidth="1" style="solid" arrowhead="vee"];\n`;
                }
            });

            dot += '}\n';

            return dot;
        }

        function rdfToDotAggregation(quads, prefixes = {}) {
            buildNodeTypesCache(currentQuads, prefixes);
            nodeLabelToUri = {};

            const nodes = new Map();
            const edges = [];
            const nodeLiterals = new Map();

            quads.forEach(quad => {
                const subject = quad.subject;
                const predicate = quad.predicate;
                const object = quad.object;

                const subjectValue = subject.value;
                const predicateValue = predicate.value;
                const objectValue = object.value;

                const subjectLabel = getPrefixedName(subjectValue, prefixes);
                const predicateLabel = getPrefixedName(predicateValue, prefixes);

                if (!nodes.has(subjectValue)) {
                    const nodeId = generateNodeId(subjectValue);
                    nodes.set(subjectValue, {
                        id: nodeId,
                        label: subjectLabel,
                        value: subjectValue,
                        isUri: subject.termType === 'NamedNode',
                        isBlank: subject.termType === 'BlankNode',
                        isLiteral: false
                    });
                    nodeLabelToUri[subjectLabel] = { uri: subjectValue, dotId: nodeId };
                    nodeLiterals.set(subjectValue, []);
                }

                if (object.termType === 'Literal') {
                    const literals = nodeLiterals.get(subjectValue);
                    literals.push({
                        predicate: predicateLabel,
                        value: objectValue,
                        isNameLabel: isNameOrLabelPredicate(predicateLabel)
                    });
                } else {
                    const objectLabel = getPrefixedName(objectValue, prefixes);
                    if (!nodes.has(objectValue)) {
                        const nodeId = generateNodeId(objectValue);
                        nodes.set(objectValue, {
                            id: nodeId,
                            label: objectLabel,
                            value: objectValue,
                            isUri: object.termType === 'NamedNode',
                            isLiteral: false,
                            isBlank: object.termType === 'BlankNode'
                        });
                        nodeLabelToUri[objectLabel] = { uri: objectValue, dotId: nodeId };
                        if (!nodeLiterals.has(objectValue)) {
                            nodeLiterals.set(objectValue, []);
                        }
                    }
                    edges.push({
                        from: nodes.get(subjectValue).id,
                        to: nodes.get(objectValue).id,
                        label: predicateLabel,
                        predicateUri: predicateValue
                    });
                }
            });

            let dot = 'digraph RDFGraph {\n';
            dot += '    rankdir=LR;\n';
            dot += '    node [fontname="Arial", shape="ellipse"];\n';
            dot += '    edge [fontname="Arial", fontsize=10];\n';
            dot += '\n';

            nodes.forEach((nodeInfo, value) => {
                const literals = nodeLiterals.get(value) || [];
                const nameLabelLiterals = literals.filter(l => l.isNameLabel);
                const otherLiterals = literals.filter(l => !l.isNameLabel);

                let htmlLabel = '<';
                htmlLabel += formatLabelWithWrap(nodeInfo.label, currentMaxLabelLength, true);

                let addedLines = 1;
                for (const lit of nameLabelLiterals) {
                    if (addedLines >= MaxAggregationParams) break;
                    htmlLabel += '<BR/>';
                    htmlLabel += formatLabelWithWrap(lit.value, currentMaxLabelLength, false);
                    addedLines++;
                }

                for (const lit of otherLiterals) {
                    if (addedLines >= MaxAggregationParams) break;
                    htmlLabel += '<BR/>';
                    const fullText = lit.predicate + ': ' + lit.value;
                    const wrappedLines = wrapTextByWords(fullText, currentMaxLabelLength);
                    for (let j = 0; j < wrappedLines.length; j++) {
                        if (j > 0) htmlLabel += '<BR/>';
                        htmlLabel += `<FONT POINT-SIZE="8">${escapeHtmlLabel(wrappedLines[j])}</FONT>`;
                    }
                    addedLines++;
                }

                htmlLabel += '>';

                const nodeStyle = getNodeStyle(nodeInfo.value, false, nodeInfo.isBlank);
                dot += `    ${nodeInfo.id} [label=${htmlLabel} ${nodeStyle}];\n`;
            });

            dot += '\n';

            edges.forEach(edge => {
                const edgeStyle = getEdgeStyle(edge.predicateUri, edge.label);
                dot += `    ${edge.from} -> ${edge.to} [label="${escapeDotString(edge.label)}" ${edgeStyle}];\n`;
            });

            dot += '}\n';
            return dot;
        }

        function rdfToDot(quads, prefixes = {}) {
            if (currentMode === 'aggregation') {
                return rdfToDotAggregation(quads, prefixes);
            }

            if (currentMode === 'vad') {
                return rdfToDotVAD(quads, prefixes);
            }

            buildNodeTypesCache(currentQuads, prefixes);
            nodeLabelToUri = {};

            const nodes = new Map();
            const edges = [];

            quads.forEach(quad => {
                const subject = quad.subject;
                const predicate = quad.predicate;
                const object = quad.object;

                const subjectValue = subject.value;
                const predicateValue = predicate.value;
                const objectValue = object.value;

                const subjectLabel = getPrefixedName(subjectValue, prefixes);
                const predicateLabel = getPrefixedName(predicateValue, prefixes);
                const objectLabel = object.termType === 'Literal'
                    ? `"${objectValue}"`
                    : getPrefixedName(objectValue, prefixes);

                if (!nodes.has(subjectValue)) {
                    const nodeId = generateNodeId(subjectValue);
                    nodes.set(subjectValue, {
                        id: nodeId,
                        label: subjectLabel,
                        value: subjectValue,
                        isUri: subject.termType === 'NamedNode',
                        isBlank: subject.termType === 'BlankNode',
                        isLiteral: false
                    });
                    nodeLabelToUri[subjectLabel] = { uri: subjectValue, dotId: nodeId };
                }

                if (!nodes.has(objectValue)) {
                    const nodeId = generateNodeId(objectValue);
                    nodes.set(objectValue, {
                        id: nodeId,
                        label: objectLabel,
                        value: objectValue,
                        isUri: object.termType === 'NamedNode',
                        isLiteral: object.termType === 'Literal',
                        isBlank: object.termType === 'BlankNode'
                    });
                    nodeLabelToUri[objectLabel] = { uri: objectValue, dotId: nodeId };
                }

                edges.push({
                    from: nodes.get(subjectValue).id,
                    to: nodes.get(objectValue).id,
                    label: predicateLabel,
                    predicateUri: predicateValue
                });
            });

            let dot = 'digraph RDFGraph {\n';
            dot += '    rankdir=LR;\n';
            dot += '    node [fontname="Arial"];\n';
            dot += '    edge [fontname="Arial", fontsize=10];\n';
            dot += '\n';

            nodes.forEach((nodeInfo, value) => {
                const nodeStyle = getNodeStyle(nodeInfo.value, nodeInfo.isLiteral, nodeInfo.isBlank);

                if (currentMode === 'notation' && nodeInfo.label.length > currentMaxLabelLength) {
                    const wrappedLabel = formatLabelWithWrap(nodeInfo.label, currentMaxLabelLength, false);
                    dot += `    ${nodeInfo.id} [label=<${wrappedLabel}> ${nodeStyle}];\n`;
                } else {
                    dot += `    ${nodeInfo.id} [label="${escapeDotString(nodeInfo.label)}" ${nodeStyle}];\n`;
                }
            });

            dot += '\n';

            edges.forEach(edge => {
                const edgeStyle = getEdgeStyle(edge.predicateUri, edge.label);
                dot += `    ${edge.from} -> ${edge.to} [label="${escapeDotString(edge.label)}" ${edgeStyle}];\n`;
            });

            dot += '}\n';
            return dot;
        }

        // ============================================================================
        // ФУНКЦИИ ОТОБРАЖЕНИЯ
        // ============================================================================

        function showLoading() {
            const output = document.getElementById('output');
            const resultContainer = document.getElementById('result-container');

            resultContainer.style.display = 'block';
            output.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Обработка RDF данных...</p>
                </div>
            `;

            document.getElementById('export-buttons').style.display = 'none';
            document.getElementById('zoom-controls').style.display = 'none';
            document.getElementById('prefixes-panel').style.display = 'none';
            document.getElementById('legend-panel').style.display = 'none';
            document.getElementById('filter-panel').style.display = 'none';
        }

        function showError(message) {
            const output = document.getElementById('output');
            const resultContainer = document.getElementById('result-container');

            resultContainer.style.display = 'block';
            output.innerHTML = `<div class="error"><strong>Ошибка:</strong> ${message}</div>`;

            document.getElementById('export-buttons').style.display = 'none';
            document.getElementById('zoom-controls').style.display = 'none';
            document.getElementById('prefixes-panel').style.display = 'none';
            document.getElementById('legend-panel').style.display = 'none';
            document.getElementById('filter-panel').style.display = 'none';
        }

        function showValidationError(message) {
            const output = document.getElementById('output');
            const resultContainer = document.getElementById('result-container');

            resultContainer.style.display = 'block';
            output.innerHTML = `<div class="validation-error">${message}</div>`;

            document.getElementById('export-buttons').style.display = 'none';
            document.getElementById('zoom-controls').style.display = 'none';
            document.getElementById('prefixes-panel').style.display = 'none';
            document.getElementById('legend-panel').style.display = 'none';
            document.getElementById('filter-panel').style.display = 'none';
        }

        function displayPrefixes(prefixes) {
            const prefixesPanel = document.getElementById('prefixes-panel');
            const prefixesContent = document.getElementById('prefixes-content');

            const prefixEntries = Object.entries(prefixes);
            if (prefixEntries.length === 0) {
                prefixesPanel.style.display = 'none';
                return;
            }

            prefixEntries.sort((a, b) => a[0].localeCompare(b[0]));

            let html = '';
            for (const [prefix, namespace] of prefixEntries) {
                html += `<div class="prefix-line">`;
                html += `<span class="prefix-name">@prefix ${prefix}:</span> `;
                html += `<a href="${namespace}" class="prefix-url" target="_blank">&lt;${namespace}&gt;</a> .`;
                html += `</div>`;
            }

            prefixesContent.innerHTML = html;
            prefixesPanel.style.display = 'block';
        }

        function displayLegend() {
            const legendPanel = document.getElementById('legend-panel');
            const legendContent = document.getElementById('legend-content');

            let html = '';

            // Выбираем источник стилей в зависимости от режима
            let nodeStylesSource, edgeStylesSource;

            if (currentMode === 'vad') {
                nodeStylesSource = VADNodeStyles;
                edgeStylesSource = VADEdgeStyles;
            } else if (currentMode === 'aggregation') {
                nodeStylesSource = AggregationNodeStyles;
                edgeStylesSource = StyleName.edgeStyles;
            } else {
                nodeStylesSource = StyleName.nodeStyles;
                edgeStylesSource = StyleName.edgeStyles;
            }

            html += '<div class="legend-section">';
            html += '<h4>Стили узлов (Node Styles)</h4>';

            for (const [styleName, styleConfig] of Object.entries(nodeStylesSource)) {
                const fillColorMatch = styleConfig.dot.match(/fillcolor="([^"]+)"/);
                const borderColorMatch = styleConfig.dot.match(/color="([^"]+)"/);
                const shapeMatch = styleConfig.dot.match(/shape="([^"]+)"/);

                const fillColor = fillColorMatch ? fillColorMatch[1] : '#ffffff';
                const borderColor = borderColorMatch ? borderColorMatch[1] : '#000000';
                const shape = shapeMatch ? shapeMatch[1] : 'ellipse';

                let shapeStyle = '';
                if (shape === 'box' || shape === 'note') {
                    shapeStyle = 'border-radius: 0;';
                } else if (shape === 'octagon') {
                    shapeStyle = 'border-radius: 0; clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);';
                } else if (shape === 'cds') {
                    shapeStyle = 'border-radius: 0; clip-path: polygon(0% 0%, 85% 0%, 100% 50%, 85% 100%, 0% 100%, 15% 50%);';
                } else {
                    shapeStyle = 'border-radius: 50%;';
                }

                html += `<div class="legend-item">`;
                html += `<div class="legend-shape" style="background-color: ${fillColor}; border-color: ${borderColor}; ${shapeStyle}"></div>`;
                html += `<span class="legend-label">${styleConfig.label}</span>`;
                html += `</div>`;
            }

            html += '</div>';

            html += '<div class="legend-section">';
            html += '<h4>Стили ребер (Edge Styles)</h4>';

            for (const [styleName, styleConfig] of Object.entries(edgeStylesSource)) {
                const colorMatch = styleConfig.dot.match(/color="([^"]+)"/);
                const penwidthMatch = styleConfig.dot.match(/penwidth="([^"]+)"/);
                const lineStyleMatch = styleConfig.dot.match(/style="([^"]+)"/);

                const color = colorMatch ? colorMatch[1] : '#666666';
                const penwidth = penwidthMatch ? parseInt(penwidthMatch[1]) : 1;
                const lineStyle = lineStyleMatch ? lineStyleMatch[1] : 'solid';

                let borderStyle = 'solid';
                if (lineStyle === 'dashed') borderStyle = 'dashed';
                if (lineStyle === 'dotted') borderStyle = 'dotted';

                html += `<div class="legend-item">`;
                html += `<span class="legend-line" style="background-color: ${color}; height: ${penwidth + 1}px; border-bottom: ${penwidth}px ${borderStyle} ${color}; background: none;"></span>`;
                html += `<span class="legend-label">${styleConfig.label}</span>`;
                html += `</div>`;
            }

            html += '</div>';

            legendContent.innerHTML = html;
            legendPanel.style.display = 'block';
        }

        // ============================================================================
        // ФУНКЦИИ ДЛЯ SPARQL SMART DESIGN
        // ============================================================================

        /**
         * Показывает сообщение в панели Smart Design
         * @param {string} message - Текст сообщения
         * @param {string} type - Тип сообщения: 'error', 'success', 'info'
         */
        function showSmartDesignMessage(message, type) {
            const messageDiv = document.getElementById('smart-design-message');
            if (messageDiv) {
                messageDiv.textContent = message;
                messageDiv.className = 'smart-design-message ' + type;
                messageDiv.style.display = 'block';
                // Сообщение остается видимым до следующего действия пользователя
                // (не скрываем автоматически по таймеру)
            }
        }

        /**
         * Скрывает сообщение в панели Smart Design
         */
        function hideSmartDesignMessage() {
            const messageDiv = document.getElementById('smart-design-message');
            if (messageDiv) {
                messageDiv.style.display = 'none';
            }
        }

        /**
         * Собирает все уникальные TriG графы из текущих данных
         * @returns {Array} - Массив объектов {uri, label}
         */
        function getAllTriGs() {
            const trigs = [];
            const seen = new Set();

            // Собираем из trigHierarchy (если есть)
            for (const [uri, info] of Object.entries(trigHierarchy)) {
                if (!seen.has(uri)) {
                    seen.add(uri);
                    const label = info.label || getPrefixedName(uri, currentPrefixes);
                    trigs.push({ uri: uri, label: label });
                }
            }

            // Также проверяем allTrigGraphs
            for (const trigUri of allTrigGraphs) {
                if (!seen.has(trigUri)) {
                    seen.add(trigUri);
                    const label = getPrefixedName(trigUri, currentPrefixes);
                    trigs.push({ uri: trigUri, label: label });
                }
            }

            return trigs.sort((a, b) => a.label.localeCompare(b.label));
        }

        /**
         * Собирает все уникальные субъекты (объекты) из текущих RDF данных
         * @returns {Array} - Массив объектов {uri, label}
         */
        function getAllSubjects() {
            const subjects = [];
            const seen = new Set();

            currentQuads.forEach(quad => {
                const uri = quad.subject.value;
                if (!seen.has(uri)) {
                    seen.add(uri);
                    const label = getPrefixedName(uri, currentPrefixes);
                    subjects.push({ uri: uri, label: label });
                }
            });

            return subjects.sort((a, b) => a.label.localeCompare(b.label));
        }

        /**
         * Собирает все уникальные предикаты из текущих RDF данных
         * @returns {Array} - Массив объектов {uri, label}
         */
        function getAllPredicates() {
            const predicates = [];
            const seen = new Set();

            currentQuads.forEach(quad => {
                const uri = quad.predicate.value;
                if (!seen.has(uri)) {
                    seen.add(uri);
                    const label = getPrefixedName(uri, currentPrefixes);
                    predicates.push({ uri: uri, label: label });
                }
            });

            return predicates.sort((a, b) => a.label.localeCompare(b.label));
        }

        /**
         * Собирает все уникальные объекты (исключая литералы) из текущих RDF данных
         * @returns {Array} - Массив объектов {uri, label}
         */
        function getAllObjects() {
            const objects = [];
            const seen = new Set();

            currentQuads.forEach(quad => {
                // Исключаем литералы согласно требованиям
                if (quad.object.termType !== 'Literal') {
                    const uri = quad.object.value;
                    if (!seen.has(uri)) {
                        seen.add(uri);
                        const label = getPrefixedName(uri, currentPrefixes);
                        objects.push({ uri: uri, label: label });
                    }
                }
            });

            return objects.sort((a, b) => a.label.localeCompare(b.label));
        }

        /**
         * Проверяет, существует ли TriG с указанным именем в RDF данных
         * @param {string} name - Имя TriG для проверки
         * @returns {boolean}
         */
        function trigExists(name) {
            const trigs = getAllTriGs();
            const normalizedName = name.toLowerCase();
            return trigs.some(t => {
                const label = t.label.toLowerCase();
                const localName = getLocalName(t.uri).toLowerCase();
                return label === normalizedName || localName === normalizedName || t.uri === name;
            });
        }

        /**
         * Проверяет, существует ли субъект с указанным именем в RDF данных
         * @param {string} name - Имя субъекта для проверки
         * @returns {boolean}
         */
        function subjectExists(name) {
            const subjects = getAllSubjects();
            const normalizedName = name.toLowerCase();
            return subjects.some(s => {
                const label = s.label.toLowerCase();
                const localName = getLocalName(s.uri).toLowerCase();
                return label === normalizedName || localName === normalizedName || s.uri === name;
            });
        }

        /**
         * Проверяет, существует ли предикат с указанным именем в RDF данных
         * @param {string} name - Имя предиката для проверки
         * @returns {boolean}
         */
        function predicateExists(name) {
            const predicates = getAllPredicates();
            const normalizedName = name.toLowerCase();
            return predicates.some(p => {
                const label = p.label.toLowerCase();
                const localName = getLocalName(p.uri).toLowerCase();
                return label === normalizedName || localName === normalizedName || p.uri === name;
            });
        }

        /**
         * Заполняет выпадающие списки в панели Smart Design
         */
        function populateSmartDesignDropdowns() {
            const trigSelect = document.getElementById('smart-design-trig');
            const subjectSelect = document.getElementById('smart-design-subject');
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const predicateSelect = document.getElementById('smart-design-predicate');
            const objectSelect = document.getElementById('smart-design-object');

            if (!trigSelect || !subjectSelect || !predicateSelect || !objectSelect) return;

            // Очищаем и заполняем TriG (без опции "New" - для создания новых TriG есть отдельная кнопка)
            trigSelect.innerHTML = '<option value="">-- Выберите TriG --</option>';
            const trigs = getAllTriGs();
            trigs.forEach(t => {
                const option = document.createElement('option');
                option.value = t.uri;
                // Отображаем id с label в скобках (при наличии)
                const id = getPrefixedName(t.uri, currentPrefixes);
                const displayText = t.label && t.label !== id ? `${id} (${t.label})` : id;
                option.textContent = displayText;
                trigSelect.appendChild(option);
            });

            // Очищаем и заполняем Subject
            subjectSelect.innerHTML = '<option value="">-- Выберите Subject --</option>';
            subjectSelect.innerHTML += '<option value="__NEW__">New (создать новый)</option>';
            const subjects = getAllSubjects();
            subjects.forEach(s => {
                const option = document.createElement('option');
                option.value = s.uri;
                option.textContent = s.label;
                subjectSelect.appendChild(option);
            });

            // Очищаем и заполняем Subject Type
            if (subjectTypeSelect) {
                populateSubjectTypeDropdown();
            }

            // Очищаем и заполняем Predicate (без опции "New" - предикаты берутся только из онтологии)
            predicateSelect.innerHTML = '<option value="">-- Выберите Predicate --</option>';
            const predicates = getAllPredicates();
            predicates.forEach(p => {
                const option = document.createElement('option');
                option.value = p.uri;
                option.textContent = p.label;
                predicateSelect.appendChild(option);
            });

            // Очищаем и заполняем Object (без литералов)
            objectSelect.innerHTML = '<option value="">-- Выберите Object --</option>';
            objectSelect.innerHTML += '<option value="__NEW__">New (создать новый литерал)</option>';
            const objects = getAllObjects();
            objects.forEach(o => {
                const option = document.createElement('option');
                option.value = o.uri;
                option.textContent = o.label;
                objectSelect.appendChild(option);
            });

            // Деактивируем Subject/Predicate/Object поля до выбора TriG
            updateSmartDesignFieldsState();
        }

        /**
         * Заполняет выпадающий список Subject Type
         * Типы зависят от выбранного TriG
         */
        function populateSubjectTypeDropdown() {
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const trigSelect = document.getElementById('smart-design-trig');

            if (!subjectTypeSelect) return;

            subjectTypeSelect.innerHTML = '<option value="">-- Выберите тип Subject --</option>';

            // Определяем доступные типы в зависимости от выбранного TriG
            const trigValue = trigSelect ? trigSelect.value : '';
            const isPtree = trigValue === 'vad:ptree' || trigValue === 'http://example.org/vad#ptree' || trigValue.endsWith('#ptree');
            const isRtree = trigValue === 'vad:rtree' || trigValue === 'http://example.org/vad#rtree' || trigValue.endsWith('#rtree');

            let availableTypes = [];

            if (isPtree) {
                // В ptree можно добавлять только TypeProcess и ProcessTree
                availableTypes = ['vad:TypeProcess', 'vad:ProcessTree'];
            } else if (isRtree) {
                // В rtree можно добавлять только TypeExecutor и ExecutorTree
                availableTypes = ['vad:TypeExecutor', 'vad:ExecutorTree'];
            } else if (trigValue) {
                // В VADProcessDia можно добавлять TypeProcess (индивиды), ExecutorGroup, VADProcessDia
                availableTypes = ['vad:TypeProcess', 'vad:ExecutorGroup', 'vad:VADProcessDia'];
            }

            availableTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                subjectTypeSelect.appendChild(option);
            });
        }

        /**
         * Получает допустимые предикаты для выбранного Subject Type в зависимости от контекста TriG
         * @param {string} subjectType - Тип субъекта (например, 'vad:Process')
         * @param {string} trigContext - Контекст TriG ('ptree', 'rtree', 'vadProcessDia')
         * @returns {Array} - Массив допустимых предикатов
         */
        function getPredicatesForSubjectType(subjectType, trigContext) {
            const typeConfig = TYPE_PREDICATE_MAP[subjectType];
            if (!typeConfig) return [];

            let predicates = [];

            if (trigContext === 'ptree' && typeConfig.ptree) {
                predicates = typeConfig.ptree;
            } else if (trigContext === 'rtree' && typeConfig.rtree) {
                predicates = typeConfig.rtree;
            } else if (trigContext === 'vadProcessDia' && typeConfig.vadProcessDia) {
                predicates = typeConfig.vadProcessDia;
            }

            return predicates;
        }

        /**
         * Определяет контекст TriG по его URI
         * @param {string} trigUri - URI TriG графа
         * @returns {string} - 'ptree', 'rtree' или 'vadProcessDia'
         */
        function getTrigContext(trigUri) {
            if (!trigUri) return '';
            if (trigUri === 'vad:ptree' || trigUri === 'http://example.org/vad#ptree' || trigUri.endsWith('#ptree')) {
                return 'ptree';
            }
            if (trigUri === 'vad:rtree' || trigUri === 'http://example.org/vad#rtree' || trigUri.endsWith('#rtree')) {
                return 'rtree';
            }
            return 'vadProcessDia';
        }

        /**
         * Обновляет выпадающий список Predicate на основе выбранного Subject Type
         */
        function updatePredicateBySubjectType() {
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const predicateSelect = document.getElementById('smart-design-predicate');
            const trigSelect = document.getElementById('smart-design-trig');

            if (!subjectTypeSelect || !predicateSelect || !trigSelect) return;

            const subjectType = subjectTypeSelect.value;
            const trigUri = trigSelect.value;
            const trigContext = getTrigContext(trigUri);

            // Сохраняем текущее выбранное значение
            const currentPredicateValue = predicateSelect.value;

            // В режиме 'full' не фильтруем предикаты
            if (smartDesignMode === 'full' || !subjectType) {
                // Восстанавливаем полный список предикатов
                predicateSelect.innerHTML = '<option value="">-- Выберите Predicate --</option>';
                const allPredicates = getAllPredicates();
                allPredicates.forEach(p => {
                    const option = document.createElement('option');
                    option.value = p.uri;
                    option.textContent = p.label;
                    predicateSelect.appendChild(option);
                });
            } else {
                // Режим 'filtered' - показываем только допустимые предикаты
                const allowedPredicates = getPredicatesForSubjectType(subjectType, trigContext);

                predicateSelect.innerHTML = '<option value="">-- Выберите Predicate --</option>';

                allowedPredicates.forEach(pred => {
                    const option = document.createElement('option');
                    // Пробуем развернуть в полный URI
                    let fullUri = pred;
                    for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                        if (pred.startsWith(prefix + ':')) {
                            fullUri = namespace + pred.substring(prefix.length + 1);
                            break;
                        }
                    }
                    option.value = fullUri;
                    option.textContent = pred;
                    predicateSelect.appendChild(option);
                });
            }

            // Восстанавливаем выбор если значение все еще доступно
            if (currentPredicateValue && Array.from(predicateSelect.options).some(o => o.value === currentPredicateValue)) {
                predicateSelect.value = currentPredicateValue;
            } else {
                predicateSelect.value = '';
            }
        }

        /**
         * Предикаты, требующие фильтрации Object по типу vad:Process (из ptree)
         */
        const PROCESS_OBJECT_PREDICATES = [
            'vad:hasNext',
            'http://example.org/vad#hasNext'
        ];

        /**
         * Проверяет, требует ли предикат фильтрации Object до типа Process
         * @param {string} predicateUri - URI или prefixed name предиката
         * @returns {boolean}
         */
        function isProcessObjectPredicate(predicateUri) {
            return PROCESS_OBJECT_PREDICATES.some(allowed =>
                predicateUri === allowed ||
                predicateUri.endsWith('#hasNext')
            );
        }

        /**
         * Обновляет список Object в зависимости от выбранного Predicate
         * В режиме Filter: если выбран vad:hasNext, показываем только объекты типа vad:Process из ptree
         */
        function updateObjectsByPredicate() {
            const predicateSelect = document.getElementById('smart-design-predicate');
            const objectSelect = document.getElementById('smart-design-object');

            if (!predicateSelect || !objectSelect) return;

            const predicateValue = predicateSelect.value;

            // Сохраняем текущее выбранное значение
            const currentObjectValue = objectSelect.value;

            // В режиме 'full' не фильтруем объекты
            if (smartDesignMode === 'full' || !predicateValue) {
                // Восстанавливаем полный список объектов
                objectSelect.innerHTML = '<option value="">-- Выберите Object --</option>';
                objectSelect.innerHTML += '<option value="__NEW__">New (создать новый литерал)</option>';
                const allObjects = getAllObjects();
                allObjects.forEach(o => {
                    const option = document.createElement('option');
                    option.value = o.uri;
                    option.textContent = o.label;
                    objectSelect.appendChild(option);
                });
            } else if (isProcessObjectPredicate(predicateValue)) {
                // Режим 'filtered' и предикат требует Object типа Process
                objectSelect.innerHTML = '<option value="">-- Выберите Object --</option>';
                // Для hasNext не показываем опцию "New (создать новый литерал)" т.к. объект должен быть Process

                // Получаем только объекты типа vad:Process из ptree
                const processObjects = getProcessSubjects();
                processObjects.forEach(p => {
                    const option = document.createElement('option');
                    option.value = p.uri;
                    option.textContent = p.label;
                    objectSelect.appendChild(option);
                });
            } else {
                // Режим 'filtered' но предикат не требует специальной фильтрации
                objectSelect.innerHTML = '<option value="">-- Выберите Object --</option>';
                objectSelect.innerHTML += '<option value="__NEW__">New (создать новый литерал)</option>';
                const allObjects = getAllObjects();
                allObjects.forEach(o => {
                    const option = document.createElement('option');
                    option.value = o.uri;
                    option.textContent = o.label;
                    objectSelect.appendChild(option);
                });
            }

            // Восстанавливаем выбор если значение все еще доступно
            if (currentObjectValue && Array.from(objectSelect.options).some(o => o.value === currentObjectValue)) {
                objectSelect.value = currentObjectValue;
            } else {
                objectSelect.value = '';
            }
        }

        /**
         * Переключает режим работы Smart Design (filtered/full)
         */
        function toggleSmartDesignMode() {
            const toggleBtn = document.getElementById('smart-design-mode-toggle');

            if (smartDesignMode === 'filtered') {
                smartDesignMode = 'full';
                if (toggleBtn) toggleBtn.textContent = 'Режим: Полный';
            } else {
                smartDesignMode = 'filtered';
                if (toggleBtn) toggleBtn.textContent = 'Режим: Фильтр';
            }

            // Обновляем список предикатов
            updatePredicateBySubjectType();
            // Обновляем список объектов
            updateObjectsByPredicate();
        }

        /**
         * Обновляет состояние полей Subject/SubjectType/Predicate/Object (активные только после выбора TriG)
         */
        function updateSmartDesignFieldsState() {
            const trigSelect = document.getElementById('smart-design-trig');
            const subjectSelect = document.getElementById('smart-design-subject');
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const predicateSelect = document.getElementById('smart-design-predicate');
            const objectSelect = document.getElementById('smart-design-object');

            if (!trigSelect || !subjectSelect || !predicateSelect || !objectSelect) return;

            const trigSelected = trigSelect.value && trigSelect.value !== '';
            const newTrigActive = document.getElementById('new-trig-modal')?.style.display === 'block';

            // Если активно окно New TriG, деактивируем все поля
            if (newTrigActive) {
                trigSelect.disabled = true;
                subjectSelect.disabled = true;
                if (subjectTypeSelect) subjectTypeSelect.disabled = true;
                predicateSelect.disabled = true;
                objectSelect.disabled = true;
            } else {
                trigSelect.disabled = false;
                subjectSelect.disabled = !trigSelected;
                if (subjectTypeSelect) subjectTypeSelect.disabled = !trigSelected;
                predicateSelect.disabled = !trigSelected;
                objectSelect.disabled = !trigSelected;
            }
        }

        /**
         * Проверяет, является ли выбранный TriG графом vad:ptree
         * @returns {boolean}
         */
        function isSelectedTrigPtree() {
            const trigSelect = document.getElementById('smart-design-trig');
            if (!trigSelect || !trigSelect.value) return false;
            const trigValue = trigSelect.value;
            return trigValue === 'vad:ptree' ||
                   trigValue === 'http://example.org/vad#ptree' ||
                   trigValue.endsWith('#ptree');
        }

        /**
         * Получает субъекты типа vad:Process для фильтрации в режиме vad:ptree
         * @returns {Array} - Массив объектов {uri, label}
         */
        function getProcessSubjects() {
            const subjects = [];
            const seen = new Set();

            currentQuads.forEach(quad => {
                const uri = quad.subject.value;
                if (!seen.has(uri) && isSubjectVadProcess(uri)) {
                    seen.add(uri);
                    const label = getPrefixedName(uri, currentPrefixes);
                    subjects.push({ uri: uri, label: label });
                }
            });

            return subjects.sort((a, b) => a.label.localeCompare(b.label));
        }

        /**
         * Получает субъекты определённого типа для фильтрации в режиме Filter
         * @param {string} typeValue - Тип субъекта (prefixed name или полный URI)
         * @returns {Array} - Массив объектов {uri, label}
         */
        function getSubjectsByType(typeValue) {
            const subjects = [];
            const seen = new Set();

            // Преобразуем typeValue в полный URI для сравнения
            let typeUri = typeValue;
            for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                if (typeValue.startsWith(prefix + ':')) {
                    typeUri = namespace + typeValue.substring(prefix.length + 1);
                    break;
                }
            }

            currentQuads.forEach(quad => {
                const uri = quad.subject.value;
                if (seen.has(uri)) return;

                const subjectTypes = nodeTypesCache[uri] || [];
                const hasType = subjectTypes.some(t =>
                    t === typeValue || t === typeUri
                );

                if (hasType) {
                    seen.add(uri);
                    const label = getPrefixedName(uri, currentPrefixes);
                    subjects.push({ uri: uri, label: label });
                }
            });

            return subjects.sort((a, b) => a.label.localeCompare(b.label));
        }

        /**
         * Обновляет содержимое выпадающего списка Subject на основе выбранного Subject Type
         * в режиме Filter (smartDesignMode === 'filtered')
         */
        function updateSubjectsBySubjectType() {
            // Если режим не Filter, ничего не делаем
            if (smartDesignMode !== 'filtered') return;

            const subjectSelect = document.getElementById('smart-design-subject');
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');

            if (!subjectSelect || !subjectTypeSelect) return;

            const selectedType = subjectTypeSelect.value;
            if (!selectedType) return; // Если тип не выбран, не фильтруем

            // Сохраняем текущее выбранное значение
            const currentSubjectValue = subjectSelect.value;

            // Очищаем и заполняем Subject
            subjectSelect.innerHTML = '<option value="">-- Выберите Subject --</option>';
            subjectSelect.innerHTML += '<option value="__NEW__">New (создать новый)</option>';

            // В режиме Filter фильтруем субъекты по выбранному типу
            const subjects = getSubjectsByType(selectedType);
            subjects.forEach(s => {
                const option = document.createElement('option');
                option.value = s.uri;
                option.textContent = s.label;
                subjectSelect.appendChild(option);
            });

            // Восстанавливаем выбор если значение все еще доступно
            if (currentSubjectValue && Array.from(subjectSelect.options).some(o => o.value === currentSubjectValue)) {
                subjectSelect.value = currentSubjectValue;
            } else {
                subjectSelect.value = '';
            }
        }

        /**
         * Получает предикаты из PTREE_PREDICATES для фильтрации в режиме vad:ptree
         * @returns {Array} - Массив объектов {uri, label}
         */
        function getPtreePredicates() {
            const predicates = [];
            const seen = new Set();

            // Добавляем только предикаты, которые есть в PTREE_PREDICATES и присутствуют в данных
            currentQuads.forEach(quad => {
                const uri = quad.predicate.value;
                const prefixedName = getPrefixedName(uri, currentPrefixes);
                if (!seen.has(uri) && (isPtreePredicate(uri) || isPtreePredicate(prefixedName))) {
                    seen.add(uri);
                    predicates.push({ uri: uri, label: prefixedName });
                }
            });

            // Также добавляем предикаты из PTREE_PREDICATES, которых может не быть в данных
            PTREE_PREDICATES.forEach(pred => {
                if (!seen.has(pred) && !pred.startsWith('http')) {
                    // Это prefixed name, проверяем есть ли такой в списке
                    const alreadyInList = predicates.some(p => p.label === pred);
                    if (!alreadyInList) {
                        // Пробуем развернуть в полный URI
                        let fullUri = pred;
                        for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                            if (pred.startsWith(prefix + ':')) {
                                fullUri = namespace + pred.substring(prefix.length + 1);
                                break;
                            }
                        }
                        if (!seen.has(fullUri)) {
                            seen.add(fullUri);
                            predicates.push({ uri: fullUri, label: pred });
                        }
                    }
                }
            });

            return predicates.sort((a, b) => a.label.localeCompare(b.label));
        }

        /**
         * Обновляет содержимое выпадающих списков Subject и Predicate
         * в зависимости от выбранного TriG (vad:ptree или другой)
         */
        function updateSubjectPredicateDropdowns() {
            const subjectSelect = document.getElementById('smart-design-subject');
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const predicateSelect = document.getElementById('smart-design-predicate');

            if (!subjectSelect || !predicateSelect) return;

            const isPtree = isSelectedTrigPtree();

            // Сохраняем текущие выбранные значения (если возможно)
            const currentSubjectValue = subjectSelect.value;
            const currentPredicateValue = predicateSelect.value;

            // Очищаем и заполняем Subject
            subjectSelect.innerHTML = '<option value="">-- Выберите Subject --</option>';
            subjectSelect.innerHTML += '<option value="__NEW__">New (создать новый)</option>';

            const subjects = isPtree ? getProcessSubjects() : getAllSubjects();
            subjects.forEach(s => {
                const option = document.createElement('option');
                option.value = s.uri;
                option.textContent = s.label;
                subjectSelect.appendChild(option);
            });

            // Сбрасываем Subject Type при смене TriG
            if (subjectTypeSelect) {
                subjectTypeSelect.value = '';
            }

            // Обновляем Predicate с учетом режима и Subject Type
            updatePredicateBySubjectType();

            // Восстанавливаем выбор если значение все еще доступно
            if (currentSubjectValue && Array.from(subjectSelect.options).some(o => o.value === currentSubjectValue)) {
                subjectSelect.value = currentSubjectValue;
            } else {
                subjectSelect.value = '';
            }
            if (currentPredicateValue && Array.from(predicateSelect.options).some(o => o.value === currentPredicateValue)) {
                predicateSelect.value = currentPredicateValue;
            } else {
                predicateSelect.value = '';
            }
        }

        /**
         * Запрашивает у пользователя новое имя и проверяет его уникальность
         * @param {string} fieldName - Название поля (TriG, Subject, Predicate, Object)
         * @param {Function} existsChecker - Функция проверки существования
         * @param {boolean} allowDuplicate - Разрешить дубликаты (для Object)
         * @returns {string|null} - Введенное имя или null если отменено
         */
        function promptForNewValue(fieldName, existsChecker, allowDuplicate = false) {
            const name = prompt(`Введите имя для нового ${fieldName}:`);
            if (!name || name.trim() === '') {
                return null;
            }

            const trimmedName = name.trim();

            if (!allowDuplicate && existsChecker(trimmedName)) {
                showSmartDesignMessage(`Ошибка: ${fieldName} с именем "${trimmedName}" уже существует в RDF данных`, 'error');
                return null;
            }

            return trimmedName;
        }

        /**
         * Обработчик изменения выбора в выпадающем списке
         * @param {HTMLSelectElement} selectElement - Элемент select
         * @param {string} fieldName - Название поля
         * @param {Function} existsChecker - Функция проверки существования
         * @param {boolean} allowDuplicate - Разрешить дубликаты
         */
        function handleSelectChange(selectElement, fieldName, existsChecker, allowDuplicate = false) {
            if (selectElement.value === '__NEW__') {
                const newValue = promptForNewValue(fieldName, existsChecker, allowDuplicate);
                if (newValue) {
                    // Добавляем новый элемент в список и выбираем его
                    const option = document.createElement('option');
                    option.value = '__CUSTOM__:' + newValue;
                    option.textContent = newValue + ' (новый)';
                    selectElement.insertBefore(option, selectElement.options[2]); // После "New"
                    selectElement.value = option.value;
                    hideSmartDesignMessage();
                } else {
                    // Сбрасываем выбор
                    selectElement.value = '';
                }
            }
        }

        /**
         * Специализированный обработчик для поля Subject с учётом логики концепт/индивид
         * @param {HTMLSelectElement} selectElement - Элемент select
         */
        function handleSubjectSelectChange(selectElement) {
            const trigSelect = document.getElementById('smart-design-trig');
            const trigContext = getTrigContext(trigSelect ? trigSelect.value : '');

            if (selectElement.value === '__NEW__') {
                if (trigContext === 'ptree') {
                    // В ptree можно создавать новые концепты Process
                    const newValue = promptForNewValue('Process (концепт)', subjectExists, false);
                    if (newValue) {
                        const option = document.createElement('option');
                        option.value = '__CUSTOM__:' + newValue;
                        option.textContent = newValue + ' (новый концепт)';
                        selectElement.insertBefore(option, selectElement.options[2]);
                        selectElement.value = option.value;
                        hideSmartDesignMessage();
                        showSmartDesignMessage('Создаётся новый концепт Process в ptree. Не забудьте добавить rdf:type, rdfs:label и другие обязательные свойства.', 'info');
                    } else {
                        selectElement.value = '';
                    }
                } else if (trigContext === 'rtree') {
                    // В rtree можно создавать новые концепты Executor
                    const newValue = promptForNewValue('Executor (концепт)', subjectExists, false);
                    if (newValue) {
                        const option = document.createElement('option');
                        option.value = '__CUSTOM__:' + newValue;
                        option.textContent = newValue + ' (новый концепт)';
                        selectElement.insertBefore(option, selectElement.options[2]);
                        selectElement.value = option.value;
                        hideSmartDesignMessage();
                        showSmartDesignMessage('Создаётся новый концепт Executor в rtree. Не забудьте добавить rdf:type и rdfs:label.', 'info');
                    } else {
                        selectElement.value = '';
                    }
                } else if (trigContext === 'vadProcessDia') {
                    // В VADProcessDia можно только выбирать существующие концепты из ptree
                    // Показываем диалог выбора концепта
                    showConceptSelectionDialog(selectElement);
                } else {
                    // Нет выбранного TriG - стандартное поведение
                    handleSelectChange(selectElement, 'Subject', subjectExists, false);
                }
            }
        }

        /**
         * Показывает диалог выбора концепта из ptree для создания индивида в VADProcessDia
         * @param {HTMLSelectElement} selectElement - Элемент select для Subject
         */
        function showConceptSelectionDialog(selectElement) {
            // Получаем список концептов Process из ptree
            const processConcepts = getProcessSubjects();

            if (processConcepts.length === 0) {
                showSmartDesignMessage('В ptree нет концептов Process. Сначала создайте концепт процесса в ptree.', 'error');
                selectElement.value = '';
                return;
            }

            // Создаём список для выбора
            const conceptNames = processConcepts.map(c => c.label).join('\n');
            const selectedConcept = prompt(
                'В VADProcessDia нельзя создавать новые имена - только индивиды существующих концептов.\n\n' +
                'Выберите концепт из ptree (введите имя):\n\n' +
                conceptNames
            );

            if (selectedConcept && selectedConcept.trim()) {
                const trimmed = selectedConcept.trim();
                // Ищем соответствующий концепт
                const matchingConcept = processConcepts.find(c =>
                    c.label === trimmed ||
                    c.label.toLowerCase() === trimmed.toLowerCase() ||
                    c.uri.endsWith('#' + trimmed) ||
                    c.uri.endsWith('/' + trimmed)
                );

                if (matchingConcept) {
                    // Выбираем существующий концепт
                    selectElement.value = matchingConcept.uri;
                    hideSmartDesignMessage();
                    showSmartDesignMessage(
                        `Выбран концепт "${matchingConcept.label}". Для создания индивида добавьте vad:isSubprocessTrig первым.`,
                        'info'
                    );
                } else {
                    showSmartDesignMessage(`Концепт "${trimmed}" не найден в ptree. Сначала создайте его там.`, 'error');
                    selectElement.value = '';
                }
            } else {
                selectElement.value = '';
            }
        }

        /**
         * Проверяет, существует ли концепт Process в ptree
         * @param {string} processUri - URI процесса для проверки
         * @returns {boolean} - true если концепт существует в ptree
         */
        function isProcessConceptInPtree(processUri) {
            const processConcepts = getProcessSubjects();
            return processConcepts.some(c => c.uri === processUri);
        }

        // Добавляем обработчики событий для выпадающих списков Smart Design
        document.addEventListener('DOMContentLoaded', function() {
            const trigSelect = document.getElementById('smart-design-trig');
            const subjectSelect = document.getElementById('smart-design-subject');
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');
            const predicateSelect = document.getElementById('smart-design-predicate');
            const objectSelect = document.getElementById('smart-design-object');

            if (trigSelect) {
                trigSelect.addEventListener('change', function() {
                    // TriG теперь не имеет опции __NEW__, просто обновляем состояние полей
                    updateSmartDesignFieldsState();
                    // Перезаполняем Subject Type в зависимости от выбранного TriG
                    populateSubjectTypeDropdown();
                    // Перезаполняем Subject и Predicate в зависимости от выбранного TriG (vad:ptree или нет)
                    updateSubjectPredicateDropdowns();
                });
            }

            if (subjectSelect) {
                subjectSelect.addEventListener('change', function() {
                    // Используем специализированный обработчик для Subject с логикой концепт/индивид
                    handleSubjectSelectChange(this);
                    // При выборе существующего Subject, автоматически определяем его тип
                    autoDetectSubjectType();
                });
            }

            if (subjectTypeSelect) {
                subjectTypeSelect.addEventListener('change', function() {
                    // При изменении Subject Type, обновляем список допустимых Subject и Predicate
                    updateSubjectsBySubjectType();
                    updatePredicateBySubjectType();
                });
            }

            if (predicateSelect) {
                predicateSelect.addEventListener('change', function() {
                    // При изменении Predicate, обновляем список допустимых Object
                    updateObjectsByPredicate();
                });
            }

            if (objectSelect) {
                objectSelect.addEventListener('change', function() {
                    // Для Object разрешаем дубликаты, новые значения - литералы
                    handleSelectChange(this, 'Object', () => false, true);
                });
            }
        });

        /**
         * Автоматически определяет тип выбранного Subject и устанавливает его в Subject Type
         */
        function autoDetectSubjectType() {
            const subjectSelect = document.getElementById('smart-design-subject');
            const subjectTypeSelect = document.getElementById('smart-design-subject-type');

            if (!subjectSelect || !subjectTypeSelect) return;

            const subjectUri = subjectSelect.value;
            if (!subjectUri || subjectUri === '__NEW__' || subjectUri.startsWith('__CUSTOM__:')) {
                // Для нового Subject не меняем Subject Type
                return;
            }

            // Получаем типы данного Subject из кэша
            const types = nodeTypesCache[subjectUri] || [];

            // Проверяем каждый известный тип
            for (const type of types) {
                const prefixedType = getPrefixedName(type, currentPrefixes);
                // Ищем соответствующий тип в выпадающем списке
                const options = Array.from(subjectTypeSelect.options);
                const matchingOption = options.find(o =>
                    o.value === prefixedType || o.value === type
                );
                if (matchingOption) {
                    subjectTypeSelect.value = matchingOption.value;
                    // Обновляем список Predicate
                    updatePredicateBySubjectType();
                    return;
                }
            }
        }

        /**
         * Получает значение из выпадающего списка (с учетом кастомных значений)
         * @param {string} selectId - ID элемента select
         * @returns {string|null} - URI или кастомное значение
         */
        function getSmartDesignValue(selectId) {
            const select = document.getElementById(selectId);
            if (!select || !select.value || select.value === '__NEW__') {
                return null;
            }

            if (select.value.startsWith('__CUSTOM__:')) {
                return select.value.substring('__CUSTOM__:'.length);
            }

            return select.value;
        }

        /**
         * Проверяет, является ли значение в выпадающем списке кастомным (новым литералом)
         * @param {string} selectId - ID элемента select
         * @returns {boolean} - true если это кастомное значение
         */
        function isSmartDesignValueCustom(selectId) {
            const select = document.getElementById(selectId);
            if (!select || !select.value) {
                return false;
            }
            return select.value.startsWith('__CUSTOM__:');
        }

        /**
         * Форматирует URI или значение для SPARQL запроса
         * @param {string} value - Значение для форматирования
         * @param {boolean} isLiteral - Является ли значение литералом (для новых Object)
         * @returns {string} - Форматированное значение
         */
        function formatForSparql(value, isLiteral = false) {
            if (!value) return '';

            // Если это литерал, заключаем в кавычки
            if (isLiteral) {
                // Экранируем специальные символы в строке
                const escaped = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                return `"${escaped}"`;
            }

            // Если это полный URI
            if (value.startsWith('http://') || value.startsWith('https://')) {
                return `<${value}>`;
            }

            // Если это префиксированное имя
            if (value.includes(':')) {
                return value;
            }

            // Если это кастомное значение без префикса, пробуем использовать vad: префикс
            if (currentPrefixes['vad']) {
                return `vad:${value}`;
            }

            // В крайнем случае создаем URI
            return `<http://example.org/vad#${value}>`;
        }

        /**
         * Проверяет, существует ли триплет в RDF данных
         * @param {string} subjectUri - URI субъекта
         * @param {string} predicateUri - URI предиката
         * @param {string} objectUri - URI объекта
         * @param {string} graphUri - URI графа (опционально)
         * @returns {boolean}
         */
        function tripleExists(subjectUri, predicateUri, objectUri, graphUri = null) {
            return currentQuads.some(quad => {
                const subjectMatch = quad.subject.value === subjectUri;
                const predicateMatch = quad.predicate.value === predicateUri;
                const objectMatch = quad.object.value === objectUri;
                const graphMatch = !graphUri || (quad.graph && quad.graph.value === graphUri);
                return subjectMatch && predicateMatch && objectMatch && graphMatch;
            });
        }

        /**
         * Генерирует SPARQL INSERT запрос
         * @param {string} trigUri - URI TriG графа
         * @param {string} subjectUri - URI субъекта
         * @param {string} predicateUri - URI предиката
         * @param {string} objectUri - URI объекта
         * @param {boolean} isObjectLiteral - Является ли Object литералом
         * @returns {string} - SPARQL INSERT запрос
         */
        function generateInsertSparql(trigUri, subjectUri, predicateUri, objectUri, isObjectLiteral = false) {
            const prefixDeclarations = generateSparqlPrefixes(currentPrefixes);

            const subject = formatForSparql(subjectUri);
            const predicate = formatForSparql(predicateUri);
            const object = formatForSparql(objectUri, isObjectLiteral);
            const graph = formatForSparql(trigUri);

            return `${prefixDeclarations}INSERT DATA {
    GRAPH ${graph} {
        ${subject} ${predicate} ${object} .
    }
}`;
        }

        /**
         * Генерирует SPARQL DELETE запрос
         * @param {string} trigUri - URI TriG графа
         * @param {string} subjectUri - URI субъекта
         * @param {string} predicateUri - URI предиката
         * @param {string} objectUri - URI объекта
         * @param {boolean} isObjectLiteral - Является ли Object литералом
         * @returns {string} - SPARQL DELETE запрос
         */
        function generateDeleteSparql(trigUri, subjectUri, predicateUri, objectUri, isObjectLiteral = false) {
            const prefixDeclarations = generateSparqlPrefixes(currentPrefixes);

            const subject = formatForSparql(subjectUri);
            const predicate = formatForSparql(predicateUri);
            const object = formatForSparql(objectUri, isObjectLiteral);
            const graph = formatForSparql(trigUri);

            return `${prefixDeclarations}DELETE DATA {
    GRAPH ${graph} {
        ${subject} ${predicate} ${object} .
    }
}`;
        }

        /**
         * Форматирует URI или значение для SPARQL запроса в префиксной форме (prefix:name)
         * @param {string} value - Значение для форматирования
         * @param {boolean} isLiteral - Является ли значение литералом (для новых Object)
         * @returns {string} - Форматированное значение в префиксной форме
         */
        function formatForSparqlWithPrefix(value, isLiteral = false) {
            if (!value) return '';

            // Если это литерал, заключаем в кавычки
            if (isLiteral) {
                // Экранируем специальные символы в строке
                const escaped = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                return `"${escaped}"`;
            }

            // Если это полный URI - преобразуем в префиксную форму
            if (value.startsWith('http://') || value.startsWith('https://')) {
                const prefixed = getPrefixedName(value, currentPrefixes);
                // Если удалось преобразовать в префиксную форму
                if (prefixed !== value && prefixed.includes(':')) {
                    return prefixed;
                }
                // Если не удалось - возвращаем в угловых скобках
                return `<${value}>`;
            }

            // Если это уже префиксированное имя
            if (value.includes(':')) {
                return value;
            }

            // Если это кастомное значение без префикса, пробуем использовать vad: префикс
            if (currentPrefixes['vad']) {
                return `vad:${value}`;
            }

            // В крайнем случае создаем URI
            return `<http://example.org/vad#${value}>`;
        }

        /**
         * Генерирует SPARQL INSERT запрос с использованием префиксов (prefix:name)
         * @param {string} trigUri - URI TriG графа
         * @param {string} subjectUri - URI субъекта
         * @param {string} predicateUri - URI предиката
         * @param {string} objectUri - URI объекта
         * @param {boolean} isObjectLiteral - Является ли Object литералом
         * @returns {string} - SPARQL INSERT запрос с префиксами
         */
        function generateInsertSparqlWithPrefix(trigUri, subjectUri, predicateUri, objectUri, isObjectLiteral = false) {
            const prefixDeclarations = generateSparqlPrefixes(currentPrefixes);

            const subject = formatForSparqlWithPrefix(subjectUri);
            const predicate = formatForSparqlWithPrefix(predicateUri);
            const object = formatForSparqlWithPrefix(objectUri, isObjectLiteral);
            const graph = formatForSparqlWithPrefix(trigUri);

            return `${prefixDeclarations}INSERT DATA {
    GRAPH ${graph} {
        ${subject} ${predicate} ${object} .
    }
}`;
        }

        /**
         * Обработчик кнопки "Создать SPARQL (prefix)" - генерирует INSERT SPARQL запрос с использованием префиксов
         */
        function smartDesignCreateWithPrefix() {
            hideSmartDesignMessage();

            // Сбрасываем флаг New TriG, т.к. создаем обычный SPARQL запрос
            isNewTrigQuery = false;
            updateSimpleTripleButtonState();

            const trigValue = getSmartDesignValue('smart-design-trig');
            const subjectValue = getSmartDesignValue('smart-design-subject');
            const predicateValue = getSmartDesignValue('smart-design-predicate');
            const objectValue = getSmartDesignValue('smart-design-object');
            const isObjectLiteral = isSmartDesignValueCustom('smart-design-object');

            if (!trigValue || !subjectValue || !predicateValue || !objectValue) {
                showSmartDesignMessage('Ошибка: Заполните все четыре поля (TriG, Subject, Predicate, Object)', 'error');
                return;
            }

            // Проверка на дубликаты (поддерживает как полные URI, так и prefixed names)
            const duplicate = findDuplicateTriple(subjectValue, predicateValue, objectValue);
            if (duplicate) {
                showSmartDesignMessage(`Ошибка: Триплет уже существует в графе "${duplicate.graphLabel}"`, 'error');
                return;
            }

            // Проверка: если TriG НЕ vad:ptree, но субъект vad:Process и предикат из PTREE_PREDICATES - ошибка
            const isPtreeTrig = trigValue === 'vad:ptree' ||
                               trigValue === 'http://example.org/vad#ptree' ||
                               trigValue.endsWith('#ptree');

            if (!isPtreeTrig) {
                // Преобразуем subjectValue в URI для проверки типа
                let subjectUri = subjectValue;
                for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                    if (subjectValue.startsWith(prefix + ':')) {
                        subjectUri = namespace + subjectValue.substring(prefix.length + 1);
                        break;
                    }
                }

                const subjectIsProcess = isSubjectVadProcess(subjectUri);
                const predicateIsPtree = isPtreePredicate(predicateValue);

                if (subjectIsProcess && predicateIsPtree) {
                    const ptreePredicatesList = PTREE_PREDICATES
                        .filter(p => !p.startsWith('http'))
                        .join(', ');
                    showSmartDesignMessage(
                        `Ошибка: Для субъекта типа vad:Process с предикатом из списка PTREE_PREDICATES ` +
                        `(${ptreePredicatesList}) триплет должен быть добавлен в граф vad:ptree, а не в "${getPrefixedName(trigValue, currentPrefixes) || trigValue}"`,
                        'error'
                    );
                    return;
                }
            }

            // Проверяем, что триплет добавляется в правильный граф (без автоматического перенаправления)
            // Если субъект является vad:TypeProcess и предикат из PTREE_PREDICATES или rdf:type vad:TypeProcess,
            // триплет должен быть добавлен только в vad:ptree
            const expectedTargetGraph = determineTargetGraph(subjectValue, predicateValue, trigValue, objectValue);

            // Нормализуем оба значения к prefixed name для корректного сравнения
            const trigLabel = getPrefixedName(trigValue, currentPrefixes) || trigValue;
            const expectedLabel = getPrefixedName(expectedTargetGraph, currentPrefixes) || expectedTargetGraph;

            if (expectedLabel !== trigLabel) {
                showSmartDesignMessage(
                    `Ошибка: Данный триплет должен быть добавлен в граф "${expectedLabel}", а не в "${trigLabel}". ` +
                    `Пожалуйста, выберите корректный TriG.`,
                    'error'
                );
                return;
            }

            // Генерируем SPARQL с использованием префиксов
            const sparqlQuery = generateInsertSparqlWithPrefix(trigValue, subjectValue, predicateValue, objectValue, isObjectLiteral);

            const resultTextarea = document.getElementById('result-sparql-query');
            if (resultTextarea) {
                resultTextarea.value = sparqlQuery;
            }

            // Формируем сообщение об успешной генерации
            showSmartDesignMessage('INSERT SPARQL запрос с prefix:name успешно сгенерирован.', 'success');
        }

        /**
         * Обработчик кнопки "Создать" - генерирует INSERT SPARQL запрос
         */
        function smartDesignCreate() {
            hideSmartDesignMessage();

            // Сбрасываем флаг New TriG, т.к. создаем обычный SPARQL запрос
            isNewTrigQuery = false;
            updateSimpleTripleButtonState();

            const trigValue = getSmartDesignValue('smart-design-trig');
            const subjectValue = getSmartDesignValue('smart-design-subject');
            const predicateValue = getSmartDesignValue('smart-design-predicate');
            const objectValue = getSmartDesignValue('smart-design-object');
            const isObjectLiteral = isSmartDesignValueCustom('smart-design-object');

            if (!trigValue || !subjectValue || !predicateValue || !objectValue) {
                showSmartDesignMessage('Ошибка: Заполните все четыре поля (TriG, Subject, Predicate, Object)', 'error');
                return;
            }

            // Проверка на дубликаты (поддерживает как полные URI, так и prefixed names)
            const duplicate = findDuplicateTriple(subjectValue, predicateValue, objectValue);
            if (duplicate) {
                showSmartDesignMessage(`Ошибка: Триплет уже существует в графе "${duplicate.graphLabel}"`, 'error');
                return;
            }

            // Проверка: если TriG НЕ vad:ptree, но субъект vad:Process и предикат из PTREE_PREDICATES - ошибка
            const isPtreeTrig = trigValue === 'vad:ptree' ||
                               trigValue === 'http://example.org/vad#ptree' ||
                               trigValue.endsWith('#ptree');

            if (!isPtreeTrig) {
                // Преобразуем subjectValue в URI для проверки типа
                let subjectUri = subjectValue;
                for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                    if (subjectValue.startsWith(prefix + ':')) {
                        subjectUri = namespace + subjectValue.substring(prefix.length + 1);
                        break;
                    }
                }

                const subjectIsProcess = isSubjectVadProcess(subjectUri);
                const predicateIsPtree = isPtreePredicate(predicateValue);

                if (subjectIsProcess && predicateIsPtree) {
                    const ptreePredicatesList = PTREE_PREDICATES
                        .filter(p => !p.startsWith('http'))
                        .join(', ');
                    showSmartDesignMessage(
                        `Ошибка: Для субъекта типа vad:Process с предикатом из списка PTREE_PREDICATES ` +
                        `(${ptreePredicatesList}) триплет должен быть добавлен в граф vad:ptree, а не в "${getPrefixedName(trigValue, currentPrefixes) || trigValue}"`,
                        'error'
                    );
                    return;
                }
            }

            // Проверяем, что триплет добавляется в правильный граф (без автоматического перенаправления)
            // Если субъект является vad:TypeProcess и предикат из PTREE_PREDICATES или rdf:type vad:TypeProcess,
            // триплет должен быть добавлен только в vad:ptree
            const expectedTargetGraph = determineTargetGraph(subjectValue, predicateValue, trigValue, objectValue);

            // Нормализуем оба значения к prefixed name для корректного сравнения
            const trigLabel = getPrefixedName(trigValue, currentPrefixes) || trigValue;
            const expectedLabel = getPrefixedName(expectedTargetGraph, currentPrefixes) || expectedTargetGraph;

            if (expectedLabel !== trigLabel) {
                showSmartDesignMessage(
                    `Ошибка: Данный триплет должен быть добавлен в граф "${expectedLabel}", а не в "${trigLabel}". ` +
                    `Пожалуйста, выберите корректный TriG.`,
                    'error'
                );
                return;
            }

            const sparqlQuery = generateInsertSparql(trigValue, subjectValue, predicateValue, objectValue, isObjectLiteral);

            const resultTextarea = document.getElementById('result-sparql-query');
            if (resultTextarea) {
                resultTextarea.value = sparqlQuery;
            }

            // Формируем сообщение об успешной генерации
            let successMessage = 'INSERT SPARQL запрос успешно сгенерирован';
            showSmartDesignMessage(successMessage, 'success');
        }

        /**
         * Обработчик кнопки "Удалить триплет" - генерирует DELETE SPARQL запрос с проверкой существования
         */
        function smartDesignDelete() {
            hideSmartDesignMessage();

            // Сбрасываем флаг New TriG, т.к. создаем обычный SPARQL запрос
            isNewTrigQuery = false;
            updateSimpleTripleButtonState();

            const trigValue = getSmartDesignValue('smart-design-trig');
            const subjectValue = getSmartDesignValue('smart-design-subject');
            const predicateValue = getSmartDesignValue('smart-design-predicate');
            const objectValue = getSmartDesignValue('smart-design-object');
            const isObjectLiteral = isSmartDesignValueCustom('smart-design-object');

            if (!trigValue || !subjectValue || !predicateValue || !objectValue) {
                showSmartDesignMessage('Ошибка: Заполните все четыре поля (TriG, Subject, Predicate, Object)', 'error');
                return;
            }

            // Проверяем существование триплета
            // Нужно преобразовать значения в полные URI для проверки
            let subjectUri = subjectValue;
            let predicateUri = predicateValue;
            let objectUri = objectValue;
            let graphUri = trigValue;

            // Если значение содержит префикс, преобразуем в полный URI
            for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                if (subjectValue.startsWith(prefix + ':')) {
                    subjectUri = namespace + subjectValue.substring(prefix.length + 1);
                }
                if (predicateValue.startsWith(prefix + ':')) {
                    predicateUri = namespace + predicateValue.substring(prefix.length + 1);
                }
                if (objectValue.startsWith(prefix + ':')) {
                    objectUri = namespace + objectValue.substring(prefix.length + 1);
                }
                if (trigValue.startsWith(prefix + ':')) {
                    graphUri = namespace + trigValue.substring(prefix.length + 1);
                }
            }

            // Проверяем существование триплета в данных
            const exists = tripleExists(subjectUri, predicateUri, objectUri, graphUri);

            if (!exists) {
                showSmartDesignMessage('Ошибка: Указанный триплет (утверждение) не найден в RDF данных', 'error');
                return;
            }

            const sparqlQuery = generateDeleteSparql(trigValue, subjectValue, predicateValue, objectValue, isObjectLiteral);

            const resultTextarea = document.getElementById('result-sparql-query');
            if (resultTextarea) {
                resultTextarea.value = sparqlQuery;
            }

            showSmartDesignMessage('DELETE SPARQL запрос успешно сгенерирован', 'success');
        }

        /**
         * Обработчик кнопки "Очистить" - очищает все поля
         */
        function smartDesignClear() {
            hideSmartDesignMessage();

            const trigSelect = document.getElementById('smart-design-trig');
            const subjectSelect = document.getElementById('smart-design-subject');
            const predicateSelect = document.getElementById('smart-design-predicate');
            const objectSelect = document.getElementById('smart-design-object');
            const resultTextarea = document.getElementById('result-sparql-query');

            if (trigSelect) trigSelect.value = '';
            if (subjectSelect) subjectSelect.value = '';
            if (predicateSelect) predicateSelect.value = '';
            if (objectSelect) objectSelect.value = '';
            if (resultTextarea) resultTextarea.value = '';

            // Сбрасываем флаг New TriG
            isNewTrigQuery = false;
            updateSimpleTripleButtonState();

            // Перезаполняем выпадающие списки (удаляем добавленные кастомные значения)
            populateSmartDesignDropdowns();

            showSmartDesignMessage('Все поля очищены', 'info');
        }

        /**
         * Обработчик кнопки "Применить SPARQL" - применяет запрос к RDF данным
         */
        async function smartDesignApply() {
            hideResultSparqlMessage();

            const resultTextarea = document.getElementById('result-sparql-query');
            if (!resultTextarea || !resultTextarea.value.trim()) {
                showResultSparqlMessage('Ошибка: Сначала сгенерируйте SPARQL запрос (нажмите "Создать SPARQL" или "Удалить триплет")', 'error');
                return;
            }

            const sparqlQuery = resultTextarea.value.trim();
            const rdfInput = document.getElementById('rdf-input');

            if (!rdfInput) {
                showResultSparqlMessage('Ошибка: Не найдено поле RDF данных', 'error');
                return;
            }

            // Определяем тип запроса (INSERT или DELETE)
            const isInsert = sparqlQuery.includes('INSERT DATA');
            const isDelete = sparqlQuery.includes('DELETE DATA');

            if (!isInsert && !isDelete) {
                showResultSparqlMessage('Ошибка: Неизвестный тип SPARQL запроса', 'error');
                return;
            }

            // Паттерн для извлечения URI/префиксного имени (поддерживает <uri> и prefix:name)
            const uriPattern = '(?:<[^>]+>|[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z0-9_-]+)';
            // Паттерн для извлечения объекта (может быть URI, префиксное имя или литерал в кавычках)
            const objectPattern = '(?:<[^>]+>|[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z0-9_-]+|"[^"]*")';

            // Извлекаем GRAPH и триплеты из запроса
            const graphMatch = sparqlQuery.match(new RegExp(`GRAPH\\s+(${uriPattern})\\s*\\{([\\s\\S]*?)\\}`, 'i'));

            if (!graphMatch) {
                showResultSparqlMessage('Ошибка: Не удалось распознать GRAPH в SPARQL запросе', 'error');
                return;
            }

            const graphRef = graphMatch[1];
            const graphBody = graphMatch[2];

            // Извлекаем триплеты из тела GRAPH
            const triplePattern = new RegExp(`(${uriPattern})\\s+(${uriPattern})\\s+(${objectPattern})\\s*\\.`, 'g');
            const triples = [];
            let tripleMatch;
            while ((tripleMatch = triplePattern.exec(graphBody)) !== null) {
                triples.push({
                    subject: tripleMatch[1],
                    predicate: tripleMatch[2],
                    object: tripleMatch[3]
                });
            }

            if (triples.length === 0) {
                showResultSparqlMessage('Ошибка: Не удалось распознать триплеты в SPARQL запросе', 'error');
                return;
            }

            // Конвертируем URI/префикс в префиксную форму для RDF текста
            function toPrefixed(ref) {
                if (ref.startsWith('<') && ref.endsWith('>')) {
                    // Полный URI - конвертируем в префиксную форму
                    const cleanUri = ref.slice(1, -1);
                    return getPrefixedName(cleanUri, currentPrefixes);
                }
                // Уже в префиксной форме или литерал
                return ref;
            }

            const graphPrefixed = toPrefixed(graphRef);

            // Получаем текущий RDF текст
            let currentRdfText = rdfInput.value;

            if (isInsert) {
                // Проверка на дубликаты для каждого триплета (кроме создания нового TriG)
                if (!isNewTrigQuery) {
                    const duplicateTriples = [];
                    for (const triple of triples) {
                        const subjectPrefixed = toPrefixed(triple.subject);
                        const predicatePrefixed = toPrefixed(triple.predicate);
                        const objectPrefixed = toPrefixed(triple.object);

                        const duplicate = findDuplicateTriple(subjectPrefixed, predicatePrefixed, objectPrefixed);
                        if (duplicate) {
                            duplicateTriples.push({
                                triple: `${subjectPrefixed} ${predicatePrefixed} ${objectPrefixed}`,
                                graph: duplicate.graphLabel
                            });
                        }
                    }

                    // Если есть дубликаты, показываем ошибку
                    if (duplicateTriples.length > 0) {
                        const duplicateMessages = duplicateTriples.map(d => `"${d.triple}" (в графе "${d.graph}")`).join(', ');
                        showResultSparqlMessage(`Ошибка: Обнаружены дубликаты триплетов: ${duplicateMessages}`, 'error');
                        return;
                    }
                }

                // Формируем триплеты для вставки
                const triplesForInsert = triples.map(t => {
                    const subjectPrefixed = toPrefixed(t.subject);
                    const predicatePrefixed = toPrefixed(t.predicate);
                    const objectPrefixed = toPrefixed(t.object);
                    return `    ${subjectPrefixed} ${predicatePrefixed} ${objectPrefixed} .`;
                }).join('\n');

                // Ищем секцию графа и добавляем триплеты В КОНЕЦ блока (перед закрывающей скобкой)
                let graphEndPattern = new RegExp(`(${escapeRegex(graphPrefixed)}\\s*\\{[^}]*)(\\s*\\})`, 's');
                let graphTextMatch = currentRdfText.match(graphEndPattern);

                if (!graphTextMatch) {
                    // Попробуем найти по полному URI (если в RDF тексте используется полный URI)
                    graphEndPattern = new RegExp(`(${escapeRegex(graphRef)}\\s*\\{[^}]*)(\\s*\\})`, 's');
                    graphTextMatch = currentRdfText.match(graphEndPattern);
                }

                if (graphTextMatch) {
                    // Добавляем триплеты в КОНЕЦ существующего графа (перед закрывающей скобкой)
                    currentRdfText = currentRdfText.replace(graphEndPattern, `$1\n${triplesForInsert}$2`);
                } else {
                    // Создаем новый граф с триплетами
                    const newGraph = `\n\n${graphPrefixed} {\n${triplesForInsert}\n}`;
                    currentRdfText += newGraph;
                }

                rdfInput.value = currentRdfText;

                // Переразбираем RDF данные для обновления currentQuads и кэша типов
                // Это позволит корректно обнаруживать дубликаты при последующих операциях
                await reparseRdfData();

                showResultSparqlMessage('Триплеты успешно добавлены в RDF данные. Нажмите "Визуализировать" для обновления графа.', 'success');

            } else if (isDelete) {
                // Удаляем триплеты из RDF данных
                let wasDeleted = false;
                let newRdfText = currentRdfText;

                for (const triple of triples) {
                    const subjectPrefixed = toPrefixed(triple.subject);
                    const predicatePrefixed = toPrefixed(triple.predicate);
                    const objectPrefixed = toPrefixed(triple.object);

                    // Пробуем найти и удалить в префиксной форме
                    let deletePattern = new RegExp(`\\s*${escapeRegex(subjectPrefixed)}\\s+${escapeRegex(predicatePrefixed)}\\s+${escapeRegex(objectPrefixed)}\\s*[;.]`, 'g');
                    const prevText = newRdfText;
                    newRdfText = newRdfText.replace(deletePattern, '');

                    if (newRdfText === prevText) {
                        // Попробуем с исходными значениями (на случай, если в RDF текст попали полные URI)
                        deletePattern = new RegExp(`\\s*${escapeRegex(triple.subject)}\\s+${escapeRegex(triple.predicate)}\\s+${escapeRegex(triple.object)}\\s*[;.]`, 'g');
                        newRdfText = newRdfText.replace(deletePattern, '');
                    }

                    if (newRdfText !== prevText) {
                        wasDeleted = true;
                    }
                }

                if (!wasDeleted) {
                    showResultSparqlMessage('Предупреждение: Триплеты не найдены в текстовом представлении RDF данных', 'info');
                } else {
                    rdfInput.value = newRdfText;

                    // Переразбираем RDF данные для обновления currentQuads и кэша типов
                    await reparseRdfData();

                    showResultSparqlMessage('Триплеты успешно удалены из RDF данных. Нажмите "Визуализировать" для обновления графа.', 'success');
                }
            }

            // Поля Smart Design и Result in SPARQL не очищаются после применения
            // Очистка происходит только по кнопке "Очистить"
        }

        /**
         * Переразбирает RDF данные из текстового поля и обновляет currentQuads и nodeTypesCache.
         * Это необходимо после добавления или удаления триплетов, чтобы проверка на дубликаты
         * работала корректно для последующих операций.
         * @returns {Promise<boolean>} - true если парсинг прошел успешно
         */
        async function reparseRdfData() {
            try {
                const rdfInput = document.getElementById('rdf-input');
                if (!rdfInput || !rdfInput.value.trim()) return false;

                const inputFormat = document.getElementById('input-format').value;
                const parser = new N3.Parser({ format: inputFormat });
                const quads = [];
                let prefixes = {};

                await new Promise((resolve, reject) => {
                    parser.parse(rdfInput.value, (error, quad, parsedPrefixes) => {
                        if (error) {
                            reject(error);
                            return;
                        }
                        if (quad) {
                            quads.push(quad);
                        } else {
                            if (parsedPrefixes) {
                                prefixes = parsedPrefixes;
                            }
                            resolve();
                        }
                    });
                });

                // Обновляем глобальные переменные
                currentQuads = quads;
                currentPrefixes = prefixes;

                // Перестраиваем кэш типов узлов
                buildNodeTypesCache(currentQuads, currentPrefixes);

                // Обновляем иерархию TriG если в режиме VAD TriG
                if (currentMode === 'vad-trig') {
                    const hierarchyResult = parseTriGHierarchy(quads, prefixes);
                    if (hierarchyResult.valid) {
                        trigHierarchy = hierarchyResult.hierarchy;
                    }
                }

                return true;
            } catch (error) {
                console.error('Ошибка при переразборе RDF данных:', error);
                return false;
            }
        }

        /**
         * Экранирует специальные символы регулярного выражения
         * @param {string} str - Строка для экранирования
         * @returns {string} - Экранированная строка
         */
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        /**
         * LITERAL_PREDICATES - Предикаты, для которых объект должен быть литералом (единственное значение)
         * При добавлении нового значения для этих предикатов, старое значение должно быть заменено
         */
        const LITERAL_PREDICATES = [
            'rdfs:label',
            'http://www.w3.org/2000/01/rdf-schema#label',
            'dcterms:description',
            'http://purl.org/dc/terms/description',
            'dcterms:title',
            'http://purl.org/dc/terms/title',
            'rdfs:comment',
            'http://www.w3.org/2000/01/rdf-schema#comment'
        ];

        /**
         * Проверяет, является ли предикат литеральным (требующим единственного значения)
         * @param {string} predicateUri - URI или prefixed name предиката
         * @returns {boolean}
         */
        function isLiteralPredicate(predicateUri) {
            return LITERAL_PREDICATES.some(allowed =>
                predicateUri === allowed || predicateUri.endsWith('#' + allowed.split(':')[1])
            );
        }

        /**
         * Находит существующее значение литерального предиката для субъекта
         * @param {string} subjectValue - URI или prefixed name субъекта
         * @param {string} predicateValue - URI или prefixed name предиката
         * @returns {Object|null} - { value: string, graphUri: string } если найдено, иначе null
         */
        function findExistingLiteralValue(subjectValue, predicateValue) {
            // Преобразуем prefixed names в полные URI
            let subjectUri = subjectValue;
            let predicateUri = predicateValue;

            for (const [prefix, namespace] of Object.entries(currentPrefixes)) {
                if (subjectValue.startsWith(prefix + ':')) {
                    subjectUri = namespace + subjectValue.substring(prefix.length + 1);
                }
                if (predicateValue.startsWith(prefix + ':')) {
                    predicateUri = namespace + predicateValue.substring(prefix.length + 1);
                }
            }

            const subjectPrefixed = getPrefixedName(subjectUri, currentPrefixes);
            const predicatePrefixed = getPrefixedName(predicateUri, currentPrefixes);

            for (const quad of currentQuads) {
                const qSubjectUri = quad.subject.value;
                const qPredicateUri = quad.predicate.value;
                const qSubjectPrefixed = getPrefixedName(qSubjectUri, currentPrefixes);
                const qPredicatePrefixed = getPrefixedName(qPredicateUri, currentPrefixes);

                const subjectMatch = (subjectUri === qSubjectUri) || (subjectPrefixed === qSubjectPrefixed);
                const predicateMatch = (predicateUri === qPredicateUri) || (predicatePrefixed === qPredicatePrefixed);

                if (subjectMatch && predicateMatch && quad.object.termType === 'Literal') {
                    const graphUri = quad.graph ? quad.graph.value : null;
                    return { value: quad.object.value, graphUri: graphUri };
                }
            }

            return null;
        }

        /**
         * Показывает сообщение в панели Result in SPARQL
         * @param {string} message - Текст сообщения
         * @param {string} type - Тип: 'success', 'error', 'info'
         */
        function showResultSparqlMessage(message, type = 'info') {
            const messageDiv = document.getElementById('result-sparql-message');
            if (messageDiv) {
                messageDiv.textContent = message;
                messageDiv.className = 'smart-design-message ' + type;
                messageDiv.style.display = 'block';
            }
        }

        /**
         * Скрывает сообщение в панели Result in SPARQL
         */
        function hideResultSparqlMessage() {
            const messageDiv = document.getElementById('result-sparql-message');
            if (messageDiv) {
                messageDiv.style.display = 'none';
            }
        }

        /**
         * Обработчик кнопки "Применить как Shorthand Triple"
         * Добавляет триплет в shorthand форме (через запятую)
         */
        function smartDesignApplyShorthand() {
            const resultTextarea = document.getElementById('result-sparql-query');
            if (!resultTextarea || !resultTextarea.value.trim()) {
                showResultSparqlMessage('Ошибка: Сначала сгенерируйте SPARQL запрос (нажмите "Создать SPARQL" или "Удалить")', 'error');
                return;
            }

            const sparqlQuery = resultTextarea.value.trim();
            const rdfInput = document.getElementById('rdf-input');

            if (!rdfInput) {
                showResultSparqlMessage('Ошибка: Не найдено поле RDF данных', 'error');
                return;
            }

            // Определяем тип запроса (только INSERT поддерживается для shorthand)
            const isInsert = sparqlQuery.includes('INSERT DATA');
            const isDelete = sparqlQuery.includes('DELETE DATA');

            if (isDelete) {
                showResultSparqlMessage('Ошибка: Shorthand Triple режим не поддерживает DELETE операции. Используйте "Применить как Simple Triple".', 'error');
                return;
            }

            if (!isInsert) {
                showResultSparqlMessage('Ошибка: Неизвестный тип SPARQL запроса', 'error');
                return;
            }

            // Паттерн для извлечения URI/префиксного имени
            const uriPattern = '(?:<[^>]+>|[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z0-9_.-]+)';
            const objectPattern = '(?:<[^>]+>|[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z0-9_.-]+|"[^"]*")';

            // Извлекаем GRAPH и триплеты из запроса
            const graphMatch = sparqlQuery.match(new RegExp(`GRAPH\\s+(${uriPattern})\\s*\\{([\\s\\S]*?)\\}`, 'i'));

            if (!graphMatch) {
                showResultSparqlMessage('Ошибка: Не удалось распознать GRAPH в SPARQL запросе', 'error');
                return;
            }

            const graphRef = graphMatch[1];
            const graphBody = graphMatch[2];

            // Извлекаем триплеты из тела GRAPH
            const triplePattern = new RegExp(`(${uriPattern})\\s+(${uriPattern})\\s+(${objectPattern})\\s*\\.`, 'g');
            const triples = [];
            let tripleMatch;
            while ((tripleMatch = triplePattern.exec(graphBody)) !== null) {
                triples.push({
                    subject: tripleMatch[1],
                    predicate: tripleMatch[2],
                    object: tripleMatch[3]
                });
            }

            if (triples.length === 0) {
                showResultSparqlMessage('Ошибка: Не удалось распознать триплеты в SPARQL запросе', 'error');
                return;
            }

            // Конвертируем URI/префикс в префиксную форму
            function toPrefixed(ref) {
                if (ref.startsWith('<') && ref.endsWith('>')) {
                    const cleanUri = ref.slice(1, -1);
                    return getPrefixedName(cleanUri, currentPrefixes);
                }
                return ref;
            }

            // Проверка на дубликаты для каждого триплета
            const duplicateTriples = [];
            for (const triple of triples) {
                const subjectPrefixed = toPrefixed(triple.subject);
                const predicatePrefixed = toPrefixed(triple.predicate);
                const objectPrefixed = toPrefixed(triple.object);

                const duplicate = findDuplicateTriple(subjectPrefixed, predicatePrefixed, objectPrefixed);
                if (duplicate) {
                    duplicateTriples.push({
                        triple: `${subjectPrefixed} ${predicatePrefixed} ${objectPrefixed}`,
                        graph: duplicate.graphLabel
                    });
                }
            }

            // Если есть дубликаты, показываем ошибку
            if (duplicateTriples.length > 0) {
                const duplicateMessages = duplicateTriples.map(d => `"${d.triple}" (в графе "${d.graph}")`).join(', ');
                showResultSparqlMessage(`Ошибка: Обнаружены дубликаты триплетов: ${duplicateMessages}`, 'error');
                return;
            }

            const graphPrefixed = toPrefixed(graphRef);
            let currentRdfText = rdfInput.value;
            let successCount = 0;
            let replaceMessages = [];

            // Специальная обработка для создания нового TriG в shorthand формате
            if (isNewTrigQuery) {
                // Группируем триплеты по субъекту для shorthand записи
                const triplesBySubject = new Map();
                for (const triple of triples) {
                    const subjectPrefixed = toPrefixed(triple.subject);
                    const predicatePrefixed = toPrefixed(triple.predicate);
                    const objectPrefixed = toPrefixed(triple.object);

                    if (!triplesBySubject.has(subjectPrefixed)) {
                        triplesBySubject.set(subjectPrefixed, []);
                    }
                    triplesBySubject.get(subjectPrefixed).push({ predicate: predicatePrefixed, object: objectPrefixed });
                }

                // Формируем shorthand запись для каждого субъекта
                let shorthandTriples = [];
                for (const [subject, predicateObjects] of triplesBySubject) {
                    if (predicateObjects.length === 1) {
                        // Один предикат-объект - простая запись
                        shorthandTriples.push(`    ${subject} ${predicateObjects[0].predicate} ${predicateObjects[0].object} .`);
                    } else {
                        // Несколько предикатов-объектов - shorthand через точку с запятой
                        const firstPO = predicateObjects[0];
                        let shorthandLine = `    ${subject} ${firstPO.predicate} ${firstPO.object}`;
                        for (let i = 1; i < predicateObjects.length; i++) {
                            shorthandLine += ` ;\n        ${predicateObjects[i].predicate} ${predicateObjects[i].object}`;
                        }
                        shorthandLine += ' .';
                        shorthandTriples.push(shorthandLine);
                    }
                }

                // Создаем новый граф с shorthand записями
                const newGraph = `\n\n${graphPrefixed} {\n${shorthandTriples.join('\n')}\n}`;
                currentRdfText += newGraph;
                rdfInput.value = currentRdfText;

                // Сбрасываем флаг New TriG
                isNewTrigQuery = false;
                updateSimpleTripleButtonState();

                showResultSparqlMessage(`Новый TriG "${graphPrefixed}" успешно создан в shorthand формате. Нажмите "Визуализировать" для обновления графа.`, 'success');
                return;
            }

            for (const triple of triples) {
                const subjectPrefixed = toPrefixed(triple.subject);
                const predicatePrefixed = toPrefixed(triple.predicate);
                const objectPrefixed = toPrefixed(triple.object);

                // Проверяем, является ли предикат литеральным
                const isLiteralPred = isLiteralPredicate(predicatePrefixed);

                if (isLiteralPred) {
                    // Для литеральных предикатов - ищем и заменяем существующее значение
                    const existingValue = findExistingLiteralValue(subjectPrefixed, predicatePrefixed);
                    if (existingValue) {
                        // Нужно удалить старое значение и добавить новое в shorthand стиле
                        const oldValueEscaped = escapeRegex(`"${existingValue.value}"`);

                        // Паттерн 1: Простой триплет "subject predicate value"
                        let replacePattern = new RegExp(
                            `(${escapeRegex(subjectPrefixed)}\\s+${escapeRegex(predicatePrefixed)}\\s+)${oldValueEscaped}`,
                            'g'
                        );
                        let newText = currentRdfText.replace(replacePattern, `$1${objectPrefixed}`);

                        // Паттерн 2: Shorthand формат - предикат после точки с запятой "... ; predicate value"
                        if (newText === currentRdfText) {
                            replacePattern = new RegExp(
                                `(;\\s*${escapeRegex(predicatePrefixed)}\\s+)${oldValueEscaped}`,
                                'g'
                            );
                            newText = currentRdfText.replace(replacePattern, `$1${objectPrefixed}`);
                        }

                        if (newText !== currentRdfText) {
                            currentRdfText = newText;
                            replaceMessages.push(`Прежнее значение "${existingValue.value}" заменено`);
                            successCount++;
                            continue;
                        }
                    }
                }

                // Сначала извлекаем содержимое целевого графа для проверки
                const graphContentPattern = new RegExp(`(${escapeRegex(graphPrefixed)}\\s*\\{)([\\s\\S]*?)(\\})`, 's');
                const graphContentMatch = currentRdfText.match(graphContentPattern);

                if (!graphContentMatch) {
                    // Граф не найден - создаем новый граф с триплетом
                    const newGraph = `\n\n${graphPrefixed} {\n    ${subjectPrefixed} ${predicatePrefixed} ${objectPrefixed} .\n}`;
                    currentRdfText += newGraph;
                    successCount++;
                    continue;
                }

                const graphContent = graphContentMatch[2];

                // Ищем существующий триплет с тем же subject и predicate В ПРЕДЕЛАХ ЦЕЛЕВОГО ГРАФА для добавления через запятую
                const subjectPredicateInGraphPattern = new RegExp(
                    `(${escapeRegex(subjectPrefixed)}\\s+${escapeRegex(predicatePrefixed)}\\s+)([^;.]+)([;.])`,
                    'g'
                );

                const existingMatchInGraph = graphContent.match(subjectPredicateInGraphPattern);
                if (existingMatchInGraph) {
                    // Добавляем новый объект через запятую В ПРЕДЕЛАХ ЦЕЛЕВОГО ГРАФА
                    const newGraphContent = graphContent.replace(
                        subjectPredicateInGraphPattern,
                        `$1$2, ${objectPrefixed}$3`
                    );
                    currentRdfText = currentRdfText.replace(graphContentPattern, `$1${newGraphContent}$3`);
                    successCount++;
                } else {
                    // Ищем существующий субъект для добавления нового предиката В ПРЕДЕЛАХ ЦЕЛЕВОГО ГРАФА
                    const subjectInGraphPattern = new RegExp(
                        `(${escapeRegex(subjectPrefixed)}\\s+[^}]*?)([;.])(?=\\s|$|\\n)`,
                        's'
                    );
                    const subjectMatchInGraph = graphContent.match(subjectInGraphPattern);

                    if (subjectMatchInGraph) {
                        // Добавляем новый предикат и объект В ПРЕДЕЛАХ ЦЕЛЕВОГО ГРАФА
                        const newGraphContent = graphContent.replace(
                            subjectInGraphPattern,
                            `$1 ;\n        ${predicatePrefixed} ${objectPrefixed}$2`
                        );
                        currentRdfText = currentRdfText.replace(graphContentPattern, `$1${newGraphContent}$3`);
                        successCount++;
                    } else {
                        // Создаем новый субъект в целевом графе
                        const newTriple = `\n    ${subjectPrefixed} ${predicatePrefixed} ${objectPrefixed} .`;
                        const newGraphContent = graphContent + newTriple;
                        currentRdfText = currentRdfText.replace(graphContentPattern, `$1${newGraphContent}$3`);
                        successCount++;
                    }
                }
            }

            if (successCount > 0) {
                rdfInput.value = currentRdfText;
                let message = `Shorthand Triple: ${successCount} значение(й) успешно добавлено.`;
                if (replaceMessages.length > 0) {
                    message += ' ' + replaceMessages.join('. ') + '.';
                }
                message += ' Нажмите "Визуализировать" для обновления графа.';
                showResultSparqlMessage(message, 'success');
            } else {
                showResultSparqlMessage('Не удалось добавить значения в shorthand формате', 'error');
            }

            // Поля Smart Design и Result in SPARQL не очищаются после применения
            // Очистка происходит только по кнопке "Очистить"
        }

        /**
         * Открывает модальное окно для создания нового TriG
         */
        function openNewTrigModal() {
            const modal = document.getElementById('new-trig-modal');
            const parentSelect = document.getElementById('new-trig-parent');

            // Заполняем список родителей существующими TriG
            parentSelect.innerHTML = '<option value="">-- Выберите родителя (опционально) --</option>';
            const trigs = getAllTriGs();
            trigs.forEach(t => {
                const option = document.createElement('option');
                option.value = t.uri;
                const id = getPrefixedName(t.uri, currentPrefixes);
                const displayText = t.label && t.label !== id ? `${id} (${t.label})` : id;
                option.textContent = displayText;
                parentSelect.appendChild(option);
            });

            // Очищаем поля ввода
            document.getElementById('new-trig-id').value = '';
            document.getElementById('new-trig-label').value = '';
            document.getElementById('new-trig-type').value = '';

            modal.style.display = 'block';

            // Деактивируем основные поля Smart Design
            updateSmartDesignFieldsState();
        }

        /**
         * Закрывает модальное окно создания нового TriG
         */
        function closeNewTrigModal() {
            const modal = document.getElementById('new-trig-modal');
            modal.style.display = 'none';

            // Активируем основные поля Smart Design
            updateSmartDesignFieldsState();
        }

        /**
         * Создает новый TriG контейнер и генерирует SPARQL запрос
         */
        function createNewTrig() {
            const trigId = document.getElementById('new-trig-id').value.trim();
            const label = document.getElementById('new-trig-label').value.trim();
            const parentUri = document.getElementById('new-trig-parent').value;
            const typeOfScheme = document.getElementById('new-trig-type').value.trim();

            if (!trigId) {
                alert('Ошибка: Введите ID для нового TriG');
                return;
            }

            // Проверяем, не существует ли уже такой TriG
            if (trigExists(trigId)) {
                alert('Ошибка: TriG с таким ID уже существует');
                return;
            }

            // Формируем URI нового TriG
            let trigUri;
            if (currentPrefixes['vad']) {
                trigUri = `vad:${trigId}`;
            } else {
                trigUri = `<http://example.org/vad#${trigId}>`;
            }

            // Генерируем SPARQL для создания TriG с нужными предикатами
            const prefixDeclarations = generateSparqlPrefixes(currentPrefixes);

            let triples = [];

            // Всегда добавляем rdf:type
            triples.push(`        ${trigUri} rdf:type vad:TriG .`);

            // rdfs:label (обязательно)
            if (label) {
                const escapedLabel = label.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                triples.push(`        ${trigUri} rdfs:label "${escapedLabel}" .`);
            }

            // vad:hasParentTrig (опционально)
            if (parentUri) {
                // Преобразуем URI родителя в префиксную форму
                const parentPrefixed = getPrefixedName(parentUri, currentPrefixes);
                triples.push(`        ${trigUri} vad:hasParentTrig ${parentPrefixed} .`);
            }

            // vad:typeOfScheme (опционально)
            if (typeOfScheme) {
                const escapedType = typeOfScheme.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                triples.push(`        ${trigUri} vad:typeOfScheme "${escapedType}" .`);
            }

            const sparqlQuery = `${prefixDeclarations}INSERT DATA {
    GRAPH ${trigUri} {
${triples.join('\n')}
    }
}`;

            // Записываем SPARQL в поле результата
            const resultTextarea = document.getElementById('result-sparql-query');
            if (resultTextarea) {
                resultTextarea.value = sparqlQuery;
            }

            // Устанавливаем флаг, что это запрос New TriG
            isNewTrigQuery = true;
            updateSimpleTripleButtonState();

            closeNewTrigModal();
            showSmartDesignMessage('SPARQL запрос для создания нового TriG сгенерирован. Нажмите "Применить как Simple Triple" (отдельные строки) или "Применить как Shorthand Triple" (составная запись через ;).', 'success');
        }

        /**
         * Обновляет состояние кнопки "Применить как Simple Triple"
         * Обе кнопки активны для создания нового TriG
         */
        function updateSimpleTripleButtonState() {
            const simpleTripleBtn = document.querySelector('.apply-btn[onclick="smartDesignApply()"]');
            if (simpleTripleBtn) {
                // Кнопка Simple Triple всегда активна
                simpleTripleBtn.disabled = false;
                simpleTripleBtn.style.opacity = '1';
                simpleTripleBtn.style.cursor = 'pointer';
                simpleTripleBtn.title = '';
            }
        }

        /**
         * Открывает RDF данные в отдельном окне браузера
         */
        function showRdfInSeparateWindow() {
            const rdfInput = document.getElementById('rdf-input');
            if (!rdfInput) return;

            const rdfContent = rdfInput.value;

            // Создаем новое окно
            const newWindow = window.open('', '_blank', 'width=800,height=600,scrollbars=yes,resizable=yes');

            if (newWindow) {
                // Формируем HTML для нового окна
                const htmlContent = '<!DOCTYPE html>' +
                    '<html><head><title>RDF данные</title>' +
                    '<style>' +
                    'body { font-family: Consolas, Monaco, monospace; padding: 20px; background-color: #f5f5f5; margin: 0; }' +
                    '.container { background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }' +
                    'h1 { color: #333; font-size: 18px; margin-top: 0; border-bottom: 2px solid #4CAF50; padding-bottom: 10px; }' +
                    'pre { white-space: pre-wrap; word-wrap: break-word; font-size: 13px; line-height: 1.5; margin: 0; color: #333; }' +
                    '.copy-btn { background-color: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-bottom: 15px; }' +
                    '.copy-btn:hover { background-color: #45a049; }' +
                    '</style></head>' +
                    '<body><div class="container">' +
                    '<h1>RDF данные</h1>' +
                    '<button class="copy-btn" id="copy-btn">Копировать в буфер</button>' +
                    '<pre id="rdf-content"></pre>' +
                    '</div></body></html>';

                newWindow.document.write(htmlContent);
                newWindow.document.close();

                // Заполняем содержимое после записи документа
                const preElement = newWindow.document.getElementById('rdf-content');
                if (preElement) {
                    preElement.textContent = rdfContent;
                }

                // Добавляем обработчик для кнопки копирования
                const copyBtn = newWindow.document.getElementById('copy-btn');
                if (copyBtn) {
                    copyBtn.onclick = function() {
                        newWindow.navigator.clipboard.writeText(rdfContent).then(function() {
                            newWindow.alert('Скопировано в буфер обмена');
                        }).catch(function() {
                            // Fallback для старых браузеров
                            const textarea = newWindow.document.createElement('textarea');
                            textarea.value = rdfContent;
                            newWindow.document.body.appendChild(textarea);
                            textarea.select();
                            newWindow.document.execCommand('copy');
                            newWindow.document.body.removeChild(textarea);
                            newWindow.alert('Скопировано в буфер обмена');
                        });
                    };
                }
            } else {
                alert('Не удалось открыть новое окно. Проверьте настройки блокировки всплывающих окон.');
            }
        }

        // Закрытие модального окна при клике вне его
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('new-trig-modal');
            if (event.target === modal) {
                closeNewTrigModal();
            }
        });

        function updateModeDescription() {
            const mode = document.getElementById('visualization-mode').value;
            const description = document.getElementById('mode-description');
            const maxVadRowLengthGroup = document.getElementById('max-vad-row-length-group');
            const sparqlModeSelect = document.getElementById('sparql-mode');
            const smartDesignOption = sparqlModeSelect ? sparqlModeSelect.querySelector('option[value="smart-design"]') : null;

            const descriptions = {
                'notation': 'С выделением типов объектов и предикатов цветом и формами',
                'base': 'Базовый режим без специальных стилей',
                'aggregation': 'Литералы агрегируются в узел субъекта',
                'vad': 'VAD: процессы как cds-фигуры с исполнителями',
                'vad-trig': 'VAD TriG: иерархия TriG с деревом и свойствами'
            };

            description.textContent = descriptions[mode] || '';

            // Показываем/скрываем параметр "Макс. длина VAD" для режимов VAD и VAD TriG
            if (mode === 'vad' || mode === 'vad-trig') {
                maxVadRowLengthGroup.style.display = 'block';
            } else {
                maxVadRowLengthGroup.style.display = 'none';
            }

            // Показываем/скрываем опцию "SPARQL Smart Design" в зависимости от режима визуализации
            if (smartDesignOption) {
                if (mode === 'vad-trig') {
                    smartDesignOption.style.display = '';
                } else {
                    smartDesignOption.style.display = 'none';
                    // Если был выбран smart-design, сбрасываем на 'no'
                    if (sparqlModeSelect.value === 'smart-design') {
                        sparqlModeSelect.value = 'no';
                    }
                }
            }

            // Обновляем состояние SPARQL панели
            toggleSparqlPanel();
        }

        function toggleSparqlPanel() {
            const sparqlMode = document.getElementById('sparql-mode').value;
            const visualizationMode = document.getElementById('visualization-mode').value;
            const sparqlPanel = document.getElementById('sparql-panel');
            const smartDesignContainer = document.getElementById('smart-design-container');

            // Скрываем оба панели по умолчанию
            sparqlPanel.classList.remove('visible');
            smartDesignContainer.classList.remove('visible');

            if (sparqlMode === 'yes') {
                sparqlPanel.classList.add('visible');
            } else if (sparqlMode === 'smart-design') {
                // SPARQL Smart Design отображается только в режиме VAD TriG
                if (visualizationMode === 'vad-trig') {
                    smartDesignContainer.classList.add('visible');
                    // Заполняем выпадающие списки при активации Smart Design
                    populateSmartDesignDropdowns();
                    // Показываем справочные сообщения при открытии панели
                    showSmartDesignMessage('Выберите TriG, затем Subject, Predicate и Object. Нажмите "Создать SPARQL" для генерации запроса.', 'info');
                    showResultSparqlMessage('После генерации SPARQL запроса нажмите "Применить как Simple Triple" или "Применить как Shorthand Triple" для добавления в RDF данные.', 'info');
                } else {
                    // Показываем сообщение, что Smart Design доступен только в VAD TriG
                    showSmartDesignMessage('SPARQL Smart Design доступен только в режиме "Режим VAD TriG"', 'info');
                }
            }
        }

        // ============================================================================
        // ОСНОВНАЯ ФУНКЦИЯ ВИЗУАЛИЗАЦИИ
        // ============================================================================

        async function visualize() {
            const rdfInput = document.getElementById('rdf-input').value.trim();
            const inputFormat = document.getElementById('input-format').value;
            const outputFormat = document.getElementById('output-format').value;
            const layoutEngine = document.getElementById('layout-engine').value;
            const visualizationMode = document.getElementById('visualization-mode').value;

            const maxLabelLengthInput = document.getElementById('max-label-length');
            const maxLabelLengthValue = parseInt(maxLabelLengthInput.value, 10);
            if (!isNaN(maxLabelLengthValue) && maxLabelLengthValue >= 5 && maxLabelLengthValue <= 200) {
                currentMaxLabelLength = maxLabelLengthValue;
            } else {
                currentMaxLabelLength = DEFAULT_MAX_LABEL_LENGTH;
                maxLabelLengthInput.value = DEFAULT_MAX_LABEL_LENGTH;
            }

            // Чтение параметра "Макс. длина VAD" для режима VAD
            const maxVadRowLengthInput = document.getElementById('max-vad-row-length');
            const maxVadRowLengthValue = parseInt(maxVadRowLengthInput.value, 10);
            if (!isNaN(maxVadRowLengthValue) && maxVadRowLengthValue >= 2 && maxVadRowLengthValue <= 20) {
                currentMaxVadRowLength = maxVadRowLengthValue;
            } else {
                currentMaxVadRowLength = DEFAULT_MAX_VAD_ROW_LENGTH;
                maxVadRowLengthInput.value = DEFAULT_MAX_VAD_ROW_LENGTH;
            }

            currentMode = visualizationMode;

            if (!rdfInput) {
                showError('Пожалуйста, введите RDF данные');
                return;
            }

            showLoading();

            const button = document.getElementById('visualize-btn');
            button.disabled = true;
            button.textContent = 'Обработка...';

            try {
                const parser = new N3.Parser({ format: inputFormat });
                const quads = [];
                let prefixes = {};

                await new Promise((resolve, reject) => {
                    parser.parse(rdfInput, (error, quad, parsedPrefixes) => {
                        if (error) {
                            reject(error);
                            return;
                        }
                        if (quad) {
                            quads.push(quad);
                        } else {
                            if (parsedPrefixes) {
                                prefixes = parsedPrefixes;
                            }
                            resolve();
                        }
                    });
                });

                currentPrefixes = prefixes;
                currentQuads = quads;
                currentStore = null;

                if (quads.length === 0) {
                    showError('Не найдено RDF триплетов в данных');
                    return;
                }

                // Валидация для режима VAD
                if (currentMode === 'vad') {
                    const validation = validateVAD(quads, prefixes);
                    if (!validation.valid) {
                        showValidationError(formatVADErrors(validation.errors));
                        button.disabled = false;
                        button.textContent = 'Визуализировать';
                        return;
                    }
                }

                // Обработка режима VAD TriG
                if (currentMode === 'vad-trig') {
                    // Парсим иерархию TriG графов
                    const hierarchyResult = parseTriGHierarchy(quads, prefixes);

                    if (!hierarchyResult.valid) {
                        showValidationError(formatVADTriGErrors(hierarchyResult.errors));
                        toggleVADTriGPanels(false);
                        button.disabled = false;
                        button.textContent = 'Визуализировать';
                        return;
                    }

                    // Сохраняем иерархию
                    trigHierarchy = hierarchyResult.hierarchy;

                    // Выбираем корневой TriG для начального отображения
                    selectedTrigUri = hierarchyResult.rootTrigUri;

                    // Показываем панели VAD TriG
                    toggleVADTriGPanels(true);

                    // Отображаем дерево TriG
                    displayTriGTree(trigHierarchy, selectedTrigUri, prefixes);

                    // Отображаем свойства корневого TriG
                    displayTriGProperties(selectedTrigUri, trigHierarchy, prefixes);

                    // Валидация VAD для квадов корневого графа
                    const rootGraphInfo = trigHierarchy[selectedTrigUri];
                    if (rootGraphInfo) {
                        const validation = validateVAD(rootGraphInfo.quads, prefixes);
                        if (!validation.valid) {
                            showValidationError(formatVADErrors(validation.errors));
                            button.disabled = false;
                            button.textContent = 'Визуализировать';
                            return;
                        }
                    }

                    // Продолжаем с квадами только из выбранного графа
                    activeFilters = [...getFilterConfig('vad').hiddenPredicates];

                    const filteredQuads = rootGraphInfo.quads.filter(quad => {
                        const predicateUri = quad.predicate.value;
                        const predicateLabel = getPrefixedName(predicateUri, prefixes);
                        return !isPredicateHidden(predicateUri, predicateLabel);
                    });

                    // Временно переключаемся в режим VAD для генерации DOT
                    const originalQuads = currentQuads;
                    currentQuads = rootGraphInfo.quads;
                    currentMode = 'vad';

                    const dotCode = rdfToDot(filteredQuads, prefixes);
                    currentDotCode = dotCode;
                    console.log('VAD TriG - Сгенерированный DOT-код:', dotCode);

                    currentQuads = originalQuads;
                    currentMode = 'vad-trig';

                    const viz = await Viz.instance();
                    const svgString = viz.renderString(dotCode, {
                        format: 'svg',
                        engine: layoutEngine
                    });

                    // В режиме VAD TriG используем специальный контейнер vad-trig-output
                    const output = document.getElementById('vad-trig-output');
                    currentScale = 1.0;
                    applyZoom();

                    if (outputFormat === 'svg') {
                        output.innerHTML = svgString;
                        currentSvgElement = output.querySelector('svg');
                        document.getElementById('export-buttons').style.display = 'block';
                        document.getElementById('vad-trig-zoom-controls').style.display = 'flex';
                    } else if (outputFormat === 'png') {
                        const pngDataUrl = await svgToPng(svgString);
                        output.innerHTML = `<img src="${pngDataUrl}" alt="RDF Graph" style="max-width: 100%;">`;
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = svgString;
                        currentSvgElement = tempDiv.querySelector('svg');
                        document.getElementById('export-buttons').style.display = 'block';
                        document.getElementById('vad-trig-zoom-controls').style.display = 'flex';
                    }

                    displayLegend();
                    displayPrefixes(prefixes);
                    displayFilters();
                    addNodeClickHandlers();
                    closeAllPropertiesPanels();

                    // Обновляем SPARQL запрос для выбранного TriG
                    updateSparqlQueryForTriG();

                    // Обновляем выпадающие списки Smart Design, если режим активен
                    if (document.getElementById('sparql-mode').value === 'smart-design') {
                        populateSmartDesignDropdowns();
                    }

                    console.log(`VAD TriG: Обработано ${quads.length} триплетов, отображается граф ${getPrefixedName(selectedTrigUri, prefixes)}`);

                    button.disabled = false;
                    button.textContent = 'Визуализировать';
                    return;
                }

                // Скрываем панели VAD TriG для других режимов
                toggleVADTriGPanels(false);

                activeFilters = [...getFilterConfig(currentMode).hiddenPredicates];

                const filteredQuads = quads.filter(quad => {
                    const predicateUri = quad.predicate.value;
                    const predicateLabel = getPrefixedName(predicateUri, prefixes);
                    return !isPredicateHidden(predicateUri, predicateLabel);
                });

                const dotCode = rdfToDot(filteredQuads, prefixes);
                currentDotCode = dotCode;
                console.log('Сгенерированный DOT-код:', dotCode);

                const viz = await Viz.instance();
                const svgString = viz.renderString(dotCode, {
                    format: 'svg',
                    engine: layoutEngine
                });

                const output = document.getElementById('output');
                currentScale = 1.0;
                applyZoom();

                if (outputFormat === 'svg') {
                    output.innerHTML = svgString;
                    currentSvgElement = output.querySelector('svg');
                    document.getElementById('export-buttons').style.display = 'block';
                    document.getElementById('zoom-controls').style.display = 'flex';
                } else if (outputFormat === 'png') {
                    const pngDataUrl = await svgToPng(svgString);
                    output.innerHTML = `<img src="${pngDataUrl}" alt="RDF Graph" style="max-width: 100%;">`;
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = svgString;
                    currentSvgElement = tempDiv.querySelector('svg');
                    document.getElementById('export-buttons').style.display = 'block';
                    document.getElementById('zoom-controls').style.display = 'flex';
                }

                if (currentMode !== 'base') {
                    displayLegend();
                } else {
                    document.getElementById('legend-panel').style.display = 'none';
                }

                displayPrefixes(prefixes);
                displayFilters();
                addNodeClickHandlers();
                closeAllPropertiesPanels();

                console.log(`Обработано ${quads.length} триплетов`);

            } catch (error) {
                console.error('Ошибка визуализации:', error);
                showError(`${error.message}`);
            } finally {
                button.disabled = false;
                button.textContent = 'Визуализировать';
            }
        }

        // ============================================================================
        // ФУНКЦИИ ЭКСПОРТА
        // ============================================================================

        function svgToPng(svgString) {
            return new Promise((resolve, reject) => {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = svgString;
                const svgElement = tempDiv.querySelector('svg');

                let width = parseInt(svgElement.getAttribute('width')) || 800;
                let height = parseInt(svgElement.getAttribute('height')) || 600;

                const widthStr = svgElement.getAttribute('width') || '';
                const heightStr = svgElement.getAttribute('height') || '';

                if (widthStr.includes('pt')) {
                    width = Math.ceil(parseFloat(widthStr) * 1.33);
                }
                if (heightStr.includes('pt')) {
                    height = Math.ceil(parseFloat(heightStr) * 1.33);
                }

                const canvas = document.createElement('canvas');
                canvas.width = width * 2;
                canvas.height = height * 2;
                const ctx = canvas.getContext('2d');
                ctx.scale(2, 2);
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, width, height);

                const img = new Image();
                const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);

                img.onload = function() {
                    ctx.drawImage(img, 0, 0, width, height);
                    URL.revokeObjectURL(url);
                    resolve(canvas.toDataURL('image/png'));
                };

                img.onerror = function() {
                    URL.revokeObjectURL(url);
                    reject(new Error('Ошибка при конвертации SVG в PNG'));
                };

                img.src = url;
            });
        }

        function downloadSVG() {
            if (!currentSvgElement) {
                alert('Сначала визуализируйте RDF данные');
                return;
            }

            const svgData = new XMLSerializer().serializeToString(currentSvgElement);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });

            const downloadLink = document.createElement('a');
            downloadLink.href = URL.createObjectURL(svgBlob);
            downloadLink.download = 'rdf-graph.svg';

            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(downloadLink.href);
        }

        async function downloadPNG() {
            if (!currentSvgElement) {
                alert('Сначала визуализируйте RDF данные');
                return;
            }

            try {
                const svgData = new XMLSerializer().serializeToString(currentSvgElement);
                const pngDataUrl = await svgToPng(svgData);

                const downloadLink = document.createElement('a');
                downloadLink.href = pngDataUrl;
                downloadLink.download = 'rdf-graph.png';

                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);

            } catch (error) {
                console.error('Ошибка при скачивании PNG:', error);
                alert('Ошибка при создании PNG файла');
            }
        }

        /**
         * Маппинг внутренних форматов на сокращенные имена для URL
         */
        const formatMapping = {
            'turtle': 'ttl',
            'n-triples': 'nt',
            'n-quads': 'nq',
            'trig': 'trig'
        };

        /**
         * Открывает визуализацию в новом окне через внешний LDF сервис
         * Формирует URL с параметрами: rdf=данные&from=формат&to=png
         */
        function openInNewWindowLdfFi() {
            // Получаем входные данные
            const rdfInput = document.getElementById('rdf-input').value.trim();
            const inputFormat = document.getElementById('input-format').value;

            // Проверяем, что данные введены
            if (!rdfInput) {
                alert('Пожалуйста, введите RDF данные');
                return;
            }

            // Получаем формат для параметра URL
            const fromFormat = formatMapping[inputFormat] || 'ttl';

            // Кодируем RDF данные для URL
            // Заменяем пробелы на + для совместимости с LDF сервисом
            const encodedRdf = encodeURIComponent(rdfInput).replace(/%20/g, '+');

            // Формируем URL для внешнего сервиса
            const serviceUrl = `https://www.ldf.fi/service/rdf-grapher?rdf=${encodedRdf}&from=${fromFormat}&to=png`;

            // Открываем в новом окне
            window.open(serviceUrl, '_blank');
        }

        /**
         * Открывает визуализацию в новом окне через GitHub Pages (без внешнего сервиса)
         * Формирует URL с данными в хеше: #rdf=данные&from=формат&to=формат&mode=режим
         * Использует URL fragment (hash) вместо query params для избежания ошибки URI Too Long
         */
        function openInNewWindowGitHub() {
            // Получаем входные данные
            const rdfInput = document.getElementById('rdf-input').value.trim();
            const inputFormat = document.getElementById('input-format').value;
            const outputFormat = document.getElementById('output-format').value;
            const visualizationMode = document.getElementById('visualization-mode').value;

            // Проверяем, что данные введены
            if (!rdfInput) {
                alert('Пожалуйста, введите RDF данные');
                return;
            }

            // Получаем формат для параметра URL
            const fromFormat = formatMapping[inputFormat] || 'ttl';

            // Кодируем RDF данные для URL
            const encodedRdf = encodeURIComponent(rdfInput);

            // Определяем базовый URL для GitHub Pages
            let baseUrl;
            if (window.location.hostname === 'bpmbpm.github.io') {
                baseUrl = 'https://bpmbpm.github.io/rdf-grapher/ver6d/';
            } else {
                // Для локального тестирования используем текущий путь
                baseUrl = window.location.origin + window.location.pathname;
            }

            // Формируем URL с данными в хеше (избегает ошибки URI Too Long)
            const hashParams = `rdf=${encodedRdf}&from=${fromFormat}&to=${outputFormat}&mode=${visualizationMode}`;
            const serviceUrl = `${baseUrl}#${hashParams}`;

            // Открываем в новом окне
            window.open(serviceUrl, '_blank');
        }

        /**
         * Открывает DOT-код в GraphvizOnline для интерактивного редактирования
         * Использует хеш URL для передачи DOT-кода
         */
        function openInNewWindowGraphvizOnline() {
            // Проверяем, что DOT-код был сгенерирован
            if (!currentDotCode) {
                alert('Сначала визуализируйте RDF данные');
                return;
            }

            // Кодируем DOT-код для URL
            const encodedDot = encodeURIComponent(currentDotCode);

            // Формируем URL с DOT-кодом в хеше
            const graphvizUrl = `https://dreampuf.github.io/GraphvizOnline/#${encodedDot}`;

            // Открываем в новом окне
            window.open(graphvizUrl, '_blank');
        }

        // ============================================================================
        // SPARQL ФУНКЦИИ
        // ============================================================================

        async function initSparqlEngine() {
            if (!currentStore) {
                currentStore = new N3.Store();
                currentQuads.forEach(quad => currentStore.addQuad(quad));
            }

            if (!comunicaEngine) {
                if (typeof Comunica !== 'undefined' && Comunica.QueryEngine) {
                    comunicaEngine = new Comunica.QueryEngine();
                }
            }

            return { store: currentStore, engine: comunicaEngine };
        }

        async function executeSparqlQuery() {
            const queryInput = document.getElementById('sparql-query');
            const resultsDiv = document.getElementById('sparql-results');
            const resultsContent = document.getElementById('sparql-results-content');

            const query = queryInput.value.trim();
            if (!query) {
                resultsContent.innerHTML = '<div class="sparql-error">Введите SPARQL запрос</div>';
                resultsDiv.style.display = 'block';
                return;
            }

            if (currentQuads.length === 0) {
                resultsContent.innerHTML = '<div class="sparql-error">Сначала визуализируйте RDF данные</div>';
                resultsDiv.style.display = 'block';
                return;
            }

            resultsContent.innerHTML = '<div class="sparql-loading"><div class="spinner"></div><p>Выполнение запроса...</p></div>';
            resultsDiv.style.display = 'block';

            try {
                const { store, engine } = await initSparqlEngine();

                if (!engine) {
                    throw new Error('SPARQL движок не инициализирован');
                }

                const bindingsStream = await engine.queryBindings(query, {
                    sources: [store]
                });

                const bindings = await bindingsStream.toArray();

                if (bindings.length === 0) {
                    resultsContent.innerHTML = '<p>Запрос не вернул результатов</p>';
                    return;
                }

                const variables = [...bindings[0].keys()].map(k => k.value);

                let html = '<table class="sparql-results-table">';
                html += '<thead><tr>';
                variables.forEach(v => {
                    html += `<th>?${v}</th>`;
                });
                html += '</tr></thead>';
                html += '<tbody>';

                let rowIndex = 0;
                bindings.forEach(binding => {
                    // Собираем URI из этой строки для навигации к узлу
                    const uris = [];
                    variables.forEach(v => {
                        const term = binding.get(v);
                        if (term && term.termType !== 'Literal') {
                            uris.push(term.value);
                        }
                    });

                    // Кодируем URI в base64 для передачи через data-атрибут
                    const urisData = btoa(encodeURIComponent(JSON.stringify(uris)));

                    html += `<tr class="clickable" data-row-index="${rowIndex}" data-uris="${urisData}" onclick="highlightNodeFromSparqlResult(this)">`;
                    variables.forEach(v => {
                        const term = binding.get(v);
                        if (term) {
                            const value = term.value;
                            const isLiteral = term.termType === 'Literal';
                            const displayValue = isLiteral ? `"${value}"` : getPrefixedName(value, currentPrefixes);
                            const cssClass = isLiteral ? 'literal' : 'uri';
                            html += `<td class="${cssClass}">${escapeHtml(displayValue)}</td>`;
                        } else {
                            html += '<td>-</td>';
                        }
                    });
                    html += '</tr>';
                    rowIndex++;
                });

                html += '</tbody></table>';
                html += `<p style="margin-top: 10px; font-size: 12px; color: #666;">Найдено результатов: ${bindings.length}</p>`;

                resultsContent.innerHTML = html;

            } catch (error) {
                console.error('Ошибка SPARQL:', error);
                resultsContent.innerHTML = `<div class="sparql-error">Ошибка: ${error.message}</div>`;
            }
        }

        /**
         * Подсвечивает узел на графе при клике на строку в результатах SPARQL
         * и открывает панель свойств для первого найденного URI
         *
         * @param {HTMLElement} rowElement - Элемент строки таблицы
         */
        function highlightNodeFromSparqlResult(rowElement) {
            // Снимаем подсветку со всех строк
            const allRows = document.querySelectorAll('.sparql-results-table tr.highlighted');
            allRows.forEach(row => row.classList.remove('highlighted'));

            // Подсвечиваем текущую строку
            rowElement.classList.add('highlighted');

            // Получаем URI из данных строки (base64 закодированный JSON)
            const urisData = rowElement.getAttribute('data-uris');
            if (!urisData) return;

            let uris;
            try {
                // Декодируем base64 и затем URL-декодируем
                uris = JSON.parse(decodeURIComponent(atob(urisData)));
            } catch (e) {
                console.error('Ошибка парсинга URI:', e);
                return;
            }

            if (uris.length === 0) return;

            // Снимаем выделение с предыдущего узла
            if (selectedNodeElement) {
                selectedNodeElement.classList.remove('selected');
                selectedNodeElement = null;
            }

            // Ищем узлы на графе по URI (в обоих контейнерах: regular и VAD TriG)
            const regularOutput = document.getElementById('output');
            const vadTrigOutput = document.getElementById('vad-trig-output');
            const regularSvg = regularOutput ? regularOutput.querySelector('svg') : null;
            const vadTrigSvg = vadTrigOutput ? vadTrigOutput.querySelector('svg') : null;

            // Collect all nodes from both SVG containers
            let allNodes = [];
            if (regularSvg) {
                allNodes = allNodes.concat(Array.from(regularSvg.querySelectorAll('.node')));
            }
            if (vadTrigSvg) {
                allNodes = allNodes.concat(Array.from(vadTrigSvg.querySelectorAll('.node')));
            }

            if (allNodes.length === 0) return;

            let foundNode = null;
            let foundUri = null;
            let foundLabel = null;

            // Пробуем найти узел для первого URI
            for (const uri of uris) {
                for (const [label, info] of Object.entries(nodeLabelToUri)) {
                    if (info.uri === uri) {
                        // Нашли маппинг, ищем узел по dotId
                        for (const node of allNodes) {
                            const titleElement = node.querySelector('title');
                            if (titleElement && titleElement.textContent === info.dotId) {
                                foundNode = node;
                                foundUri = uri;
                                foundLabel = label;
                                break;
                            }
                        }
                        if (foundNode) break;
                    }
                }
                if (foundNode) break;
            }

            if (foundNode) {
                // Выделяем найденный узел
                foundNode.classList.add('selected');
                selectedNodeElement = foundNode;

                // Прокручиваем к узлу
                foundNode.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });

                // Открываем панель свойств для найденного URI
                if (foundUri) {
                    const displayLabel = foundLabel || getPrefixedName(foundUri, currentPrefixes);
                    showNodeProperties(foundUri, displayLabel);
                }
            } else if (uris.length > 0) {
                // Если узел не найден на графе, все равно открываем панель свойств для первого URI
                const uri = uris[0];
                const displayLabel = getPrefixedName(uri, currentPrefixes);
                showNodeProperties(uri, displayLabel);
            }
        }

        function resetSparqlQuery() {
            // В режиме VAD TriG используем запрос с GRAPH clause
            if (currentMode === 'vad-trig' && selectedTrigUri) {
                document.getElementById('sparql-query').value = getSparqlQueryForTriG(selectedTrigUri);
            } else {
                document.getElementById('sparql-query').value = defaultSparqlQuery;
            }
            document.getElementById('sparql-results').style.display = 'none';
        }

        /**
         * Парсит URL параметры и возвращает объект с параметрами
         * Поддерживает параметры как в query string (?...), так и в hash (#...)
         * Hash имеет приоритет над query string для избежания ошибки URI Too Long
         *
         * Поддерживаемые параметры:
         * - rdf: RDF данные (URL-encoded)
         * - from: входной формат (ttl, nt, nq, trig)
         * - to: выходной формат (svg, png)
         * - mode: режим визуализации (notation, base, aggregation, vad)
         *
         * @returns {Object} - Объект с параметрами
         */
        function parseUrlParams() {
            // Сначала пробуем получить параметры из hash (приоритет)
            let urlParams;
            if (window.location.hash && window.location.hash.length > 1) {
                // Убираем # и парсим как URLSearchParams
                urlParams = new URLSearchParams(window.location.hash.substring(1));
            } else {
                // Fallback на query string для обратной совместимости
                urlParams = new URLSearchParams(window.location.search);
            }

            const params = {};

            // Маппинг обратный: параметры URL -> внутренние форматы
            const reverseFormatMapping = {
                'ttl': 'turtle',
                'turtle': 'turtle',
                'nt': 'n-triples',
                'n-triples': 'n-triples',
                'nq': 'n-quads',
                'n-quads': 'n-quads',
                'trig': 'trig'
            };

            // Получаем RDF данные из параметра
            if (urlParams.has('rdf')) {
                params.rdf = urlParams.get('rdf');
            }

            // Получаем входной формат
            if (urlParams.has('from')) {
                const fromParam = urlParams.get('from');
                params.from = reverseFormatMapping[fromParam] || 'turtle';
            }

            // Получаем выходной формат
            if (urlParams.has('to')) {
                const toParam = urlParams.get('to');
                if (toParam === 'png' || toParam === 'svg') {
                    params.to = toParam;
                }
            }

            // Получаем режим визуализации
            if (urlParams.has('mode')) {
                const modeParam = urlParams.get('mode');
                const validModes = ['notation', 'base', 'aggregation', 'vad', 'vad-trig'];
                if (validModes.includes(modeParam)) {
                    params.mode = modeParam;
                }
            }

            return params;
        }

        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', function() {
            updateModeDescription();

            // Парсим URL параметры
            const params = parseUrlParams();

            // Если есть RDF данные в URL, заполняем форму и визуализируем
            if (params.rdf) {
                console.log('Обнаружены RDF данные в URL, загружаем...');

                // Заполняем текстовое поле RDF данными
                document.getElementById('rdf-input').value = params.rdf;

                // Устанавливаем входной формат, если указан
                if (params.from) {
                    document.getElementById('input-format').value = params.from;
                }

                // Устанавливаем выходной формат, если указан
                if (params.to) {
                    document.getElementById('output-format').value = params.to;
                }

                // Устанавливаем режим визуализации, если указан
                if (params.mode) {
                    document.getElementById('visualization-mode').value = params.mode;
                    updateModeDescription();
                }

                // Небольшая задержка для уверенности, что все элементы загружены
                setTimeout(function() {
                    visualize();
                }, 100);
            }
        });
    </script>
</body>
</html>
